var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module, copyDefault, desc) => {
  if (module && typeof module === "object" || typeof module === "function") {
    for (let key of __getOwnPropNames(module))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", !isNodeMode && module && module.__esModule ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module, temp) => {
    return cache && cache.get(module) || (temp = __reExport(__markAsModule({}), module, 1), cache && cache.set(module, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports, module) {
    "use strict";
    init_react();
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i = 0; i < 10; i++) {
          test2["_" + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from2;
      var to = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from2 = Object(arguments[s]);
        for (var key in from2) {
          if (hasOwnProperty2.call(from2, key)) {
            to[key] = from2[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from2);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from2, symbols[i])) {
              to[symbols[i]] = from2[symbols[i]];
            }
          }
        }
      }
      return to;
    };
  }
});

// node_modules/react/cjs/react.development.js
var require_react_development = __commonJS({
  "node_modules/react/cjs/react.development.js"(exports) {
    "use strict";
    init_react();
    if (true) {
      (function() {
        "use strict";
        var _assign = require_object_assign();
        var ReactVersion = "17.0.2";
        var REACT_ELEMENT_TYPE = 60103;
        var REACT_PORTAL_TYPE = 60106;
        exports.Fragment = 60107;
        exports.StrictMode = 60108;
        exports.Profiler = 60114;
        var REACT_PROVIDER_TYPE = 60109;
        var REACT_CONTEXT_TYPE = 60110;
        var REACT_FORWARD_REF_TYPE = 60112;
        exports.Suspense = 60113;
        var REACT_SUSPENSE_LIST_TYPE = 60120;
        var REACT_MEMO_TYPE = 60115;
        var REACT_LAZY_TYPE = 60116;
        var REACT_BLOCK_TYPE = 60121;
        var REACT_SERVER_BLOCK_TYPE = 60122;
        var REACT_FUNDAMENTAL_TYPE = 60117;
        var REACT_SCOPE_TYPE = 60119;
        var REACT_OPAQUE_ID_TYPE = 60128;
        var REACT_DEBUG_TRACING_MODE_TYPE = 60129;
        var REACT_OFFSCREEN_TYPE = 60130;
        var REACT_LEGACY_HIDDEN_TYPE = 60131;
        if (typeof Symbol === "function" && Symbol.for) {
          var symbolFor = Symbol.for;
          REACT_ELEMENT_TYPE = symbolFor("react.element");
          REACT_PORTAL_TYPE = symbolFor("react.portal");
          exports.Fragment = symbolFor("react.fragment");
          exports.StrictMode = symbolFor("react.strict_mode");
          exports.Profiler = symbolFor("react.profiler");
          REACT_PROVIDER_TYPE = symbolFor("react.provider");
          REACT_CONTEXT_TYPE = symbolFor("react.context");
          REACT_FORWARD_REF_TYPE = symbolFor("react.forward_ref");
          exports.Suspense = symbolFor("react.suspense");
          REACT_SUSPENSE_LIST_TYPE = symbolFor("react.suspense_list");
          REACT_MEMO_TYPE = symbolFor("react.memo");
          REACT_LAZY_TYPE = symbolFor("react.lazy");
          REACT_BLOCK_TYPE = symbolFor("react.block");
          REACT_SERVER_BLOCK_TYPE = symbolFor("react.server.block");
          REACT_FUNDAMENTAL_TYPE = symbolFor("react.fundamental");
          REACT_SCOPE_TYPE = symbolFor("react.scope");
          REACT_OPAQUE_ID_TYPE = symbolFor("react.opaque.id");
          REACT_DEBUG_TRACING_MODE_TYPE = symbolFor("react.debug_trace_mode");
          REACT_OFFSCREEN_TYPE = symbolFor("react.offscreen");
          REACT_LEGACY_HIDDEN_TYPE = symbolFor("react.legacy_hidden");
        }
        var MAYBE_ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var ReactCurrentDispatcher = {
          current: null
        };
        var ReactCurrentBatchConfig = {
          transition: 0
        };
        var ReactCurrentOwner = {
          current: null
        };
        var ReactDebugCurrentFrame = {};
        var currentExtraStackFrame = null;
        function setExtraStackFrame(stack) {
          {
            currentExtraStackFrame = stack;
          }
        }
        {
          ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
            {
              currentExtraStackFrame = stack;
            }
          };
          ReactDebugCurrentFrame.getCurrentStack = null;
          ReactDebugCurrentFrame.getStackAddendum = function() {
            var stack = "";
            if (currentExtraStackFrame) {
              stack += currentExtraStackFrame;
            }
            var impl = ReactDebugCurrentFrame.getCurrentStack;
            if (impl) {
              stack += impl() || "";
            }
            return stack;
          };
        }
        var IsSomeRendererActing = {
          current: false
        };
        var ReactSharedInternals = {
          ReactCurrentDispatcher,
          ReactCurrentBatchConfig,
          ReactCurrentOwner,
          IsSomeRendererActing,
          assign: _assign
        };
        {
          ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
        }
        function warn(format2) {
          {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            printWarning("warn", format2, args);
          }
        }
        function error(format2) {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format2, args);
          }
        }
        function printWarning(level, format2, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format2 += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return "" + item;
            });
            argsWithFormat.unshift("Warning: " + format2);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var didWarnStateUpdateForUnmountedComponent = {};
        function warnNoop(publicInstance, callerName) {
          {
            var _constructor = publicInstance.constructor;
            var componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass";
            var warningKey = componentName + "." + callerName;
            if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
              return;
            }
            error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName);
            didWarnStateUpdateForUnmountedComponent[warningKey] = true;
          }
        }
        var ReactNoopUpdateQueue = {
          isMounted: function(publicInstance) {
            return false;
          },
          enqueueForceUpdate: function(publicInstance, callback, callerName) {
            warnNoop(publicInstance, "forceUpdate");
          },
          enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
            warnNoop(publicInstance, "replaceState");
          },
          enqueueSetState: function(publicInstance, partialState, callback, callerName) {
            warnNoop(publicInstance, "setState");
          }
        };
        var emptyObject = {};
        {
          Object.freeze(emptyObject);
        }
        function Component(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        Component.prototype.isReactComponent = {};
        Component.prototype.setState = function(partialState, callback) {
          if (!(typeof partialState === "object" || typeof partialState === "function" || partialState == null)) {
            {
              throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
            }
          }
          this.updater.enqueueSetState(this, partialState, callback, "setState");
        };
        Component.prototype.forceUpdate = function(callback) {
          this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
        };
        {
          var deprecatedAPIs = {
            isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
            replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
          };
          var defineDeprecationWarning = function(methodName, info) {
            Object.defineProperty(Component.prototype, methodName, {
              get: function() {
                warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
                return void 0;
              }
            });
          };
          for (var fnName in deprecatedAPIs) {
            if (deprecatedAPIs.hasOwnProperty(fnName)) {
              defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
            }
          }
        }
        function ComponentDummy() {
        }
        ComponentDummy.prototype = Component.prototype;
        function PureComponent(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
        pureComponentPrototype.constructor = PureComponent;
        _assign(pureComponentPrototype, Component.prototype);
        pureComponentPrototype.isPureReactComponent = true;
        function createRef() {
          var refObject = {
            current: null
          };
          {
            Object.seal(refObject);
          }
          return refObject;
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var functionName = innerType.displayName || innerType.name || "";
          return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
        }
        function getContextName(type) {
          return type.displayName || "Context";
        }
        function getComponentName(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case exports.Fragment:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case exports.Profiler:
              return "Profiler";
            case exports.StrictMode:
              return "StrictMode";
            case exports.Suspense:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                return getComponentName(type.type);
              case REACT_BLOCK_TYPE:
                return getComponentName(type._render);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init2 = lazyComponent._init;
                try {
                  return getComponentName(init2(payload));
                } catch (x) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var hasOwnProperty2 = Object.prototype.hasOwnProperty;
        var RESERVED_PROPS = {
          key: true,
          ref: true,
          __self: true,
          __source: true
        };
        var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
        {
          didWarnAboutStringRefs = {};
        }
        function hasValidRef(config2) {
          {
            if (hasOwnProperty2.call(config2, "ref")) {
              var getter = Object.getOwnPropertyDescriptor(config2, "ref").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config2.ref !== void 0;
        }
        function hasValidKey(config2) {
          {
            if (hasOwnProperty2.call(config2, "key")) {
              var getter = Object.getOwnPropertyDescriptor(config2, "key").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config2.key !== void 0;
        }
        function defineKeyPropWarningGetter(props, displayName) {
          var warnAboutAccessingKey = function() {
            {
              if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true;
                error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            }
          };
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
        function defineRefPropWarningGetter(props, displayName) {
          var warnAboutAccessingRef = function() {
            {
              if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true;
                error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            }
          };
          warnAboutAccessingRef.isReactWarning = true;
          Object.defineProperty(props, "ref", {
            get: warnAboutAccessingRef,
            configurable: true
          });
        }
        function warnIfStringRefCannotBeAutoConverted(config2) {
          {
            if (typeof config2.ref === "string" && ReactCurrentOwner.current && config2.__self && ReactCurrentOwner.current.stateNode !== config2.__self) {
              var componentName = getComponentName(ReactCurrentOwner.current.type);
              if (!didWarnAboutStringRefs[componentName]) {
                error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, config2.ref);
                didWarnAboutStringRefs[componentName] = true;
              }
            }
          }
        }
        var ReactElement = function(type, key, ref, self2, source, owner, props) {
          var element = {
            $$typeof: REACT_ELEMENT_TYPE,
            type,
            key,
            ref,
            props,
            _owner: owner
          };
          {
            element._store = {};
            Object.defineProperty(element._store, "validated", {
              configurable: false,
              enumerable: false,
              writable: true,
              value: false
            });
            Object.defineProperty(element, "_self", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: self2
            });
            Object.defineProperty(element, "_source", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: source
            });
            if (Object.freeze) {
              Object.freeze(element.props);
              Object.freeze(element);
            }
          }
          return element;
        };
        function createElement7(type, config2, children) {
          var propName;
          var props = {};
          var key = null;
          var ref = null;
          var self2 = null;
          var source = null;
          if (config2 != null) {
            if (hasValidRef(config2)) {
              ref = config2.ref;
              {
                warnIfStringRefCannotBeAutoConverted(config2);
              }
            }
            if (hasValidKey(config2)) {
              key = "" + config2.key;
            }
            self2 = config2.__self === void 0 ? null : config2.__self;
            source = config2.__source === void 0 ? null : config2.__source;
            for (propName in config2) {
              if (hasOwnProperty2.call(config2, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                props[propName] = config2[propName];
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i = 0; i < childrenLength; i++) {
              childArray[i] = arguments[i + 2];
            }
            {
              if (Object.freeze) {
                Object.freeze(childArray);
              }
            }
            props.children = childArray;
          }
          if (type && type.defaultProps) {
            var defaultProps = type.defaultProps;
            for (propName in defaultProps) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps[propName];
              }
            }
          }
          {
            if (key || ref) {
              var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
              if (key) {
                defineKeyPropWarningGetter(props, displayName);
              }
              if (ref) {
                defineRefPropWarningGetter(props, displayName);
              }
            }
          }
          return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
        }
        function cloneAndReplaceKey(oldElement, newKey) {
          var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
          return newElement;
        }
        function cloneElement(element, config2, children) {
          if (!!(element === null || element === void 0)) {
            {
              throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
            }
          }
          var propName;
          var props = _assign({}, element.props);
          var key = element.key;
          var ref = element.ref;
          var self2 = element._self;
          var source = element._source;
          var owner = element._owner;
          if (config2 != null) {
            if (hasValidRef(config2)) {
              ref = config2.ref;
              owner = ReactCurrentOwner.current;
            }
            if (hasValidKey(config2)) {
              key = "" + config2.key;
            }
            var defaultProps;
            if (element.type && element.type.defaultProps) {
              defaultProps = element.type.defaultProps;
            }
            for (propName in config2) {
              if (hasOwnProperty2.call(config2, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                if (config2[propName] === void 0 && defaultProps !== void 0) {
                  props[propName] = defaultProps[propName];
                } else {
                  props[propName] = config2[propName];
                }
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i = 0; i < childrenLength; i++) {
              childArray[i] = arguments[i + 2];
            }
            props.children = childArray;
          }
          return ReactElement(element.type, key, ref, self2, source, owner, props);
        }
        function isValidElement2(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        var SEPARATOR = ".";
        var SUBSEPARATOR = ":";
        function escape(key) {
          var escapeRegex = /[=:]/g;
          var escaperLookup = {
            "=": "=0",
            ":": "=2"
          };
          var escapedString = key.replace(escapeRegex, function(match) {
            return escaperLookup[match];
          });
          return "$" + escapedString;
        }
        var didWarnAboutMaps = false;
        var userProvidedKeyEscapeRegex = /\/+/g;
        function escapeUserProvidedKey(text) {
          return text.replace(userProvidedKeyEscapeRegex, "$&/");
        }
        function getElementKey(element, index) {
          if (typeof element === "object" && element !== null && element.key != null) {
            return escape("" + element.key);
          }
          return index.toString(36);
        }
        function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
          var type = typeof children;
          if (type === "undefined" || type === "boolean") {
            children = null;
          }
          var invokeCallback = false;
          if (children === null) {
            invokeCallback = true;
          } else {
            switch (type) {
              case "string":
              case "number":
                invokeCallback = true;
                break;
              case "object":
                switch (children.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                  case REACT_PORTAL_TYPE:
                    invokeCallback = true;
                }
            }
          }
          if (invokeCallback) {
            var _child = children;
            var mappedChild = callback(_child);
            var childKey = nameSoFar === "" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
            if (Array.isArray(mappedChild)) {
              var escapedChildKey = "";
              if (childKey != null) {
                escapedChildKey = escapeUserProvidedKey(childKey) + "/";
              }
              mapIntoArray(mappedChild, array, escapedChildKey, "", function(c) {
                return c;
              });
            } else if (mappedChild != null) {
              if (isValidElement2(mappedChild)) {
                mappedChild = cloneAndReplaceKey(mappedChild, escapedPrefix + (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? escapeUserProvidedKey("" + mappedChild.key) + "/" : "") + childKey);
              }
              array.push(mappedChild);
            }
            return 1;
          }
          var child;
          var nextName;
          var subtreeCount = 0;
          var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
          if (Array.isArray(children)) {
            for (var i = 0; i < children.length; i++) {
              child = children[i];
              nextName = nextNamePrefix + getElementKey(child, i);
              subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
            }
          } else {
            var iteratorFn = getIteratorFn(children);
            if (typeof iteratorFn === "function") {
              var iterableChildren = children;
              {
                if (iteratorFn === iterableChildren.entries) {
                  if (!didWarnAboutMaps) {
                    warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                  }
                  didWarnAboutMaps = true;
                }
              }
              var iterator = iteratorFn.call(iterableChildren);
              var step;
              var ii = 0;
              while (!(step = iterator.next()).done) {
                child = step.value;
                nextName = nextNamePrefix + getElementKey(child, ii++);
                subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
              }
            } else if (type === "object") {
              var childrenString = "" + children;
              {
                {
                  throw Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + "). If you meant to render a collection of children, use an array instead.");
                }
              }
            }
          }
          return subtreeCount;
        }
        function mapChildren(children, func, context) {
          if (children == null) {
            return children;
          }
          var result = [];
          var count = 0;
          mapIntoArray(children, result, "", "", function(child) {
            return func.call(context, child, count++);
          });
          return result;
        }
        function countChildren(children) {
          var n = 0;
          mapChildren(children, function() {
            n++;
          });
          return n;
        }
        function forEachChildren(children, forEachFunc, forEachContext) {
          mapChildren(children, function() {
            forEachFunc.apply(this, arguments);
          }, forEachContext);
        }
        function toArray(children) {
          return mapChildren(children, function(child) {
            return child;
          }) || [];
        }
        function onlyChild(children) {
          if (!isValidElement2(children)) {
            {
              throw Error("React.Children.only expected to receive a single React element child.");
            }
          }
          return children;
        }
        function createContext3(defaultValue, calculateChangedBits) {
          if (calculateChangedBits === void 0) {
            calculateChangedBits = null;
          } else {
            {
              if (calculateChangedBits !== null && typeof calculateChangedBits !== "function") {
                error("createContext: Expected the optional second argument to be a function. Instead received: %s", calculateChangedBits);
              }
            }
          }
          var context = {
            $$typeof: REACT_CONTEXT_TYPE,
            _calculateChangedBits: calculateChangedBits,
            _currentValue: defaultValue,
            _currentValue2: defaultValue,
            _threadCount: 0,
            Provider: null,
            Consumer: null
          };
          context.Provider = {
            $$typeof: REACT_PROVIDER_TYPE,
            _context: context
          };
          var hasWarnedAboutUsingNestedContextConsumers = false;
          var hasWarnedAboutUsingConsumerProvider = false;
          var hasWarnedAboutDisplayNameOnConsumer = false;
          {
            var Consumer = {
              $$typeof: REACT_CONTEXT_TYPE,
              _context: context,
              _calculateChangedBits: context._calculateChangedBits
            };
            Object.defineProperties(Consumer, {
              Provider: {
                get: function() {
                  if (!hasWarnedAboutUsingConsumerProvider) {
                    hasWarnedAboutUsingConsumerProvider = true;
                    error("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?");
                  }
                  return context.Provider;
                },
                set: function(_Provider) {
                  context.Provider = _Provider;
                }
              },
              _currentValue: {
                get: function() {
                  return context._currentValue;
                },
                set: function(_currentValue) {
                  context._currentValue = _currentValue;
                }
              },
              _currentValue2: {
                get: function() {
                  return context._currentValue2;
                },
                set: function(_currentValue2) {
                  context._currentValue2 = _currentValue2;
                }
              },
              _threadCount: {
                get: function() {
                  return context._threadCount;
                },
                set: function(_threadCount) {
                  context._threadCount = _threadCount;
                }
              },
              Consumer: {
                get: function() {
                  if (!hasWarnedAboutUsingNestedContextConsumers) {
                    hasWarnedAboutUsingNestedContextConsumers = true;
                    error("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                  }
                  return context.Consumer;
                }
              },
              displayName: {
                get: function() {
                  return context.displayName;
                },
                set: function(displayName) {
                  if (!hasWarnedAboutDisplayNameOnConsumer) {
                    warn("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", displayName);
                    hasWarnedAboutDisplayNameOnConsumer = true;
                  }
                }
              }
            });
            context.Consumer = Consumer;
          }
          {
            context._currentRenderer = null;
            context._currentRenderer2 = null;
          }
          return context;
        }
        var Uninitialized = -1;
        var Pending = 0;
        var Resolved = 1;
        var Rejected = 2;
        function lazyInitializer(payload) {
          if (payload._status === Uninitialized) {
            var ctor = payload._result;
            var thenable = ctor();
            var pending = payload;
            pending._status = Pending;
            pending._result = thenable;
            thenable.then(function(moduleObject) {
              if (payload._status === Pending) {
                var defaultExport = moduleObject.default;
                {
                  if (defaultExport === void 0) {
                    error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
                  }
                }
                var resolved = payload;
                resolved._status = Resolved;
                resolved._result = defaultExport;
              }
            }, function(error2) {
              if (payload._status === Pending) {
                var rejected = payload;
                rejected._status = Rejected;
                rejected._result = error2;
              }
            });
          }
          if (payload._status === Resolved) {
            return payload._result;
          } else {
            throw payload._result;
          }
        }
        function lazy(ctor) {
          var payload = {
            _status: -1,
            _result: ctor
          };
          var lazyType = {
            $$typeof: REACT_LAZY_TYPE,
            _payload: payload,
            _init: lazyInitializer
          };
          {
            var defaultProps;
            var propTypes;
            Object.defineProperties(lazyType, {
              defaultProps: {
                configurable: true,
                get: function() {
                  return defaultProps;
                },
                set: function(newDefaultProps) {
                  error("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  defaultProps = newDefaultProps;
                  Object.defineProperty(lazyType, "defaultProps", {
                    enumerable: true
                  });
                }
              },
              propTypes: {
                configurable: true,
                get: function() {
                  return propTypes;
                },
                set: function(newPropTypes) {
                  error("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  propTypes = newPropTypes;
                  Object.defineProperty(lazyType, "propTypes", {
                    enumerable: true
                  });
                }
              }
            });
          }
          return lazyType;
        }
        function forwardRef3(render) {
          {
            if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
              error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).");
            } else if (typeof render !== "function") {
              error("forwardRef requires a render function but was given %s.", render === null ? "null" : typeof render);
            } else {
              if (render.length !== 0 && render.length !== 2) {
                error("forwardRef render functions accept exactly two parameters: props and ref. %s", render.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
              }
            }
            if (render != null) {
              if (render.defaultProps != null || render.propTypes != null) {
                error("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
              }
            }
          }
          var elementType = {
            $$typeof: REACT_FORWARD_REF_TYPE,
            render
          };
          {
            var ownName;
            Object.defineProperty(elementType, "displayName", {
              enumerable: false,
              configurable: true,
              get: function() {
                return ownName;
              },
              set: function(name) {
                ownName = name;
                if (render.displayName == null) {
                  render.displayName = name;
                }
              }
            });
          }
          return elementType;
        }
        var enableScopeAPI = false;
        function isValidElementType(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === exports.Fragment || type === exports.Profiler || type === REACT_DEBUG_TRACING_MODE_TYPE || type === exports.StrictMode || type === exports.Suspense || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
              return true;
            }
          }
          return false;
        }
        function memo(type, compare3) {
          {
            if (!isValidElementType(type)) {
              error("memo: The first argument must be a component. Instead received: %s", type === null ? "null" : typeof type);
            }
          }
          var elementType = {
            $$typeof: REACT_MEMO_TYPE,
            type,
            compare: compare3 === void 0 ? null : compare3
          };
          {
            var ownName;
            Object.defineProperty(elementType, "displayName", {
              enumerable: false,
              configurable: true,
              get: function() {
                return ownName;
              },
              set: function(name) {
                ownName = name;
                if (type.displayName == null) {
                  type.displayName = name;
                }
              }
            });
          }
          return elementType;
        }
        function resolveDispatcher() {
          var dispatcher = ReactCurrentDispatcher.current;
          if (!(dispatcher !== null)) {
            {
              throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
            }
          }
          return dispatcher;
        }
        function useContext4(Context, unstable_observedBits) {
          var dispatcher = resolveDispatcher();
          {
            if (unstable_observedBits !== void 0) {
              error("useContext() second argument is reserved for future use in React. Passing it is not supported. You passed: %s.%s", unstable_observedBits, typeof unstable_observedBits === "number" && Array.isArray(arguments[2]) ? "\n\nDid you call array.map(useContext)? Calling Hooks inside a loop is not supported. Learn more at https://reactjs.org/link/rules-of-hooks" : "");
            }
            if (Context._context !== void 0) {
              var realContext = Context._context;
              if (realContext.Consumer === Context) {
                error("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?");
              } else if (realContext.Provider === Context) {
                error("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
              }
            }
          }
          return dispatcher.useContext(Context, unstable_observedBits);
        }
        function useState4(initialState) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useState(initialState);
        }
        function useReducer(reducer, initialArg, init2) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useReducer(reducer, initialArg, init2);
        }
        function useRef5(initialValue) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useRef(initialValue);
        }
        function useEffect4(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useEffect(create, deps);
        }
        function useLayoutEffect4(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useLayoutEffect(create, deps);
        }
        function useCallback5(callback, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useCallback(callback, deps);
        }
        function useMemo4(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useMemo(create, deps);
        }
        function useImperativeHandle(ref, create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useImperativeHandle(ref, create, deps);
        }
        function useDebugValue(value, formatterFn) {
          {
            var dispatcher = resolveDispatcher();
            return dispatcher.useDebugValue(value, formatterFn);
          }
        }
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: _assign({}, props, {
                  value: prevLog
                }),
                info: _assign({}, props, {
                  value: prevInfo
                }),
                warn: _assign({}, props, {
                  value: prevWarn
                }),
                error: _assign({}, props, {
                  value: prevError
                }),
                group: _assign({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: _assign({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: _assign({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x) {
                var match = x.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
              }
            }
            return "\n" + prefix + name;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  control = x;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x) {
                  control = x;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x) {
                control = x;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s = sampleLines.length - 1;
              var c = controlLines.length - 1;
              while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                c--;
              }
              for (; s >= 1 && c >= 0; s--, c--) {
                if (sampleLines[s] !== controlLines[c]) {
                  if (s !== 1 || c !== 1) {
                    do {
                      s--;
                      c--;
                      if (c < 0 || sampleLines[s] !== controlLines[c]) {
                        var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s >= 1 && c >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher$1.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component2) {
          var prototype = Component2.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
          if (type == null) {
            return "";
          }
          if (typeof type === "function") {
            {
              return describeNativeComponentFrame(type, shouldConstruct(type));
            }
          }
          if (typeof type === "string") {
            return describeBuiltInComponentFrame(type);
          }
          switch (type) {
            case exports.Suspense:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
              case REACT_BLOCK_TYPE:
                return describeFunctionComponentFrame(type._render);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init2 = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init2(payload), source, ownerFn);
                } catch (x) {
                }
              }
            }
          }
          return "";
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame$1.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location2, componentName, element) {
          {
            var has = Function.call.bind(Object.prototype.hasOwnProperty);
            for (var typeSpecName in typeSpecs) {
              if (has(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location2, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location2, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error("Failed %s type: %s", location2, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        function setCurrentlyValidatingElement$1(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              setExtraStackFrame(stack);
            } else {
              setExtraStackFrame(null);
            }
          }
        }
        var propTypesMisspellWarningShown;
        {
          propTypesMisspellWarningShown = false;
        }
        function getDeclarationErrorAddendum() {
          if (ReactCurrentOwner.current) {
            var name = getComponentName(ReactCurrentOwner.current.type);
            if (name) {
              return "\n\nCheck the render method of `" + name + "`.";
            }
          }
          return "";
        }
        function getSourceInfoErrorAddendum(source) {
          if (source !== void 0) {
            var fileName = source.fileName.replace(/^.*[\\\/]/, "");
            var lineNumber = source.lineNumber;
            return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
          }
          return "";
        }
        function getSourceInfoErrorAddendumForProps(elementProps) {
          if (elementProps !== null && elementProps !== void 0) {
            return getSourceInfoErrorAddendum(elementProps.__source);
          }
          return "";
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
          var info = getDeclarationErrorAddendum();
          if (!info) {
            var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
            if (parentName) {
              info = "\n\nCheck the top-level render call using <" + parentName + ">.";
            }
          }
          return info;
        }
        function validateExplicitKey(element, parentType) {
          if (!element._store || element._store.validated || element.key != null) {
            return;
          }
          element._store.validated = true;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return;
          }
          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
          var childOwner = "";
          if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
            childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
          }
          {
            setCurrentlyValidatingElement$1(element);
            error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
            setCurrentlyValidatingElement$1(null);
          }
        }
        function validateChildKeys(node, parentType) {
          if (typeof node !== "object") {
            return;
          }
          if (Array.isArray(node)) {
            for (var i = 0; i < node.length; i++) {
              var child = node[i];
              if (isValidElement2(child)) {
                validateExplicitKey(child, parentType);
              }
            }
          } else if (isValidElement2(node)) {
            if (node._store) {
              node._store.validated = true;
            }
          } else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn === "function") {
              if (iteratorFn !== node.entries) {
                var iterator = iteratorFn.call(node);
                var step;
                while (!(step = iterator.next()).done) {
                  if (isValidElement2(step.value)) {
                    validateExplicitKey(step.value, parentType);
                  }
                }
              }
            }
          }
        }
        function validatePropTypes(element) {
          {
            var type = element.type;
            if (type === null || type === void 0 || typeof type === "string") {
              return;
            }
            var propTypes;
            if (typeof type === "function") {
              propTypes = type.propTypes;
            } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MEMO_TYPE)) {
              propTypes = type.propTypes;
            } else {
              return;
            }
            if (propTypes) {
              var name = getComponentName(type);
              checkPropTypes(propTypes, element.props, "prop", name, element);
            } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
              propTypesMisspellWarningShown = true;
              var _name = getComponentName(type);
              error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
            }
            if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
              error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
            }
          }
        }
        function validateFragmentProps(fragment) {
          {
            var keys2 = Object.keys(fragment.props);
            for (var i = 0; i < keys2.length; i++) {
              var key = keys2[i];
              if (key !== "children" && key !== "key") {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                setCurrentlyValidatingElement$1(null);
                break;
              }
            }
            if (fragment.ref !== null) {
              setCurrentlyValidatingElement$1(fragment);
              error("Invalid attribute `ref` supplied to `React.Fragment`.");
              setCurrentlyValidatingElement$1(null);
            }
          }
        }
        function createElementWithValidation(type, props, children) {
          var validType = isValidElementType(type);
          if (!validType) {
            var info = "";
            if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
            var sourceInfo = getSourceInfoErrorAddendumForProps(props);
            if (sourceInfo) {
              info += sourceInfo;
            } else {
              info += getDeclarationErrorAddendum();
            }
            var typeString;
            if (type === null) {
              typeString = "null";
            } else if (Array.isArray(type)) {
              typeString = "array";
            } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
              typeString = "<" + (getComponentName(type.type) || "Unknown") + " />";
              info = " Did you accidentally export a JSX literal instead of a component?";
            } else {
              typeString = typeof type;
            }
            {
              error("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
            }
          }
          var element = createElement7.apply(this, arguments);
          if (element == null) {
            return element;
          }
          if (validType) {
            for (var i = 2; i < arguments.length; i++) {
              validateChildKeys(arguments[i], type);
            }
          }
          if (type === exports.Fragment) {
            validateFragmentProps(element);
          } else {
            validatePropTypes(element);
          }
          return element;
        }
        var didWarnAboutDeprecatedCreateFactory = false;
        function createFactoryWithValidation(type) {
          var validatedFactory = createElementWithValidation.bind(null, type);
          validatedFactory.type = type;
          {
            if (!didWarnAboutDeprecatedCreateFactory) {
              didWarnAboutDeprecatedCreateFactory = true;
              warn("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.");
            }
            Object.defineProperty(validatedFactory, "type", {
              enumerable: false,
              get: function() {
                warn("Factory.type is deprecated. Access the class directly before passing it to createFactory.");
                Object.defineProperty(this, "type", {
                  value: type
                });
                return type;
              }
            });
          }
          return validatedFactory;
        }
        function cloneElementWithValidation(element, props, children) {
          var newElement = cloneElement.apply(this, arguments);
          for (var i = 2; i < arguments.length; i++) {
            validateChildKeys(arguments[i], newElement.type);
          }
          validatePropTypes(newElement);
          return newElement;
        }
        {
          try {
            var frozenObject = Object.freeze({});
            /* @__PURE__ */ new Map([[frozenObject, null]]);
            /* @__PURE__ */ new Set([frozenObject]);
          } catch (e) {
          }
        }
        var createElement$1 = createElementWithValidation;
        var cloneElement$1 = cloneElementWithValidation;
        var createFactory = createFactoryWithValidation;
        var Children2 = {
          map: mapChildren,
          forEach: forEachChildren,
          count: countChildren,
          toArray,
          only: onlyChild
        };
        exports.Children = Children2;
        exports.Component = Component;
        exports.PureComponent = PureComponent;
        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
        exports.cloneElement = cloneElement$1;
        exports.createContext = createContext3;
        exports.createElement = createElement$1;
        exports.createFactory = createFactory;
        exports.createRef = createRef;
        exports.forwardRef = forwardRef3;
        exports.isValidElement = isValidElement2;
        exports.lazy = lazy;
        exports.memo = memo;
        exports.useCallback = useCallback5;
        exports.useContext = useContext4;
        exports.useDebugValue = useDebugValue;
        exports.useEffect = useEffect4;
        exports.useImperativeHandle = useImperativeHandle;
        exports.useLayoutEffect = useLayoutEffect4;
        exports.useMemo = useMemo4;
        exports.useReducer = useReducer;
        exports.useRef = useRef5;
        exports.useState = useState4;
        exports.version = ReactVersion;
      })();
    }
  }
});

// node_modules/react/index.js
var require_react = __commonJS({
  "node_modules/react/index.js"(exports, module) {
    "use strict";
    init_react();
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_development();
    }
  }
});

// node_modules/@remix-run/dev/compiler/shims/react.ts
var React;
var init_react = __esm({
  "node_modules/@remix-run/dev/compiler/shims/react.ts"() {
    React = __toESM(require_react());
  }
});

// node_modules/set-cookie-parser/lib/set-cookie.js
var require_set_cookie = __commonJS({
  "node_modules/set-cookie-parser/lib/set-cookie.js"(exports, module) {
    "use strict";
    init_react();
    var defaultParseOptions = {
      decodeValues: true,
      map: false,
      silent: false
    };
    function isNonEmptyString(str) {
      return typeof str === "string" && !!str.trim();
    }
    function parseString(setCookieValue, options) {
      var parts = setCookieValue.split(";").filter(isNonEmptyString);
      var nameValue = parts.shift().split("=");
      var name = nameValue.shift();
      var value = nameValue.join("=");
      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
      try {
        value = options.decodeValues ? decodeURIComponent(value) : value;
      } catch (e) {
        console.error("set-cookie-parser encountered an error while decoding a cookie with value '" + value + "'. Set options.decodeValues to false to disable this feature.", e);
      }
      var cookie = {
        name,
        value
      };
      parts.forEach(function(part) {
        var sides = part.split("=");
        var key = sides.shift().trimLeft().toLowerCase();
        var value2 = sides.join("=");
        if (key === "expires") {
          cookie.expires = new Date(value2);
        } else if (key === "max-age") {
          cookie.maxAge = parseInt(value2, 10);
        } else if (key === "secure") {
          cookie.secure = true;
        } else if (key === "httponly") {
          cookie.httpOnly = true;
        } else if (key === "samesite") {
          cookie.sameSite = value2;
        } else {
          cookie[key] = value2;
        }
      });
      return cookie;
    }
    function parse(input, options) {
      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
      if (!input) {
        if (!options.map) {
          return [];
        } else {
          return {};
        }
      }
      if (input.headers && input.headers["set-cookie"]) {
        input = input.headers["set-cookie"];
      } else if (input.headers) {
        var sch = input.headers[Object.keys(input.headers).find(function(key) {
          return key.toLowerCase() === "set-cookie";
        })];
        if (!sch && input.headers.cookie && !options.silent) {
          console.warn("Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning.");
        }
        input = sch;
      }
      if (!Array.isArray(input)) {
        input = [input];
      }
      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
      if (!options.map) {
        return input.filter(isNonEmptyString).map(function(str) {
          return parseString(str, options);
        });
      } else {
        var cookies = {};
        return input.filter(isNonEmptyString).reduce(function(cookies2, str) {
          var cookie = parseString(str, options);
          cookies2[cookie.name] = cookie;
          return cookies2;
        }, cookies);
      }
    }
    function splitCookiesString2(cookiesString) {
      if (Array.isArray(cookiesString)) {
        return cookiesString;
      }
      if (typeof cookiesString !== "string") {
        return [];
      }
      var cookiesStrings = [];
      var pos = 0;
      var start;
      var ch;
      var lastComma;
      var nextStart;
      var cookiesSeparatorFound;
      function skipWhitespace() {
        while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
          pos += 1;
        }
        return pos < cookiesString.length;
      }
      function notSpecialChar() {
        ch = cookiesString.charAt(pos);
        return ch !== "=" && ch !== ";" && ch !== ",";
      }
      while (pos < cookiesString.length) {
        start = pos;
        cookiesSeparatorFound = false;
        while (skipWhitespace()) {
          ch = cookiesString.charAt(pos);
          if (ch === ",") {
            lastComma = pos;
            pos += 1;
            skipWhitespace();
            nextStart = pos;
            while (pos < cookiesString.length && notSpecialChar()) {
              pos += 1;
            }
            if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
              cookiesSeparatorFound = true;
              pos = nextStart;
              cookiesStrings.push(cookiesString.substring(start, lastComma));
              start = pos;
            } else {
              pos = lastComma + 1;
            }
          } else {
            pos += 1;
          }
        }
        if (!cookiesSeparatorFound || pos >= cookiesString.length) {
          cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
        }
      }
      return cookiesStrings;
    }
    module.exports = parse;
    module.exports.parse = parse;
    module.exports.parseString = parseString;
    module.exports.splitCookiesString = splitCookiesString2;
  }
});

// node_modules/jsesc/jsesc.js
var require_jsesc = __commonJS({
  "node_modules/jsesc/jsesc.js"(exports, module) {
    "use strict";
    init_react();
    var object = {};
    var hasOwnProperty2 = object.hasOwnProperty;
    var forOwn = (object2, callback) => {
      for (const key in object2) {
        if (hasOwnProperty2.call(object2, key)) {
          callback(key, object2[key]);
        }
      }
    };
    var extend = (destination, source) => {
      if (!source) {
        return destination;
      }
      forOwn(source, (key, value) => {
        destination[key] = value;
      });
      return destination;
    };
    var forEach2 = (array, callback) => {
      const length = array.length;
      let index = -1;
      while (++index < length) {
        callback(array[index]);
      }
    };
    var fourHexEscape = (hex) => {
      return "\\u" + ("0000" + hex).slice(-4);
    };
    var hexadecimal = (code, lowercase) => {
      let hexadecimal2 = code.toString(16);
      if (lowercase)
        return hexadecimal2;
      return hexadecimal2.toUpperCase();
    };
    var toString3 = object.toString;
    var isArray3 = Array.isArray;
    var isBuffer2 = (value) => {
      return typeof Buffer === "function" && Buffer.isBuffer(value);
    };
    var isObject2 = (value) => {
      return toString3.call(value) == "[object Object]";
    };
    var isString2 = (value) => {
      return typeof value == "string" || toString3.call(value) == "[object String]";
    };
    var isNumber2 = (value) => {
      return typeof value == "number" || toString3.call(value) == "[object Number]";
    };
    var isFunction2 = (value) => {
      return typeof value == "function";
    };
    var isMap = (value) => {
      return toString3.call(value) == "[object Map]";
    };
    var isSet = (value) => {
      return toString3.call(value) == "[object Set]";
    };
    var singleEscapes = {
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t"
    };
    var regexSingleEscape = /[\\\b\f\n\r\t]/;
    var regexDigit = /[0-9]/;
    var regexWhitespace = /[\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
    var escapeEverythingRegex = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^]/g;
    var escapeNonAsciiRegex = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^ !#-&\(-\[\]-_a-~]/g;
    var jsesc2 = (argument, options) => {
      const increaseIndentation = () => {
        oldIndent = indent;
        ++options.indentLevel;
        indent = options.indent.repeat(options.indentLevel);
      };
      const defaults = {
        "escapeEverything": false,
        "minimal": false,
        "isScriptContext": false,
        "quotes": "single",
        "wrap": false,
        "es6": false,
        "json": false,
        "compact": true,
        "lowercaseHex": false,
        "numbers": "decimal",
        "indent": "	",
        "indentLevel": 0,
        "__inline1__": false,
        "__inline2__": false
      };
      const json2 = options && options.json;
      if (json2) {
        defaults.quotes = "double";
        defaults.wrap = true;
      }
      options = extend(defaults, options);
      if (options.quotes != "single" && options.quotes != "double" && options.quotes != "backtick") {
        options.quotes = "single";
      }
      const quote = options.quotes == "double" ? '"' : options.quotes == "backtick" ? "`" : "'";
      const compact = options.compact;
      const lowercaseHex = options.lowercaseHex;
      let indent = options.indent.repeat(options.indentLevel);
      let oldIndent = "";
      const inline1 = options.__inline1__;
      const inline2 = options.__inline2__;
      const newLine = compact ? "" : "\n";
      let result;
      let isEmpty = true;
      const useBinNumbers = options.numbers == "binary";
      const useOctNumbers = options.numbers == "octal";
      const useDecNumbers = options.numbers == "decimal";
      const useHexNumbers = options.numbers == "hexadecimal";
      if (json2 && argument && isFunction2(argument.toJSON)) {
        argument = argument.toJSON();
      }
      if (!isString2(argument)) {
        if (isMap(argument)) {
          if (argument.size == 0) {
            return "new Map()";
          }
          if (!compact) {
            options.__inline1__ = true;
            options.__inline2__ = false;
          }
          return "new Map(" + jsesc2(Array.from(argument), options) + ")";
        }
        if (isSet(argument)) {
          if (argument.size == 0) {
            return "new Set()";
          }
          return "new Set(" + jsesc2(Array.from(argument), options) + ")";
        }
        if (isBuffer2(argument)) {
          if (argument.length == 0) {
            return "Buffer.from([])";
          }
          return "Buffer.from(" + jsesc2(Array.from(argument), options) + ")";
        }
        if (isArray3(argument)) {
          result = [];
          options.wrap = true;
          if (inline1) {
            options.__inline1__ = false;
            options.__inline2__ = true;
          }
          if (!inline2) {
            increaseIndentation();
          }
          forEach2(argument, (value) => {
            isEmpty = false;
            if (inline2) {
              options.__inline2__ = false;
            }
            result.push((compact || inline2 ? "" : indent) + jsesc2(value, options));
          });
          if (isEmpty) {
            return "[]";
          }
          if (inline2) {
            return "[" + result.join(", ") + "]";
          }
          return "[" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "]";
        } else if (isNumber2(argument)) {
          if (json2) {
            return JSON.stringify(argument);
          }
          if (useDecNumbers) {
            return String(argument);
          }
          if (useHexNumbers) {
            let hexadecimal2 = argument.toString(16);
            if (!lowercaseHex) {
              hexadecimal2 = hexadecimal2.toUpperCase();
            }
            return "0x" + hexadecimal2;
          }
          if (useBinNumbers) {
            return "0b" + argument.toString(2);
          }
          if (useOctNumbers) {
            return "0o" + argument.toString(8);
          }
        } else if (!isObject2(argument)) {
          if (json2) {
            return JSON.stringify(argument) || "null";
          }
          return String(argument);
        } else {
          result = [];
          options.wrap = true;
          increaseIndentation();
          forOwn(argument, (key, value) => {
            isEmpty = false;
            result.push((compact ? "" : indent) + jsesc2(key, options) + ":" + (compact ? "" : " ") + jsesc2(value, options));
          });
          if (isEmpty) {
            return "{}";
          }
          return "{" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "}";
        }
      }
      const regex = options.escapeEverything ? escapeEverythingRegex : escapeNonAsciiRegex;
      result = argument.replace(regex, (char, pair, lone, quoteChar, index, string) => {
        if (pair) {
          if (options.minimal)
            return pair;
          const first = pair.charCodeAt(0);
          const second = pair.charCodeAt(1);
          if (options.es6) {
            const codePoint = (first - 55296) * 1024 + second - 56320 + 65536;
            const hex2 = hexadecimal(codePoint, lowercaseHex);
            return "\\u{" + hex2 + "}";
          }
          return fourHexEscape(hexadecimal(first, lowercaseHex)) + fourHexEscape(hexadecimal(second, lowercaseHex));
        }
        if (lone) {
          return fourHexEscape(hexadecimal(lone.charCodeAt(0), lowercaseHex));
        }
        if (char == "\0" && !json2 && !regexDigit.test(string.charAt(index + 1))) {
          return "\\0";
        }
        if (quoteChar) {
          if (quoteChar == quote || options.escapeEverything) {
            return "\\" + quoteChar;
          }
          return quoteChar;
        }
        if (regexSingleEscape.test(char)) {
          return singleEscapes[char];
        }
        if (options.minimal && !regexWhitespace.test(char)) {
          return char;
        }
        const hex = hexadecimal(char.charCodeAt(0), lowercaseHex);
        if (json2 || hex.length > 2) {
          return fourHexEscape(hex);
        }
        return "\\x" + ("00" + hex).slice(-2);
      });
      if (quote == "`") {
        result = result.replace(/\$\{/g, "\\${");
      }
      if (options.isScriptContext) {
        result = result.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, json2 ? "\\u003C!--" : "\\x3C!--");
      }
      if (options.wrap) {
        result = quote + result + quote;
      }
      return result;
    };
    jsesc2.version = "3.0.2";
    module.exports = jsesc2;
  }
});

// node-modules-polyfills:events
function EventHandlers() {
}
function EventEmitter() {
  EventEmitter.init.call(this);
}
function $getMaxListeners(that) {
  if (that._maxListeners === void 0)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}
function emitNone(handler, isFn, self2) {
  if (isFn)
    handler.call(self2);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].call(self2);
  }
}
function emitOne(handler, isFn, self2, arg1) {
  if (isFn)
    handler.call(self2, arg1);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].call(self2, arg1);
  }
}
function emitTwo(handler, isFn, self2, arg1, arg2) {
  if (isFn)
    handler.call(self2, arg1, arg2);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].call(self2, arg1, arg2);
  }
}
function emitThree(handler, isFn, self2, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self2, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].call(self2, arg1, arg2, arg3);
  }
}
function emitMany(handler, isFn, self2, args) {
  if (isFn)
    handler.apply(self2, args);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].apply(self2, args);
  }
}
function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  events = target._events;
  if (!events) {
    events = target._events = new EventHandlers();
    target._eventsCount = 0;
  } else {
    if (events.newListener) {
      target.emit("newListener", type, listener.listener ? listener.listener : listener);
      events = target._events;
    }
    existing = events[type];
  }
  if (!existing) {
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events[type] = prepend ? [listener, existing] : [existing, listener];
    } else {
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + type + " listeners added. Use emitter.setMaxListeners() to increase limit");
        w.name = "MaxListenersExceededWarning";
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        emitWarning(w);
      }
    }
  }
  return target;
}
function emitWarning(e) {
  typeof console.warn === "function" ? console.warn(e) : console.log(e);
}
function _onceWrap(target, type, listener) {
  var fired = false;
  function g() {
    target.removeListener(type, g);
    if (!fired) {
      fired = true;
      listener.apply(target, arguments);
    }
  }
  g.listener = listener;
  return g;
}
function listenerCount(type) {
  var events = this._events;
  if (events) {
    var evlistener = events[type];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }
  return 0;
}
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}
function arrayClone(arr, i) {
  var copy2 = new Array(i);
  while (i--)
    copy2[i] = arr[i];
  return copy2;
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}
var domain, events_default;
var init_events = __esm({
  "node-modules-polyfills:events"() {
    "use strict";
    init_react();
    EventHandlers.prototype = /* @__PURE__ */ Object.create(null);
    events_default = EventEmitter;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.usingDomains = false;
    EventEmitter.prototype.domain = void 0;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._maxListeners = void 0;
    EventEmitter.defaultMaxListeners = 10;
    EventEmitter.init = function() {
      this.domain = null;
      if (EventEmitter.usingDomains) {
        if (domain.active && !(this instanceof domain.Domain)) {
          this.domain = domain.active;
        }
      }
      if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
        this._events = new EventHandlers();
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || isNaN(n))
        throw new TypeError('"n" argument must be a positive number');
      this._maxListeners = n;
      return this;
    };
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return $getMaxListeners(this);
    };
    EventEmitter.prototype.emit = function emit(type) {
      var er, handler, len, args, i, events, domain2;
      var needDomainExit = false;
      var doError = type === "error";
      events = this._events;
      if (events)
        doError = doError && events.error == null;
      else if (!doError)
        return false;
      domain2 = this.domain;
      if (doError) {
        er = arguments[1];
        if (domain2) {
          if (!er)
            er = new Error('Uncaught, unspecified "error" event');
          er.domainEmitter = this;
          er.domain = domain2;
          er.domainThrown = false;
          domain2.emit("error", er);
        } else if (er instanceof Error) {
          throw er;
        } else {
          var err = new Error('Uncaught, unspecified "error" event. (' + er + ")");
          err.context = er;
          throw err;
        }
        return false;
      }
      handler = events[type];
      if (!handler)
        return false;
      var isFn = typeof handler === "function";
      len = arguments.length;
      switch (len) {
        case 1:
          emitNone(handler, isFn, this);
          break;
        case 2:
          emitOne(handler, isFn, this, arguments[1]);
          break;
        case 3:
          emitTwo(handler, isFn, this, arguments[1], arguments[2]);
          break;
        case 4:
          emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
          break;
        default:
          args = new Array(len - 1);
          for (i = 1; i < len; i++)
            args[i - 1] = arguments[i];
          emitMany(handler, isFn, this, args);
      }
      if (needDomainExit)
        domain2.exit();
      return true;
    };
    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    EventEmitter.prototype.once = function once(type, listener) {
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i, originalListener;
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      events = this._events;
      if (!events)
        return this;
      list = events[type];
      if (!list)
        return this;
      if (list === listener || list.listener && list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = new EventHandlers();
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length; i-- > 0; ) {
          if (list[i] === listener || list[i].listener && list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (list.length === 1) {
          list[0] = void 0;
          if (--this._eventsCount === 0) {
            this._events = new EventHandlers();
            return this;
          } else {
            delete events[type];
          }
        } else {
          spliceOne(list, position);
        }
        if (events.removeListener)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners2, events;
      events = this._events;
      if (!events)
        return this;
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = new EventHandlers();
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = new EventHandlers();
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys2 = Object.keys(events);
        for (var i = 0, key; i < keys2.length; ++i) {
          key = keys2[i];
          if (key === "removeListener")
            continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = new EventHandlers();
        this._eventsCount = 0;
        return this;
      }
      listeners2 = events[type];
      if (typeof listeners2 === "function") {
        this.removeListener(type, listeners2);
      } else if (listeners2) {
        do {
          this.removeListener(type, listeners2[listeners2.length - 1]);
        } while (listeners2[0]);
      }
      return this;
    };
    EventEmitter.prototype.listeners = function listeners(type) {
      var evlistener;
      var ret;
      var events = this._events;
      if (!events)
        ret = [];
      else {
        evlistener = events[type];
        if (!evlistener)
          ret = [];
        else if (typeof evlistener === "function")
          ret = [evlistener.listener || evlistener];
        else
          ret = unwrapListeners(evlistener);
      }
      return ret;
    };
    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
    };
  }
});

// node-modules-polyfills:process
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e2) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e2) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
function nextTick(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
function noop() {
}
function binding(name) {
  throw new Error("process.binding is not supported");
}
function cwd() {
  return "/";
}
function chdir(dir) {
  throw new Error("process.chdir is not supported");
}
function umask() {
  return 0;
}
function hrtime(previousTimestamp) {
  var clocktime = performanceNow.call(performance) * 1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds, nanoseconds];
}
function uptime() {
  var currentTime = new Date();
  var dif = currentTime - startTime;
  return dif / 1e3;
}
var cachedSetTimeout, cachedClearTimeout, queue, draining, currentQueue, queueIndex, title, platform, browser, env, argv, version, versions, release, config, on, addListener2, once2, off, removeListener2, removeAllListeners2, emit2, performance, performanceNow, startTime, browser$1, process_default;
var init_process = __esm({
  "node-modules-polyfills:process"() {
    init_react();
    cachedSetTimeout = defaultSetTimout;
    cachedClearTimeout = defaultClearTimeout;
    if (typeof globalThis.setTimeout === "function") {
      cachedSetTimeout = setTimeout;
    }
    if (typeof globalThis.clearTimeout === "function") {
      cachedClearTimeout = clearTimeout;
    }
    queue = [];
    draining = false;
    queueIndex = -1;
    Item.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    title = "browser";
    platform = "browser";
    browser = true;
    env = {};
    argv = [];
    version = "";
    versions = {};
    release = {};
    config = {};
    on = noop;
    addListener2 = noop;
    once2 = noop;
    off = noop;
    removeListener2 = noop;
    removeAllListeners2 = noop;
    emit2 = noop;
    performance = globalThis.performance || {};
    performanceNow = performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow || function() {
      return new Date().getTime();
    };
    startTime = new Date();
    browser$1 = {
      nextTick,
      title,
      browser,
      env,
      argv,
      version,
      versions,
      on,
      addListener: addListener2,
      once: once2,
      off,
      removeListener: removeListener2,
      removeAllListeners: removeAllListeners2,
      emit: emit2,
      binding,
      cwd,
      chdir,
      umask,
      hrtime,
      platform,
      release,
      config,
      uptime
    };
    process_default = browser$1;
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/inherits.js
var inherits, inherits_default;
var init_inherits = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/inherits.js"() {
    init_react();
    if (typeof Object.create === "function") {
      inherits = function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      };
    } else {
      inherits = function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      };
    }
    inherits_default = inherits;
  }
});

// node-modules-polyfills:util
function format(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(" ");
  }
  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x2) {
    if (x2 === "%%")
      return "%";
    if (i >= len)
      return x2;
    switch (x2) {
      case "%s":
        return String(args[i++]);
      case "%d":
        return Number(args[i++]);
      case "%j":
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return "[Circular]";
        }
      default:
        return x2;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += " " + x;
    } else {
      str += " " + inspect(x);
    }
  }
  return str;
}
function deprecate(fn, msg) {
  if (isUndefined(globalThis.process)) {
    return function() {
      return deprecate(fn, msg).apply(this, arguments);
    };
  }
  if (process_default.noDeprecation === true) {
    return fn;
  }
  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process_default.throwDeprecation) {
        throw new Error(msg);
      } else if (process_default.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }
  return deprecated;
}
function debuglog(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process_default.env.NODE_DEBUG || "";
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
      var pid = 0;
      debugs[set] = function() {
        var msg = format.apply(null, arguments);
        console.error("%s %d: %s", set, pid, msg);
      };
    } else {
      debugs[set] = function() {
      };
    }
  }
  return debugs[set];
}
function inspect(obj, opts) {
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  if (arguments.length >= 3)
    ctx.depth = arguments[2];
  if (arguments.length >= 4)
    ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    ctx.showHidden = opts;
  } else if (opts) {
    _extend(ctx, opts);
  }
  if (isUndefined(ctx.showHidden))
    ctx.showHidden = false;
  if (isUndefined(ctx.depth))
    ctx.depth = 2;
  if (isUndefined(ctx.colors))
    ctx.colors = false;
  if (isUndefined(ctx.customInspect))
    ctx.customInspect = true;
  if (ctx.colors)
    ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];
  if (style) {
    return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
  } else {
    return str;
  }
}
function stylizeNoColor(str, styleType) {
  return str;
}
function arrayToHash(array) {
  var hash = {};
  array.forEach(function(val, idx) {
    hash[val] = true;
  });
  return hash;
}
function formatValue(ctx, value, recurseTimes) {
  if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== inspect && !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }
  var keys2 = Object.keys(value);
  var visibleKeys = arrayToHash(keys2);
  if (ctx.showHidden) {
    keys2 = Object.getOwnPropertyNames(value);
  }
  if (isError(value) && (keys2.indexOf("message") >= 0 || keys2.indexOf("description") >= 0)) {
    return formatError(value);
  }
  if (keys2.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ": " + value.name : "";
      return ctx.stylize("[Function" + name + "]", "special");
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), "date");
    }
    if (isError(value)) {
      return formatError(value);
    }
  }
  var base = "", array = false, braces = ["{", "}"];
  if (isArray(value)) {
    array = true;
    braces = ["[", "]"];
  }
  if (isFunction(value)) {
    var n = value.name ? ": " + value.name : "";
    base = " [Function" + n + "]";
  }
  if (isRegExp(value)) {
    base = " " + RegExp.prototype.toString.call(value);
  }
  if (isDate(value)) {
    base = " " + Date.prototype.toUTCString.call(value);
  }
  if (isError(value)) {
    base = " " + formatError(value);
  }
  if (keys2.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }
  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
    } else {
      return ctx.stylize("[Object]", "special");
    }
  }
  ctx.seen.push(value);
  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys2);
  } else {
    output = keys2.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }
  ctx.seen.pop();
  return reduceToSingleString(output, base, braces);
}
function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize("undefined", "undefined");
  if (isString(value)) {
    var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
    return ctx.stylize(simple, "string");
  }
  if (isNumber(value))
    return ctx.stylize("" + value, "number");
  if (isBoolean(value))
    return ctx.stylize("" + value, "boolean");
  if (isNull(value))
    return ctx.stylize("null", "null");
}
function formatError(value) {
  return "[" + Error.prototype.toString.call(value) + "]";
}
function formatArray(ctx, value, recurseTimes, visibleKeys, keys2) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
    } else {
      output.push("");
    }
  }
  keys2.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    }
  });
  return output;
}
function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize("[Getter/Setter]", "special");
    } else {
      str = ctx.stylize("[Getter]", "special");
    }
  } else {
    if (desc.set) {
      str = ctx.stylize("[Setter]", "special");
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = "[" + key + "]";
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf("\n") > -1) {
        if (array) {
          str = str.split("\n").map(function(line) {
            return "  " + line;
          }).join("\n").substr(2);
        } else {
          str = "\n" + str.split("\n").map(function(line) {
            return "   " + line;
          }).join("\n");
        }
      }
    } else {
      str = ctx.stylize("[Circular]", "special");
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify("" + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, "name");
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, "string");
    }
  }
  return name + ": " + str;
}
function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf("\n") >= 0)
      numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
  }, 0);
  if (length > 60) {
    return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
  }
  return braces[0] + base + " " + output.join(", ") + " " + braces[1];
}
function isArray(ar) {
  return Array.isArray(ar);
}
function isBoolean(arg) {
  return typeof arg === "boolean";
}
function isNull(arg) {
  return arg === null;
}
function isNumber(arg) {
  return typeof arg === "number";
}
function isString(arg) {
  return typeof arg === "string";
}
function isUndefined(arg) {
  return arg === void 0;
}
function isRegExp(re) {
  return isObject(re) && objectToString(re) === "[object RegExp]";
}
function isObject(arg) {
  return typeof arg === "object" && arg !== null;
}
function isDate(d) {
  return isObject(d) && objectToString(d) === "[object Date]";
}
function isError(e) {
  return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
}
function isFunction(arg) {
  return typeof arg === "function";
}
function objectToString(o) {
  return Object.prototype.toString.call(o);
}
function _extend(origin, add) {
  if (!add || !isObject(add))
    return origin;
  var keys2 = Object.keys(add);
  var i = keys2.length;
  while (i--) {
    origin[keys2[i]] = add[keys2[i]];
  }
  return origin;
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
var formatRegExp, debugs, debugEnviron;
var init_util = __esm({
  "node-modules-polyfills:util"() {
    init_react();
    init_process();
    init_inherits();
    formatRegExp = /%[sdj%]/g;
    debugs = {};
    inspect.colors = {
      "bold": [1, 22],
      "italic": [3, 23],
      "underline": [4, 24],
      "inverse": [7, 27],
      "white": [37, 39],
      "grey": [90, 39],
      "black": [30, 39],
      "blue": [34, 39],
      "cyan": [36, 39],
      "green": [32, 39],
      "magenta": [35, 39],
      "red": [31, 39],
      "yellow": [33, 39]
    };
    inspect.styles = {
      "special": "cyan",
      "number": "yellow",
      "boolean": "yellow",
      "undefined": "grey",
      "null": "bold",
      "string": "green",
      "date": "magenta",
      "regexp": "red"
    };
  }
});

// node-modules-polyfills:buffer
function init() {
  inited = true;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
}
function toByteArray(b64) {
  if (!inited) {
    init();
  }
  var i, j, l, tmp, placeHolders, arr;
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
  arr = new Arr(len * 3 / 4 - placeHolders);
  l = placeHolders > 0 ? len - 4 : len;
  var L = 0;
  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[L++] = tmp >> 16 & 255;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  if (placeHolders === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[L++] = tmp & 255;
  } else if (placeHolders === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  if (!inited) {
    init();
  }
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var output = "";
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[tmp << 4 & 63];
    output += "==";
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    output += lookup[tmp >> 10];
    output += lookup[tmp >> 4 & 63];
    output += lookup[tmp << 2 & 63];
    output += "=";
  }
  parts.push(output);
  return parts.join("");
}
function read(buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
  }
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
}
function write(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
  }
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
  }
  buffer[offset + i - d] |= s * 128;
}
function kMaxLength() {
  return Buffer2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError("Invalid typed array length");
  }
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    that = new Uint8Array(length);
    that.__proto__ = Buffer2.prototype;
  } else {
    if (that === null) {
      that = new Buffer2(length);
    }
    that.length = length;
  }
  return that;
}
function Buffer2(arg, encodingOrOffset, length) {
  if (!Buffer2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer2)) {
    return new Buffer2(arg, encodingOrOffset, length);
  }
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new Error("If encoding is specified then the first argument must be a string");
    }
    return allocUnsafe(this, arg);
  }
  return from(this, arg, encodingOrOffset, length);
}
function from(that, value, encodingOrOffset, length) {
  if (typeof value === "number") {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }
  if (typeof value === "string") {
    return fromString(that, value, encodingOrOffset);
  }
  return fromObject(that, value);
}
function assertSize(size) {
  if (typeof size !== "number") {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}
function alloc(that, size, fill2, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size);
  }
  if (fill2 !== void 0) {
    return typeof encoding === "string" ? createBuffer(that, size).fill(fill2, encoding) : createBuffer(that, size).fill(fill2);
  }
  return createBuffer(that, size);
}
function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer2.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that;
}
function fromString(that, string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer2.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }
  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);
  var actual = that.write(string, encoding);
  if (actual !== length) {
    that = that.slice(0, actual);
  }
  return that;
}
function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that;
}
function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength;
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError("'offset' is out of bounds");
  }
  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError("'length' is out of bounds");
  }
  if (byteOffset === void 0 && length === void 0) {
    array = new Uint8Array(array);
  } else if (length === void 0) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    that = array;
    that.__proto__ = Buffer2.prototype;
  } else {
    that = fromArrayLike(that, array);
  }
  return that;
}
function fromObject(that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);
    if (that.length === 0) {
      return that;
    }
    obj.copy(that, 0, 0, len);
    return that;
  }
  if (obj) {
    if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
      if (typeof obj.length !== "number" || isnan(obj.length)) {
        return createBuffer(that, 0);
      }
      return fromArrayLike(that, obj);
    }
    if (obj.type === "Buffer" && isArray2(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function checked(length) {
  if (length >= kMaxLength()) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
  }
  return length | 0;
}
function internalIsBuffer(b) {
  return !!(b != null && b._isBuffer);
}
function byteLength(string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== "string") {
    string = "" + string;
  }
  var len = string.length;
  if (len === 0)
    return 0;
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes(string).length;
      default:
        if (loweredCase)
          return utf8ToBytes(string).length;
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
function slowToString(encoding, start, end) {
  var loweredCase = false;
  if (start === void 0 || start < 0) {
    start = 0;
  }
  if (start > this.length) {
    return "";
  }
  if (end === void 0 || end > this.length) {
    end = this.length;
  }
  if (end <= 0) {
    return "";
  }
  end >>>= 0;
  start >>>= 0;
  if (end <= start) {
    return "";
  }
  if (!encoding)
    encoding = "utf8";
  while (true) {
    switch (encoding) {
      case "hex":
        return hexSlice(this, start, end);
      case "utf8":
      case "utf-8":
        return utf8Slice(this, start, end);
      case "ascii":
        return asciiSlice(this, start, end);
      case "latin1":
      case "binary":
        return latin1Slice(this, start, end);
      case "base64":
        return base64Slice(this, start, end);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice(this, start, end);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase();
        loweredCase = true;
    }
  }
}
function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  if (buffer.length === 0)
    return -1;
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer.length - 1;
  }
  if (byteOffset < 0)
    byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir)
      return -1;
    else
      byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir)
      byteOffset = 0;
    else
      return -1;
  }
  if (typeof val === "string") {
    val = Buffer2.from(val, encoding);
  }
  if (internalIsBuffer(val)) {
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === "number") {
    val = val & 255;
    if (Buffer2.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== void 0) {
    encoding = String(encoding).toLowerCase();
    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read2(buf, i2) {
    if (indexSize === 1) {
      return buf[i2];
    } else {
      return buf.readUInt16BE(i2 * indexSize);
    }
  }
  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read2(arr, i) === read2(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1)
          foundIndex = i;
        if (i - foundIndex + 1 === valLength)
          return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1)
          i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength)
      byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read2(arr, i + j) !== read2(val, j)) {
          found = false;
          break;
        }
      }
      if (found)
        return i;
    }
  }
  return -1;
}
function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }
  var strLen = string.length;
  if (strLen % 2 !== 0)
    throw new TypeError("Invalid hex string");
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed))
      return i;
    buf[offset + i] = parsed;
  }
  return i;
}
function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}
function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return fromByteArray(buf);
  } else {
    return fromByteArray(buf.slice(start, end));
  }
}
function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  var res = "";
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}
function asciiSlice(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 127);
  }
  return ret;
}
function latin1Slice(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}
function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0)
    start = 0;
  if (!end || end < 0 || end > len)
    end = len;
  var out = "";
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out;
}
function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = "";
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0)
    throw new RangeError("offset is not uint");
  if (offset + ext > length)
    throw new RangeError("Trying to access beyond buffer length");
}
function checkInt(buf, value, offset, ext, max, min) {
  if (!internalIsBuffer(buf))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min)
    throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
}
function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 65535 + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}
function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 4294967295 + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255;
  }
}
function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
  if (offset < 0)
    throw new RangeError("Index out of range");
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4);
  }
  write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}
function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8);
  }
  write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}
function base64clean(str) {
  str = stringtrim(str).replace(INVALID_BASE64_RE, "");
  if (str.length < 2)
    return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
function stringtrim(str) {
  if (str.trim)
    return str.trim();
  return str.replace(/^\s+|\s+$/g, "");
}
function toHex(n) {
  if (n < 16)
    return "0" + n.toString(16);
  return n.toString(16);
}
function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        } else if (i + 1 === length) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function asciiToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    byteArray.push(str.charCodeAt(i) & 255);
  }
  return byteArray;
}
function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0)
      break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes(str) {
  return toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length)
      break;
    dst[i + offset] = src[i];
  }
  return i;
}
function isnan(val) {
  return val !== val;
}
function isBuffer(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
}
function isFastBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer(obj.slice(0, 0));
}
var lookup, revLookup, Arr, inited, toString, isArray2, INSPECT_MAX_BYTES, _kMaxLength, MAX_ARGUMENTS_LENGTH, INVALID_BASE64_RE;
var init_buffer = __esm({
  "node-modules-polyfills:buffer"() {
    init_react();
    lookup = [];
    revLookup = [];
    Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    inited = false;
    toString = {}.toString;
    isArray2 = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
    INSPECT_MAX_BYTES = 50;
    Buffer2.TYPED_ARRAY_SUPPORT = globalThis.TYPED_ARRAY_SUPPORT !== void 0 ? globalThis.TYPED_ARRAY_SUPPORT : true;
    _kMaxLength = kMaxLength();
    Buffer2.poolSize = 8192;
    Buffer2._augment = function(arr) {
      arr.__proto__ = Buffer2.prototype;
      return arr;
    };
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from(null, value, encodingOrOffset, length);
    };
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      Buffer2.prototype.__proto__ = Uint8Array.prototype;
      Buffer2.__proto__ = Uint8Array;
    }
    Buffer2.alloc = function(size, fill2, encoding) {
      return alloc(null, size, fill2, encoding);
    };
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(null, size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(null, size);
    };
    Buffer2.isBuffer = isBuffer;
    Buffer2.compare = function compare(a, b) {
      if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
        throw new TypeError("Arguments must be Buffers");
      }
      if (a === b)
        return 0;
      var x = a.length;
      var y = b.length;
      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat(list, length) {
      if (!isArray2(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      var i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      var buffer = Buffer2.allocUnsafe(length);
      var pos = 0;
      for (i = 0; i < list.length; ++i) {
        var buf = list[i];
        if (!internalIsBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        buf.copy(buffer, pos);
        pos += buf.length;
      }
      return buffer;
    };
    Buffer2.byteLength = byteLength;
    Buffer2.prototype._isBuffer = true;
    Buffer2.prototype.swap16 = function swap16() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString2() {
      var length = this.length | 0;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.equals = function equals(b) {
      if (!internalIsBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer2.compare(this, b) === 0;
    };
    Buffer2.prototype.inspect = function inspect2() {
      var str = "";
      var max = INSPECT_MAX_BYTES;
      if (this.length > 0) {
        str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
        if (this.length > max)
          str += " ... ";
      }
      return "<Buffer " + str + ">";
    };
    Buffer2.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
      if (!internalIsBuffer(target)) {
        throw new TypeError("Argument must be a Buffer");
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    Buffer2.prototype.write = function write2(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset | 0;
        if (isFinite(length)) {
          length = length | 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      }
      var remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
            return asciiWrite(this, string, offset, length);
          case "latin1":
          case "binary":
            return latin1Write(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    MAX_ARGUMENTS_LENGTH = 4096;
    Buffer2.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      var newBuf;
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end);
        newBuf.__proto__ = Buffer2.prototype;
      } else {
        var sliceLen = end - start;
        newBuf = new Buffer2(sliceLen, void 0);
        for (var i = 0; i < sliceLen; ++i) {
          newBuf[i] = this[i + start];
        }
      }
      return newBuf;
    };
    Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      var val = this[offset + --byteLength2];
      var mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var i = byteLength2;
      var mul = 1;
      var val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return read(this, offset, false, 52, 8);
    };
    Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var mul = 1;
      var i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      if (!Buffer2.TYPED_ARRAY_SUPPORT)
        value = Math.floor(value);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (!Buffer2.TYPED_ARRAY_SUPPORT)
        value = Math.floor(value);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("sourceStart out of bounds");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      var i;
      if (this === target && start < targetStart && targetStart < end) {
        for (i = len - 1; i >= 0; --i) {
          target[i + targetStart] = this[i + start];
        }
      } else if (len < 1e3 || !Buffer2.TYPED_ARRAY_SUPPORT) {
        for (i = 0; i < len; ++i) {
          target[i + targetStart] = this[i + start];
        }
      } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (code < 256) {
            val = code;
          }
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
      } else if (typeof val === "number") {
        val = val & 255;
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      var i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer2(val, encoding).toString());
        var len = bytes.length;
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/buffer-list.js
function BufferList() {
  this.head = null;
  this.tail = null;
  this.length = 0;
}
var buffer_list_default;
var init_buffer_list = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/buffer-list.js"() {
    init_react();
    init_buffer();
    buffer_list_default = BufferList;
    BufferList.prototype.push = function(v) {
      var entry2 = { data: v, next: null };
      if (this.length > 0)
        this.tail.next = entry2;
      else
        this.head = entry2;
      this.tail = entry2;
      ++this.length;
    };
    BufferList.prototype.unshift = function(v) {
      var entry2 = { data: v, next: this.head };
      if (this.length === 0)
        this.tail = entry2;
      this.head = entry2;
      ++this.length;
    };
    BufferList.prototype.shift = function() {
      if (this.length === 0)
        return;
      var ret = this.head.data;
      if (this.length === 1)
        this.head = this.tail = null;
      else
        this.head = this.head.next;
      --this.length;
      return ret;
    };
    BufferList.prototype.clear = function() {
      this.head = this.tail = null;
      this.length = 0;
    };
    BufferList.prototype.join = function(s) {
      if (this.length === 0)
        return "";
      var p = this.head;
      var ret = "" + p.data;
      while (p = p.next) {
        ret += s + p.data;
      }
      return ret;
    };
    BufferList.prototype.concat = function(n) {
      if (this.length === 0)
        return Buffer2.alloc(0);
      if (this.length === 1)
        return this.head.data;
      var ret = Buffer2.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;
      while (p) {
        p.data.copy(ret, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    };
  }
});

// node-modules-polyfills:string_decoder
function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error("Unknown encoding: " + encoding);
  }
}
function StringDecoder(encoding) {
  this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "");
  assertEncoding(encoding);
  switch (this.encoding) {
    case "utf8":
      this.surrogateSize = 3;
      break;
    case "ucs2":
    case "utf16le":
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case "base64":
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }
  this.charBuffer = new Buffer2(6);
  this.charReceived = 0;
  this.charLength = 0;
}
function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}
function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}
function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}
var isBufferEncoding;
var init_string_decoder = __esm({
  "node-modules-polyfills:string_decoder"() {
    init_react();
    init_buffer();
    isBufferEncoding = Buffer2.isEncoding || function(encoding) {
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    StringDecoder.prototype.write = function(buffer) {
      var charStr = "";
      while (this.charLength) {
        var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
        buffer.copy(this.charBuffer, this.charReceived, 0, available);
        this.charReceived += available;
        if (this.charReceived < this.charLength) {
          return "";
        }
        buffer = buffer.slice(available, buffer.length);
        charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
        var charCode = charStr.charCodeAt(charStr.length - 1);
        if (charCode >= 55296 && charCode <= 56319) {
          this.charLength += this.surrogateSize;
          charStr = "";
          continue;
        }
        this.charReceived = this.charLength = 0;
        if (buffer.length === 0) {
          return charStr;
        }
        break;
      }
      this.detectIncompleteChar(buffer);
      var end = buffer.length;
      if (this.charLength) {
        buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
        end -= this.charReceived;
      }
      charStr += buffer.toString(this.encoding, 0, end);
      var end = charStr.length - 1;
      var charCode = charStr.charCodeAt(end);
      if (charCode >= 55296 && charCode <= 56319) {
        var size = this.surrogateSize;
        this.charLength += size;
        this.charReceived += size;
        this.charBuffer.copy(this.charBuffer, size, 0, size);
        buffer.copy(this.charBuffer, 0, 0, size);
        return charStr.substring(0, end);
      }
      return charStr;
    };
    StringDecoder.prototype.detectIncompleteChar = function(buffer) {
      var i = buffer.length >= 3 ? 3 : buffer.length;
      for (; i > 0; i--) {
        var c = buffer[buffer.length - i];
        if (i == 1 && c >> 5 == 6) {
          this.charLength = 2;
          break;
        }
        if (i <= 2 && c >> 4 == 14) {
          this.charLength = 3;
          break;
        }
        if (i <= 3 && c >> 3 == 30) {
          this.charLength = 4;
          break;
        }
      }
      this.charReceived = i;
    };
    StringDecoder.prototype.end = function(buffer) {
      var res = "";
      if (buffer && buffer.length)
        res = this.write(buffer);
      if (this.charReceived) {
        var cr = this.charReceived;
        var buf = this.charBuffer;
        var enc = this.encoding;
        res += buf.slice(0, cr).toString(enc);
      }
      return res;
    };
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/readable.js
function prependListener2(emitter, event, fn) {
  if (typeof emitter.prependListener === "function") {
    return emitter.prependListener(event, fn);
  } else {
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
}
function listenerCount2(emitter, type) {
  return emitter.listeners(type).length;
}
function ReadableState(options, stream) {
  options = options || {};
  this.objectMode = !!options.objectMode;
  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.readableObjectMode;
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
  this.highWaterMark = ~~this.highWaterMark;
  this.buffer = new buffer_list_default();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;
  this.sync = true;
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.defaultEncoding = options.defaultEncoding || "utf8";
  this.ranOut = false;
  this.awaitDrain = 0;
  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}
function Readable(options) {
  if (!(this instanceof Readable))
    return new Readable(options);
  this._readableState = new ReadableState(options, this);
  this.readable = true;
  if (options && typeof options.read === "function")
    this._read = options.read;
  events_default.call(this);
}
function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit("error", er);
  } else if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error("stream.push() after EOF");
      stream.emit("error", e);
    } else if (state.endEmitted && addToFront) {
      var _e = new Error("stream.unshift() after end event");
      stream.emit("error", _e);
    } else {
      var skipAdd;
      if (state.decoder && !addToFront && !encoding) {
        chunk = state.decoder.write(chunk);
        skipAdd = !state.objectMode && chunk.length === 0;
      }
      if (!addToFront)
        state.reading = false;
      if (!skipAdd) {
        if (state.flowing && state.length === 0 && !state.sync) {
          stream.emit("data", chunk);
          stream.read(0);
        } else {
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront)
            state.buffer.unshift(chunk);
          else
            state.buffer.push(chunk);
          if (state.needReadable)
            emitReadable(stream);
        }
      }
      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }
  return needMoreData(state);
}
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended)
    return 0;
  if (state.objectMode)
    return 1;
  if (n !== n) {
    if (state.flowing && state.length)
      return state.buffer.head.data.length;
    else
      return state.length;
  }
  if (n > state.highWaterMark)
    state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length)
    return n;
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}
function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer.isBuffer(chunk) && typeof chunk !== "string" && chunk !== null && chunk !== void 0 && !state.objectMode) {
    er = new TypeError("Invalid non-string/buffer chunk");
  }
  return er;
}
function onEofChunk(stream, state) {
  if (state.ended)
    return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;
  emitReadable(stream);
}
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug("emitReadable", state.flowing);
    state.emittedReadable = true;
    if (state.sync)
      nextTick(emitReadable_, stream);
    else
      emitReadable_(stream);
  }
}
function emitReadable_(stream) {
  debug("emit readable");
  stream.emit("readable");
  flow(stream);
}
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    nextTick(maybeReadMore_, stream, state);
  }
}
function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug("maybeReadMore read 0");
    stream.read(0);
    if (len === state.length)
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}
function pipeOnDrain(src) {
  return function() {
    var state = src._readableState;
    debug("pipeOnDrain", state.awaitDrain);
    if (state.awaitDrain)
      state.awaitDrain--;
    if (state.awaitDrain === 0 && src.listeners("data").length) {
      state.flowing = true;
      flow(src);
    }
  };
}
function nReadingNextTick(self2) {
  debug("readable nexttick read 0");
  self2.read(0);
}
function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    nextTick(resume_, stream, state);
  }
}
function resume_(stream, state) {
  if (!state.reading) {
    debug("resume read 0");
    stream.read(0);
  }
  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit("resume");
  flow(stream);
  if (state.flowing && !state.reading)
    stream.read(0);
}
function flow(stream) {
  var state = stream._readableState;
  debug("flow", state.flowing);
  while (state.flowing && stream.read() !== null) {
  }
}
function fromList(n, state) {
  if (state.length === 0)
    return null;
  var ret;
  if (state.objectMode)
    ret = state.buffer.shift();
  else if (!n || n >= state.length) {
    if (state.decoder)
      ret = state.buffer.join("");
    else if (state.buffer.length === 1)
      ret = state.buffer.head.data;
    else
      ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    ret = fromListPartial(n, state.buffer, state.decoder);
  }
  return ret;
}
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    ret = list.shift();
  } else {
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length)
      ret += str;
    else
      ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next)
          list.head = p.next;
        else
          list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next)
          list.head = p.next;
        else
          list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}
function endReadable(stream) {
  var state = stream._readableState;
  if (state.length > 0)
    throw new Error('"endReadable()" called on non-empty stream');
  if (!state.endEmitted) {
    state.ended = true;
    nextTick(endReadableNT, state, stream);
  }
}
function endReadableNT(state, stream) {
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit("end");
  }
}
function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}
function indexOf2(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x)
      return i;
  }
  return -1;
}
var debug, MAX_HWM;
var init_readable = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/readable.js"() {
    "use strict";
    init_react();
    init_events();
    init_util();
    init_buffer_list();
    init_string_decoder();
    init_duplex();
    init_process();
    Readable.ReadableState = ReadableState;
    debug = debuglog("stream");
    inherits_default(Readable, events_default);
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      if (!state.objectMode && typeof chunk === "string") {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer.from(chunk, encoding);
          encoding = "";
        }
      }
      return readableAddChunk(this, state, chunk, encoding, false);
    };
    Readable.prototype.unshift = function(chunk) {
      var state = this._readableState;
      return readableAddChunk(this, state, chunk, "", true);
    };
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    MAX_HWM = 8388608;
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      } else {
        state.length -= n;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    Readable.prototype._read = function(n) {
      this.emit("error", new Error("not implemented"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = !pipeOpts || pipeOpts.end !== false;
      var endFn = doEnd ? onend2 : cleanup;
      if (state.endEmitted)
        nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable) {
        debug("onunpipe");
        if (readable === src) {
          cleanup();
        }
      }
      function onend2() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend2);
        src.removeListener("end", cleanup);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      var increasedAwaitDrain = false;
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);
        if (ret === false && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf2(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", src._readableState.awaitDrain);
            src._readableState.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (listenerCount2(dest, "error") === 0)
          dest.emit("error", er);
      }
      prependListener2(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var _i = 0; _i < len; _i++) {
          dests[_i].emit("unpipe", this);
        }
        return this;
      }
      var i = indexOf2(state.pipes, dest);
      if (i === -1)
        return this;
      state.pipes.splice(i, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = events_default.prototype.on.call(this, ev, fn);
      if (ev === "data") {
        if (this._readableState.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            nextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this, state);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    Readable.prototype.wrap = function(stream) {
      var state = this._readableState;
      var paused = false;
      var self2 = this;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            self2.push(chunk);
        }
        self2.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = self2.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      var events = ["error", "close", "destroy", "pause", "resume"];
      forEach(events, function(ev) {
        stream.on(ev, self2.emit.bind(self2, ev));
      });
      self2._read = function(n) {
        debug("wrapped _read", n);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return self2;
    };
    Readable._fromList = fromList;
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/writable.js
function nop() {
}
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}
function WritableState(options, stream) {
  Object.defineProperty(this, "buffer", {
    get: deprecate(function() {
      return this.getBuffer();
    }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.")
  });
  options = options || {};
  this.objectMode = !!options.objectMode;
  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.writableObjectMode;
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
  this.highWaterMark = ~~this.highWaterMark;
  this.needDrain = false;
  this.ending = false;
  this.ended = false;
  this.finished = false;
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;
  this.defaultEncoding = options.defaultEncoding || "utf8";
  this.length = 0;
  this.writing = false;
  this.corked = 0;
  this.sync = true;
  this.bufferProcessing = false;
  this.onwrite = function(er) {
    onwrite(stream, er);
  };
  this.writecb = null;
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null;
  this.pendingcb = 0;
  this.prefinished = false;
  this.errorEmitted = false;
  this.bufferedRequestCount = 0;
  this.corkedRequestsFree = new CorkedRequest(this);
}
function Writable(options) {
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options);
  this._writableState = new WritableState(options, this);
  this.writable = true;
  if (options) {
    if (typeof options.write === "function")
      this._write = options.write;
    if (typeof options.writev === "function")
      this._writev = options.writev;
  }
  EventEmitter.call(this);
}
function writeAfterEnd(stream, cb) {
  var er = new Error("write after end");
  stream.emit("error", er);
  nextTick(cb, er);
}
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;
  if (chunk === null) {
    er = new TypeError("May not write null values to stream");
  } else if (!Buffer2.isBuffer(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
    er = new TypeError("Invalid non-string/buffer chunk");
  }
  if (er) {
    stream.emit("error", er);
    nextTick(cb, er);
    valid = false;
  }
  return valid;
}
function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
    chunk = Buffer2.from(chunk, encoding);
  }
  return chunk;
}
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  if (Buffer2.isBuffer(chunk))
    encoding = "buffer";
  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark;
  if (!ret)
    state.needDrain = true;
  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }
  return ret;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev)
    stream._writev(chunk, state.onwrite);
  else
    stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}
function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync)
    nextTick(cb, er);
  else
    cb(er);
  stream._writableState.errorEmitted = true;
  stream.emit("error", er);
}
function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}
function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  onwriteStateUpdate(state);
  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    var finished = needFinish(state);
    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }
    if (sync) {
      nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}
function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit("drain");
  }
}
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry2 = state.bufferedRequest;
  if (stream._writev && entry2 && entry2.next) {
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry2;
    var count = 0;
    while (entry2) {
      buffer[count] = entry2;
      entry2 = entry2.next;
      count += 1;
    }
    doWrite(stream, state, true, state.length, buffer, "", holder.finish);
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
  } else {
    while (entry2) {
      var chunk = entry2.chunk;
      var encoding = entry2.encoding;
      var cb = entry2.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry2 = entry2.next;
      if (state.writing) {
        break;
      }
    }
    if (entry2 === null)
      state.lastBufferedRequest = null;
  }
  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry2;
  state.bufferProcessing = false;
}
function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit("prefinish");
  }
}
function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit("finish");
    } else {
      prefinish(stream, state);
    }
  }
  return need;
}
function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      nextTick(cb);
    else
      stream.once("finish", cb);
  }
  state.ended = true;
  stream.writable = false;
}
function CorkedRequest(state) {
  var _this = this;
  this.next = null;
  this.entry = null;
  this.finish = function(err) {
    var entry2 = _this.entry;
    _this.entry = null;
    while (entry2) {
      var cb = entry2.callback;
      state.pendingcb--;
      cb(err);
      entry2 = entry2.next;
    }
    if (state.corkedRequestsFree) {
      state.corkedRequestsFree.next = _this;
    } else {
      state.corkedRequestsFree = _this;
    }
  };
}
var init_writable = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/writable.js"() {
    init_react();
    init_util();
    init_buffer();
    init_events();
    init_duplex();
    init_process();
    Writable.WritableState = WritableState;
    inherits_default(Writable, EventEmitter);
    WritableState.prototype.getBuffer = function writableStateGetBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (Buffer2.isBuffer(chunk))
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ended)
        writeAfterEnd(this, cb);
      else if (validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new TypeError("Unknown encoding: " + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/duplex.js
function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  if (options && options.readable === false)
    this.readable = false;
  if (options && options.writable === false)
    this.writable = false;
  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;
  this.once("end", onend);
}
function onend() {
  if (this.allowHalfOpen || this._writableState.ended)
    return;
  nextTick(onEndNT, this);
}
function onEndNT(self2) {
  self2.end();
}
var keys, method, v;
var init_duplex = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/duplex.js"() {
    init_react();
    init_util();
    init_process();
    init_readable();
    init_writable();
    inherits_default(Duplex, Readable);
    keys = Object.keys(Writable.prototype);
    for (v = 0; v < keys.length; v++) {
      method = keys[v];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/transform.js
function TransformState(stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };
  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}
function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (!cb)
    return stream.emit("error", new Error("no writecb in Transform class"));
  ts.writechunk = null;
  ts.writecb = null;
  if (data !== null && data !== void 0)
    stream.push(data);
  cb(er);
  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}
function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);
  Duplex.call(this, options);
  this._transformState = new TransformState(this);
  var stream = this;
  this._readableState.needReadable = true;
  this._readableState.sync = false;
  if (options) {
    if (typeof options.transform === "function")
      this._transform = options.transform;
    if (typeof options.flush === "function")
      this._flush = options.flush;
  }
  this.once("prefinish", function() {
    if (typeof this._flush === "function")
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}
function done(stream, er) {
  if (er)
    return stream.emit("error", er);
  var ws = stream._writableState;
  var ts = stream._transformState;
  if (ws.length)
    throw new Error("Calling transform done when ws.length != 0");
  if (ts.transforming)
    throw new Error("Calling transform done when still transforming");
  return stream.push(null);
}
var init_transform = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/transform.js"() {
    init_react();
    init_duplex();
    init_util();
    inherits_default(Transform, Duplex);
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("Not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/passthrough.js
function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);
  Transform.call(this, options);
}
var init_passthrough = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/passthrough.js"() {
    init_react();
    init_transform();
    init_util();
    inherits_default(PassThrough, Transform);
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node-modules-polyfills:stream
var stream_exports = {};
__export(stream_exports, {
  Duplex: () => Duplex,
  PassThrough: () => PassThrough,
  Readable: () => Readable,
  Stream: () => Stream,
  Transform: () => Transform,
  Writable: () => Writable,
  default: () => stream_default
});
function Stream() {
  events_default.call(this);
}
var stream_default;
var init_stream = __esm({
  "node-modules-polyfills:stream"() {
    init_react();
    init_events();
    init_util();
    init_duplex();
    init_readable();
    init_writable();
    init_transform();
    init_passthrough();
    inherits_default(Stream, events_default);
    Stream.Readable = Readable;
    Stream.Writable = Writable;
    Stream.Duplex = Duplex;
    Stream.Transform = Transform;
    Stream.PassThrough = PassThrough;
    Stream.Stream = Stream;
    stream_default = Stream;
    Stream.prototype.pipe = function(dest, options) {
      var source = this;
      function ondata(chunk) {
        if (dest.writable) {
          if (dest.write(chunk) === false && source.pause) {
            source.pause();
          }
        }
      }
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }
      dest.on("drain", ondrain);
      if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend2);
        source.on("close", onclose);
      }
      var didOnEnd = false;
      function onend2() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        dest.end();
      }
      function onclose() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        if (typeof dest.destroy === "function")
          dest.destroy();
      }
      function onerror(er) {
        cleanup();
        if (events_default.listenerCount(this, "error") === 0) {
          throw er;
        }
      }
      source.on("error", onerror);
      dest.on("error", onerror);
      function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend2);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
      }
      source.on("end", cleanup);
      source.on("close", cleanup);
      dest.on("close", cleanup);
      dest.emit("pipe", source);
      return dest;
    };
  }
});

// node-modules-polyfills-commonjs:stream
var require_stream = __commonJS({
  "node-modules-polyfills-commonjs:stream"(exports, module) {
    init_react();
    var polyfill = (init_stream(), __toCommonJS(stream_exports));
    if (polyfill && polyfill.default) {
      module.exports = polyfill.default;
      for (let k in polyfill) {
        module.exports[k] = polyfill[k];
      }
    } else if (polyfill) {
      module.exports = polyfill;
    }
  }
});

// node_modules/react-dom/cjs/react-dom-server.node.development.js
var require_react_dom_server_node_development = __commonJS({
  "node_modules/react-dom/cjs/react-dom-server.node.development.js"(exports) {
    "use strict";
    init_react();
    if (true) {
      (function() {
        "use strict";
        var React6 = require_react();
        var _assign = require_object_assign();
        var stream = require_stream();
        var ReactVersion = "17.0.2";
        function formatProdErrorMessage(code) {
          var url = "https://reactjs.org/docs/error-decoder.html?invariant=" + code;
          for (var i2 = 1; i2 < arguments.length; i2++) {
            url += "&args[]=" + encodeURIComponent(arguments[i2]);
          }
          return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
        }
        var ReactSharedInternals = React6.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function warn(format2) {
          {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            printWarning("warn", format2, args);
          }
        }
        function error(format2) {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format2, args);
          }
        }
        function printWarning(level, format2, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format2 += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return "" + item;
            });
            argsWithFormat.unshift("Warning: " + format2);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var REACT_ELEMENT_TYPE = 60103;
        var REACT_PORTAL_TYPE = 60106;
        var REACT_FRAGMENT_TYPE = 60107;
        var REACT_STRICT_MODE_TYPE = 60108;
        var REACT_PROFILER_TYPE = 60114;
        var REACT_PROVIDER_TYPE = 60109;
        var REACT_CONTEXT_TYPE = 60110;
        var REACT_FORWARD_REF_TYPE = 60112;
        var REACT_SUSPENSE_TYPE = 60113;
        var REACT_SUSPENSE_LIST_TYPE = 60120;
        var REACT_MEMO_TYPE = 60115;
        var REACT_LAZY_TYPE = 60116;
        var REACT_BLOCK_TYPE = 60121;
        var REACT_SERVER_BLOCK_TYPE = 60122;
        var REACT_FUNDAMENTAL_TYPE = 60117;
        var REACT_SCOPE_TYPE = 60119;
        var REACT_OPAQUE_ID_TYPE = 60128;
        var REACT_DEBUG_TRACING_MODE_TYPE = 60129;
        var REACT_OFFSCREEN_TYPE = 60130;
        var REACT_LEGACY_HIDDEN_TYPE = 60131;
        if (typeof Symbol === "function" && Symbol.for) {
          var symbolFor = Symbol.for;
          REACT_ELEMENT_TYPE = symbolFor("react.element");
          REACT_PORTAL_TYPE = symbolFor("react.portal");
          REACT_FRAGMENT_TYPE = symbolFor("react.fragment");
          REACT_STRICT_MODE_TYPE = symbolFor("react.strict_mode");
          REACT_PROFILER_TYPE = symbolFor("react.profiler");
          REACT_PROVIDER_TYPE = symbolFor("react.provider");
          REACT_CONTEXT_TYPE = symbolFor("react.context");
          REACT_FORWARD_REF_TYPE = symbolFor("react.forward_ref");
          REACT_SUSPENSE_TYPE = symbolFor("react.suspense");
          REACT_SUSPENSE_LIST_TYPE = symbolFor("react.suspense_list");
          REACT_MEMO_TYPE = symbolFor("react.memo");
          REACT_LAZY_TYPE = symbolFor("react.lazy");
          REACT_BLOCK_TYPE = symbolFor("react.block");
          REACT_SERVER_BLOCK_TYPE = symbolFor("react.server.block");
          REACT_FUNDAMENTAL_TYPE = symbolFor("react.fundamental");
          REACT_SCOPE_TYPE = symbolFor("react.scope");
          REACT_OPAQUE_ID_TYPE = symbolFor("react.opaque.id");
          REACT_DEBUG_TRACING_MODE_TYPE = symbolFor("react.debug_trace_mode");
          REACT_OFFSCREEN_TYPE = symbolFor("react.offscreen");
          REACT_LEGACY_HIDDEN_TYPE = symbolFor("react.legacy_hidden");
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var functionName = innerType.displayName || innerType.name || "";
          return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
        }
        function getContextName(type) {
          return type.displayName || "Context";
        }
        function getComponentName(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                return getComponentName(type.type);
              case REACT_BLOCK_TYPE:
                return getComponentName(type._render);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init2 = lazyComponent._init;
                try {
                  return getComponentName(init2(payload));
                } catch (x) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var enableSuspenseServerRenderer = false;
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: _assign({}, props, {
                  value: prevLog
                }),
                info: _assign({}, props, {
                  value: prevInfo
                }),
                warn: _assign({}, props, {
                  value: prevWarn
                }),
                error: _assign({}, props, {
                  value: prevError
                }),
                group: _assign({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: _assign({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: _assign({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x) {
                var match = x.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
              }
            }
            return "\n" + prefix + name;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  control = x;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x) {
                  control = x;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x) {
                control = x;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s = sampleLines.length - 1;
              var c = controlLines.length - 1;
              while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                c--;
              }
              for (; s >= 1 && c >= 0; s--, c--) {
                if (sampleLines[s] !== controlLines[c]) {
                  if (s !== 1 || c !== 1) {
                    do {
                      s--;
                      c--;
                      if (c < 0 || sampleLines[s] !== controlLines[c]) {
                        var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s >= 1 && c >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component) {
          var prototype = Component.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
          if (type == null) {
            return "";
          }
          if (typeof type === "function") {
            {
              return describeNativeComponentFrame(type, shouldConstruct(type));
            }
          }
          if (typeof type === "string") {
            return describeBuiltInComponentFrame(type);
          }
          switch (type) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
              case REACT_BLOCK_TYPE:
                return describeFunctionComponentFrame(type._render);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init2 = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init2(payload), source, ownerFn);
                } catch (x) {
                }
              }
            }
          }
          return "";
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location2, componentName, element) {
          {
            var has = Function.call.bind(Object.prototype.hasOwnProperty);
            for (var typeSpecName in typeSpecs) {
              if (has(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location2, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location2, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error("Failed %s type: %s", location2, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        var didWarnAboutInvalidateContextType;
        {
          didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
        }
        var emptyObject = {};
        {
          Object.freeze(emptyObject);
        }
        function maskContext(type, context) {
          var contextTypes = type.contextTypes;
          if (!contextTypes) {
            return emptyObject;
          }
          var maskedContext = {};
          for (var contextName in contextTypes) {
            maskedContext[contextName] = context[contextName];
          }
          return maskedContext;
        }
        function checkContextTypes(typeSpecs, values, location2) {
          {
            checkPropTypes(typeSpecs, values, location2, "Component");
          }
        }
        function validateContextBounds(context, threadID) {
          for (var i2 = context._threadCount | 0; i2 <= threadID; i2++) {
            context[i2] = context._currentValue2;
            context._threadCount = i2 + 1;
          }
        }
        function processContext(type, context, threadID, isClass) {
          if (isClass) {
            var contextType = type.contextType;
            {
              if ("contextType" in type) {
                var isValid = contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0;
                if (!isValid && !didWarnAboutInvalidateContextType.has(type)) {
                  didWarnAboutInvalidateContextType.add(type);
                  var addendum = "";
                  if (contextType === void 0) {
                    addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
                  } else if (typeof contextType !== "object") {
                    addendum = " However, it is set to a " + typeof contextType + ".";
                  } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                    addendum = " Did you accidentally pass the Context.Provider instead?";
                  } else if (contextType._context !== void 0) {
                    addendum = " Did you accidentally pass the Context.Consumer instead?";
                  } else {
                    addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
                  }
                  error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentName(type) || "Component", addendum);
                }
              }
            }
            if (typeof contextType === "object" && contextType !== null) {
              validateContextBounds(contextType, threadID);
              return contextType[threadID];
            }
            {
              var maskedContext = maskContext(type, context);
              {
                if (type.contextTypes) {
                  checkContextTypes(type.contextTypes, maskedContext, "context");
                }
              }
              return maskedContext;
            }
          } else {
            {
              var _maskedContext = maskContext(type, context);
              {
                if (type.contextTypes) {
                  checkContextTypes(type.contextTypes, _maskedContext, "context");
                }
              }
              return _maskedContext;
            }
          }
        }
        var nextAvailableThreadIDs = new Uint16Array(16);
        for (var i = 0; i < 15; i++) {
          nextAvailableThreadIDs[i] = i + 1;
        }
        nextAvailableThreadIDs[15] = 0;
        function growThreadCountAndReturnNextAvailable() {
          var oldArray = nextAvailableThreadIDs;
          var oldSize = oldArray.length;
          var newSize = oldSize * 2;
          if (!(newSize <= 65536)) {
            {
              throw Error("Maximum number of concurrent React renderers exceeded. This can happen if you are not properly destroying the Readable provided by React. Ensure that you call .destroy() on it if you no longer want to read from it, and did not read to the end. If you use .pipe() this should be automatic.");
            }
          }
          var newArray = new Uint16Array(newSize);
          newArray.set(oldArray);
          nextAvailableThreadIDs = newArray;
          nextAvailableThreadIDs[0] = oldSize + 1;
          for (var _i = oldSize; _i < newSize - 1; _i++) {
            nextAvailableThreadIDs[_i] = _i + 1;
          }
          nextAvailableThreadIDs[newSize - 1] = 0;
          return oldSize;
        }
        function allocThreadID() {
          var nextID = nextAvailableThreadIDs[0];
          if (nextID === 0) {
            return growThreadCountAndReturnNextAvailable();
          }
          nextAvailableThreadIDs[0] = nextAvailableThreadIDs[nextID];
          return nextID;
        }
        function freeThreadID(id) {
          nextAvailableThreadIDs[id] = nextAvailableThreadIDs[0];
          nextAvailableThreadIDs[0] = id;
        }
        var RESERVED = 0;
        var STRING = 1;
        var BOOLEANISH_STRING = 2;
        var BOOLEAN = 3;
        var OVERLOADED_BOOLEAN = 4;
        var NUMERIC = 5;
        var POSITIVE_NUMERIC = 6;
        var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
        var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
        var ROOT_ATTRIBUTE_NAME = "data-reactroot";
        var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
        var hasOwnProperty2 = Object.prototype.hasOwnProperty;
        var illegalAttributeNameCache = {};
        var validatedAttributeNameCache = {};
        function isAttributeNameSafe(attributeName) {
          if (hasOwnProperty2.call(validatedAttributeNameCache, attributeName)) {
            return true;
          }
          if (hasOwnProperty2.call(illegalAttributeNameCache, attributeName)) {
            return false;
          }
          if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
            validatedAttributeNameCache[attributeName] = true;
            return true;
          }
          illegalAttributeNameCache[attributeName] = true;
          {
            error("Invalid attribute name: `%s`", attributeName);
          }
          return false;
        }
        function shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag) {
          if (propertyInfo !== null) {
            return propertyInfo.type === RESERVED;
          }
          if (isCustomComponentTag) {
            return false;
          }
          if (name.length > 2 && (name[0] === "o" || name[0] === "O") && (name[1] === "n" || name[1] === "N")) {
            return true;
          }
          return false;
        }
        function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
          if (propertyInfo !== null && propertyInfo.type === RESERVED) {
            return false;
          }
          switch (typeof value) {
            case "function":
            case "symbol":
              return true;
            case "boolean": {
              if (isCustomComponentTag) {
                return false;
              }
              if (propertyInfo !== null) {
                return !propertyInfo.acceptsBooleans;
              } else {
                var prefix2 = name.toLowerCase().slice(0, 5);
                return prefix2 !== "data-" && prefix2 !== "aria-";
              }
            }
            default:
              return false;
          }
        }
        function shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag) {
          if (value === null || typeof value === "undefined") {
            return true;
          }
          if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag)) {
            return true;
          }
          if (isCustomComponentTag) {
            return false;
          }
          if (propertyInfo !== null) {
            switch (propertyInfo.type) {
              case BOOLEAN:
                return !value;
              case OVERLOADED_BOOLEAN:
                return value === false;
              case NUMERIC:
                return isNaN(value);
              case POSITIVE_NUMERIC:
                return isNaN(value) || value < 1;
            }
          }
          return false;
        }
        function getPropertyInfo(name) {
          return properties.hasOwnProperty(name) ? properties[name] : null;
        }
        function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
          this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
          this.attributeName = attributeName;
          this.attributeNamespace = attributeNamespace;
          this.mustUseProperty = mustUseProperty;
          this.propertyName = name;
          this.type = type;
          this.sanitizeURL = sanitizeURL2;
          this.removeEmptyString = removeEmptyString;
        }
        var properties = {};
        var reservedProps = [
          "children",
          "dangerouslySetInnerHTML",
          "defaultValue",
          "defaultChecked",
          "innerHTML",
          "suppressContentEditableWarning",
          "suppressHydrationWarning",
          "style"
        ];
        reservedProps.forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, RESERVED, false, name, null, false, false);
        });
        [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
          var name = _ref[0], attributeName = _ref[1];
          properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);
        });
        ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name.toLowerCase(), null, false, false);
        });
        ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name, null, false, false);
        });
        [
          "allowFullScreen",
          "async",
          "autoFocus",
          "autoPlay",
          "controls",
          "default",
          "defer",
          "disabled",
          "disablePictureInPicture",
          "disableRemotePlayback",
          "formNoValidate",
          "hidden",
          "loop",
          "noModule",
          "noValidate",
          "open",
          "playsInline",
          "readOnly",
          "required",
          "reversed",
          "scoped",
          "seamless",
          "itemScope"
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, BOOLEAN, false, name.toLowerCase(), null, false, false);
        });
        [
          "checked",
          "multiple",
          "muted",
          "selected"
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, BOOLEAN, true, name, null, false, false);
        });
        [
          "capture",
          "download"
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, OVERLOADED_BOOLEAN, false, name, null, false, false);
        });
        [
          "cols",
          "rows",
          "size",
          "span"
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, POSITIVE_NUMERIC, false, name, null, false, false);
        });
        ["rowSpan", "start"].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, NUMERIC, false, name.toLowerCase(), null, false, false);
        });
        var CAMELIZE = /[\-\:]([a-z])/g;
        var capitalize = function(token) {
          return token[1].toUpperCase();
        };
        [
          "accent-height",
          "alignment-baseline",
          "arabic-form",
          "baseline-shift",
          "cap-height",
          "clip-path",
          "clip-rule",
          "color-interpolation",
          "color-interpolation-filters",
          "color-profile",
          "color-rendering",
          "dominant-baseline",
          "enable-background",
          "fill-opacity",
          "fill-rule",
          "flood-color",
          "flood-opacity",
          "font-family",
          "font-size",
          "font-size-adjust",
          "font-stretch",
          "font-style",
          "font-variant",
          "font-weight",
          "glyph-name",
          "glyph-orientation-horizontal",
          "glyph-orientation-vertical",
          "horiz-adv-x",
          "horiz-origin-x",
          "image-rendering",
          "letter-spacing",
          "lighting-color",
          "marker-end",
          "marker-mid",
          "marker-start",
          "overline-position",
          "overline-thickness",
          "paint-order",
          "panose-1",
          "pointer-events",
          "rendering-intent",
          "shape-rendering",
          "stop-color",
          "stop-opacity",
          "strikethrough-position",
          "strikethrough-thickness",
          "stroke-dasharray",
          "stroke-dashoffset",
          "stroke-linecap",
          "stroke-linejoin",
          "stroke-miterlimit",
          "stroke-opacity",
          "stroke-width",
          "text-anchor",
          "text-decoration",
          "text-rendering",
          "underline-position",
          "underline-thickness",
          "unicode-bidi",
          "unicode-range",
          "units-per-em",
          "v-alphabetic",
          "v-hanging",
          "v-ideographic",
          "v-mathematical",
          "vector-effect",
          "vert-adv-y",
          "vert-origin-x",
          "vert-origin-y",
          "word-spacing",
          "writing-mode",
          "xmlns:xlink",
          "x-height"
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);
        });
        [
          "xlink:actuate",
          "xlink:arcrole",
          "xlink:role",
          "xlink:show",
          "xlink:title",
          "xlink:type"
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, "http://www.w3.org/1999/xlink", false, false);
        });
        [
          "xml:base",
          "xml:lang",
          "xml:space"
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, "http://www.w3.org/XML/1998/namespace", false, false);
        });
        ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
          properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, false, false);
        });
        var xlinkHref = "xlinkHref";
        properties[xlinkHref] = new PropertyInfoRecord("xlinkHref", STRING, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
        ["src", "href", "action", "formAction"].forEach(function(attributeName) {
          properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, true, true);
        });
        var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
        var didWarn = false;
        function sanitizeURL(url) {
          {
            if (!didWarn && isJavaScriptProtocol.test(url)) {
              didWarn = true;
              error("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url));
            }
          }
        }
        var matchHtmlRegExp = /["'&<>]/;
        function escapeHtml(string) {
          var str = "" + string;
          var match = matchHtmlRegExp.exec(str);
          if (!match) {
            return str;
          }
          var escape;
          var html = "";
          var index;
          var lastIndex = 0;
          for (index = match.index; index < str.length; index++) {
            switch (str.charCodeAt(index)) {
              case 34:
                escape = "&quot;";
                break;
              case 38:
                escape = "&amp;";
                break;
              case 39:
                escape = "&#x27;";
                break;
              case 60:
                escape = "&lt;";
                break;
              case 62:
                escape = "&gt;";
                break;
              default:
                continue;
            }
            if (lastIndex !== index) {
              html += str.substring(lastIndex, index);
            }
            lastIndex = index + 1;
            html += escape;
          }
          return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
        }
        function escapeTextForBrowser(text) {
          if (typeof text === "boolean" || typeof text === "number") {
            return "" + text;
          }
          return escapeHtml(text);
        }
        function quoteAttributeValueForBrowser(value) {
          return '"' + escapeTextForBrowser(value) + '"';
        }
        function createMarkupForRoot() {
          return ROOT_ATTRIBUTE_NAME + '=""';
        }
        function createMarkupForProperty(name, value) {
          var propertyInfo = getPropertyInfo(name);
          if (name !== "style" && shouldIgnoreAttribute(name, propertyInfo, false)) {
            return "";
          }
          if (shouldRemoveAttribute(name, value, propertyInfo, false)) {
            return "";
          }
          if (propertyInfo !== null) {
            var attributeName = propertyInfo.attributeName;
            var type = propertyInfo.type;
            if (type === BOOLEAN || type === OVERLOADED_BOOLEAN && value === true) {
              return attributeName + '=""';
            } else {
              if (propertyInfo.sanitizeURL) {
                value = "" + value;
                sanitizeURL(value);
              }
              return attributeName + "=" + quoteAttributeValueForBrowser(value);
            }
          } else if (isAttributeNameSafe(name)) {
            return name + "=" + quoteAttributeValueForBrowser(value);
          }
          return "";
        }
        function createMarkupForCustomAttribute(name, value) {
          if (!isAttributeNameSafe(name) || value == null) {
            return "";
          }
          return name + "=" + quoteAttributeValueForBrowser(value);
        }
        function is(x, y) {
          return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is;
        var currentlyRenderingComponent = null;
        var firstWorkInProgressHook = null;
        var workInProgressHook = null;
        var isReRender = false;
        var didScheduleRenderPhaseUpdate = false;
        var renderPhaseUpdates = null;
        var numberOfReRenders = 0;
        var RE_RENDER_LIMIT = 25;
        var isInHookUserCodeInDev = false;
        var currentHookNameInDev;
        function resolveCurrentlyRenderingComponent() {
          if (!(currentlyRenderingComponent !== null)) {
            {
              throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
            }
          }
          {
            if (isInHookUserCodeInDev) {
              error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
            }
          }
          return currentlyRenderingComponent;
        }
        function areHookInputsEqual(nextDeps, prevDeps) {
          if (prevDeps === null) {
            {
              error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
            }
            return false;
          }
          {
            if (nextDeps.length !== prevDeps.length) {
              error("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + nextDeps.join(", ") + "]", "[" + prevDeps.join(", ") + "]");
            }
          }
          for (var i2 = 0; i2 < prevDeps.length && i2 < nextDeps.length; i2++) {
            if (objectIs(nextDeps[i2], prevDeps[i2])) {
              continue;
            }
            return false;
          }
          return true;
        }
        function createHook() {
          if (numberOfReRenders > 0) {
            {
              {
                throw Error("Rendered more hooks than during the previous render");
              }
            }
          }
          return {
            memoizedState: null,
            queue: null,
            next: null
          };
        }
        function createWorkInProgressHook() {
          if (workInProgressHook === null) {
            if (firstWorkInProgressHook === null) {
              isReRender = false;
              firstWorkInProgressHook = workInProgressHook = createHook();
            } else {
              isReRender = true;
              workInProgressHook = firstWorkInProgressHook;
            }
          } else {
            if (workInProgressHook.next === null) {
              isReRender = false;
              workInProgressHook = workInProgressHook.next = createHook();
            } else {
              isReRender = true;
              workInProgressHook = workInProgressHook.next;
            }
          }
          return workInProgressHook;
        }
        function prepareToUseHooks(componentIdentity) {
          currentlyRenderingComponent = componentIdentity;
          {
            isInHookUserCodeInDev = false;
          }
        }
        function finishHooks(Component, props, children, refOrContext) {
          while (didScheduleRenderPhaseUpdate) {
            didScheduleRenderPhaseUpdate = false;
            numberOfReRenders += 1;
            workInProgressHook = null;
            children = Component(props, refOrContext);
          }
          resetHooksState();
          return children;
        }
        function resetHooksState() {
          {
            isInHookUserCodeInDev = false;
          }
          currentlyRenderingComponent = null;
          didScheduleRenderPhaseUpdate = false;
          firstWorkInProgressHook = null;
          numberOfReRenders = 0;
          renderPhaseUpdates = null;
          workInProgressHook = null;
        }
        function readContext(context, observedBits) {
          var threadID = currentPartialRenderer.threadID;
          validateContextBounds(context, threadID);
          {
            if (isInHookUserCodeInDev) {
              error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
            }
          }
          return context[threadID];
        }
        function useContext4(context, observedBits) {
          {
            currentHookNameInDev = "useContext";
          }
          resolveCurrentlyRenderingComponent();
          var threadID = currentPartialRenderer.threadID;
          validateContextBounds(context, threadID);
          return context[threadID];
        }
        function basicStateReducer(state, action) {
          return typeof action === "function" ? action(state) : action;
        }
        function useState4(initialState) {
          {
            currentHookNameInDev = "useState";
          }
          return useReducer(basicStateReducer, initialState);
        }
        function useReducer(reducer, initialArg, init2) {
          {
            if (reducer !== basicStateReducer) {
              currentHookNameInDev = "useReducer";
            }
          }
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          if (isReRender) {
            var queue2 = workInProgressHook.queue;
            var dispatch = queue2.dispatch;
            if (renderPhaseUpdates !== null) {
              var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue2);
              if (firstRenderPhaseUpdate !== void 0) {
                renderPhaseUpdates.delete(queue2);
                var newState = workInProgressHook.memoizedState;
                var update = firstRenderPhaseUpdate;
                do {
                  var action = update.action;
                  {
                    isInHookUserCodeInDev = true;
                  }
                  newState = reducer(newState, action);
                  {
                    isInHookUserCodeInDev = false;
                  }
                  update = update.next;
                } while (update !== null);
                workInProgressHook.memoizedState = newState;
                return [newState, dispatch];
              }
            }
            return [workInProgressHook.memoizedState, dispatch];
          } else {
            {
              isInHookUserCodeInDev = true;
            }
            var initialState;
            if (reducer === basicStateReducer) {
              initialState = typeof initialArg === "function" ? initialArg() : initialArg;
            } else {
              initialState = init2 !== void 0 ? init2(initialArg) : initialArg;
            }
            {
              isInHookUserCodeInDev = false;
            }
            workInProgressHook.memoizedState = initialState;
            var _queue = workInProgressHook.queue = {
              last: null,
              dispatch: null
            };
            var _dispatch = _queue.dispatch = dispatchAction.bind(null, currentlyRenderingComponent, _queue);
            return [workInProgressHook.memoizedState, _dispatch];
          }
        }
        function useMemo4(nextCreate, deps) {
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          if (workInProgressHook !== null) {
            var prevState = workInProgressHook.memoizedState;
            if (prevState !== null) {
              if (nextDeps !== null) {
                var prevDeps = prevState[1];
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  return prevState[0];
                }
              }
            }
          }
          {
            isInHookUserCodeInDev = true;
          }
          var nextValue = nextCreate();
          {
            isInHookUserCodeInDev = false;
          }
          workInProgressHook.memoizedState = [nextValue, nextDeps];
          return nextValue;
        }
        function useRef5(initialValue) {
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          var previousRef = workInProgressHook.memoizedState;
          if (previousRef === null) {
            var ref = {
              current: initialValue
            };
            {
              Object.seal(ref);
            }
            workInProgressHook.memoizedState = ref;
            return ref;
          } else {
            return previousRef;
          }
        }
        function useLayoutEffect4(create, inputs) {
          {
            currentHookNameInDev = "useLayoutEffect";
            error("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
          }
        }
        function dispatchAction(componentIdentity, queue2, action) {
          if (!(numberOfReRenders < RE_RENDER_LIMIT)) {
            {
              throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
            }
          }
          if (componentIdentity === currentlyRenderingComponent) {
            didScheduleRenderPhaseUpdate = true;
            var update = {
              action,
              next: null
            };
            if (renderPhaseUpdates === null) {
              renderPhaseUpdates = /* @__PURE__ */ new Map();
            }
            var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue2);
            if (firstRenderPhaseUpdate === void 0) {
              renderPhaseUpdates.set(queue2, update);
            } else {
              var lastRenderPhaseUpdate = firstRenderPhaseUpdate;
              while (lastRenderPhaseUpdate.next !== null) {
                lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
              }
              lastRenderPhaseUpdate.next = update;
            }
          }
        }
        function useCallback5(callback, deps) {
          return useMemo4(function() {
            return callback;
          }, deps);
        }
        function useMutableSource(source, getSnapshot, subscribe) {
          resolveCurrentlyRenderingComponent();
          return getSnapshot(source._source);
        }
        function useDeferredValue(value) {
          resolveCurrentlyRenderingComponent();
          return value;
        }
        function useTransition2() {
          resolveCurrentlyRenderingComponent();
          var startTransition = function(callback) {
            callback();
          };
          return [startTransition, false];
        }
        function useOpaqueIdentifier() {
          return (currentPartialRenderer.identifierPrefix || "") + "R:" + (currentPartialRenderer.uniqueID++).toString(36);
        }
        function noop2() {
        }
        var currentPartialRenderer = null;
        function setCurrentPartialRenderer(renderer) {
          currentPartialRenderer = renderer;
        }
        var Dispatcher = {
          readContext,
          useContext: useContext4,
          useMemo: useMemo4,
          useReducer,
          useRef: useRef5,
          useState: useState4,
          useLayoutEffect: useLayoutEffect4,
          useCallback: useCallback5,
          useImperativeHandle: noop2,
          useEffect: noop2,
          useDebugValue: noop2,
          useDeferredValue,
          useTransition: useTransition2,
          useOpaqueIdentifier,
          useMutableSource
        };
        var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
        var MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
        var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
        var Namespaces = {
          html: HTML_NAMESPACE,
          mathml: MATH_NAMESPACE,
          svg: SVG_NAMESPACE
        };
        function getIntrinsicNamespace(type) {
          switch (type) {
            case "svg":
              return SVG_NAMESPACE;
            case "math":
              return MATH_NAMESPACE;
            default:
              return HTML_NAMESPACE;
          }
        }
        function getChildNamespace(parentNamespace, type) {
          if (parentNamespace == null || parentNamespace === HTML_NAMESPACE) {
            return getIntrinsicNamespace(type);
          }
          if (parentNamespace === SVG_NAMESPACE && type === "foreignObject") {
            return HTML_NAMESPACE;
          }
          return parentNamespace;
        }
        var hasReadOnlyValue = {
          button: true,
          checkbox: true,
          image: true,
          hidden: true,
          radio: true,
          reset: true,
          submit: true
        };
        function checkControlledValueProps(tagName, props) {
          {
            if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
              error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
            }
            if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
              error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
            }
          }
        }
        var omittedCloseTags = {
          area: true,
          base: true,
          br: true,
          col: true,
          embed: true,
          hr: true,
          img: true,
          input: true,
          keygen: true,
          link: true,
          meta: true,
          param: true,
          source: true,
          track: true,
          wbr: true
        };
        var voidElementTags = _assign({
          menuitem: true
        }, omittedCloseTags);
        var HTML = "__html";
        function assertValidProps(tag, props) {
          if (!props) {
            return;
          }
          if (voidElementTags[tag]) {
            if (!(props.children == null && props.dangerouslySetInnerHTML == null)) {
              {
                throw Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
              }
            }
          }
          if (props.dangerouslySetInnerHTML != null) {
            if (!(props.children == null)) {
              {
                throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
              }
            }
            if (!(typeof props.dangerouslySetInnerHTML === "object" && HTML in props.dangerouslySetInnerHTML)) {
              {
                throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
              }
            }
          }
          {
            if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
              error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
            }
          }
          if (!(props.style == null || typeof props.style === "object")) {
            {
              throw Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
            }
          }
        }
        var isUnitlessNumber = {
          animationIterationCount: true,
          borderImageOutset: true,
          borderImageSlice: true,
          borderImageWidth: true,
          boxFlex: true,
          boxFlexGroup: true,
          boxOrdinalGroup: true,
          columnCount: true,
          columns: true,
          flex: true,
          flexGrow: true,
          flexPositive: true,
          flexShrink: true,
          flexNegative: true,
          flexOrder: true,
          gridArea: true,
          gridRow: true,
          gridRowEnd: true,
          gridRowSpan: true,
          gridRowStart: true,
          gridColumn: true,
          gridColumnEnd: true,
          gridColumnSpan: true,
          gridColumnStart: true,
          fontWeight: true,
          lineClamp: true,
          lineHeight: true,
          opacity: true,
          order: true,
          orphans: true,
          tabSize: true,
          widows: true,
          zIndex: true,
          zoom: true,
          fillOpacity: true,
          floodOpacity: true,
          stopOpacity: true,
          strokeDasharray: true,
          strokeDashoffset: true,
          strokeMiterlimit: true,
          strokeOpacity: true,
          strokeWidth: true
        };
        function prefixKey(prefix2, key) {
          return prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
        }
        var prefixes = ["Webkit", "ms", "Moz", "O"];
        Object.keys(isUnitlessNumber).forEach(function(prop) {
          prefixes.forEach(function(prefix2) {
            isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop];
          });
        });
        function dangerousStyleValue(name, value, isCustomProperty) {
          var isEmpty = value == null || typeof value === "boolean" || value === "";
          if (isEmpty) {
            return "";
          }
          if (!isCustomProperty && typeof value === "number" && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {
            return value + "px";
          }
          return ("" + value).trim();
        }
        var uppercasePattern = /([A-Z])/g;
        var msPattern = /^ms-/;
        function hyphenateStyleName(name) {
          return name.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern, "-ms-");
        }
        function isCustomComponent(tagName, props) {
          if (tagName.indexOf("-") === -1) {
            return typeof props.is === "string";
          }
          switch (tagName) {
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
              return false;
            default:
              return true;
          }
        }
        var warnValidStyle = function() {
        };
        {
          var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
          var msPattern$1 = /^-ms-/;
          var hyphenPattern = /-(.)/g;
          var badStyleValueWithSemicolonPattern = /;\s*$/;
          var warnedStyleNames = {};
          var warnedStyleValues = {};
          var warnedForNaNValue = false;
          var warnedForInfinityValue = false;
          var camelize = function(string) {
            return string.replace(hyphenPattern, function(_, character) {
              return character.toUpperCase();
            });
          };
          var warnHyphenatedStyleName = function(name) {
            if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
              return;
            }
            warnedStyleNames[name] = true;
            error("Unsupported style property %s. Did you mean %s?", name, camelize(name.replace(msPattern$1, "ms-")));
          };
          var warnBadVendoredStyleName = function(name) {
            if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
              return;
            }
            warnedStyleNames[name] = true;
            error("Unsupported vendor-prefixed style property %s. Did you mean %s?", name, name.charAt(0).toUpperCase() + name.slice(1));
          };
          var warnStyleValueWithSemicolon = function(name, value) {
            if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
              return;
            }
            warnedStyleValues[value] = true;
            error(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name, value.replace(badStyleValueWithSemicolonPattern, ""));
          };
          var warnStyleValueIsNaN = function(name, value) {
            if (warnedForNaNValue) {
              return;
            }
            warnedForNaNValue = true;
            error("`NaN` is an invalid value for the `%s` css style property.", name);
          };
          var warnStyleValueIsInfinity = function(name, value) {
            if (warnedForInfinityValue) {
              return;
            }
            warnedForInfinityValue = true;
            error("`Infinity` is an invalid value for the `%s` css style property.", name);
          };
          warnValidStyle = function(name, value) {
            if (name.indexOf("-") > -1) {
              warnHyphenatedStyleName(name);
            } else if (badVendoredStyleNamePattern.test(name)) {
              warnBadVendoredStyleName(name);
            } else if (badStyleValueWithSemicolonPattern.test(value)) {
              warnStyleValueWithSemicolon(name, value);
            }
            if (typeof value === "number") {
              if (isNaN(value)) {
                warnStyleValueIsNaN(name, value);
              } else if (!isFinite(value)) {
                warnStyleValueIsInfinity(name, value);
              }
            }
          };
        }
        var warnValidStyle$1 = warnValidStyle;
        var ariaProperties = {
          "aria-current": 0,
          "aria-details": 0,
          "aria-disabled": 0,
          "aria-hidden": 0,
          "aria-invalid": 0,
          "aria-keyshortcuts": 0,
          "aria-label": 0,
          "aria-roledescription": 0,
          "aria-autocomplete": 0,
          "aria-checked": 0,
          "aria-expanded": 0,
          "aria-haspopup": 0,
          "aria-level": 0,
          "aria-modal": 0,
          "aria-multiline": 0,
          "aria-multiselectable": 0,
          "aria-orientation": 0,
          "aria-placeholder": 0,
          "aria-pressed": 0,
          "aria-readonly": 0,
          "aria-required": 0,
          "aria-selected": 0,
          "aria-sort": 0,
          "aria-valuemax": 0,
          "aria-valuemin": 0,
          "aria-valuenow": 0,
          "aria-valuetext": 0,
          "aria-atomic": 0,
          "aria-busy": 0,
          "aria-live": 0,
          "aria-relevant": 0,
          "aria-dropeffect": 0,
          "aria-grabbed": 0,
          "aria-activedescendant": 0,
          "aria-colcount": 0,
          "aria-colindex": 0,
          "aria-colspan": 0,
          "aria-controls": 0,
          "aria-describedby": 0,
          "aria-errormessage": 0,
          "aria-flowto": 0,
          "aria-labelledby": 0,
          "aria-owns": 0,
          "aria-posinset": 0,
          "aria-rowcount": 0,
          "aria-rowindex": 0,
          "aria-rowspan": 0,
          "aria-setsize": 0
        };
        var warnedProperties = {};
        var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
        var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
        var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
        function validateProperty(tagName, name) {
          {
            if (hasOwnProperty$1.call(warnedProperties, name) && warnedProperties[name]) {
              return true;
            }
            if (rARIACamel.test(name)) {
              var ariaName = "aria-" + name.slice(4).toLowerCase();
              var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
              if (correctName == null) {
                error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name);
                warnedProperties[name] = true;
                return true;
              }
              if (name !== correctName) {
                error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, correctName);
                warnedProperties[name] = true;
                return true;
              }
            }
            if (rARIA.test(name)) {
              var lowerCasedName = name.toLowerCase();
              var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
              if (standardName == null) {
                warnedProperties[name] = true;
                return false;
              }
              if (name !== standardName) {
                error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, standardName);
                warnedProperties[name] = true;
                return true;
              }
            }
          }
          return true;
        }
        function warnInvalidARIAProps(type, props) {
          {
            var invalidProps = [];
            for (var key in props) {
              var isValid = validateProperty(type, key);
              if (!isValid) {
                invalidProps.push(key);
              }
            }
            var unknownPropString = invalidProps.map(function(prop) {
              return "`" + prop + "`";
            }).join(", ");
            if (invalidProps.length === 1) {
              error("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
            } else if (invalidProps.length > 1) {
              error("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
            }
          }
        }
        function validateProperties(type, props) {
          if (isCustomComponent(type, props)) {
            return;
          }
          warnInvalidARIAProps(type, props);
        }
        var didWarnValueNull = false;
        function validateProperties$1(type, props) {
          {
            if (type !== "input" && type !== "textarea" && type !== "select") {
              return;
            }
            if (props != null && props.value === null && !didWarnValueNull) {
              didWarnValueNull = true;
              if (type === "select" && props.multiple) {
                error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type);
              } else {
                error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type);
              }
            }
          }
        }
        var possibleStandardNames = {
          accept: "accept",
          acceptcharset: "acceptCharset",
          "accept-charset": "acceptCharset",
          accesskey: "accessKey",
          action: "action",
          allowfullscreen: "allowFullScreen",
          alt: "alt",
          as: "as",
          async: "async",
          autocapitalize: "autoCapitalize",
          autocomplete: "autoComplete",
          autocorrect: "autoCorrect",
          autofocus: "autoFocus",
          autoplay: "autoPlay",
          autosave: "autoSave",
          capture: "capture",
          cellpadding: "cellPadding",
          cellspacing: "cellSpacing",
          challenge: "challenge",
          charset: "charSet",
          checked: "checked",
          children: "children",
          cite: "cite",
          class: "className",
          classid: "classID",
          classname: "className",
          cols: "cols",
          colspan: "colSpan",
          content: "content",
          contenteditable: "contentEditable",
          contextmenu: "contextMenu",
          controls: "controls",
          controlslist: "controlsList",
          coords: "coords",
          crossorigin: "crossOrigin",
          dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
          data: "data",
          datetime: "dateTime",
          default: "default",
          defaultchecked: "defaultChecked",
          defaultvalue: "defaultValue",
          defer: "defer",
          dir: "dir",
          disabled: "disabled",
          disablepictureinpicture: "disablePictureInPicture",
          disableremoteplayback: "disableRemotePlayback",
          download: "download",
          draggable: "draggable",
          enctype: "encType",
          enterkeyhint: "enterKeyHint",
          for: "htmlFor",
          form: "form",
          formmethod: "formMethod",
          formaction: "formAction",
          formenctype: "formEncType",
          formnovalidate: "formNoValidate",
          formtarget: "formTarget",
          frameborder: "frameBorder",
          headers: "headers",
          height: "height",
          hidden: "hidden",
          high: "high",
          href: "href",
          hreflang: "hrefLang",
          htmlfor: "htmlFor",
          httpequiv: "httpEquiv",
          "http-equiv": "httpEquiv",
          icon: "icon",
          id: "id",
          innerhtml: "innerHTML",
          inputmode: "inputMode",
          integrity: "integrity",
          is: "is",
          itemid: "itemID",
          itemprop: "itemProp",
          itemref: "itemRef",
          itemscope: "itemScope",
          itemtype: "itemType",
          keyparams: "keyParams",
          keytype: "keyType",
          kind: "kind",
          label: "label",
          lang: "lang",
          list: "list",
          loop: "loop",
          low: "low",
          manifest: "manifest",
          marginwidth: "marginWidth",
          marginheight: "marginHeight",
          max: "max",
          maxlength: "maxLength",
          media: "media",
          mediagroup: "mediaGroup",
          method: "method",
          min: "min",
          minlength: "minLength",
          multiple: "multiple",
          muted: "muted",
          name: "name",
          nomodule: "noModule",
          nonce: "nonce",
          novalidate: "noValidate",
          open: "open",
          optimum: "optimum",
          pattern: "pattern",
          placeholder: "placeholder",
          playsinline: "playsInline",
          poster: "poster",
          preload: "preload",
          profile: "profile",
          radiogroup: "radioGroup",
          readonly: "readOnly",
          referrerpolicy: "referrerPolicy",
          rel: "rel",
          required: "required",
          reversed: "reversed",
          role: "role",
          rows: "rows",
          rowspan: "rowSpan",
          sandbox: "sandbox",
          scope: "scope",
          scoped: "scoped",
          scrolling: "scrolling",
          seamless: "seamless",
          selected: "selected",
          shape: "shape",
          size: "size",
          sizes: "sizes",
          span: "span",
          spellcheck: "spellCheck",
          src: "src",
          srcdoc: "srcDoc",
          srclang: "srcLang",
          srcset: "srcSet",
          start: "start",
          step: "step",
          style: "style",
          summary: "summary",
          tabindex: "tabIndex",
          target: "target",
          title: "title",
          type: "type",
          usemap: "useMap",
          value: "value",
          width: "width",
          wmode: "wmode",
          wrap: "wrap",
          about: "about",
          accentheight: "accentHeight",
          "accent-height": "accentHeight",
          accumulate: "accumulate",
          additive: "additive",
          alignmentbaseline: "alignmentBaseline",
          "alignment-baseline": "alignmentBaseline",
          allowreorder: "allowReorder",
          alphabetic: "alphabetic",
          amplitude: "amplitude",
          arabicform: "arabicForm",
          "arabic-form": "arabicForm",
          ascent: "ascent",
          attributename: "attributeName",
          attributetype: "attributeType",
          autoreverse: "autoReverse",
          azimuth: "azimuth",
          basefrequency: "baseFrequency",
          baselineshift: "baselineShift",
          "baseline-shift": "baselineShift",
          baseprofile: "baseProfile",
          bbox: "bbox",
          begin: "begin",
          bias: "bias",
          by: "by",
          calcmode: "calcMode",
          capheight: "capHeight",
          "cap-height": "capHeight",
          clip: "clip",
          clippath: "clipPath",
          "clip-path": "clipPath",
          clippathunits: "clipPathUnits",
          cliprule: "clipRule",
          "clip-rule": "clipRule",
          color: "color",
          colorinterpolation: "colorInterpolation",
          "color-interpolation": "colorInterpolation",
          colorinterpolationfilters: "colorInterpolationFilters",
          "color-interpolation-filters": "colorInterpolationFilters",
          colorprofile: "colorProfile",
          "color-profile": "colorProfile",
          colorrendering: "colorRendering",
          "color-rendering": "colorRendering",
          contentscripttype: "contentScriptType",
          contentstyletype: "contentStyleType",
          cursor: "cursor",
          cx: "cx",
          cy: "cy",
          d: "d",
          datatype: "datatype",
          decelerate: "decelerate",
          descent: "descent",
          diffuseconstant: "diffuseConstant",
          direction: "direction",
          display: "display",
          divisor: "divisor",
          dominantbaseline: "dominantBaseline",
          "dominant-baseline": "dominantBaseline",
          dur: "dur",
          dx: "dx",
          dy: "dy",
          edgemode: "edgeMode",
          elevation: "elevation",
          enablebackground: "enableBackground",
          "enable-background": "enableBackground",
          end: "end",
          exponent: "exponent",
          externalresourcesrequired: "externalResourcesRequired",
          fill: "fill",
          fillopacity: "fillOpacity",
          "fill-opacity": "fillOpacity",
          fillrule: "fillRule",
          "fill-rule": "fillRule",
          filter: "filter",
          filterres: "filterRes",
          filterunits: "filterUnits",
          floodopacity: "floodOpacity",
          "flood-opacity": "floodOpacity",
          floodcolor: "floodColor",
          "flood-color": "floodColor",
          focusable: "focusable",
          fontfamily: "fontFamily",
          "font-family": "fontFamily",
          fontsize: "fontSize",
          "font-size": "fontSize",
          fontsizeadjust: "fontSizeAdjust",
          "font-size-adjust": "fontSizeAdjust",
          fontstretch: "fontStretch",
          "font-stretch": "fontStretch",
          fontstyle: "fontStyle",
          "font-style": "fontStyle",
          fontvariant: "fontVariant",
          "font-variant": "fontVariant",
          fontweight: "fontWeight",
          "font-weight": "fontWeight",
          format: "format",
          from: "from",
          fx: "fx",
          fy: "fy",
          g1: "g1",
          g2: "g2",
          glyphname: "glyphName",
          "glyph-name": "glyphName",
          glyphorientationhorizontal: "glyphOrientationHorizontal",
          "glyph-orientation-horizontal": "glyphOrientationHorizontal",
          glyphorientationvertical: "glyphOrientationVertical",
          "glyph-orientation-vertical": "glyphOrientationVertical",
          glyphref: "glyphRef",
          gradienttransform: "gradientTransform",
          gradientunits: "gradientUnits",
          hanging: "hanging",
          horizadvx: "horizAdvX",
          "horiz-adv-x": "horizAdvX",
          horizoriginx: "horizOriginX",
          "horiz-origin-x": "horizOriginX",
          ideographic: "ideographic",
          imagerendering: "imageRendering",
          "image-rendering": "imageRendering",
          in2: "in2",
          in: "in",
          inlist: "inlist",
          intercept: "intercept",
          k1: "k1",
          k2: "k2",
          k3: "k3",
          k4: "k4",
          k: "k",
          kernelmatrix: "kernelMatrix",
          kernelunitlength: "kernelUnitLength",
          kerning: "kerning",
          keypoints: "keyPoints",
          keysplines: "keySplines",
          keytimes: "keyTimes",
          lengthadjust: "lengthAdjust",
          letterspacing: "letterSpacing",
          "letter-spacing": "letterSpacing",
          lightingcolor: "lightingColor",
          "lighting-color": "lightingColor",
          limitingconeangle: "limitingConeAngle",
          local: "local",
          markerend: "markerEnd",
          "marker-end": "markerEnd",
          markerheight: "markerHeight",
          markermid: "markerMid",
          "marker-mid": "markerMid",
          markerstart: "markerStart",
          "marker-start": "markerStart",
          markerunits: "markerUnits",
          markerwidth: "markerWidth",
          mask: "mask",
          maskcontentunits: "maskContentUnits",
          maskunits: "maskUnits",
          mathematical: "mathematical",
          mode: "mode",
          numoctaves: "numOctaves",
          offset: "offset",
          opacity: "opacity",
          operator: "operator",
          order: "order",
          orient: "orient",
          orientation: "orientation",
          origin: "origin",
          overflow: "overflow",
          overlineposition: "overlinePosition",
          "overline-position": "overlinePosition",
          overlinethickness: "overlineThickness",
          "overline-thickness": "overlineThickness",
          paintorder: "paintOrder",
          "paint-order": "paintOrder",
          panose1: "panose1",
          "panose-1": "panose1",
          pathlength: "pathLength",
          patterncontentunits: "patternContentUnits",
          patterntransform: "patternTransform",
          patternunits: "patternUnits",
          pointerevents: "pointerEvents",
          "pointer-events": "pointerEvents",
          points: "points",
          pointsatx: "pointsAtX",
          pointsaty: "pointsAtY",
          pointsatz: "pointsAtZ",
          prefix: "prefix",
          preservealpha: "preserveAlpha",
          preserveaspectratio: "preserveAspectRatio",
          primitiveunits: "primitiveUnits",
          property: "property",
          r: "r",
          radius: "radius",
          refx: "refX",
          refy: "refY",
          renderingintent: "renderingIntent",
          "rendering-intent": "renderingIntent",
          repeatcount: "repeatCount",
          repeatdur: "repeatDur",
          requiredextensions: "requiredExtensions",
          requiredfeatures: "requiredFeatures",
          resource: "resource",
          restart: "restart",
          result: "result",
          results: "results",
          rotate: "rotate",
          rx: "rx",
          ry: "ry",
          scale: "scale",
          security: "security",
          seed: "seed",
          shaperendering: "shapeRendering",
          "shape-rendering": "shapeRendering",
          slope: "slope",
          spacing: "spacing",
          specularconstant: "specularConstant",
          specularexponent: "specularExponent",
          speed: "speed",
          spreadmethod: "spreadMethod",
          startoffset: "startOffset",
          stddeviation: "stdDeviation",
          stemh: "stemh",
          stemv: "stemv",
          stitchtiles: "stitchTiles",
          stopcolor: "stopColor",
          "stop-color": "stopColor",
          stopopacity: "stopOpacity",
          "stop-opacity": "stopOpacity",
          strikethroughposition: "strikethroughPosition",
          "strikethrough-position": "strikethroughPosition",
          strikethroughthickness: "strikethroughThickness",
          "strikethrough-thickness": "strikethroughThickness",
          string: "string",
          stroke: "stroke",
          strokedasharray: "strokeDasharray",
          "stroke-dasharray": "strokeDasharray",
          strokedashoffset: "strokeDashoffset",
          "stroke-dashoffset": "strokeDashoffset",
          strokelinecap: "strokeLinecap",
          "stroke-linecap": "strokeLinecap",
          strokelinejoin: "strokeLinejoin",
          "stroke-linejoin": "strokeLinejoin",
          strokemiterlimit: "strokeMiterlimit",
          "stroke-miterlimit": "strokeMiterlimit",
          strokewidth: "strokeWidth",
          "stroke-width": "strokeWidth",
          strokeopacity: "strokeOpacity",
          "stroke-opacity": "strokeOpacity",
          suppresscontenteditablewarning: "suppressContentEditableWarning",
          suppresshydrationwarning: "suppressHydrationWarning",
          surfacescale: "surfaceScale",
          systemlanguage: "systemLanguage",
          tablevalues: "tableValues",
          targetx: "targetX",
          targety: "targetY",
          textanchor: "textAnchor",
          "text-anchor": "textAnchor",
          textdecoration: "textDecoration",
          "text-decoration": "textDecoration",
          textlength: "textLength",
          textrendering: "textRendering",
          "text-rendering": "textRendering",
          to: "to",
          transform: "transform",
          typeof: "typeof",
          u1: "u1",
          u2: "u2",
          underlineposition: "underlinePosition",
          "underline-position": "underlinePosition",
          underlinethickness: "underlineThickness",
          "underline-thickness": "underlineThickness",
          unicode: "unicode",
          unicodebidi: "unicodeBidi",
          "unicode-bidi": "unicodeBidi",
          unicoderange: "unicodeRange",
          "unicode-range": "unicodeRange",
          unitsperem: "unitsPerEm",
          "units-per-em": "unitsPerEm",
          unselectable: "unselectable",
          valphabetic: "vAlphabetic",
          "v-alphabetic": "vAlphabetic",
          values: "values",
          vectoreffect: "vectorEffect",
          "vector-effect": "vectorEffect",
          version: "version",
          vertadvy: "vertAdvY",
          "vert-adv-y": "vertAdvY",
          vertoriginx: "vertOriginX",
          "vert-origin-x": "vertOriginX",
          vertoriginy: "vertOriginY",
          "vert-origin-y": "vertOriginY",
          vhanging: "vHanging",
          "v-hanging": "vHanging",
          videographic: "vIdeographic",
          "v-ideographic": "vIdeographic",
          viewbox: "viewBox",
          viewtarget: "viewTarget",
          visibility: "visibility",
          vmathematical: "vMathematical",
          "v-mathematical": "vMathematical",
          vocab: "vocab",
          widths: "widths",
          wordspacing: "wordSpacing",
          "word-spacing": "wordSpacing",
          writingmode: "writingMode",
          "writing-mode": "writingMode",
          x1: "x1",
          x2: "x2",
          x: "x",
          xchannelselector: "xChannelSelector",
          xheight: "xHeight",
          "x-height": "xHeight",
          xlinkactuate: "xlinkActuate",
          "xlink:actuate": "xlinkActuate",
          xlinkarcrole: "xlinkArcrole",
          "xlink:arcrole": "xlinkArcrole",
          xlinkhref: "xlinkHref",
          "xlink:href": "xlinkHref",
          xlinkrole: "xlinkRole",
          "xlink:role": "xlinkRole",
          xlinkshow: "xlinkShow",
          "xlink:show": "xlinkShow",
          xlinktitle: "xlinkTitle",
          "xlink:title": "xlinkTitle",
          xlinktype: "xlinkType",
          "xlink:type": "xlinkType",
          xmlbase: "xmlBase",
          "xml:base": "xmlBase",
          xmllang: "xmlLang",
          "xml:lang": "xmlLang",
          xmlns: "xmlns",
          "xml:space": "xmlSpace",
          xmlnsxlink: "xmlnsXlink",
          "xmlns:xlink": "xmlnsXlink",
          xmlspace: "xmlSpace",
          y1: "y1",
          y2: "y2",
          y: "y",
          ychannelselector: "yChannelSelector",
          z: "z",
          zoomandpan: "zoomAndPan"
        };
        var validateProperty$1 = function() {
        };
        {
          var warnedProperties$1 = {};
          var _hasOwnProperty = Object.prototype.hasOwnProperty;
          var EVENT_NAME_REGEX = /^on./;
          var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
          var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
          var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
          validateProperty$1 = function(tagName, name, value, eventRegistry) {
            if (_hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {
              return true;
            }
            var lowerCasedName = name.toLowerCase();
            if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
              error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (eventRegistry != null) {
              var registrationNameDependencies = eventRegistry.registrationNameDependencies, possibleRegistrationNames = eventRegistry.possibleRegistrationNames;
              if (registrationNameDependencies.hasOwnProperty(name)) {
                return true;
              }
              var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;
              if (registrationName != null) {
                error("Invalid event handler property `%s`. Did you mean `%s`?", name, registrationName);
                warnedProperties$1[name] = true;
                return true;
              }
              if (EVENT_NAME_REGEX.test(name)) {
                error("Unknown event handler property `%s`. It will be ignored.", name);
                warnedProperties$1[name] = true;
                return true;
              }
            } else if (EVENT_NAME_REGEX.test(name)) {
              if (INVALID_EVENT_NAME_REGEX.test(name)) {
                error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name);
              }
              warnedProperties$1[name] = true;
              return true;
            }
            if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
              return true;
            }
            if (lowerCasedName === "innerhtml") {
              error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (lowerCasedName === "aria") {
              error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (lowerCasedName === "is" && value !== null && value !== void 0 && typeof value !== "string") {
              error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value);
              warnedProperties$1[name] = true;
              return true;
            }
            if (typeof value === "number" && isNaN(value)) {
              error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name);
              warnedProperties$1[name] = true;
              return true;
            }
            var propertyInfo = getPropertyInfo(name);
            var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
            if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
              var standardName = possibleStandardNames[lowerCasedName];
              if (standardName !== name) {
                error("Invalid DOM property `%s`. Did you mean `%s`?", name, standardName);
                warnedProperties$1[name] = true;
                return true;
              }
            } else if (!isReserved && name !== lowerCasedName) {
              error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName);
              warnedProperties$1[name] = true;
              return true;
            }
            if (typeof value === "boolean" && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
              if (value) {
                error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name, name, value, name);
              } else {
                error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
              }
              warnedProperties$1[name] = true;
              return true;
            }
            if (isReserved) {
              return true;
            }
            if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
              warnedProperties$1[name] = true;
              return false;
            }
            if ((value === "false" || value === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
              error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name, value);
              warnedProperties$1[name] = true;
              return true;
            }
            return true;
          };
        }
        var warnUnknownProperties = function(type, props, eventRegistry) {
          {
            var unknownProps = [];
            for (var key in props) {
              var isValid = validateProperty$1(type, key, props[key], eventRegistry);
              if (!isValid) {
                unknownProps.push(key);
              }
            }
            var unknownPropString = unknownProps.map(function(prop) {
              return "`" + prop + "`";
            }).join(", ");
            if (unknownProps.length === 1) {
              error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
            } else if (unknownProps.length > 1) {
              error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
            }
          }
        };
        function validateProperties$2(type, props, eventRegistry) {
          if (isCustomComponent(type, props)) {
            return;
          }
          warnUnknownProperties(type, props, eventRegistry);
        }
        var toArray = React6.Children.toArray;
        var currentDebugStacks = [];
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
        var ReactDebugCurrentFrame$1;
        var prevGetCurrentStackImpl = null;
        var getCurrentServerStackImpl = function() {
          return "";
        };
        var describeStackFrame = function(element) {
          return "";
        };
        var validatePropertiesInDevelopment = function(type, props) {
        };
        var pushCurrentDebugStack = function(stack) {
        };
        var pushElementToDebugStack = function(element) {
        };
        var popCurrentDebugStack = function() {
        };
        var hasWarnedAboutUsingContextAsConsumer = false;
        {
          ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
          validatePropertiesInDevelopment = function(type, props) {
            validateProperties(type, props);
            validateProperties$1(type, props);
            validateProperties$2(type, props, null);
          };
          describeStackFrame = function(element) {
            return describeUnknownElementTypeFrameInDEV(element.type, element._source, null);
          };
          pushCurrentDebugStack = function(stack) {
            currentDebugStacks.push(stack);
            if (currentDebugStacks.length === 1) {
              prevGetCurrentStackImpl = ReactDebugCurrentFrame$1.getCurrentStack;
              ReactDebugCurrentFrame$1.getCurrentStack = getCurrentServerStackImpl;
            }
          };
          pushElementToDebugStack = function(element) {
            var stack = currentDebugStacks[currentDebugStacks.length - 1];
            var frame = stack[stack.length - 1];
            frame.debugElementStack.push(element);
          };
          popCurrentDebugStack = function() {
            currentDebugStacks.pop();
            if (currentDebugStacks.length === 0) {
              ReactDebugCurrentFrame$1.getCurrentStack = prevGetCurrentStackImpl;
              prevGetCurrentStackImpl = null;
            }
          };
          getCurrentServerStackImpl = function() {
            if (currentDebugStacks.length === 0) {
              return "";
            }
            var frames = currentDebugStacks[currentDebugStacks.length - 1];
            var stack = "";
            for (var i2 = frames.length - 1; i2 >= 0; i2--) {
              var frame = frames[i2];
              var debugElementStack = frame.debugElementStack;
              for (var ii = debugElementStack.length - 1; ii >= 0; ii--) {
                stack += describeStackFrame(debugElementStack[ii]);
              }
            }
            return stack;
          };
        }
        var didWarnDefaultInputValue = false;
        var didWarnDefaultChecked = false;
        var didWarnDefaultSelectValue = false;
        var didWarnDefaultTextareaValue = false;
        var didWarnInvalidOptionChildren = false;
        var didWarnAboutNoopUpdateForComponent = {};
        var didWarnAboutBadClass = {};
        var didWarnAboutModulePatternComponent = {};
        var didWarnAboutDeprecatedWillMount = {};
        var didWarnAboutUndefinedDerivedState = {};
        var didWarnAboutUninitializedState = {};
        var valuePropNames = ["value", "defaultValue"];
        var newlineEatingTags = {
          listing: true,
          pre: true,
          textarea: true
        };
        var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
        var validatedTagCache = {};
        function validateDangerousTag(tag) {
          if (!validatedTagCache.hasOwnProperty(tag)) {
            if (!VALID_TAG_REGEX.test(tag)) {
              {
                throw Error("Invalid tag: " + tag);
              }
            }
            validatedTagCache[tag] = true;
          }
        }
        var styleNameCache = {};
        var processStyleName = function(styleName) {
          if (styleNameCache.hasOwnProperty(styleName)) {
            return styleNameCache[styleName];
          }
          var result = hyphenateStyleName(styleName);
          styleNameCache[styleName] = result;
          return result;
        };
        function createMarkupForStyles(styles) {
          var serialized = "";
          var delimiter = "";
          for (var styleName in styles) {
            if (!styles.hasOwnProperty(styleName)) {
              continue;
            }
            var isCustomProperty = styleName.indexOf("--") === 0;
            var styleValue = styles[styleName];
            {
              if (!isCustomProperty) {
                warnValidStyle$1(styleName, styleValue);
              }
            }
            if (styleValue != null) {
              serialized += delimiter + (isCustomProperty ? styleName : processStyleName(styleName)) + ":";
              serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);
              delimiter = ";";
            }
          }
          return serialized || null;
        }
        function warnNoop(publicInstance, callerName) {
          {
            var _constructor = publicInstance.constructor;
            var componentName = _constructor && getComponentName(_constructor) || "ReactClass";
            var warningKey = componentName + "." + callerName;
            if (didWarnAboutNoopUpdateForComponent[warningKey]) {
              return;
            }
            error("%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.\n\nPlease check the code for the %s component.", callerName, callerName, componentName);
            didWarnAboutNoopUpdateForComponent[warningKey] = true;
          }
        }
        function shouldConstruct$1(Component) {
          return Component.prototype && Component.prototype.isReactComponent;
        }
        function getNonChildrenInnerMarkup(props) {
          var innerHTML = props.dangerouslySetInnerHTML;
          if (innerHTML != null) {
            if (innerHTML.__html != null) {
              return innerHTML.__html;
            }
          } else {
            var content = props.children;
            if (typeof content === "string" || typeof content === "number") {
              return escapeTextForBrowser(content);
            }
          }
          return null;
        }
        function flattenTopLevelChildren(children) {
          if (!React6.isValidElement(children)) {
            return toArray(children);
          }
          var element = children;
          if (element.type !== REACT_FRAGMENT_TYPE) {
            return [element];
          }
          var fragmentChildren = element.props.children;
          if (!React6.isValidElement(fragmentChildren)) {
            return toArray(fragmentChildren);
          }
          var fragmentChildElement = fragmentChildren;
          return [fragmentChildElement];
        }
        function flattenOptionChildren(children) {
          if (children === void 0 || children === null) {
            return children;
          }
          var content = "";
          React6.Children.forEach(children, function(child) {
            if (child == null) {
              return;
            }
            content += child;
            {
              if (!didWarnInvalidOptionChildren && typeof child !== "string" && typeof child !== "number") {
                didWarnInvalidOptionChildren = true;
                error("Only strings and numbers are supported as <option> children.");
              }
            }
          });
          return content;
        }
        var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
        var STYLE = "style";
        var RESERVED_PROPS = {
          children: null,
          dangerouslySetInnerHTML: null,
          suppressContentEditableWarning: null,
          suppressHydrationWarning: null
        };
        function createOpenTagMarkup(tagVerbatim, tagLowercase, props, namespace, makeStaticMarkup, isRootElement) {
          var ret = "<" + tagVerbatim;
          var isCustomComponent$1 = isCustomComponent(tagLowercase, props);
          for (var propKey in props) {
            if (!hasOwnProperty$2.call(props, propKey)) {
              continue;
            }
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            if (propKey === STYLE) {
              propValue = createMarkupForStyles(propValue);
            }
            var markup = null;
            if (isCustomComponent$1) {
              if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
                markup = createMarkupForCustomAttribute(propKey, propValue);
              }
            } else {
              markup = createMarkupForProperty(propKey, propValue);
            }
            if (markup) {
              ret += " " + markup;
            }
          }
          if (makeStaticMarkup) {
            return ret;
          }
          if (isRootElement) {
            ret += " " + createMarkupForRoot();
          }
          return ret;
        }
        function validateRenderResult(child, type) {
          if (child === void 0) {
            {
              {
                throw Error((getComponentName(type) || "Component") + "(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.");
              }
            }
          }
        }
        function resolve(child, context, threadID) {
          while (React6.isValidElement(child)) {
            var element = child;
            var Component = element.type;
            {
              pushElementToDebugStack(element);
            }
            if (typeof Component !== "function") {
              break;
            }
            processChild(element, Component);
          }
          function processChild(element2, Component2) {
            var isClass = shouldConstruct$1(Component2);
            var publicContext = processContext(Component2, context, threadID, isClass);
            var queue2 = [];
            var replace = false;
            var updater = {
              isMounted: function(publicInstance) {
                return false;
              },
              enqueueForceUpdate: function(publicInstance) {
                if (queue2 === null) {
                  warnNoop(publicInstance, "forceUpdate");
                  return null;
                }
              },
              enqueueReplaceState: function(publicInstance, completeState) {
                replace = true;
                queue2 = [completeState];
              },
              enqueueSetState: function(publicInstance, currentPartialState) {
                if (queue2 === null) {
                  warnNoop(publicInstance, "setState");
                  return null;
                }
                queue2.push(currentPartialState);
              }
            };
            var inst;
            if (isClass) {
              inst = new Component2(element2.props, publicContext, updater);
              if (typeof Component2.getDerivedStateFromProps === "function") {
                {
                  if (inst.state === null || inst.state === void 0) {
                    var componentName = getComponentName(Component2) || "Unknown";
                    if (!didWarnAboutUninitializedState[componentName]) {
                      error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, inst.state === null ? "null" : "undefined", componentName);
                      didWarnAboutUninitializedState[componentName] = true;
                    }
                  }
                }
                var partialState = Component2.getDerivedStateFromProps.call(null, element2.props, inst.state);
                {
                  if (partialState === void 0) {
                    var _componentName = getComponentName(Component2) || "Unknown";
                    if (!didWarnAboutUndefinedDerivedState[_componentName]) {
                      error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", _componentName);
                      didWarnAboutUndefinedDerivedState[_componentName] = true;
                    }
                  }
                }
                if (partialState != null) {
                  inst.state = _assign({}, inst.state, partialState);
                }
              }
            } else {
              {
                if (Component2.prototype && typeof Component2.prototype.render === "function") {
                  var _componentName2 = getComponentName(Component2) || "Unknown";
                  if (!didWarnAboutBadClass[_componentName2]) {
                    error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", _componentName2, _componentName2);
                    didWarnAboutBadClass[_componentName2] = true;
                  }
                }
              }
              var componentIdentity = {};
              prepareToUseHooks(componentIdentity);
              inst = Component2(element2.props, publicContext, updater);
              inst = finishHooks(Component2, element2.props, inst, publicContext);
              {
                if (inst != null && inst.render != null) {
                  var _componentName3 = getComponentName(Component2) || "Unknown";
                  if (!didWarnAboutModulePatternComponent[_componentName3]) {
                    error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName3, _componentName3, _componentName3);
                    didWarnAboutModulePatternComponent[_componentName3] = true;
                  }
                }
              }
              if (inst == null || inst.render == null) {
                child = inst;
                validateRenderResult(child, Component2);
                return;
              }
            }
            inst.props = element2.props;
            inst.context = publicContext;
            inst.updater = updater;
            var initialState = inst.state;
            if (initialState === void 0) {
              inst.state = initialState = null;
            }
            if (typeof inst.UNSAFE_componentWillMount === "function" || typeof inst.componentWillMount === "function") {
              if (typeof inst.componentWillMount === "function") {
                {
                  if (inst.componentWillMount.__suppressDeprecationWarning !== true) {
                    var _componentName4 = getComponentName(Component2) || "Unknown";
                    if (!didWarnAboutDeprecatedWillMount[_componentName4]) {
                      warn("componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.\n\nPlease update the following components: %s", _componentName4);
                      didWarnAboutDeprecatedWillMount[_componentName4] = true;
                    }
                  }
                }
                if (typeof Component2.getDerivedStateFromProps !== "function") {
                  inst.componentWillMount();
                }
              }
              if (typeof inst.UNSAFE_componentWillMount === "function" && typeof Component2.getDerivedStateFromProps !== "function") {
                inst.UNSAFE_componentWillMount();
              }
              if (queue2.length) {
                var oldQueue = queue2;
                var oldReplace = replace;
                queue2 = null;
                replace = false;
                if (oldReplace && oldQueue.length === 1) {
                  inst.state = oldQueue[0];
                } else {
                  var nextState = oldReplace ? oldQueue[0] : inst.state;
                  var dontMutate = true;
                  for (var i2 = oldReplace ? 1 : 0; i2 < oldQueue.length; i2++) {
                    var partial = oldQueue[i2];
                    var _partialState = typeof partial === "function" ? partial.call(inst, nextState, element2.props, publicContext) : partial;
                    if (_partialState != null) {
                      if (dontMutate) {
                        dontMutate = false;
                        nextState = _assign({}, nextState, _partialState);
                      } else {
                        _assign(nextState, _partialState);
                      }
                    }
                  }
                  inst.state = nextState;
                }
              } else {
                queue2 = null;
              }
            }
            child = inst.render();
            {
              if (child === void 0 && inst.render._isMockFunction) {
                child = null;
              }
            }
            validateRenderResult(child, Component2);
            var childContext;
            {
              if (typeof inst.getChildContext === "function") {
                var _childContextTypes = Component2.childContextTypes;
                if (typeof _childContextTypes === "object") {
                  childContext = inst.getChildContext();
                  for (var contextKey in childContext) {
                    if (!(contextKey in _childContextTypes)) {
                      {
                        throw Error((getComponentName(Component2) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
                      }
                    }
                  }
                } else {
                  {
                    error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", getComponentName(Component2) || "Unknown");
                  }
                }
              }
              if (childContext) {
                context = _assign({}, context, childContext);
              }
            }
          }
          return {
            child,
            context
          };
        }
        var ReactDOMServerRenderer = /* @__PURE__ */ function() {
          function ReactDOMServerRenderer2(children, makeStaticMarkup, options) {
            var flatChildren = flattenTopLevelChildren(children);
            var topFrame = {
              type: null,
              domNamespace: Namespaces.html,
              children: flatChildren,
              childIndex: 0,
              context: emptyObject,
              footer: ""
            };
            {
              topFrame.debugElementStack = [];
            }
            this.threadID = allocThreadID();
            this.stack = [topFrame];
            this.exhausted = false;
            this.currentSelectValue = null;
            this.previousWasTextNode = false;
            this.makeStaticMarkup = makeStaticMarkup;
            this.suspenseDepth = 0;
            this.contextIndex = -1;
            this.contextStack = [];
            this.contextValueStack = [];
            this.uniqueID = 0;
            this.identifierPrefix = options && options.identifierPrefix || "";
            {
              this.contextProviderStack = [];
            }
          }
          var _proto = ReactDOMServerRenderer2.prototype;
          _proto.destroy = function destroy() {
            if (!this.exhausted) {
              this.exhausted = true;
              this.clearProviders();
              freeThreadID(this.threadID);
            }
          };
          _proto.pushProvider = function pushProvider(provider) {
            var index = ++this.contextIndex;
            var context = provider.type._context;
            var threadID = this.threadID;
            validateContextBounds(context, threadID);
            var previousValue = context[threadID];
            this.contextStack[index] = context;
            this.contextValueStack[index] = previousValue;
            {
              this.contextProviderStack[index] = provider;
            }
            context[threadID] = provider.props.value;
          };
          _proto.popProvider = function popProvider(provider) {
            var index = this.contextIndex;
            {
              if (index < 0 || provider !== this.contextProviderStack[index]) {
                error("Unexpected pop.");
              }
            }
            var context = this.contextStack[index];
            var previousValue = this.contextValueStack[index];
            this.contextStack[index] = null;
            this.contextValueStack[index] = null;
            {
              this.contextProviderStack[index] = null;
            }
            this.contextIndex--;
            context[this.threadID] = previousValue;
          };
          _proto.clearProviders = function clearProviders() {
            for (var index = this.contextIndex; index >= 0; index--) {
              var context = this.contextStack[index];
              var previousValue = this.contextValueStack[index];
              context[this.threadID] = previousValue;
            }
          };
          _proto.read = function read2(bytes) {
            if (this.exhausted) {
              return null;
            }
            var prevPartialRenderer = currentPartialRenderer;
            setCurrentPartialRenderer(this);
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = Dispatcher;
            try {
              var out = [""];
              var suspended = false;
              while (out[0].length < bytes) {
                if (this.stack.length === 0) {
                  this.exhausted = true;
                  freeThreadID(this.threadID);
                  break;
                }
                var frame = this.stack[this.stack.length - 1];
                if (suspended || frame.childIndex >= frame.children.length) {
                  var footer = frame.footer;
                  if (footer !== "") {
                    this.previousWasTextNode = false;
                  }
                  this.stack.pop();
                  if (frame.type === "select") {
                    this.currentSelectValue = null;
                  } else if (frame.type != null && frame.type.type != null && frame.type.type.$$typeof === REACT_PROVIDER_TYPE) {
                    var provider = frame.type;
                    this.popProvider(provider);
                  } else if (frame.type === REACT_SUSPENSE_TYPE) {
                    this.suspenseDepth--;
                    var buffered = out.pop();
                    if (suspended) {
                      suspended = false;
                      var fallbackFrame = frame.fallbackFrame;
                      if (!fallbackFrame) {
                        {
                          throw Error(true ? "ReactDOMServer did not find an internal fallback frame for Suspense. This is a bug in React. Please file an issue." : formatProdErrorMessage(303));
                        }
                      }
                      this.stack.push(fallbackFrame);
                      out[this.suspenseDepth] += "<!--$!-->";
                      continue;
                    } else {
                      out[this.suspenseDepth] += buffered;
                    }
                  }
                  out[this.suspenseDepth] += footer;
                  continue;
                }
                var child = frame.children[frame.childIndex++];
                var outBuffer = "";
                if (true) {
                  pushCurrentDebugStack(this.stack);
                  frame.debugElementStack.length = 0;
                }
                try {
                  outBuffer += this.render(child, frame.context, frame.domNamespace);
                } catch (err) {
                  if (err != null && typeof err.then === "function") {
                    if (enableSuspenseServerRenderer) {
                      if (!(this.suspenseDepth > 0)) {
                        {
                          throw Error(true ? "A React component suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display." : formatProdErrorMessage(342));
                        }
                      }
                      suspended = true;
                    } else {
                      if (true) {
                        {
                          throw Error(true ? "ReactDOMServer does not yet support Suspense." : formatProdErrorMessage(294));
                        }
                      }
                    }
                  } else {
                    throw err;
                  }
                } finally {
                  if (true) {
                    popCurrentDebugStack();
                  }
                }
                if (out.length <= this.suspenseDepth) {
                  out.push("");
                }
                out[this.suspenseDepth] += outBuffer;
              }
              return out[0];
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
              setCurrentPartialRenderer(prevPartialRenderer);
              resetHooksState();
            }
          };
          _proto.render = function render(child, context, parentNamespace) {
            if (typeof child === "string" || typeof child === "number") {
              var text = "" + child;
              if (text === "") {
                return "";
              }
              if (this.makeStaticMarkup) {
                return escapeTextForBrowser(text);
              }
              if (this.previousWasTextNode) {
                return "<!-- -->" + escapeTextForBrowser(text);
              }
              this.previousWasTextNode = true;
              return escapeTextForBrowser(text);
            } else {
              var nextChild;
              var _resolve = resolve(child, context, this.threadID);
              nextChild = _resolve.child;
              context = _resolve.context;
              if (nextChild === null || nextChild === false) {
                return "";
              } else if (!React6.isValidElement(nextChild)) {
                if (nextChild != null && nextChild.$$typeof != null) {
                  var $$typeof = nextChild.$$typeof;
                  if (!($$typeof !== REACT_PORTAL_TYPE)) {
                    {
                      throw Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
                    }
                  }
                  {
                    {
                      throw Error("Unknown element-like object type: " + $$typeof.toString() + ". This is likely a bug in React. Please file an issue.");
                    }
                  }
                }
                var nextChildren = toArray(nextChild);
                var frame = {
                  type: null,
                  domNamespace: parentNamespace,
                  children: nextChildren,
                  childIndex: 0,
                  context,
                  footer: ""
                };
                {
                  frame.debugElementStack = [];
                }
                this.stack.push(frame);
                return "";
              }
              var nextElement = nextChild;
              var elementType = nextElement.type;
              if (typeof elementType === "string") {
                return this.renderDOM(nextElement, context, parentNamespace);
              }
              switch (elementType) {
                case REACT_LEGACY_HIDDEN_TYPE:
                case REACT_DEBUG_TRACING_MODE_TYPE:
                case REACT_STRICT_MODE_TYPE:
                case REACT_PROFILER_TYPE:
                case REACT_SUSPENSE_LIST_TYPE:
                case REACT_FRAGMENT_TYPE: {
                  var _nextChildren = toArray(nextChild.props.children);
                  var _frame = {
                    type: null,
                    domNamespace: parentNamespace,
                    children: _nextChildren,
                    childIndex: 0,
                    context,
                    footer: ""
                  };
                  {
                    _frame.debugElementStack = [];
                  }
                  this.stack.push(_frame);
                  return "";
                }
                case REACT_SUSPENSE_TYPE: {
                  {
                    {
                      {
                        throw Error("ReactDOMServer does not yet support Suspense.");
                      }
                    }
                  }
                }
                case REACT_SCOPE_TYPE: {
                  {
                    {
                      throw Error("ReactDOMServer does not yet support scope components.");
                    }
                  }
                }
              }
              if (typeof elementType === "object" && elementType !== null) {
                switch (elementType.$$typeof) {
                  case REACT_FORWARD_REF_TYPE: {
                    var element = nextChild;
                    var _nextChildren5;
                    var componentIdentity = {};
                    prepareToUseHooks(componentIdentity);
                    _nextChildren5 = elementType.render(element.props, element.ref);
                    _nextChildren5 = finishHooks(elementType.render, element.props, _nextChildren5, element.ref);
                    _nextChildren5 = toArray(_nextChildren5);
                    var _frame5 = {
                      type: null,
                      domNamespace: parentNamespace,
                      children: _nextChildren5,
                      childIndex: 0,
                      context,
                      footer: ""
                    };
                    {
                      _frame5.debugElementStack = [];
                    }
                    this.stack.push(_frame5);
                    return "";
                  }
                  case REACT_MEMO_TYPE: {
                    var _element = nextChild;
                    var _nextChildren6 = [React6.createElement(elementType.type, _assign({
                      ref: _element.ref
                    }, _element.props))];
                    var _frame6 = {
                      type: null,
                      domNamespace: parentNamespace,
                      children: _nextChildren6,
                      childIndex: 0,
                      context,
                      footer: ""
                    };
                    {
                      _frame6.debugElementStack = [];
                    }
                    this.stack.push(_frame6);
                    return "";
                  }
                  case REACT_PROVIDER_TYPE: {
                    var provider = nextChild;
                    var nextProps = provider.props;
                    var _nextChildren7 = toArray(nextProps.children);
                    var _frame7 = {
                      type: provider,
                      domNamespace: parentNamespace,
                      children: _nextChildren7,
                      childIndex: 0,
                      context,
                      footer: ""
                    };
                    {
                      _frame7.debugElementStack = [];
                    }
                    this.pushProvider(provider);
                    this.stack.push(_frame7);
                    return "";
                  }
                  case REACT_CONTEXT_TYPE: {
                    var reactContext = nextChild.type;
                    {
                      if (reactContext._context === void 0) {
                        if (reactContext !== reactContext.Consumer) {
                          if (!hasWarnedAboutUsingContextAsConsumer) {
                            hasWarnedAboutUsingContextAsConsumer = true;
                            error("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                          }
                        }
                      } else {
                        reactContext = reactContext._context;
                      }
                    }
                    var _nextProps = nextChild.props;
                    var threadID = this.threadID;
                    validateContextBounds(reactContext, threadID);
                    var nextValue = reactContext[threadID];
                    var _nextChildren8 = toArray(_nextProps.children(nextValue));
                    var _frame8 = {
                      type: nextChild,
                      domNamespace: parentNamespace,
                      children: _nextChildren8,
                      childIndex: 0,
                      context,
                      footer: ""
                    };
                    {
                      _frame8.debugElementStack = [];
                    }
                    this.stack.push(_frame8);
                    return "";
                  }
                  case REACT_FUNDAMENTAL_TYPE: {
                    {
                      {
                        throw Error("ReactDOMServer does not yet support the fundamental API.");
                      }
                    }
                  }
                  case REACT_LAZY_TYPE: {
                    var _element2 = nextChild;
                    var lazyComponent = nextChild.type;
                    var payload = lazyComponent._payload;
                    var init2 = lazyComponent._init;
                    var result = init2(payload);
                    var _nextChildren10 = [React6.createElement(result, _assign({
                      ref: _element2.ref
                    }, _element2.props))];
                    var _frame10 = {
                      type: null,
                      domNamespace: parentNamespace,
                      children: _nextChildren10,
                      childIndex: 0,
                      context,
                      footer: ""
                    };
                    {
                      _frame10.debugElementStack = [];
                    }
                    this.stack.push(_frame10);
                    return "";
                  }
                }
              }
              var info = "";
              {
                var owner = nextElement._owner;
                if (elementType === void 0 || typeof elementType === "object" && elementType !== null && Object.keys(elementType).length === 0) {
                  info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                }
                var ownerName = owner ? getComponentName(owner) : null;
                if (ownerName) {
                  info += "\n\nCheck the render method of `" + ownerName + "`.";
                }
              }
              {
                {
                  throw Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (elementType == null ? elementType : typeof elementType) + "." + info);
                }
              }
            }
          };
          _proto.renderDOM = function renderDOM(element, context, parentNamespace) {
            var tag = element.type.toLowerCase();
            var namespace = parentNamespace;
            if (parentNamespace === Namespaces.html) {
              namespace = getIntrinsicNamespace(tag);
            }
            {
              if (namespace === Namespaces.html) {
                if (tag !== element.type) {
                  error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", element.type);
                }
              }
            }
            validateDangerousTag(tag);
            var props = element.props;
            if (tag === "input") {
              {
                checkControlledValueProps("input", props);
                if (props.checked !== void 0 && props.defaultChecked !== void 0 && !didWarnDefaultChecked) {
                  error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type);
                  didWarnDefaultChecked = true;
                }
                if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultInputValue) {
                  error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type);
                  didWarnDefaultInputValue = true;
                }
              }
              props = _assign({
                type: void 0
              }, props, {
                defaultChecked: void 0,
                defaultValue: void 0,
                value: props.value != null ? props.value : props.defaultValue,
                checked: props.checked != null ? props.checked : props.defaultChecked
              });
            } else if (tag === "textarea") {
              {
                checkControlledValueProps("textarea", props);
                if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultTextareaValue) {
                  error("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components");
                  didWarnDefaultTextareaValue = true;
                }
              }
              var initialValue = props.value;
              if (initialValue == null) {
                var defaultValue = props.defaultValue;
                var textareaChildren = props.children;
                if (textareaChildren != null) {
                  {
                    error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
                  }
                  if (!(defaultValue == null)) {
                    {
                      throw Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
                    }
                  }
                  if (Array.isArray(textareaChildren)) {
                    if (!(textareaChildren.length <= 1)) {
                      {
                        throw Error("<textarea> can only have at most one child.");
                      }
                    }
                    textareaChildren = textareaChildren[0];
                  }
                  defaultValue = "" + textareaChildren;
                }
                if (defaultValue == null) {
                  defaultValue = "";
                }
                initialValue = defaultValue;
              }
              props = _assign({}, props, {
                value: void 0,
                children: "" + initialValue
              });
            } else if (tag === "select") {
              {
                checkControlledValueProps("select", props);
                for (var i2 = 0; i2 < valuePropNames.length; i2++) {
                  var propName = valuePropNames[i2];
                  if (props[propName] == null) {
                    continue;
                  }
                  var isArray3 = Array.isArray(props[propName]);
                  if (props.multiple && !isArray3) {
                    error("The `%s` prop supplied to <select> must be an array if `multiple` is true.", propName);
                  } else if (!props.multiple && isArray3) {
                    error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", propName);
                  }
                }
                if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultSelectValue) {
                  error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components");
                  didWarnDefaultSelectValue = true;
                }
              }
              this.currentSelectValue = props.value != null ? props.value : props.defaultValue;
              props = _assign({}, props, {
                value: void 0
              });
            } else if (tag === "option") {
              var selected = null;
              var selectValue = this.currentSelectValue;
              var optionChildren = flattenOptionChildren(props.children);
              if (selectValue != null) {
                var value;
                if (props.value != null) {
                  value = props.value + "";
                } else {
                  value = optionChildren;
                }
                selected = false;
                if (Array.isArray(selectValue)) {
                  for (var j = 0; j < selectValue.length; j++) {
                    if ("" + selectValue[j] === value) {
                      selected = true;
                      break;
                    }
                  }
                } else {
                  selected = "" + selectValue === value;
                }
                props = _assign({
                  selected: void 0,
                  children: void 0
                }, props, {
                  selected,
                  children: optionChildren
                });
              }
            }
            {
              validatePropertiesInDevelopment(tag, props);
            }
            assertValidProps(tag, props);
            var out = createOpenTagMarkup(element.type, tag, props, namespace, this.makeStaticMarkup, this.stack.length === 1);
            var footer = "";
            if (omittedCloseTags.hasOwnProperty(tag)) {
              out += "/>";
            } else {
              out += ">";
              footer = "</" + element.type + ">";
            }
            var children;
            var innerMarkup = getNonChildrenInnerMarkup(props);
            if (innerMarkup != null) {
              children = [];
              if (newlineEatingTags.hasOwnProperty(tag) && innerMarkup.charAt(0) === "\n") {
                out += "\n";
              }
              out += innerMarkup;
            } else {
              children = toArray(props.children);
            }
            var frame = {
              domNamespace: getChildNamespace(parentNamespace, element.type),
              type: tag,
              children,
              childIndex: 0,
              context,
              footer
            };
            {
              frame.debugElementStack = [];
            }
            this.stack.push(frame);
            this.previousWasTextNode = false;
            return out;
          };
          return ReactDOMServerRenderer2;
        }();
        function renderToString2(element, options) {
          var renderer = new ReactDOMServerRenderer(element, false, options);
          try {
            var markup = renderer.read(Infinity);
            return markup;
          } finally {
            renderer.destroy();
          }
        }
        function renderToStaticMarkup(element, options) {
          var renderer = new ReactDOMServerRenderer(element, true, options);
          try {
            var markup = renderer.read(Infinity);
            return markup;
          } finally {
            renderer.destroy();
          }
        }
        function _inheritsLoose(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          subClass.__proto__ = superClass;
        }
        var ReactMarkupReadableStream = /* @__PURE__ */ function(_Readable) {
          _inheritsLoose(ReactMarkupReadableStream2, _Readable);
          function ReactMarkupReadableStream2(element, makeStaticMarkup, options) {
            var _this;
            _this = _Readable.call(this, {}) || this;
            _this.partialRenderer = new ReactDOMServerRenderer(element, makeStaticMarkup, options);
            return _this;
          }
          var _proto = ReactMarkupReadableStream2.prototype;
          _proto._destroy = function _destroy(err, callback) {
            this.partialRenderer.destroy();
            callback(err);
          };
          _proto._read = function _read(size) {
            try {
              this.push(this.partialRenderer.read(size));
            } catch (err) {
              this.destroy(err);
            }
          };
          return ReactMarkupReadableStream2;
        }(stream.Readable);
        function renderToNodeStream(element, options) {
          return new ReactMarkupReadableStream(element, false, options);
        }
        function renderToStaticNodeStream(element, options) {
          return new ReactMarkupReadableStream(element, true, options);
        }
        exports.renderToNodeStream = renderToNodeStream;
        exports.renderToStaticMarkup = renderToStaticMarkup;
        exports.renderToStaticNodeStream = renderToStaticNodeStream;
        exports.renderToString = renderToString2;
        exports.version = ReactVersion;
      })();
    }
  }
});

// node_modules/react-dom/server.node.js
var require_server_node = __commonJS({
  "node_modules/react-dom/server.node.js"(exports, module) {
    "use strict";
    init_react();
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_dom_server_node_development();
    }
  }
});

// node_modules/react-dom/server.js
var require_server = __commonJS({
  "node_modules/react-dom/server.js"(exports, module) {
    "use strict";
    init_react();
    module.exports = require_server_node();
  }
});

// server.js
init_react();

// node_modules/@remix-run/cloudflare-pages/esm/index.js
init_react();

// node_modules/@remix-run/cloudflare-pages/esm/globals.js
init_react();

// node_modules/@remix-run/cloudflare-pages/esm/cookieSigning.js
init_react();
var encoder = new TextEncoder();
async function sign(value, secret) {
  let key = await crypto.subtle.importKey("raw", encoder.encode(secret), {
    name: "HMAC",
    hash: "SHA-256"
  }, false, ["sign"]);
  let data = encoder.encode(value);
  let signature = await crypto.subtle.sign("HMAC", key, data);
  let hash = btoa(String.fromCharCode(...new Uint8Array(signature))).replace(/=+$/, "");
  return value + "." + hash;
}
async function unsign(cookie, secret) {
  let key = await crypto.subtle.importKey("raw", encoder.encode(secret), {
    name: "HMAC",
    hash: "SHA-256"
  }, false, ["verify"]);
  let value = cookie.slice(0, cookie.lastIndexOf("."));
  let hash = cookie.slice(cookie.lastIndexOf(".") + 1);
  let data = encoder.encode(value);
  let signature = byteStringToUint8Array(atob(hash));
  let valid = await crypto.subtle.verify("HMAC", key, signature, data);
  return valid ? value : false;
}
function byteStringToUint8Array(byteString) {
  let array = new Uint8Array(byteString.length);
  for (let i = 0; i < byteString.length; i++) {
    array[i] = byteString.charCodeAt(i);
  }
  return array;
}

// node_modules/@remix-run/cloudflare-pages/esm/globals.js
function installGlobals() {
  self.sign = sign;
  self.unsign = unsign;
}

// node_modules/@remix-run/cloudflare-pages/esm/sessions/cloudflareKVSessionStorage.js
init_react();

// node_modules/@remix-run/server-runtime/esm/index.js
init_react();

// node_modules/@remix-run/server-runtime/esm/responses.js
init_react();
function json(data, init2 = {}) {
  let responseInit = init2;
  if (typeof init2 === "number") {
    responseInit = {
      status: init2
    };
  }
  let headers = new Headers(responseInit.headers);
  if (!headers.has("Content-Type")) {
    headers.set("Content-Type", "application/json; charset=utf-8");
  }
  return new Response(JSON.stringify(data), __spreadProps(__spreadValues({}, responseInit), {
    headers
  }));
}
function isResponse(value) {
  return value != null && typeof value.status === "number" && typeof value.statusText === "string" && typeof value.headers === "object" && typeof value.body !== "undefined";
}
var redirectStatusCodes = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);
function isRedirectResponse(response) {
  return redirectStatusCodes.has(response.status);
}
function isCatchResponse(response) {
  return response.headers.get("X-Remix-Catch") != null;
}

// node_modules/@remix-run/server-runtime/esm/server.js
init_react();

// node_modules/@remix-run/server-runtime/esm/data.js
init_react();
async function callRouteAction({
  loadContext,
  match,
  request
}) {
  let action = match.route.module.action;
  if (!action) {
    throw new Error(`You made a ${request.method} request to ${request.url} but did not provide an \`action\` for route "${match.route.id}", so there is no way to handle the request.`);
  }
  let result;
  try {
    result = await action({
      request: stripDataParam(stripIndexParam(request)),
      context: loadContext,
      params: match.params
    });
  } catch (error) {
    if (!isResponse(error)) {
      throw error;
    }
    if (!isRedirectResponse(error)) {
      error.headers.set("X-Remix-Catch", "yes");
    }
    result = error;
  }
  if (result === void 0) {
    throw new Error(`You defined an action for route "${match.route.id}" but didn't return anything from your \`action\` function. Please return a value or \`null\`.`);
  }
  return isResponse(result) ? result : json(result);
}
async function callRouteLoader({
  loadContext,
  match,
  request
}) {
  let loader = match.route.module.loader;
  if (!loader) {
    throw new Error(`You made a ${request.method} request to ${request.url} but did not provide a \`loader\` for route "${match.route.id}", so there is no way to handle the request.`);
  }
  let result;
  try {
    result = await loader({
      request: stripDataParam(stripIndexParam(request.clone())),
      context: loadContext,
      params: match.params
    });
  } catch (error) {
    if (!isResponse(error)) {
      throw error;
    }
    if (!isRedirectResponse(error)) {
      error.headers.set("X-Remix-Catch", "yes");
    }
    result = error;
  }
  if (result === void 0) {
    throw new Error(`You defined a loader for route "${match.route.id}" but didn't return anything from your \`loader\` function. Please return a value or \`null\`.`);
  }
  return isResponse(result) ? result : json(result);
}
function stripIndexParam(request) {
  let url = new URL(request.url);
  let indexValues = url.searchParams.getAll("index");
  url.searchParams.delete("index");
  let indexValuesToKeep = [];
  for (let indexValue of indexValues) {
    if (indexValue) {
      indexValuesToKeep.push(indexValue);
    }
  }
  for (let toKeep of indexValuesToKeep) {
    url.searchParams.append("index", toKeep);
  }
  return new Request(url.href, request);
}
function stripDataParam(request) {
  let url = new URL(request.url);
  url.searchParams.delete("_data");
  return new Request(url.href, request);
}
function extractData(response) {
  let contentType = response.headers.get("Content-Type");
  if (contentType && /\bapplication\/json\b/.test(contentType)) {
    return response.json();
  }
  return response.text();
}

// node_modules/@remix-run/server-runtime/esm/entry.js
init_react();
function createEntryMatches(matches, routes2) {
  return matches.map((match) => ({
    params: match.params,
    pathname: match.pathname,
    route: routes2[match.route.id]
  }));
}
function createEntryRouteModules(manifest) {
  return Object.keys(manifest).reduce((memo, routeId) => {
    memo[routeId] = manifest[routeId].module;
    return memo;
  }, {});
}

// node_modules/@remix-run/server-runtime/esm/errors.js
init_react();
async function serializeError(error) {
  return {
    message: error.message,
    stack: error.stack
  };
}

// node_modules/@remix-run/server-runtime/esm/headers.js
init_react();
var import_set_cookie_parser = __toESM(require_set_cookie());
function getDocumentHeaders(build, matches, routeLoaderResponses, actionResponse) {
  return matches.reduce((parentHeaders, match, index) => {
    let routeModule = build.routes[match.route.id].module;
    let routeLoaderResponse = routeLoaderResponses[match.route.id];
    let loaderHeaders = routeLoaderResponse ? routeLoaderResponse.headers : new Headers();
    let actionHeaders = actionResponse ? actionResponse.headers : new Headers();
    let headers = new Headers(routeModule.headers ? typeof routeModule.headers === "function" ? routeModule.headers({
      loaderHeaders,
      parentHeaders,
      actionHeaders
    }) : routeModule.headers : void 0);
    prependCookies(actionHeaders, headers);
    prependCookies(loaderHeaders, headers);
    prependCookies(parentHeaders, headers);
    return headers;
  }, new Headers());
}
function prependCookies(parentHeaders, childHeaders) {
  let parentSetCookieString = parentHeaders.get("Set-Cookie");
  if (parentSetCookieString) {
    let cookies = (0, import_set_cookie_parser.splitCookiesString)(parentSetCookieString);
    cookies.forEach((cookie) => {
      childHeaders.append("Set-Cookie", cookie);
    });
  }
}

// node_modules/@remix-run/server-runtime/esm/routeMatching.js
init_react();

// node_modules/react-router-dom/index.js
init_react();
var import_react2 = __toESM(require_react());

// node_modules/history/index.js
init_react();

// node_modules/@babel/runtime/helpers/esm/extends.js
init_react();

// node_modules/history/index.js
var Action;
(function(Action2) {
  Action2["Pop"] = "POP";
  Action2["Push"] = "PUSH";
  Action2["Replace"] = "REPLACE";
})(Action || (Action = {}));
function createPath(_ref) {
  var _ref$pathname = _ref.pathname, pathname = _ref$pathname === void 0 ? "/" : _ref$pathname, _ref$search = _ref.search, search = _ref$search === void 0 ? "" : _ref$search, _ref$hash = _ref.hash, hash = _ref$hash === void 0 ? "" : _ref$hash;
  if (search && search !== "?")
    pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash && hash !== "#")
    pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
  return pathname;
}
function parsePath(path) {
  var parsedPath = {};
  if (path) {
    var hashIndex = path.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path.substr(hashIndex);
      path = path.substr(0, hashIndex);
    }
    var searchIndex = path.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path.substr(searchIndex);
      path = path.substr(0, searchIndex);
    }
    if (path) {
      parsedPath.pathname = path;
    }
  }
  return parsedPath;
}

// node_modules/react-router/index.js
init_react();
var import_react = __toESM(require_react());
function invariant(cond, message) {
  if (!cond)
    throw new Error(message);
}
function warning(cond, message) {
  if (!cond) {
    if (typeof console !== "undefined")
      console.warn(message);
    try {
      throw new Error(message);
    } catch (e) {
    }
  }
}
var alreadyWarned = {};
function warningOnce(key, cond, message) {
  if (!cond && !alreadyWarned[key]) {
    alreadyWarned[key] = true;
    true ? warning(false, message) : void 0;
  }
}
var NavigationContext = /* @__PURE__ */ (0, import_react.createContext)(null);
if (true) {
  NavigationContext.displayName = "Navigation";
}
var LocationContext = /* @__PURE__ */ (0, import_react.createContext)(null);
if (true) {
  LocationContext.displayName = "Location";
}
var RouteContext = /* @__PURE__ */ (0, import_react.createContext)({
  outlet: null,
  matches: []
});
if (true) {
  RouteContext.displayName = "Route";
}
function Outlet(props) {
  return useOutlet(props.context);
}
function Router(_ref3) {
  let {
    basename: basenameProp = "/",
    children = null,
    location: locationProp,
    navigationType = Action.Pop,
    navigator,
    static: staticProp = false
  } = _ref3;
  !!useInRouterContext() ? true ? invariant(false, "You cannot render a <Router> inside another <Router>. You should never have more than one in your app.") : invariant(false) : void 0;
  let basename = normalizePathname(basenameProp);
  let navigationContext = (0, import_react.useMemo)(() => ({
    basename,
    navigator,
    static: staticProp
  }), [basename, navigator, staticProp]);
  if (typeof locationProp === "string") {
    locationProp = parsePath(locationProp);
  }
  let {
    pathname = "/",
    search = "",
    hash = "",
    state = null,
    key = "default"
  } = locationProp;
  let location2 = (0, import_react.useMemo)(() => {
    let trailingPathname = stripBasename(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      pathname: trailingPathname,
      search,
      hash,
      state,
      key
    };
  }, [basename, pathname, search, hash, state, key]);
  true ? warning(location2 != null, '<Router basename="' + basename + '"> is not able to match the URL ' + ('"' + pathname + search + hash + '" because it does not start with the ') + "basename, so the <Router> won't render anything.") : void 0;
  if (location2 == null) {
    return null;
  }
  return /* @__PURE__ */ (0, import_react.createElement)(NavigationContext.Provider, {
    value: navigationContext
  }, /* @__PURE__ */ (0, import_react.createElement)(LocationContext.Provider, {
    children,
    value: {
      location: location2,
      navigationType
    }
  }));
}
function useHref(to) {
  !useInRouterContext() ? true ? invariant(false, "useHref() may be used only in the context of a <Router> component.") : invariant(false) : void 0;
  let {
    basename,
    navigator
  } = (0, import_react.useContext)(NavigationContext);
  let {
    hash,
    pathname,
    search
  } = useResolvedPath(to);
  let joinedPathname = pathname;
  if (basename !== "/") {
    let toPathname = getToPathname(to);
    let endsWithSlash = toPathname != null && toPathname.endsWith("/");
    joinedPathname = pathname === "/" ? basename + (endsWithSlash ? "/" : "") : joinPaths([basename, pathname]);
  }
  return navigator.createHref({
    pathname: joinedPathname,
    search,
    hash
  });
}
function useInRouterContext() {
  return (0, import_react.useContext)(LocationContext) != null;
}
function useLocation() {
  !useInRouterContext() ? true ? invariant(false, "useLocation() may be used only in the context of a <Router> component.") : invariant(false) : void 0;
  return (0, import_react.useContext)(LocationContext).location;
}
function useNavigate() {
  !useInRouterContext() ? true ? invariant(false, "useNavigate() may be used only in the context of a <Router> component.") : invariant(false) : void 0;
  let {
    basename,
    navigator
  } = (0, import_react.useContext)(NavigationContext);
  let {
    matches
  } = (0, import_react.useContext)(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(matches.map((match) => match.pathnameBase));
  let activeRef = (0, import_react.useRef)(false);
  (0, import_react.useEffect)(() => {
    activeRef.current = true;
  });
  let navigate = (0, import_react.useCallback)(function(to, options) {
    if (options === void 0) {
      options = {};
    }
    true ? warning(activeRef.current, "You should call navigate() in a React.useEffect(), not when your component is first rendered.") : void 0;
    if (!activeRef.current)
      return;
    if (typeof to === "number") {
      navigator.go(to);
      return;
    }
    let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname);
    if (basename !== "/") {
      path.pathname = joinPaths([basename, path.pathname]);
    }
    (!!options.replace ? navigator.replace : navigator.push)(path, options.state);
  }, [basename, navigator, routePathnamesJson, locationPathname]);
  return navigate;
}
var OutletContext = /* @__PURE__ */ (0, import_react.createContext)(null);
function useOutlet(context) {
  let outlet = (0, import_react.useContext)(RouteContext).outlet;
  if (outlet) {
    return /* @__PURE__ */ (0, import_react.createElement)(OutletContext.Provider, {
      value: context
    }, outlet);
  }
  return outlet;
}
function useResolvedPath(to) {
  let {
    matches
  } = (0, import_react.useContext)(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(matches.map((match) => match.pathnameBase));
  return (0, import_react.useMemo)(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname), [to, routePathnamesJson, locationPathname]);
}
function useRoutes(routes2, locationArg) {
  !useInRouterContext() ? true ? invariant(false, "useRoutes() may be used only in the context of a <Router> component.") : invariant(false) : void 0;
  let {
    matches: parentMatches
  } = (0, import_react.useContext)(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  let parentPathname = routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  let parentRoute = routeMatch && routeMatch.route;
  if (true) {
    let parentPath = parentRoute && parentRoute.path || "";
    warningOnce(parentPathname, !parentRoute || parentPath.endsWith("*"), "You rendered descendant <Routes> (or called `useRoutes()`) at " + ('"' + parentPathname + '" (under <Route path="' + parentPath + '">) but the ') + `parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

` + ('Please change the parent <Route path="' + parentPath + '"> to <Route ') + ('path="' + (parentPath === "/" ? "*" : parentPath + "/*") + '">.'));
  }
  let locationFromContext = useLocation();
  let location2;
  if (locationArg) {
    var _parsedLocationArg$pa;
    let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
    !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? true ? invariant(false, "When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, the location pathname must begin with the portion of the URL pathname that was " + ('matched by all parent routes. The current pathname base is "' + parentPathnameBase + '" ') + ('but pathname "' + parsedLocationArg.pathname + '" was given in the `location` prop.')) : invariant(false) : void 0;
    location2 = parsedLocationArg;
  } else {
    location2 = locationFromContext;
  }
  let pathname = location2.pathname || "/";
  let remainingPathname = parentPathnameBase === "/" ? pathname : pathname.slice(parentPathnameBase.length) || "/";
  let matches = matchRoutes(routes2, {
    pathname: remainingPathname
  });
  if (true) {
    true ? warning(parentRoute || matches != null, 'No routes matched location "' + location2.pathname + location2.search + location2.hash + '" ') : void 0;
    true ? warning(matches == null || matches[matches.length - 1].route.element !== void 0, 'Matched leaf route at location "' + location2.pathname + location2.search + location2.hash + '" does not have an element. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.') : void 0;
  }
  return _renderMatches(matches && matches.map((match) => Object.assign({}, match, {
    params: Object.assign({}, parentParams, match.params),
    pathname: joinPaths([parentPathnameBase, match.pathname]),
    pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([parentPathnameBase, match.pathnameBase])
  })), parentMatches);
}
function matchRoutes(routes2, locationArg, basename) {
  if (basename === void 0) {
    basename = "/";
  }
  let location2 = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
  let pathname = stripBasename(location2.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes2);
  rankRouteBranches(branches);
  let matches = null;
  for (let i = 0; matches == null && i < branches.length; ++i) {
    matches = matchRouteBranch(branches[i], pathname);
  }
  return matches;
}
function flattenRoutes(routes2, branches, parentsMeta, parentPath) {
  if (branches === void 0) {
    branches = [];
  }
  if (parentsMeta === void 0) {
    parentsMeta = [];
  }
  if (parentPath === void 0) {
    parentPath = "";
  }
  routes2.forEach((route, index) => {
    let meta2 = {
      relativePath: route.path || "",
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index,
      route
    };
    if (meta2.relativePath.startsWith("/")) {
      !meta2.relativePath.startsWith(parentPath) ? true ? invariant(false, 'Absolute route path "' + meta2.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes.") : invariant(false) : void 0;
      meta2.relativePath = meta2.relativePath.slice(parentPath.length);
    }
    let path = joinPaths([parentPath, meta2.relativePath]);
    let routesMeta = parentsMeta.concat(meta2);
    if (route.children && route.children.length > 0) {
      !(route.index !== true) ? true ? invariant(false, "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path + '".')) : invariant(false) : void 0;
      flattenRoutes(route.children, branches, routesMeta, path);
    }
    if (route.path == null && !route.index) {
      return;
    }
    branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  });
  return branches;
}
function rankRouteBranches(branches) {
  branches.sort((a, b) => a.score !== b.score ? b.score - a.score : compareIndexes(a.routesMeta.map((meta2) => meta2.childrenIndex), b.routesMeta.map((meta2) => meta2.childrenIndex)));
}
var paramRe = /^:\w+$/;
var dynamicSegmentValue = 3;
var indexRouteValue = 2;
var emptySegmentValue = 1;
var staticSegmentValue = 10;
var splatPenalty = -2;
var isSplat = (s) => s === "*";
function computeScore(path, index) {
  let segments = path.split("/");
  let initialScore = segments.length;
  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index) {
    initialScore += indexRouteValue;
  }
  return segments.filter((s) => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}
function compareIndexes(a, b) {
  let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);
  return siblings ? a[a.length - 1] - b[b.length - 1] : 0;
}
function matchRouteBranch(branch, pathname) {
  let {
    routesMeta
  } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];
  for (let i = 0; i < routesMeta.length; ++i) {
    let meta2 = routesMeta[i];
    let end = i === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match = matchPath({
      path: meta2.relativePath,
      caseSensitive: meta2.caseSensitive,
      end
    }, remainingPathname);
    if (!match)
      return null;
    Object.assign(matchedParams, match.params);
    let route = meta2.route;
    matches.push({
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match.pathname]),
      pathnameBase: joinPaths([matchedPathname, match.pathnameBase]),
      route
    });
    if (match.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
    }
  }
  return matches;
}
function _renderMatches(matches, parentMatches) {
  if (parentMatches === void 0) {
    parentMatches = [];
  }
  if (matches == null)
    return null;
  return matches.reduceRight((outlet, match, index) => {
    return /* @__PURE__ */ (0, import_react.createElement)(RouteContext.Provider, {
      children: match.route.element !== void 0 ? match.route.element : /* @__PURE__ */ (0, import_react.createElement)(Outlet, null),
      value: {
        outlet,
        matches: parentMatches.concat(matches.slice(0, index + 1))
      }
    });
  }, null);
}
function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = {
      path: pattern,
      caseSensitive: false,
      end: true
    };
  }
  let [matcher, paramNames] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
  let match = pathname.match(matcher);
  if (!match)
    return null;
  let matchedPathname = match[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match.slice(1);
  let params = paramNames.reduce((memo, paramName, index) => {
    if (paramName === "*") {
      let splatValue = captureGroups[index] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }
    memo[paramName] = safelyDecodeURIComponent(captureGroups[index] || "", paramName);
    return memo;
  }, {});
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path, caseSensitive, end) {
  if (caseSensitive === void 0) {
    caseSensitive = false;
  }
  if (end === void 0) {
    end = true;
  }
  true ? warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".')) : void 0;
  let paramNames = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/:(\w+)/g, (_, paramName) => {
    paramNames.push(paramName);
    return "([^\\/]+)";
  });
  if (path.endsWith("*")) {
    paramNames.push("*");
    regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
  } else {
    regexpSource += end ? "\\/*$" : "(?:\\b|\\/|$)";
  }
  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
  return [matcher, paramNames];
}
function safelyDecodeURIComponent(value, paramName) {
  try {
    return decodeURIComponent(value);
  } catch (error) {
    true ? warning(false, 'The value for the URL param "' + paramName + '" will not be decoded because' + (' the string "' + value + '" is a malformed URL segment. This is probably') + (" due to a bad percent encoding (" + error + ").")) : void 0;
    return value;
  }
}
function resolvePath(to, fromPathname) {
  if (fromPathname === void 0) {
    fromPathname = "/";
  }
  let {
    pathname: toPathname,
    search = "",
    hash = ""
  } = typeof to === "string" ? parsePath(to) : to;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach((segment) => {
    if (segment === "..") {
      if (segments.length > 1)
        segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}
function resolveTo(toArg, routePathnames, locationPathname) {
  let to = typeof toArg === "string" ? parsePath(toArg) : toArg;
  let toPathname = toArg === "" || to.pathname === "" ? "/" : to.pathname;
  let from2;
  if (toPathname == null) {
    from2 = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    if (toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to.pathname = toSegments.join("/");
    }
    from2 = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to, from2);
  if (toPathname && toPathname !== "/" && toPathname.endsWith("/") && !path.pathname.endsWith("/")) {
    path.pathname += "/";
  }
  return path;
}
function getToPathname(to) {
  return to === "" || to.pathname === "" ? "/" : typeof to === "string" ? parsePath(to).pathname : to.pathname;
}
function stripBasename(pathname, basename) {
  if (basename === "/")
    return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  let nextChar = pathname.charAt(basename.length);
  if (nextChar && nextChar !== "/") {
    return null;
  }
  return pathname.slice(basename.length) || "/";
}
var joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
var normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
var normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
var normalizeHash = (hash) => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;

// node_modules/react-router-dom/index.js
function _extends2() {
  _extends2 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends2.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var _excluded = ["onClick", "reloadDocument", "replace", "state", "target", "to"];
var _excluded2 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "children"];
function HistoryRouter(_ref3) {
  let {
    basename,
    children,
    history
  } = _ref3;
  const [state, setState] = (0, import_react2.useState)({
    action: history.action,
    location: history.location
  });
  (0, import_react2.useLayoutEffect)(() => history.listen(setState), [history]);
  return /* @__PURE__ */ (0, import_react2.createElement)(Router, {
    basename,
    children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}
if (true) {
  HistoryRouter.displayName = "unstable_HistoryRouter";
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
var Link = /* @__PURE__ */ (0, import_react2.forwardRef)(function LinkWithRef(_ref4, ref) {
  let {
    onClick,
    reloadDocument,
    replace = false,
    state,
    target,
    to
  } = _ref4, rest = _objectWithoutPropertiesLoose(_ref4, _excluded);
  let href = useHref(to);
  let internalOnClick = useLinkClickHandler(to, {
    replace,
    state,
    target
  });
  function handleClick(event) {
    if (onClick)
      onClick(event);
    if (!event.defaultPrevented && !reloadDocument) {
      internalOnClick(event);
    }
  }
  return /* @__PURE__ */ (0, import_react2.createElement)("a", _extends2({}, rest, {
    href,
    onClick: handleClick,
    ref,
    target
  }));
});
if (true) {
  Link.displayName = "Link";
}
var NavLink = /* @__PURE__ */ (0, import_react2.forwardRef)(function NavLinkWithRef(_ref5, ref) {
  let {
    "aria-current": ariaCurrentProp = "page",
    caseSensitive = false,
    className: classNameProp = "",
    end = false,
    style: styleProp,
    to,
    children
  } = _ref5, rest = _objectWithoutPropertiesLoose(_ref5, _excluded2);
  let location2 = useLocation();
  let path = useResolvedPath(to);
  let locationPathname = location2.pathname;
  let toPathname = path.pathname;
  if (!caseSensitive) {
    locationPathname = locationPathname.toLowerCase();
    toPathname = toPathname.toLowerCase();
  }
  let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(toPathname.length) === "/";
  let ariaCurrent = isActive ? ariaCurrentProp : void 0;
  let className;
  if (typeof classNameProp === "function") {
    className = classNameProp({
      isActive
    });
  } else {
    className = [classNameProp, isActive ? "active" : null].filter(Boolean).join(" ");
  }
  let style = typeof styleProp === "function" ? styleProp({
    isActive
  }) : styleProp;
  return /* @__PURE__ */ (0, import_react2.createElement)(Link, _extends2({}, rest, {
    "aria-current": ariaCurrent,
    className,
    ref,
    style,
    to
  }), typeof children === "function" ? children({
    isActive
  }) : children);
});
if (true) {
  NavLink.displayName = "NavLink";
}
function useLinkClickHandler(to, _temp) {
  let {
    target,
    replace: replaceProp,
    state
  } = _temp === void 0 ? {} : _temp;
  let navigate = useNavigate();
  let location2 = useLocation();
  let path = useResolvedPath(to);
  return (0, import_react2.useCallback)((event) => {
    if (event.button === 0 && (!target || target === "_self") && !isModifiedEvent(event)) {
      event.preventDefault();
      let replace = !!replaceProp || createPath(location2) === createPath(path);
      navigate(to, {
        replace,
        state
      });
    }
  }, [location2, navigate, path, replaceProp, state, target, to]);
}

// node_modules/@remix-run/server-runtime/esm/routeMatching.js
function matchServerRoutes(routes2, pathname) {
  let matches = matchRoutes(routes2, pathname);
  if (!matches)
    return null;
  return matches.map((match) => ({
    params: match.params,
    pathname: match.pathname,
    route: match.route
  }));
}

// node_modules/@remix-run/server-runtime/esm/mode.js
init_react();
var ServerMode;
(function(ServerMode2) {
  ServerMode2["Development"] = "development";
  ServerMode2["Production"] = "production";
  ServerMode2["Test"] = "test";
})(ServerMode || (ServerMode = {}));
function isServerMode(value) {
  return value === ServerMode.Development || value === ServerMode.Production || value === ServerMode.Test;
}

// node_modules/@remix-run/server-runtime/esm/routes.js
init_react();
function createRoutes(manifest, parentId) {
  return Object.keys(manifest).filter((key) => manifest[key].parentId === parentId).map((id) => __spreadProps(__spreadValues({}, manifest[id]), {
    children: createRoutes(manifest, id)
  }));
}

// node_modules/@remix-run/server-runtime/esm/serverHandoff.js
init_react();
var import_jsesc = __toESM(require_jsesc());
function createServerHandoffString(serverHandoff) {
  return (0, import_jsesc.default)(serverHandoff, {
    isScriptContext: true
  });
}

// node_modules/@remix-run/server-runtime/esm/server.js
function createRequestHandler(build, platform2, mode) {
  let routes2 = createRoutes(build.routes);
  let serverMode = isServerMode(mode) ? mode : ServerMode.Production;
  return async function requestHandler(request, loadContext) {
    let url = new URL(request.url);
    let matches = matchServerRoutes(routes2, url.pathname);
    let requestType = getRequestType(url, matches);
    let response;
    switch (requestType) {
      case "data":
        response = await handleDataRequest({
          request,
          loadContext,
          matches,
          handleDataRequest: build.entry.module.handleDataRequest,
          serverMode
        });
        break;
      case "document":
        response = await renderDocumentRequest({
          build,
          loadContext,
          matches,
          request,
          routes: routes2,
          serverMode
        });
        break;
      case "resource":
        response = await handleResourceRequest({
          request,
          loadContext,
          matches,
          serverMode
        });
        break;
    }
    if (request.method.toLowerCase() === "head") {
      return new Response(null, {
        headers: response.headers,
        status: response.status,
        statusText: response.statusText
      });
    }
    return response;
  };
}
async function handleDataRequest({
  handleDataRequest: handleDataRequest2,
  loadContext,
  matches,
  request,
  serverMode
}) {
  if (!isValidRequestMethod(request)) {
    return errorBoundaryError(new Error(`Invalid request method "${request.method}"`), 405);
  }
  let url = new URL(request.url);
  if (!matches) {
    return errorBoundaryError(new Error(`No route matches URL "${url.pathname}"`), 404);
  }
  let response;
  let match;
  try {
    if (isActionRequest(request)) {
      match = getActionRequestMatch(url, matches);
      response = await callRouteAction({
        loadContext,
        match,
        request
      });
    } else {
      let routeId = url.searchParams.get("_data");
      if (!routeId) {
        return errorBoundaryError(new Error(`Missing route id in ?_data`), 403);
      }
      let tempMatch = matches.find((match2) => match2.route.id === routeId);
      if (!tempMatch) {
        return errorBoundaryError(new Error(`Route "${routeId}" does not match URL "${url.pathname}"`), 403);
      }
      match = tempMatch;
      response = await callRouteLoader({
        loadContext,
        match,
        request
      });
    }
    if (isRedirectResponse(response)) {
      let headers = new Headers(response.headers);
      headers.set("X-Remix-Redirect", headers.get("Location"));
      headers.delete("Location");
      return new Response(null, {
        status: 204,
        headers
      });
    }
    if (handleDataRequest2) {
      response = await handleDataRequest2(response.clone(), {
        context: loadContext,
        params: match.params,
        request: request.clone()
      });
    }
    return response;
  } catch (error) {
    if (serverMode !== ServerMode.Test) {
      console.error(error);
    }
    if (serverMode === ServerMode.Development) {
      return errorBoundaryError(error, 500);
    }
    return errorBoundaryError(new Error("Unexpected Server Error"), 500);
  }
}
async function renderDocumentRequest({
  build,
  loadContext,
  matches,
  request,
  routes: routes2,
  serverMode
}) {
  let url = new URL(request.url);
  let appState = {
    trackBoundaries: true,
    trackCatchBoundaries: true,
    catchBoundaryRouteId: null,
    renderBoundaryRouteId: null,
    loaderBoundaryRouteId: null,
    error: void 0,
    catch: void 0
  };
  if (!isValidRequestMethod(request)) {
    matches = null;
    appState.trackCatchBoundaries = false;
    appState.catch = {
      data: null,
      status: 405,
      statusText: "Method Not Allowed"
    };
  } else if (!matches) {
    appState.trackCatchBoundaries = false;
    appState.catch = {
      data: null,
      status: 404,
      statusText: "Not Found"
    };
  }
  let actionStatus;
  let actionData;
  let actionMatch;
  let actionResponse;
  if (matches && isActionRequest(request)) {
    actionMatch = getActionRequestMatch(url, matches);
    try {
      actionResponse = await callRouteAction({
        loadContext,
        match: actionMatch,
        request
      });
      if (isRedirectResponse(actionResponse)) {
        return actionResponse;
      }
      actionStatus = {
        status: actionResponse.status,
        statusText: actionResponse.statusText
      };
      if (isCatchResponse(actionResponse)) {
        appState.catchBoundaryRouteId = getDeepestRouteIdWithBoundary(matches, "CatchBoundary");
        appState.trackCatchBoundaries = false;
        appState.catch = __spreadProps(__spreadValues({}, actionStatus), {
          data: await extractData(actionResponse)
        });
      } else {
        actionData = {
          [actionMatch.route.id]: await extractData(actionResponse)
        };
      }
    } catch (error) {
      appState.loaderBoundaryRouteId = getDeepestRouteIdWithBoundary(matches, "ErrorBoundary");
      appState.trackBoundaries = false;
      appState.error = await serializeError(error);
      if (serverMode !== ServerMode.Test) {
        console.error(`There was an error running the action for route ${actionMatch.route.id}`);
      }
    }
  }
  let routeModules = createEntryRouteModules(build.routes);
  let matchesToLoad = matches || [];
  if (appState.catch) {
    matchesToLoad = getMatchesUpToDeepestBoundary(matchesToLoad.slice(0, -1), "CatchBoundary");
  } else if (appState.error) {
    matchesToLoad = getMatchesUpToDeepestBoundary(matchesToLoad.slice(0, -1), "ErrorBoundary");
  }
  let routeLoaderResults = await Promise.allSettled(matchesToLoad.map((match) => match.route.module.loader ? callRouteLoader({
    loadContext,
    match,
    request
  }) : Promise.resolve(void 0)));
  let actionCatch = appState.catch;
  let actionError = appState.error;
  let actionCatchBoundaryRouteId = appState.catchBoundaryRouteId;
  let actionLoaderBoundaryRouteId = appState.loaderBoundaryRouteId;
  appState.catch = void 0;
  appState.error = void 0;
  let routeLoaderResponses = {};
  let loaderStatusCodes = [];
  let routeData = {};
  for (let index = 0; index < matchesToLoad.length; index++) {
    let match = matchesToLoad[index];
    let result = routeLoaderResults[index];
    let error = result.status === "rejected" ? result.reason : void 0;
    let response = result.status === "fulfilled" ? result.value : void 0;
    let isRedirect = response ? isRedirectResponse(response) : false;
    let isCatch = response ? isCatchResponse(response) : false;
    if (appState.catch || appState.error) {
      break;
    }
    if (!actionCatch && !actionError && response && isRedirect) {
      return response;
    }
    if (match.route.module.CatchBoundary) {
      appState.catchBoundaryRouteId = match.route.id;
    }
    if (match.route.module.ErrorBoundary) {
      appState.loaderBoundaryRouteId = match.route.id;
    }
    if (error) {
      loaderStatusCodes.push(500);
      appState.trackBoundaries = false;
      appState.error = await serializeError(error);
      if (serverMode !== ServerMode.Test) {
        console.error(`There was an error running the data loader for route ${match.route.id}`);
      }
      break;
    } else if (response) {
      routeLoaderResponses[match.route.id] = response;
      loaderStatusCodes.push(response.status);
      if (isCatch) {
        appState.trackCatchBoundaries = false;
        appState.catch = {
          data: await extractData(response),
          status: response.status,
          statusText: response.statusText
        };
        break;
      } else {
        routeData[match.route.id] = await extractData(response);
      }
    }
  }
  if (!appState.catch) {
    appState.catchBoundaryRouteId = actionCatchBoundaryRouteId;
  }
  if (!appState.error) {
    appState.loaderBoundaryRouteId = actionLoaderBoundaryRouteId;
  }
  appState.catch = actionCatch || appState.catch;
  appState.error = actionError || appState.error;
  let renderableMatches = getRenderableMatches(matches, appState);
  if (!renderableMatches) {
    renderableMatches = [];
    let root = routes2[0];
    if (root !== null && root !== void 0 && root.module.CatchBoundary) {
      appState.catchBoundaryRouteId = "root";
      renderableMatches.push({
        params: {},
        pathname: "",
        route: routes2[0]
      });
    }
  }
  let notOkResponse = actionStatus && actionStatus.status !== 200 ? actionStatus.status : loaderStatusCodes.find((status) => status !== 200);
  let responseStatusCode = appState.error ? 500 : typeof notOkResponse === "number" ? notOkResponse : appState.catch ? appState.catch.status : 200;
  let responseHeaders = getDocumentHeaders(build, renderableMatches, routeLoaderResponses, actionResponse);
  let entryMatches = createEntryMatches(renderableMatches, build.assets.routes);
  let serverHandoff = {
    actionData,
    appState,
    matches: entryMatches,
    routeData
  };
  let entryContext = __spreadProps(__spreadValues({}, serverHandoff), {
    manifest: build.assets,
    routeModules,
    serverHandoffString: createServerHandoffString(serverHandoff)
  });
  let handleDocumentRequest = build.entry.module.default;
  try {
    return await handleDocumentRequest(request.clone(), responseStatusCode, responseHeaders, entryContext);
  } catch (error) {
    responseStatusCode = 500;
    appState.trackBoundaries = false;
    appState.error = await serializeError(error);
    entryContext.serverHandoffString = createServerHandoffString(serverHandoff);
    try {
      return await handleDocumentRequest(request.clone(), responseStatusCode, responseHeaders, entryContext);
    } catch (error2) {
      if (serverMode !== ServerMode.Test) {
        console.error(error2);
      }
      let message = "Unexpected Server Error";
      if (serverMode === ServerMode.Development) {
        message += `

${String(error2)}`;
      }
      return new Response(message, {
        status: 500,
        headers: {
          "Content-Type": "text/plain"
        }
      });
    }
  }
}
async function handleResourceRequest({
  loadContext,
  matches,
  request,
  serverMode
}) {
  let match = matches.slice(-1)[0];
  try {
    if (isActionRequest(request)) {
      return await callRouteAction({
        match,
        loadContext,
        request
      });
    } else {
      return await callRouteLoader({
        match,
        loadContext,
        request
      });
    }
  } catch (error) {
    if (serverMode !== ServerMode.Test) {
      console.error(error);
    }
    let message = "Unexpected Server Error";
    if (serverMode === ServerMode.Development) {
      message += `

${String(error)}`;
    }
    return new Response(message, {
      status: 500,
      headers: {
        "Content-Type": "text/plain"
      }
    });
  }
}
function getRequestType(url, matches) {
  if (url.searchParams.has("_data")) {
    return "data";
  }
  if (!matches) {
    return "document";
  }
  let match = matches.slice(-1)[0];
  if (!match.route.module.default) {
    return "resource";
  }
  return "document";
}
function isActionRequest(request) {
  let method = request.method.toLowerCase();
  return method === "post" || method === "put" || method === "patch" || method === "delete";
}
function isHeadRequest(request) {
  return request.method.toLowerCase() === "head";
}
function isValidRequestMethod(request) {
  return request.method.toLowerCase() === "get" || isHeadRequest(request) || isActionRequest(request);
}
async function errorBoundaryError(error, status) {
  return json(await serializeError(error), {
    status,
    headers: {
      "X-Remix-Error": "yes"
    }
  });
}
function isIndexRequestUrl(url) {
  let indexRequest = false;
  for (let param of url.searchParams.getAll("index")) {
    if (!param) {
      indexRequest = true;
    }
  }
  return indexRequest;
}
function getActionRequestMatch(url, matches) {
  let match = matches.slice(-1)[0];
  if (!isIndexRequestUrl(url) && match.route.id.endsWith("/index")) {
    return matches.slice(-2)[0];
  }
  return match;
}
function getDeepestRouteIdWithBoundary(matches, key) {
  let matched = getMatchesUpToDeepestBoundary(matches, key).slice(-1)[0];
  return matched ? matched.route.id : null;
}
function getMatchesUpToDeepestBoundary(matches, key) {
  let deepestBoundaryIndex = -1;
  matches.forEach((match, index) => {
    if (match.route.module[key]) {
      deepestBoundaryIndex = index;
    }
  });
  if (deepestBoundaryIndex === -1) {
    return [];
  }
  return matches.slice(0, deepestBoundaryIndex + 1);
}
function getRenderableMatches(matches, appState) {
  if (!matches) {
    return null;
  }
  if (!appState.catch && !appState.error) {
    return matches;
  }
  let lastRenderableIndex = -1;
  matches.forEach((match, index) => {
    let id = match.route.id;
    if (appState.renderBoundaryRouteId === id || appState.loaderBoundaryRouteId === id || appState.catchBoundaryRouteId === id) {
      lastRenderableIndex = index;
    }
  });
  return matches.slice(0, lastRenderableIndex + 1);
}

// node_modules/@remix-run/cloudflare-pages/esm/worker.js
init_react();
function createRequestHandler2({
  build,
  getLoadContext,
  mode
}) {
  let platform2 = {};
  let handleRequest3 = createRequestHandler(build, platform2, mode);
  return (context) => {
    let loadContext = typeof getLoadContext === "function" ? getLoadContext(context) : void 0;
    return handleRequest3(context.request, loadContext);
  };
}
function createPagesFunctionHandler({
  build,
  getLoadContext,
  mode
}) {
  const handleRequest3 = createRequestHandler2({
    build,
    getLoadContext,
    mode
  });
  const handleFetch = async (context) => {
    let response;
    context.request.headers.delete("if-none-match");
    try {
      response = await context.env.ASSETS.fetch(context.request.url, context.request.clone());
      response = response && response.status >= 200 && response.status < 400 ? new Response(response.body, response) : void 0;
    } catch {
    }
    if (!response) {
      response = await handleRequest3(context);
    }
    return response;
  };
  return async (context) => {
    try {
      return await handleFetch(context);
    } catch (e) {
      if (e instanceof Error) {
        console.error(e);
        return new Response(e.message || e.toString(), {
          status: 500
        });
      }
      return new Response("Internal Error", {
        status: 500
      });
    }
  };
}

// node_modules/@remix-run/cloudflare-pages/esm/index.js
installGlobals();

// server-entry-module:@remix-run/dev/server-build
var server_build_exports = {};
__export(server_build_exports, {
  assets: () => assets_manifest_default,
  entry: () => entry,
  routes: () => routes
});
init_react();

// app/entry.server.tsx
var entry_server_exports = {};
__export(entry_server_exports, {
  default: () => handleRequest
});
init_react();
var import_server3 = __toESM(require_server());

// node_modules/remix/esm/index.js
init_react();

// node_modules/@remix-run/react/esm/index.js
init_react();

// node_modules/@remix-run/react/esm/components.js
init_react();

// node_modules/@remix-run/react/esm/_virtual/_rollupPluginBabelHelpers.js
init_react();
function _extends3() {
  _extends3 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends3.apply(this, arguments);
}

// node_modules/@remix-run/react/esm/components.js
var React3 = __toESM(require_react());

// node_modules/@remix-run/react/esm/errorBoundaries.js
init_react();
var import_react3 = __toESM(require_react());
var RemixErrorBoundary = class extends import_react3.default.Component {
  constructor(props) {
    super(props);
    this.state = {
      error: props.error || null,
      location: props.location
    };
  }
  static getDerivedStateFromError(error) {
    return {
      error
    };
  }
  static getDerivedStateFromProps(props, state) {
    if (state.location !== props.location) {
      return {
        error: props.error || null,
        location: props.location
      };
    }
    return {
      error: props.error || state.error,
      location: state.location
    };
  }
  render() {
    if (this.state.error) {
      return /* @__PURE__ */ import_react3.default.createElement(this.props.component, {
        error: this.state.error
      });
    } else {
      return this.props.children;
    }
  }
};
function RemixRootDefaultErrorBoundary({
  error
}) {
  console.error(error);
  return /* @__PURE__ */ import_react3.default.createElement("html", {
    lang: "en"
  }, /* @__PURE__ */ import_react3.default.createElement("head", null, /* @__PURE__ */ import_react3.default.createElement("meta", {
    charSet: "utf-8"
  }), /* @__PURE__ */ import_react3.default.createElement("meta", {
    name: "viewport",
    content: "width=device-width,initial-scale=1,viewport-fit=cover"
  }), /* @__PURE__ */ import_react3.default.createElement("title", null, "Application Error!")), /* @__PURE__ */ import_react3.default.createElement("body", null, /* @__PURE__ */ import_react3.default.createElement("main", {
    style: {
      fontFamily: "system-ui, sans-serif",
      padding: "2rem"
    }
  }, /* @__PURE__ */ import_react3.default.createElement("h1", {
    style: {
      fontSize: "24px"
    }
  }, "Application Error"), /* @__PURE__ */ import_react3.default.createElement("pre", {
    style: {
      padding: "2rem",
      background: "hsla(10, 50%, 50%, 0.1)",
      color: "red",
      overflow: "auto"
    }
  }, error.stack)), /* @__PURE__ */ import_react3.default.createElement("script", {
    dangerouslySetInnerHTML: {
      __html: `
              console.log(
                "\u{1F4BF} Hey developer\u{1F44B}. You can provide a way better UX than this when your app throws errors. Check out https://remix.run/guides/errors for more information."
              );
            `
    }
  })));
}
var RemixCatchContext = /* @__PURE__ */ import_react3.default.createContext(void 0);
function useCatch() {
  return (0, import_react3.useContext)(RemixCatchContext);
}
function RemixCatchBoundary({
  catch: catchVal,
  component: Component,
  children
}) {
  if (catchVal) {
    return /* @__PURE__ */ import_react3.default.createElement(RemixCatchContext.Provider, {
      value: catchVal
    }, /* @__PURE__ */ import_react3.default.createElement(Component, null));
  }
  return /* @__PURE__ */ import_react3.default.createElement(import_react3.default.Fragment, null, children);
}
function RemixRootDefaultCatchBoundary() {
  let caught = useCatch();
  return /* @__PURE__ */ import_react3.default.createElement("html", {
    lang: "en"
  }, /* @__PURE__ */ import_react3.default.createElement("head", null, /* @__PURE__ */ import_react3.default.createElement("meta", {
    charSet: "utf-8"
  }), /* @__PURE__ */ import_react3.default.createElement("meta", {
    name: "viewport",
    content: "width=device-width,initial-scale=1,viewport-fit=cover"
  }), /* @__PURE__ */ import_react3.default.createElement("title", null, "Unhandled Thrown Response!")), /* @__PURE__ */ import_react3.default.createElement("body", null, /* @__PURE__ */ import_react3.default.createElement("h1", {
    style: {
      fontFamily: "system-ui, sans-serif",
      padding: "2rem"
    }
  }, caught.status, " ", caught.statusText), /* @__PURE__ */ import_react3.default.createElement("script", {
    dangerouslySetInnerHTML: {
      __html: `
              console.log(
                "\u{1F4BF} Hey developer\u{1F44B}. You can provide a way better UX than this when your app throws 404s (and other responses). Check out https://remix.run/guides/not-found for more information."
              );
            `
    }
  })));
}

// node_modules/@remix-run/react/esm/invariant.js
init_react();
function invariant2(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}

// node_modules/@remix-run/react/esm/links.js
init_react();

// node_modules/@remix-run/react/esm/routeModules.js
init_react();
async function loadRouteModule(route, routeModulesCache) {
  if (route.id in routeModulesCache) {
    return routeModulesCache[route.id];
  }
  try {
    let routeModule = await import(route.module);
    routeModulesCache[route.id] = routeModule;
    return routeModule;
  } catch (error) {
    window.location.reload();
    return new Promise(() => {
    });
  }
}

// node_modules/@remix-run/react/esm/links.js
function getLinksForMatches(matches, routeModules, manifest) {
  let descriptors = matches.map((match) => {
    var _module$links;
    let module = routeModules[match.route.id];
    return ((_module$links = module.links) === null || _module$links === void 0 ? void 0 : _module$links.call(module)) || [];
  }).flat(1);
  let preloads = getCurrentPageModulePreloadHrefs(matches, manifest);
  return dedupe(descriptors, preloads);
}
async function prefetchStyleLinks(routeModule) {
  if (!routeModule.links)
    return;
  let descriptors = routeModule.links();
  if (!descriptors)
    return;
  let styleLinks = [];
  for (let descriptor of descriptors) {
    if (!isPageLinkDescriptor(descriptor) && descriptor.rel === "stylesheet") {
      styleLinks.push(__spreadProps(__spreadValues({}, descriptor), {
        rel: "preload",
        as: "style"
      }));
    }
  }
  let matchingLinks = styleLinks.filter((link) => !link.media || window.matchMedia(link.media).matches);
  await Promise.all(matchingLinks.map(prefetchStyleLink));
}
async function prefetchStyleLink(descriptor) {
  return new Promise((resolve) => {
    let link = document.createElement("link");
    Object.assign(link, descriptor);
    function removeLink() {
      if (document.head.contains(link)) {
        document.head.removeChild(link);
      }
    }
    link.onload = () => {
      removeLink();
      resolve();
    };
    link.onerror = () => {
      removeLink();
      resolve();
    };
    document.head.appendChild(link);
  });
}
function isPageLinkDescriptor(object) {
  return object != null && typeof object.page === "string";
}
function isHtmlLinkDescriptor(object) {
  return object != null && typeof object.rel === "string" && typeof object.href === "string";
}
async function getStylesheetPrefetchLinks(matches, routeModules) {
  let links2 = await Promise.all(matches.map(async (match) => {
    let mod = await loadRouteModule(match.route, routeModules);
    return mod.links ? mod.links() : [];
  }));
  return links2.flat(1).filter(isHtmlLinkDescriptor).filter((link) => link.rel === "stylesheet" || link.rel === "preload").map((_a) => {
    var _b = _a, {
      rel
    } = _b, attrs = __objRest(_b, [
      "rel"
    ]);
    return rel === "preload" ? __spreadValues({
      rel: "prefetch"
    }, attrs) : __spreadValues({
      rel: "prefetch",
      as: "style"
    }, attrs);
  });
}
function getNewMatchesForLinks(page, nextMatches, currentMatches, location2, mode) {
  let path = parsePathPatch(page);
  let isNew = (match, index) => {
    if (!currentMatches[index])
      return true;
    return match.route.id !== currentMatches[index].route.id;
  };
  let matchPathChanged = (match, index) => {
    var _currentMatches$index;
    return currentMatches[index].pathname !== match.pathname || ((_currentMatches$index = currentMatches[index].route.path) === null || _currentMatches$index === void 0 ? void 0 : _currentMatches$index.endsWith("*")) && currentMatches[index].params["*"] !== match.params["*"];
  };
  let newMatches = mode === "data" && location2.search !== path.search ? nextMatches.filter((match, index) => {
    if (!match.route.hasLoader) {
      return false;
    }
    if (isNew(match, index) || matchPathChanged(match, index)) {
      return true;
    }
    if (match.route.shouldReload) {
      return match.route.shouldReload({
        params: match.params,
        prevUrl: new URL(location2.pathname + location2.search + location2.hash, window.origin),
        url: new URL(page, window.origin)
      });
    }
    return true;
  }) : nextMatches.filter((match, index) => {
    return match.route.hasLoader && (isNew(match, index) || matchPathChanged(match, index));
  });
  return newMatches;
}
function getDataLinkHrefs(page, matches, manifest) {
  let path = parsePathPatch(page);
  return dedupeHrefs(matches.filter((match) => manifest.routes[match.route.id].hasLoader).map((match) => {
    let {
      pathname,
      search
    } = path;
    let searchParams = new URLSearchParams(search);
    searchParams.set("_data", match.route.id);
    return `${pathname}?${searchParams}`;
  }));
}
function getModuleLinkHrefs(matches, manifestPatch) {
  return dedupeHrefs(matches.map((match) => {
    let route = manifestPatch.routes[match.route.id];
    let hrefs = [route.module];
    if (route.imports) {
      hrefs = hrefs.concat(route.imports);
    }
    return hrefs;
  }).flat(1));
}
function getCurrentPageModulePreloadHrefs(matches, manifest) {
  return dedupeHrefs(matches.map((match) => {
    let route = manifest.routes[match.route.id];
    let hrefs = [route.module];
    if (route.imports) {
      hrefs = hrefs.concat(route.imports);
    }
    return hrefs;
  }).flat(1));
}
function dedupeHrefs(hrefs) {
  return [...new Set(hrefs)];
}
function dedupe(descriptors, preloads) {
  let set = /* @__PURE__ */ new Set();
  let preloadsSet = new Set(preloads);
  return descriptors.reduce((deduped, descriptor) => {
    let alreadyModulePreload = !isPageLinkDescriptor(descriptor) && descriptor.as === "script" && descriptor.href && preloadsSet.has(descriptor.href);
    if (alreadyModulePreload) {
      return deduped;
    }
    let str = JSON.stringify(descriptor);
    if (!set.has(str)) {
      set.add(str);
      deduped.push(descriptor);
    }
    return deduped;
  }, []);
}
function parsePathPatch(href) {
  let path = parsePath(href);
  if (path.search === void 0)
    path.search = "";
  return path;
}

// node_modules/@remix-run/react/esm/markup.js
init_react();
function createHtml(html) {
  return {
    __html: html
  };
}

// node_modules/@remix-run/react/esm/routes.js
init_react();
var React2 = __toESM(require_react());

// node_modules/@remix-run/react/esm/data.js
init_react();
function isCatchResponse2(response) {
  return response instanceof Response && response.headers.get("X-Remix-Catch") != null;
}
function isErrorResponse(response) {
  return response instanceof Response && response.headers.get("X-Remix-Error") != null;
}
function isRedirectResponse2(response) {
  return response instanceof Response && response.headers.get("X-Remix-Redirect") != null;
}
async function fetchData(url, routeId, signal, submission) {
  url.searchParams.set("_data", routeId);
  let init2 = submission ? getActionInit(submission, signal) : {
    credentials: "same-origin",
    signal
  };
  let response = await fetch(url.href, init2);
  if (isErrorResponse(response)) {
    let data = await response.json();
    let error = new Error(data.message);
    error.stack = data.stack;
    return error;
  }
  return response;
}
async function extractData2(response) {
  let contentType = response.headers.get("Content-Type");
  if (contentType && /\bapplication\/json\b/.test(contentType)) {
    return response.json();
  }
  return response.text();
}
function getActionInit(submission, signal) {
  let {
    encType,
    method,
    formData
  } = submission;
  let headers = void 0;
  let body = formData;
  if (encType === "application/x-www-form-urlencoded") {
    body = new URLSearchParams();
    for (let [key, value] of formData) {
      invariant2(typeof value === "string", `File inputs are not supported with encType "application/x-www-form-urlencoded", please use "multipart/form-data" instead.`);
      body.append(key, value);
    }
    headers = {
      "Content-Type": encType
    };
  }
  return {
    method,
    body,
    signal,
    credentials: "same-origin",
    headers
  };
}

// node_modules/@remix-run/react/esm/transition.js
init_react();

// node_modules/@remix-run/react/esm/routeMatching.js
init_react();
function matchClientRoutes(routes2, location2) {
  let matches = matchRoutes(routes2, location2);
  if (!matches)
    return null;
  return matches.map((match) => ({
    params: match.params,
    pathname: match.pathname,
    route: match.route
  }));
}

// node_modules/@remix-run/react/esm/transition.js
var CatchValue = class {
  constructor(status, statusText, data) {
    this.status = status;
    this.statusText = statusText;
    this.data = data;
  }
};
function isActionSubmission(submission) {
  return ["POST", "PUT", "PATCH", "DELETE"].includes(submission.method);
}
function isLoaderSubmission(submission) {
  return submission.method === "GET";
}
function isRedirectLocation(location2) {
  return Boolean(location2.state) && location2.state.isRedirect;
}
function isLoaderRedirectLocation(location2) {
  return isRedirectLocation(location2) && location2.state.type === "loader";
}
function isActionRedirectLocation(location2) {
  return isRedirectLocation(location2) && location2.state.type === "action";
}
function isFetchActionRedirect(location2) {
  return isRedirectLocation(location2) && location2.state.type === "fetchAction";
}
function isLoaderSubmissionRedirectLocation(location2) {
  return isRedirectLocation(location2) && location2.state.type === "loaderSubmission";
}
var TransitionRedirect = class {
  constructor(location2) {
    this.location = typeof location2 === "string" ? location2 : location2.pathname + location2.search;
  }
};
var IDLE_TRANSITION = {
  state: "idle",
  submission: void 0,
  location: void 0,
  type: "idle"
};
var IDLE_FETCHER = {
  state: "idle",
  type: "init",
  data: void 0,
  submission: void 0
};
function createTransitionManager(init2) {
  let {
    routes: routes2
  } = init2;
  let pendingNavigationController;
  let fetchControllers = /* @__PURE__ */ new Map();
  let incrementingLoadId = 0;
  let navigationLoadId = -1;
  let fetchReloadIds = /* @__PURE__ */ new Map();
  let matches = matchClientRoutes(routes2, init2.location);
  if (!matches) {
    matches = [{
      params: {},
      pathname: "",
      route: routes2[0]
    }];
  }
  let state = {
    location: init2.location,
    loaderData: init2.loaderData || {},
    actionData: init2.actionData,
    catch: init2.catch,
    error: init2.error,
    catchBoundaryId: init2.catchBoundaryId || null,
    errorBoundaryId: init2.errorBoundaryId || null,
    matches,
    nextMatches: void 0,
    transition: IDLE_TRANSITION,
    fetchers: /* @__PURE__ */ new Map()
  };
  function update(updates) {
    state = Object.assign({}, state, updates);
    init2.onChange(state);
  }
  function getState() {
    return state;
  }
  function getFetcher(key) {
    return state.fetchers.get(key) || IDLE_FETCHER;
  }
  function deleteFetcher(key) {
    if (fetchControllers.has(key))
      abortFetcher(key);
    fetchReloadIds.delete(key);
    state.fetchers.delete(key);
  }
  async function send(event) {
    switch (event.type) {
      case "navigation": {
        let {
          action,
          location: location2,
          submission
        } = event;
        let matches2 = matchClientRoutes(routes2, location2);
        if (!matches2) {
          matches2 = [{
            params: {},
            pathname: "",
            route: routes2[0]
          }];
          await handleNotFoundNavigation(location2, matches2);
        } else if (!submission && isHashChangeOnly(location2)) {
          await handleHashChange(location2, matches2);
        } else if (action === Action.Pop) {
          await handleLoad(location2, matches2);
        } else if (submission && isActionSubmission(submission)) {
          await handleActionSubmissionNavigation(location2, submission, matches2);
        } else if (submission && isLoaderSubmission(submission)) {
          await handleLoaderSubmissionNavigation(location2, submission, matches2);
        } else if (isActionRedirectLocation(location2)) {
          await handleActionRedirect(location2, matches2);
        } else if (isLoaderSubmissionRedirectLocation(location2)) {
          await handleLoaderSubmissionRedirect(location2, matches2);
        } else if (isLoaderRedirectLocation(location2)) {
          await handleLoaderRedirect(location2, matches2);
        } else if (isFetchActionRedirect(location2)) {
          await handleFetchActionRedirect(location2, matches2);
        } else {
          await handleLoad(location2, matches2);
        }
        navigationLoadId = -1;
        break;
      }
      case "fetcher": {
        let {
          key,
          submission,
          href
        } = event;
        let matches2 = matchClientRoutes(routes2, href);
        invariant2(matches2, "No matches found");
        let match = matches2.slice(-1)[0];
        if (fetchControllers.has(key))
          abortFetcher(key);
        if (submission && isActionSubmission(submission)) {
          await handleActionFetchSubmission(key, submission, match);
        } else if (submission && isLoaderSubmission(submission)) {
          await handleLoaderFetchSubmission(href, key, submission, match);
        } else {
          await handleLoaderFetch(href, key, match);
        }
        break;
      }
      default: {
        throw new Error(`Unknown data event type: ${event.type}`);
      }
    }
  }
  function dispose() {
    abortNormalNavigation();
    for (let [, controller] of fetchControllers) {
      controller.abort();
    }
  }
  async function handleActionFetchSubmission(key, submission, match) {
    let currentFetcher = state.fetchers.get(key);
    let fetcher = {
      state: "submitting",
      type: "actionSubmission",
      submission,
      data: (currentFetcher === null || currentFetcher === void 0 ? void 0 : currentFetcher.data) || void 0
    };
    state.fetchers.set(key, fetcher);
    update({
      fetchers: new Map(state.fetchers)
    });
    let controller = new AbortController();
    fetchControllers.set(key, controller);
    let result = await callAction(submission, match, controller.signal);
    if (controller.signal.aborted) {
      return;
    }
    if (isRedirectResult(result)) {
      let locationState = {
        isRedirect: true,
        type: "fetchAction"
      };
      init2.onRedirect(result.value.location, locationState);
      let doneFetcher2 = {
        state: "idle",
        type: "done",
        data: result.value,
        submission: void 0
      };
      state.fetchers.set(key, doneFetcher2);
      update({
        fetchers: new Map(state.fetchers)
      });
      return;
    }
    if (maybeBailOnError(match, key, result)) {
      return;
    }
    if (await maybeBailOnCatch(match, key, result)) {
      return;
    }
    let loadFetcher = {
      state: "loading",
      type: "actionReload",
      data: result.value,
      submission
    };
    state.fetchers.set(key, loadFetcher);
    update({
      fetchers: new Map(state.fetchers)
    });
    let maybeActionErrorResult = isErrorResult(result) ? result : void 0;
    let maybeActionCatchResult = isCatchResult(result) ? result : void 0;
    let loadId = ++incrementingLoadId;
    fetchReloadIds.set(key, loadId);
    let matchesToLoad = state.nextMatches || state.matches;
    let hrefToLoad = createHref(state.transition.location || state.location);
    let results = await callLoaders(state, createUrl(hrefToLoad), matchesToLoad, controller.signal, maybeActionErrorResult, maybeActionCatchResult, submission, match.route.id, loadFetcher);
    if (controller.signal.aborted) {
      return;
    }
    fetchReloadIds.delete(key);
    fetchControllers.delete(key);
    let redirect = findRedirect(results);
    if (redirect) {
      let locationState = {
        isRedirect: true,
        type: "loader"
      };
      init2.onRedirect(redirect.location, locationState);
      return;
    }
    let [error, errorBoundaryId] = findErrorAndBoundaryId(results, state.matches, maybeActionErrorResult);
    let [catchVal, catchBoundaryId] = await findCatchAndBoundaryId(results, state.matches, maybeActionCatchResult);
    let doneFetcher = {
      state: "idle",
      type: "done",
      data: result.value,
      submission: void 0
    };
    state.fetchers.set(key, doneFetcher);
    let abortedKeys = abortStaleFetchLoads(loadId);
    if (abortedKeys) {
      markFetchersDone(abortedKeys);
    }
    let yeetedNavigation = yeetStaleNavigationLoad(loadId);
    if (yeetedNavigation) {
      let {
        transition
      } = state;
      invariant2(transition.state === "loading", "Expected loading transition");
      update({
        location: transition.location,
        matches: state.nextMatches,
        error,
        errorBoundaryId,
        catch: catchVal,
        catchBoundaryId,
        loaderData: makeLoaderData(state, results, matchesToLoad),
        actionData: transition.type === "actionReload" ? state.actionData : void 0,
        transition: IDLE_TRANSITION,
        fetchers: new Map(state.fetchers)
      });
    } else {
      update({
        fetchers: new Map(state.fetchers),
        error,
        errorBoundaryId,
        loaderData: makeLoaderData(state, results, matchesToLoad)
      });
    }
  }
  function yeetStaleNavigationLoad(landedId) {
    let isLoadingNavigation = state.transition.state === "loading";
    if (isLoadingNavigation && navigationLoadId < landedId) {
      abortNormalNavigation();
      return true;
    }
    return false;
  }
  function markFetchersDone(keys2) {
    for (let key of keys2) {
      let fetcher = getFetcher(key);
      let doneFetcher = {
        state: "idle",
        type: "done",
        data: fetcher.data,
        submission: void 0
      };
      state.fetchers.set(key, doneFetcher);
    }
  }
  function abortStaleFetchLoads(landedId) {
    let yeetedKeys = [];
    for (let [key, id] of fetchReloadIds) {
      if (id < landedId) {
        let fetcher = state.fetchers.get(key);
        invariant2(fetcher, `Expected fetcher: ${key}`);
        if (fetcher.state === "loading") {
          abortFetcher(key);
          fetchReloadIds.delete(key);
          yeetedKeys.push(key);
        }
      }
    }
    return yeetedKeys.length ? yeetedKeys : false;
  }
  async function handleLoaderFetchSubmission(href, key, submission, match) {
    let currentFetcher = state.fetchers.get(key);
    let fetcher = {
      state: "submitting",
      type: "loaderSubmission",
      submission,
      data: (currentFetcher === null || currentFetcher === void 0 ? void 0 : currentFetcher.data) || void 0
    };
    state.fetchers.set(key, fetcher);
    update({
      fetchers: new Map(state.fetchers)
    });
    let controller = new AbortController();
    fetchControllers.set(key, controller);
    let result = await callLoader(match, createUrl(href), controller.signal);
    fetchControllers.delete(key);
    if (controller.signal.aborted) {
      return;
    }
    if (isRedirectResult(result)) {
      let locationState = {
        isRedirect: true,
        type: "loader"
      };
      init2.onRedirect(result.value.location, locationState);
      return;
    }
    if (maybeBailOnError(match, key, result)) {
      return;
    }
    if (await maybeBailOnCatch(match, key, result)) {
      return;
    }
    let doneFetcher = {
      state: "idle",
      type: "done",
      data: result.value,
      submission: void 0
    };
    state.fetchers.set(key, doneFetcher);
    update({
      fetchers: new Map(state.fetchers)
    });
  }
  async function handleLoaderFetch(href, key, match) {
    if (typeof AbortController === "undefined") {
      throw new Error("handleLoaderFetch was called during the server render, but it shouldn't be. You are likely calling useFetcher.load() in the body of your component. Try moving it to a useEffect or a callback.");
    }
    let currentFetcher = state.fetchers.get(key);
    let fetcher = {
      state: "loading",
      type: "normalLoad",
      submission: void 0,
      data: (currentFetcher === null || currentFetcher === void 0 ? void 0 : currentFetcher.data) || void 0
    };
    state.fetchers.set(key, fetcher);
    update({
      fetchers: new Map(state.fetchers)
    });
    let controller = new AbortController();
    fetchControllers.set(key, controller);
    let result = await callLoader(match, createUrl(href), controller.signal);
    if (controller.signal.aborted)
      return;
    fetchControllers.delete(key);
    if (isRedirectResult(result)) {
      let locationState = {
        isRedirect: true,
        type: "loader"
      };
      init2.onRedirect(result.value.location, locationState);
      return;
    }
    if (maybeBailOnError(match, key, result)) {
      return;
    }
    if (await maybeBailOnCatch(match, key, result)) {
      return;
    }
    let doneFetcher = {
      state: "idle",
      type: "done",
      data: result.value,
      submission: void 0
    };
    state.fetchers.set(key, doneFetcher);
    update({
      fetchers: new Map(state.fetchers)
    });
  }
  async function maybeBailOnCatch(match, key, result) {
    if (isCatchResult(result)) {
      let catchBoundaryId = findNearestCatchBoundary(match, state.matches);
      state.fetchers.delete(key);
      update({
        transition: IDLE_TRANSITION,
        fetchers: new Map(state.fetchers),
        catch: {
          data: result.value.data,
          status: result.value.status,
          statusText: result.value.statusText
        },
        catchBoundaryId
      });
      return true;
    }
    return false;
  }
  function maybeBailOnError(match, key, result) {
    if (isErrorResult(result)) {
      let errorBoundaryId = findNearestBoundary(match, state.matches);
      state.fetchers.delete(key);
      update({
        fetchers: new Map(state.fetchers),
        error: result.value,
        errorBoundaryId
      });
      return true;
    }
    return false;
  }
  async function handleNotFoundNavigation(location2, matches2) {
    abortNormalNavigation();
    let transition = {
      state: "loading",
      type: "normalLoad",
      submission: void 0,
      location: location2
    };
    update({
      transition,
      nextMatches: matches2
    });
    await Promise.resolve();
    let catchBoundaryId = findNearestCatchBoundary(matches2[0], matches2);
    update({
      location: location2,
      matches: matches2,
      catch: {
        data: null,
        status: 404,
        statusText: "Not Found"
      },
      catchBoundaryId,
      transition: IDLE_TRANSITION
    });
  }
  async function handleActionSubmissionNavigation(location2, submission, matches2) {
    abortNormalNavigation();
    let transition = {
      state: "submitting",
      type: "actionSubmission",
      submission,
      location: location2
    };
    update({
      transition,
      nextMatches: matches2
    });
    let controller = new AbortController();
    pendingNavigationController = controller;
    if (!isIndexRequestAction(submission.action) && matches2[matches2.length - 1].route.id.endsWith("/index")) {
      matches2 = matches2.slice(0, -1);
    }
    let leafMatch = matches2.slice(-1)[0];
    let result = await callAction(submission, leafMatch, controller.signal);
    if (controller.signal.aborted) {
      return;
    }
    if (isRedirectResult(result)) {
      let locationState = {
        isRedirect: true,
        type: "action"
      };
      init2.onRedirect(result.value.location, locationState);
      return;
    }
    if (isCatchResult(result)) {
      let [catchVal, catchBoundaryId] = await findCatchAndBoundaryId([result], matches2, result);
      update({
        transition: IDLE_TRANSITION,
        catch: catchVal,
        catchBoundaryId
      });
      return;
    }
    let loadTransition = {
      state: "loading",
      type: "actionReload",
      submission,
      location: location2
    };
    update({
      transition: loadTransition,
      actionData: {
        [leafMatch.route.id]: result.value
      }
    });
    await loadPageData(location2, matches2, submission, leafMatch.route.id, result);
  }
  async function handleLoaderSubmissionNavigation(location2, submission, matches2) {
    abortNormalNavigation();
    let transition = {
      state: "submitting",
      type: "loaderSubmission",
      submission,
      location: location2
    };
    update({
      transition,
      nextMatches: matches2
    });
    await loadPageData(location2, matches2, submission);
  }
  async function handleHashChange(location2, matches2) {
    abortNormalNavigation();
    let transition = {
      state: "loading",
      type: "normalLoad",
      submission: void 0,
      location: location2
    };
    update({
      transition,
      nextMatches: matches2
    });
    await Promise.resolve();
    update({
      location: location2,
      matches: matches2,
      transition: IDLE_TRANSITION
    });
  }
  async function handleLoad(location2, matches2) {
    abortNormalNavigation();
    let transition = {
      state: "loading",
      type: "normalLoad",
      submission: void 0,
      location: location2
    };
    update({
      transition,
      nextMatches: matches2
    });
    await loadPageData(location2, matches2);
  }
  async function handleLoaderRedirect(location2, matches2) {
    abortNormalNavigation();
    let transition = {
      state: "loading",
      type: "normalRedirect",
      submission: void 0,
      location: location2
    };
    update({
      transition,
      nextMatches: matches2
    });
    await loadPageData(location2, matches2);
  }
  async function handleLoaderSubmissionRedirect(location2, matches2) {
    abortNormalNavigation();
    invariant2(state.transition.type === "loaderSubmission", `Unexpected transition: ${JSON.stringify(state.transition)}`);
    let {
      submission
    } = state.transition;
    let transition = {
      state: "loading",
      type: "loaderSubmissionRedirect",
      submission,
      location: location2
    };
    update({
      transition,
      nextMatches: matches2
    });
    await loadPageData(location2, matches2, submission);
  }
  async function handleFetchActionRedirect(location2, matches2) {
    abortNormalNavigation();
    let transition = {
      state: "loading",
      type: "fetchActionRedirect",
      submission: void 0,
      location: location2
    };
    update({
      transition,
      nextMatches: matches2
    });
    await loadPageData(location2, matches2);
  }
  async function handleActionRedirect(location2, matches2) {
    abortNormalNavigation();
    invariant2(state.transition.type === "actionSubmission" || state.transition.type === "actionReload", `Unexpected transition: ${JSON.stringify(state.transition)}`);
    let {
      submission
    } = state.transition;
    let transition = {
      state: "loading",
      type: "actionRedirect",
      submission,
      location: location2
    };
    update({
      transition,
      nextMatches: matches2
    });
    await loadPageData(location2, matches2, submission);
  }
  function isHashChangeOnly(location2) {
    return createHref(state.location) === createHref(location2) && state.location.hash !== location2.hash;
  }
  async function loadPageData(location2, matches2, submission, submissionRouteId, actionResult) {
    let maybeActionErrorResult = actionResult && isErrorResult(actionResult) ? actionResult : void 0;
    let maybeActionCatchResult = actionResult && isCatchResult(actionResult) ? actionResult : void 0;
    let controller = new AbortController();
    pendingNavigationController = controller;
    navigationLoadId = ++incrementingLoadId;
    let results = await callLoaders(state, createUrl(createHref(location2)), matches2, controller.signal, maybeActionErrorResult, maybeActionCatchResult, submission, submissionRouteId);
    if (controller.signal.aborted) {
      return;
    }
    let redirect = findRedirect(results);
    if (redirect) {
      if (state.transition.type === "actionReload") {
        let locationState = {
          isRedirect: true,
          type: "action"
        };
        init2.onRedirect(redirect.location, locationState);
      } else if (state.transition.type === "loaderSubmission") {
        let locationState = {
          isRedirect: true,
          type: "loaderSubmission"
        };
        init2.onRedirect(redirect.location, locationState);
      } else {
        let locationState = {
          isRedirect: true,
          type: "loader"
        };
        init2.onRedirect(redirect.location, locationState);
      }
      return;
    }
    let [error, errorBoundaryId] = findErrorAndBoundaryId(results, matches2, maybeActionErrorResult);
    let [catchVal, catchBoundaryId] = await findCatchAndBoundaryId(results, matches2, maybeActionErrorResult);
    let abortedIds = abortStaleFetchLoads(navigationLoadId);
    if (abortedIds) {
      markFetchersDone(abortedIds);
    }
    update({
      location: location2,
      matches: matches2,
      error,
      errorBoundaryId,
      catch: catchVal,
      catchBoundaryId,
      loaderData: makeLoaderData(state, results, matches2),
      actionData: state.transition.type === "actionReload" ? state.actionData : void 0,
      transition: IDLE_TRANSITION,
      fetchers: abortedIds ? new Map(state.fetchers) : state.fetchers
    });
  }
  function abortNormalNavigation() {
    var _pendingNavigationCon;
    (_pendingNavigationCon = pendingNavigationController) === null || _pendingNavigationCon === void 0 ? void 0 : _pendingNavigationCon.abort();
  }
  function abortFetcher(key) {
    let controller = fetchControllers.get(key);
    invariant2(controller, `Expected fetch controller: ${key}`);
    controller.abort();
    fetchControllers.delete(key);
  }
  return {
    send,
    getState,
    getFetcher,
    deleteFetcher,
    dispose,
    get _internalFetchControllers() {
      return fetchControllers;
    }
  };
}
function isIndexRequestAction(action) {
  let indexRequest = false;
  let searchParams = new URLSearchParams(action.split("?", 2)[1] || "");
  for (let param of searchParams.getAll("index")) {
    if (!param) {
      indexRequest = true;
    }
  }
  return indexRequest;
}
async function callLoaders(state, url, matches, signal, actionErrorResult, actionCatchResult, submission, submissionRouteId, fetcher) {
  let matchesToLoad = filterMatchesToLoad(state, url, matches, actionErrorResult, actionCatchResult, submission, submissionRouteId, fetcher);
  return Promise.all(matchesToLoad.map((match) => callLoader(match, url, signal)));
}
async function callLoader(match, url, signal) {
  invariant2(match.route.loader, `Expected loader for ${match.route.id}`);
  try {
    let {
      params
    } = match;
    let value = await match.route.loader({
      params,
      url,
      signal
    });
    return {
      match,
      value
    };
  } catch (error) {
    return {
      match,
      value: error
    };
  }
}
async function callAction(submission, match, signal) {
  if (!match.route.action) {
    throw new Error(`Route "${match.route.id}" does not have an action, but you are trying to submit to it. To fix this, please add an \`action\` function to the route`);
  }
  try {
    let value = await match.route.action({
      url: createUrl(submission.action),
      params: match.params,
      submission,
      signal
    });
    return {
      match,
      value
    };
  } catch (error) {
    return {
      match,
      value: error
    };
  }
}
function filterMatchesToLoad(state, url, matches, actionErrorResult, actionCatchResult, submission, submissionRouteId, fetcher) {
  if (submissionRouteId && (actionCatchResult || actionErrorResult)) {
    let foundProblematicRoute = false;
    matches = matches.filter((match) => {
      if (foundProblematicRoute) {
        return false;
      }
      if (match.route.id === submissionRouteId) {
        foundProblematicRoute = true;
        return false;
      }
      return true;
    });
  }
  let isNew = (match, index) => {
    if (!state.matches[index])
      return true;
    return match.route.id !== state.matches[index].route.id;
  };
  let matchPathChanged = (match, index) => {
    var _state$matches$index$;
    return state.matches[index].pathname !== match.pathname || ((_state$matches$index$ = state.matches[index].route.path) === null || _state$matches$index$ === void 0 ? void 0 : _state$matches$index$.endsWith("*")) && state.matches[index].params["*"] !== match.params["*"];
  };
  let filterByRouteProps = (match, index) => {
    if (!match.route.loader) {
      return false;
    }
    if (isNew(match, index) || matchPathChanged(match, index)) {
      return true;
    }
    if (match.route.shouldReload) {
      let prevUrl = createUrl(createHref(state.location));
      return match.route.shouldReload({
        prevUrl,
        url,
        submission,
        params: match.params
      });
    }
    return true;
  };
  let isInRootCatchBoundary = state.matches.length === 1;
  if (isInRootCatchBoundary) {
    return matches.filter((match) => !!match.route.loader);
  }
  if ((fetcher === null || fetcher === void 0 ? void 0 : fetcher.type) === "actionReload") {
    return matches.filter(filterByRouteProps);
  } else if (state.transition.type === "actionReload" || state.transition.type === "actionRedirect" || createHref(url) === createHref(state.location) || url.searchParams.toString() !== state.location.search.substring(1)) {
    return matches.filter(filterByRouteProps);
  }
  return matches.filter((match, index, arr) => {
    if ((actionErrorResult || actionCatchResult) && arr.length - 1 === index) {
      return false;
    }
    return match.route.loader && (isNew(match, index) || matchPathChanged(match, index));
  });
}
function isRedirectResult(result) {
  return result.value instanceof TransitionRedirect;
}
function createHref(location2) {
  return location2.pathname + location2.search;
}
function findRedirect(results) {
  for (let result of results) {
    if (isRedirectResult(result)) {
      return result.value;
    }
  }
  return null;
}
async function findCatchAndBoundaryId(results, matches, actionCatchResult) {
  let loaderCatchResult;
  for (let result of results) {
    if (isCatchResult(result)) {
      loaderCatchResult = result;
      break;
    }
  }
  let extractCatchData = async (res) => ({
    status: res.status,
    statusText: res.statusText,
    data: res.data
  });
  if (actionCatchResult && loaderCatchResult) {
    let boundaryId = findNearestCatchBoundary(loaderCatchResult.match, matches);
    return [await extractCatchData(actionCatchResult.value), boundaryId];
  }
  if (loaderCatchResult) {
    let boundaryId = findNearestCatchBoundary(loaderCatchResult.match, matches);
    return [await extractCatchData(loaderCatchResult.value), boundaryId];
  }
  return [void 0, void 0];
}
function findErrorAndBoundaryId(results, matches, actionErrorResult) {
  let loaderErrorResult;
  for (let result of results) {
    if (isErrorResult(result)) {
      loaderErrorResult = result;
      break;
    }
  }
  if (actionErrorResult && loaderErrorResult) {
    let boundaryId = findNearestBoundary(loaderErrorResult.match, matches);
    return [actionErrorResult.value, boundaryId];
  }
  if (actionErrorResult) {
    let boundaryId = findNearestBoundary(actionErrorResult.match, matches);
    return [actionErrorResult.value, boundaryId];
  }
  if (loaderErrorResult) {
    let boundaryId = findNearestBoundary(loaderErrorResult.match, matches);
    return [loaderErrorResult.value, boundaryId];
  }
  return [void 0, void 0];
}
function findNearestCatchBoundary(matchWithError, matches) {
  let nearestBoundaryId = null;
  for (let match of matches) {
    if (match.route.CatchBoundary) {
      nearestBoundaryId = match.route.id;
    }
    if (match === matchWithError) {
      break;
    }
  }
  return nearestBoundaryId;
}
function findNearestBoundary(matchWithError, matches) {
  let nearestBoundaryId = null;
  for (let match of matches) {
    if (match.route.ErrorBoundary) {
      nearestBoundaryId = match.route.id;
    }
    if (match === matchWithError) {
      break;
    }
  }
  return nearestBoundaryId;
}
function makeLoaderData(state, results, matches) {
  let newData = {};
  for (let {
    match,
    value
  } of results) {
    newData[match.route.id] = value;
  }
  let loaderData = {};
  for (let {
    route
  } of matches) {
    let value = newData[route.id] !== void 0 ? newData[route.id] : state.loaderData[route.id];
    if (value !== void 0) {
      loaderData[route.id] = value;
    }
  }
  return loaderData;
}
function isCatchResult(result) {
  return result.value instanceof CatchValue;
}
function isErrorResult(result) {
  return result.value instanceof Error;
}
function createUrl(href) {
  return new URL(href, window.location.origin);
}

// node_modules/@remix-run/react/esm/routes.js
function createClientRoute(entryRoute, routeModulesCache, Component) {
  return {
    caseSensitive: !!entryRoute.caseSensitive,
    element: /* @__PURE__ */ React2.createElement(Component, {
      id: entryRoute.id
    }),
    id: entryRoute.id,
    path: entryRoute.path,
    index: entryRoute.index,
    module: entryRoute.module,
    loader: createLoader(entryRoute, routeModulesCache),
    action: createAction(entryRoute),
    shouldReload: createShouldReload(entryRoute, routeModulesCache),
    ErrorBoundary: entryRoute.hasErrorBoundary,
    CatchBoundary: entryRoute.hasCatchBoundary,
    hasLoader: entryRoute.hasLoader
  };
}
function createClientRoutes(routeManifest, routeModulesCache, Component, parentId) {
  return Object.keys(routeManifest).filter((key) => routeManifest[key].parentId === parentId).map((key) => {
    let route = createClientRoute(routeManifest[key], routeModulesCache, Component);
    let children = createClientRoutes(routeManifest, routeModulesCache, Component, route.id);
    if (children.length > 0)
      route.children = children;
    return route;
  });
}
function createShouldReload(route, routeModules) {
  let shouldReload = (arg) => {
    let module = routeModules[route.id];
    invariant2(module, `Expected route module to be loaded for ${route.id}`);
    if (module.unstable_shouldReload) {
      return module.unstable_shouldReload(arg);
    }
    return true;
  };
  return shouldReload;
}
async function loadRouteModuleWithBlockingLinks(route, routeModules) {
  let routeModule = await loadRouteModule(route, routeModules);
  await prefetchStyleLinks(routeModule);
  return routeModule;
}
function createLoader(route, routeModules) {
  let loader = async ({
    url,
    signal,
    submission
  }) => {
    if (route.hasLoader) {
      let [result] = await Promise.all([fetchData(url, route.id, signal, submission), loadRouteModuleWithBlockingLinks(route, routeModules)]);
      if (result instanceof Error)
        throw result;
      let redirect = await checkRedirect(result);
      if (redirect)
        return redirect;
      if (isCatchResponse2(result)) {
        throw new CatchValue(result.status, result.statusText, await extractData2(result.clone()));
      }
      return extractData2(result);
    } else {
      await loadRouteModuleWithBlockingLinks(route, routeModules);
    }
  };
  return loader;
}
function createAction(route) {
  if (!route.hasAction)
    return void 0;
  let action = async ({
    url,
    signal,
    submission
  }) => {
    let result = await fetchData(url, route.id, signal, submission);
    if (result instanceof Error) {
      throw result;
    }
    let redirect = await checkRedirect(result);
    if (redirect)
      return redirect;
    if (isCatchResponse2(result)) {
      throw new CatchValue(result.status, result.statusText, await extractData2(result.clone()));
    }
    return extractData2(result);
  };
  return action;
}
async function checkRedirect(response) {
  if (isRedirectResponse2(response)) {
    let url = new URL(response.headers.get("X-Remix-Redirect"), window.location.origin);
    if (url.origin !== window.location.origin) {
      await new Promise(() => {
        window.location.replace(url.href);
      });
    } else {
      return new TransitionRedirect(url.pathname + url.search);
    }
  }
  return null;
}

// node_modules/@remix-run/react/esm/components.js
var RemixEntryContext = /* @__PURE__ */ React3.createContext(void 0);
function useRemixEntryContext() {
  let context = React3.useContext(RemixEntryContext);
  invariant2(context, "You must render this element inside a <Remix> element");
  return context;
}
function RemixEntry({
  context: entryContext,
  action,
  location: historyLocation,
  navigator: _navigator,
  static: staticProp = false
}) {
  let {
    manifest,
    routeData: documentLoaderData,
    actionData: documentActionData,
    routeModules,
    serverHandoffString,
    appState: entryComponentDidCatchEmulator
  } = entryContext;
  let clientRoutes = React3.useMemo(() => createClientRoutes(manifest.routes, routeModules, RemixRoute), [manifest, routeModules]);
  let [clientState, setClientState] = React3.useState(entryComponentDidCatchEmulator);
  let [transitionManager] = React3.useState(() => {
    return createTransitionManager({
      routes: clientRoutes,
      actionData: documentActionData,
      loaderData: documentLoaderData,
      location: historyLocation,
      catch: entryComponentDidCatchEmulator.catch,
      catchBoundaryId: entryComponentDidCatchEmulator.catchBoundaryRouteId,
      onRedirect: _navigator.replace,
      onChange: (state) => {
        setClientState({
          catch: state.catch,
          error: state.error,
          catchBoundaryRouteId: state.catchBoundaryId,
          loaderBoundaryRouteId: state.errorBoundaryId,
          renderBoundaryRouteId: null,
          trackBoundaries: false,
          trackCatchBoundaries: false
        });
      }
    });
  });
  let navigator = React3.useMemo(() => {
    let push = (to, state) => {
      return transitionManager.getState().transition.state !== "idle" ? _navigator.replace(to, state) : _navigator.push(to, state);
    };
    return __spreadProps(__spreadValues({}, _navigator), {
      push
    });
  }, [_navigator, transitionManager]);
  let {
    location: location2,
    matches,
    loaderData,
    actionData
  } = transitionManager.getState();
  React3.useEffect(() => {
    let {
      location: location3
    } = transitionManager.getState();
    if (historyLocation === location3)
      return;
    transitionManager.send({
      type: "navigation",
      location: historyLocation,
      submission: consumeNextNavigationSubmission(),
      action
    });
  }, [transitionManager, historyLocation, action]);
  let ssrErrorBeforeRoutesRendered = clientState.error && clientState.renderBoundaryRouteId === null && clientState.loaderBoundaryRouteId === null ? deserializeError(clientState.error) : void 0;
  let ssrCatchBeforeRoutesRendered = clientState.catch && clientState.catchBoundaryRouteId === null ? clientState.catch : void 0;
  return /* @__PURE__ */ React3.createElement(RemixEntryContext.Provider, {
    value: {
      matches,
      manifest,
      appState: clientState,
      routeModules,
      serverHandoffString,
      clientRoutes,
      routeData: loaderData,
      actionData,
      transitionManager
    }
  }, /* @__PURE__ */ React3.createElement(RemixErrorBoundary, {
    location: location2,
    component: RemixRootDefaultErrorBoundary,
    error: ssrErrorBeforeRoutesRendered
  }, /* @__PURE__ */ React3.createElement(RemixCatchBoundary, {
    location: location2,
    component: RemixRootDefaultCatchBoundary,
    catch: ssrCatchBeforeRoutesRendered
  }, /* @__PURE__ */ React3.createElement(Router, {
    navigationType: action,
    location: location2,
    navigator,
    static: staticProp
  }, /* @__PURE__ */ React3.createElement(Routes2, null)))));
}
function deserializeError(data) {
  let error = new Error(data.message);
  error.stack = data.stack;
  return error;
}
function Routes2() {
  let {
    clientRoutes
  } = useRemixEntryContext();
  let element = useRoutes(clientRoutes) || clientRoutes[0].element;
  return element;
}
var RemixRouteContext = /* @__PURE__ */ React3.createContext(void 0);
function DefaultRouteComponent({
  id
}) {
  throw new Error(`Route "${id}" has no component! Please go add a \`default\` export in the route module file.
If you were trying to navigate or submit to a resource route, use \`<a>\` instead of \`<Link>\` or \`<Form reloadDocument>\`.`);
}
function RemixRoute({
  id
}) {
  let location2 = useLocation();
  let {
    routeData,
    routeModules,
    appState
  } = useRemixEntryContext();
  let data = routeData[id];
  let {
    default: Component,
    CatchBoundary,
    ErrorBoundary
  } = routeModules[id];
  let element = Component ? /* @__PURE__ */ React3.createElement(Component, null) : /* @__PURE__ */ React3.createElement(DefaultRouteComponent, {
    id
  });
  let context = {
    data,
    id
  };
  if (CatchBoundary) {
    let maybeServerCaught = appState.catch && appState.catchBoundaryRouteId === id ? appState.catch : void 0;
    if (appState.trackCatchBoundaries) {
      appState.catchBoundaryRouteId = id;
    }
    context = maybeServerCaught ? {
      id,
      get data() {
        console.error("You cannot `useLoaderData` in a catch boundary.");
        return void 0;
      }
    } : {
      id,
      data
    };
    element = /* @__PURE__ */ React3.createElement(RemixCatchBoundary, {
      location: location2,
      component: CatchBoundary,
      catch: maybeServerCaught
    }, element);
  }
  if (ErrorBoundary) {
    let maybeServerRenderError = appState.error && (appState.renderBoundaryRouteId === id || appState.loaderBoundaryRouteId === id) ? deserializeError(appState.error) : void 0;
    if (appState.trackBoundaries) {
      appState.renderBoundaryRouteId = id;
    }
    context = maybeServerRenderError ? {
      id,
      get data() {
        console.error("You cannot `useLoaderData` in an error boundary.");
        return void 0;
      }
    } : {
      id,
      data
    };
    element = /* @__PURE__ */ React3.createElement(RemixErrorBoundary, {
      location: location2,
      component: ErrorBoundary,
      error: maybeServerRenderError
    }, element);
  }
  return /* @__PURE__ */ React3.createElement(RemixRouteContext.Provider, {
    value: context
  }, element);
}
function usePrefetchBehavior(prefetch, theirElementProps) {
  let [maybePrefetch, setMaybePrefetch] = React3.useState(false);
  let [shouldPrefetch, setShouldPrefetch] = React3.useState(false);
  let {
    onFocus,
    onBlur,
    onMouseEnter,
    onMouseLeave,
    onTouchStart
  } = theirElementProps;
  React3.useEffect(() => {
    if (prefetch === "render") {
      setShouldPrefetch(true);
    }
  }, [prefetch]);
  let setIntent = () => {
    if (prefetch === "intent") {
      setMaybePrefetch(true);
    }
  };
  let cancelIntent = () => {
    if (prefetch === "intent") {
      setMaybePrefetch(false);
    }
  };
  React3.useEffect(() => {
    if (maybePrefetch) {
      let id = setTimeout(() => {
        setShouldPrefetch(true);
      }, 100);
      return () => {
        clearTimeout(id);
      };
    }
  }, [maybePrefetch]);
  return [shouldPrefetch, {
    onFocus: composeEventHandlers(onFocus, setIntent),
    onBlur: composeEventHandlers(onBlur, cancelIntent),
    onMouseEnter: composeEventHandlers(onMouseEnter, setIntent),
    onMouseLeave: composeEventHandlers(onMouseLeave, cancelIntent),
    onTouchStart: composeEventHandlers(onTouchStart, setIntent)
  }];
}
var NavLink2 = /* @__PURE__ */ React3.forwardRef((_a, forwardedRef) => {
  var _b = _a, {
    to,
    prefetch = "none"
  } = _b, props = __objRest(_b, [
    "to",
    "prefetch"
  ]);
  let href = useHref(to);
  let [shouldPrefetch, prefetchHandlers] = usePrefetchBehavior(prefetch, props);
  return /* @__PURE__ */ React3.createElement(React3.Fragment, null, /* @__PURE__ */ React3.createElement(NavLink, _extends3({
    ref: forwardedRef,
    to
  }, props, prefetchHandlers)), shouldPrefetch ? /* @__PURE__ */ React3.createElement(PrefetchPageLinks, {
    page: href
  }) : null);
});
var Link2 = /* @__PURE__ */ React3.forwardRef((_a, forwardedRef) => {
  var _b = _a, {
    to,
    prefetch = "none"
  } = _b, props = __objRest(_b, [
    "to",
    "prefetch"
  ]);
  let href = useHref(to);
  let [shouldPrefetch, prefetchHandlers] = usePrefetchBehavior(prefetch, props);
  return /* @__PURE__ */ React3.createElement(React3.Fragment, null, /* @__PURE__ */ React3.createElement(Link, _extends3({
    ref: forwardedRef,
    to
  }, props, prefetchHandlers)), shouldPrefetch ? /* @__PURE__ */ React3.createElement(PrefetchPageLinks, {
    page: href
  }) : null);
});
function composeEventHandlers(theirHandler, ourHandler) {
  return (event) => {
    theirHandler && theirHandler(event);
    if (!event.defaultPrevented) {
      ourHandler(event);
    }
  };
}
function Links() {
  let {
    matches,
    routeModules,
    manifest
  } = useRemixEntryContext();
  let links2 = React3.useMemo(() => getLinksForMatches(matches, routeModules, manifest), [matches, routeModules, manifest]);
  return /* @__PURE__ */ React3.createElement(React3.Fragment, null, links2.map((link) => isPageLinkDescriptor(link) ? /* @__PURE__ */ React3.createElement(PrefetchPageLinks, _extends3({
    key: link.page
  }, link)) : /* @__PURE__ */ React3.createElement("link", _extends3({
    key: link.rel + link.href
  }, link))));
}
function PrefetchPageLinks(_a) {
  var _b = _a, {
    page
  } = _b, dataLinkProps = __objRest(_b, [
    "page"
  ]);
  let {
    clientRoutes
  } = useRemixEntryContext();
  let matches = React3.useMemo(() => matchClientRoutes(clientRoutes, page), [clientRoutes, page]);
  if (!matches) {
    console.warn(`Tried to prefetch ${page} but no routes matched.`);
    return null;
  }
  return /* @__PURE__ */ React3.createElement(PrefetchPageLinksImpl, _extends3({
    page,
    matches
  }, dataLinkProps));
}
function usePrefetchedStylesheets(matches) {
  let {
    routeModules
  } = useRemixEntryContext();
  let [styleLinks, setStyleLinks] = React3.useState([]);
  React3.useEffect(() => {
    let interrupted = false;
    getStylesheetPrefetchLinks(matches, routeModules).then((links2) => {
      if (!interrupted)
        setStyleLinks(links2);
    });
    return () => {
      interrupted = true;
    };
  }, [matches, routeModules]);
  return styleLinks;
}
function PrefetchPageLinksImpl(_a) {
  var _b = _a, {
    page,
    matches: nextMatches
  } = _b, linkProps = __objRest(_b, [
    "page",
    "matches"
  ]);
  let location2 = useLocation();
  let {
    matches,
    manifest
  } = useRemixEntryContext();
  let newMatchesForData = React3.useMemo(() => getNewMatchesForLinks(page, nextMatches, matches, location2, "data"), [page, nextMatches, matches, location2]);
  let newMatchesForAssets = React3.useMemo(() => getNewMatchesForLinks(page, nextMatches, matches, location2, "assets"), [page, nextMatches, matches, location2]);
  let dataHrefs = React3.useMemo(() => getDataLinkHrefs(page, newMatchesForData, manifest), [newMatchesForData, page, manifest]);
  let moduleHrefs = React3.useMemo(() => getModuleLinkHrefs(newMatchesForAssets, manifest), [newMatchesForAssets, manifest]);
  let styleLinks = usePrefetchedStylesheets(newMatchesForAssets);
  return /* @__PURE__ */ React3.createElement(React3.Fragment, null, dataHrefs.map((href) => /* @__PURE__ */ React3.createElement("link", _extends3({
    key: href,
    rel: "prefetch",
    as: "fetch",
    href
  }, linkProps))), moduleHrefs.map((href) => /* @__PURE__ */ React3.createElement("link", _extends3({
    key: href,
    rel: "modulepreload",
    href
  }, linkProps))), styleLinks.map((link) => /* @__PURE__ */ React3.createElement("link", _extends3({
    key: link.href
  }, link))));
}
function Meta() {
  let {
    matches,
    routeData,
    routeModules
  } = useRemixEntryContext();
  let location2 = useLocation();
  let meta2 = {};
  let parentsData = {};
  for (let match of matches) {
    let routeId = match.route.id;
    let data = routeData[routeId];
    let params = match.params;
    let routeModule = routeModules[routeId];
    if (routeModule.meta) {
      let routeMeta = typeof routeModule.meta === "function" ? routeModule.meta({
        data,
        parentsData,
        params,
        location: location2
      }) : routeModule.meta;
      Object.assign(meta2, routeMeta);
    }
    parentsData[routeId] = data;
  }
  return /* @__PURE__ */ React3.createElement(React3.Fragment, null, Object.entries(meta2).map(([name, value]) => {
    let isOpenGraphTag = name.startsWith("og:");
    return name === "title" ? /* @__PURE__ */ React3.createElement("title", {
      key: "title"
    }, value) : Array.isArray(value) ? value.map((content) => isOpenGraphTag ? /* @__PURE__ */ React3.createElement("meta", {
      key: name + content,
      property: name,
      content
    }) : /* @__PURE__ */ React3.createElement("meta", {
      key: name + content,
      name,
      content
    })) : isOpenGraphTag ? /* @__PURE__ */ React3.createElement("meta", {
      key: name,
      property: name,
      content: value
    }) : /* @__PURE__ */ React3.createElement("meta", {
      key: name,
      name,
      content: value
    });
  }));
}
var isHydrated = false;
function Scripts(props) {
  let {
    manifest,
    matches,
    pendingLocation,
    clientRoutes,
    serverHandoffString
  } = useRemixEntryContext();
  React3.useEffect(() => {
    isHydrated = true;
  }, []);
  let initialScripts = React3.useMemo(() => {
    let contextScript = serverHandoffString ? `window.__remixContext = ${serverHandoffString};` : "";
    let routeModulesScript = `${matches.map((match, index) => `import * as route${index} from ${JSON.stringify(manifest.routes[match.route.id].module)};`).join("\n")}
window.__remixRouteModules = {${matches.map((match, index) => `${JSON.stringify(match.route.id)}:route${index}`).join(",")}};`;
    return /* @__PURE__ */ React3.createElement(React3.Fragment, null, /* @__PURE__ */ React3.createElement("script", _extends3({}, props, {
      suppressHydrationWarning: true,
      dangerouslySetInnerHTML: createHtml(contextScript)
    })), /* @__PURE__ */ React3.createElement("script", _extends3({}, props, {
      src: manifest.url
    })), /* @__PURE__ */ React3.createElement("script", _extends3({}, props, {
      dangerouslySetInnerHTML: createHtml(routeModulesScript),
      type: "module"
    })), /* @__PURE__ */ React3.createElement("script", _extends3({}, props, {
      src: manifest.entry.module,
      type: "module"
    })));
  }, []);
  let nextMatches = React3.useMemo(() => {
    if (pendingLocation) {
      let matches2 = matchClientRoutes(clientRoutes, pendingLocation);
      invariant2(matches2, `No routes match path "${pendingLocation.pathname}"`);
      return matches2;
    }
    return [];
  }, [pendingLocation, clientRoutes]);
  let routePreloads = matches.concat(nextMatches).map((match) => {
    let route = manifest.routes[match.route.id];
    return (route.imports || []).concat([route.module]);
  }).flat(1);
  let preloads = manifest.entry.imports.concat(routePreloads);
  return /* @__PURE__ */ React3.createElement(React3.Fragment, null, dedupe2(preloads).map((path) => /* @__PURE__ */ React3.createElement("link", {
    key: path,
    rel: "modulepreload",
    href: path,
    crossOrigin: props.crossOrigin
  })), isHydrated ? null : initialScripts);
}
function dedupe2(array) {
  return [...new Set(array)];
}
var nextNavigationSubmission;
function consumeNextNavigationSubmission() {
  let submission = nextNavigationSubmission;
  nextNavigationSubmission = void 0;
  return submission;
}
function useBeforeUnload(callback) {
  React3.useEffect(() => {
    window.addEventListener("beforeunload", callback);
    return () => {
      window.removeEventListener("beforeunload", callback);
    };
  }, [callback]);
}
function useTransition() {
  let {
    transitionManager
  } = useRemixEntryContext();
  return transitionManager.getState().transition;
}
var LiveReload = false ? () => null : function LiveReload2({
  port = Number(50417)
}) {
  let setupLiveReload = ((port2) => {
    let protocol = location.protocol === "https:" ? "wss:" : "ws:";
    let host = location.hostname;
    let socketPath = `${protocol}//${host}:${port2}/socket`;
    let ws = new WebSocket(socketPath);
    ws.onmessage = (message) => {
      let event = JSON.parse(message.data);
      if (event.type === "LOG") {
        console.log(event.message);
      }
      if (event.type === "RELOAD") {
        console.log("\u{1F4BF} Reloading window ...");
        window.location.reload();
      }
    };
    ws.onerror = (error) => {
      console.log("Remix dev asset server web socket error:");
      console.error(error);
    };
  }).toString();
  return /* @__PURE__ */ React3.createElement("script", {
    suppressHydrationWarning: true,
    dangerouslySetInnerHTML: {
      __html: `(${setupLiveReload})(${JSON.stringify(port)})`
    }
  });
};

// node_modules/@remix-run/react/esm/scroll-restoration.js
init_react();
var React4 = __toESM(require_react());
var STORAGE_KEY = "positions";
var positions = {};
if (typeof document !== "undefined") {
  let sessionPositions = sessionStorage.getItem(STORAGE_KEY);
  if (sessionPositions) {
    positions = JSON.parse(sessionPositions);
  }
}
function ScrollRestoration() {
  useScrollRestoration();
  React4.useEffect(() => {
    window.history.scrollRestoration = "manual";
  }, []);
  useBeforeUnload(React4.useCallback(() => {
    window.history.scrollRestoration = "auto";
  }, []));
  let restoreScroll = ((STORAGE_KEY2) => {
    if (!window.history.state || !window.history.state.key) {
      let key = Math.random().toString(32).slice(2);
      window.history.replaceState({
        key
      }, "");
    }
    try {
      let positions2 = JSON.parse(sessionStorage.getItem(STORAGE_KEY2) || "{}");
      let storedY = positions2[window.history.state.key];
      if (typeof storedY === "number") {
        window.scrollTo(0, storedY);
      }
    } catch (error) {
      console.error(error);
      sessionStorage.removeItem(STORAGE_KEY2);
    }
  }).toString();
  return /* @__PURE__ */ React4.createElement("script", {
    suppressHydrationWarning: true,
    dangerouslySetInnerHTML: {
      __html: `(${restoreScroll})(${JSON.stringify(STORAGE_KEY)})`
    }
  });
}
var hydrated = false;
function useScrollRestoration() {
  let location2 = useLocation();
  let transition = useTransition();
  let wasSubmissionRef = React4.useRef(false);
  React4.useEffect(() => {
    if (transition.submission) {
      wasSubmissionRef.current = true;
    }
  }, [transition]);
  React4.useEffect(() => {
    if (transition.location) {
      positions[location2.key] = window.scrollY;
    }
  }, [transition, location2]);
  useBeforeUnload(React4.useCallback(() => {
    sessionStorage.setItem(STORAGE_KEY, JSON.stringify(positions));
  }, []));
  if (typeof document !== "undefined") {
    React4.useLayoutEffect(() => {
      if (!hydrated) {
        hydrated = true;
        return;
      }
      let y = positions[location2.key];
      if (y != void 0) {
        window.scrollTo(0, y);
        return;
      }
      if (location2.hash) {
        let el = document.getElementById(location2.hash.slice(1));
        if (el) {
          el.scrollIntoView();
          return;
        }
      }
      if (wasSubmissionRef.current === true) {
        wasSubmissionRef.current = false;
        return;
      }
      window.scrollTo(0, 0);
    }, [location2]);
  }
  React4.useEffect(() => {
    if (transition.submission) {
      wasSubmissionRef.current = true;
    }
  }, [transition]);
}

// node_modules/@remix-run/react/esm/server.js
init_react();
var React5 = __toESM(require_react());
function RemixServer({
  context,
  url
}) {
  if (typeof url === "string") {
    url = new URL(url);
  }
  let location2 = {
    pathname: url.pathname,
    search: url.search,
    hash: "",
    state: null,
    key: "default"
  };
  let staticNavigator = {
    createHref(to) {
      return typeof to === "string" ? to : createPath(to);
    },
    push(to) {
      throw new Error(`You cannot use navigator.push() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${JSON.stringify(to)})\` somewhere in your app.`);
    },
    replace(to) {
      throw new Error(`You cannot use navigator.replace() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${JSON.stringify(to)}, { replace: true })\` somewhere in your app.`);
    },
    go(delta) {
      throw new Error(`You cannot use navigator.go() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${delta})\` somewhere in your app.`);
    },
    back() {
      throw new Error(`You cannot use navigator.back() on the server because it is a stateless environment.`);
    },
    forward() {
      throw new Error(`You cannot use navigator.forward() on the server because it is a stateless environment.`);
    },
    block() {
      throw new Error(`You cannot use navigator.block() on the server because it is a stateless environment.`);
    }
  };
  return /* @__PURE__ */ React5.createElement(RemixEntry, {
    context,
    action: Action.Pop,
    location: location2,
    navigator: staticNavigator,
    static: true
  });
}

// app/entry.server.tsx
function handleRequest(request, responseStatusCode, responseHeaders, remixContext) {
  const markup = (0, import_server3.renderToString)(/* @__PURE__ */ React.createElement(RemixServer, {
    context: remixContext,
    url: request.url
  }));
  responseHeaders.set("Content-Type", "text/html");
  return new Response("<!DOCTYPE html>" + markup, {
    status: responseStatusCode,
    headers: responseHeaders
  });
}

// route:D:\Github\Projects\alongvili.dev\app\root.tsx
var root_exports = {};
__export(root_exports, {
  default: () => App,
  links: () => links,
  meta: () => meta
});
init_react();

// app/components/navbar.tsx
init_react();
function NavBar() {
  return /* @__PURE__ */ React.createElement("nav", {
    className: "flex justify-between max-w-6xl mx-auto fixed inset-0 h-16 p-4"
  }, /* @__PURE__ */ React.createElement(Link2, {
    className: "text-[#394359]",
    to: "/"
  }, "AlonGvili"), /* @__PURE__ */ React.createElement("div", {
    className: "flex items-center space-x-6"
  }, /* @__PURE__ */ React.createElement(NavLink2, {
    to: "/projects",
    className: ({ isActive }) => isActive ? "text-white" : `text-[#394359]`
  }, "Projects"), /* @__PURE__ */ React.createElement(NavLink2, {
    to: "/lists",
    className: ({ isActive }) => isActive ? "text-white" : `text-[#394359]`
  }, "Lists"), /* @__PURE__ */ React.createElement(NavLink2, {
    to: "/me",
    className: ({ isActive }) => isActive ? "text-white" : `text-[#394359]`
  }, "Me")));
}

// app/tailwind.css
var tailwind_default = "/build/_assets/tailwind-5KEIPZXS.css";

// route:D:\Github\Projects\alongvili.dev\app\root.tsx
var links = () => {
  return [
    {
      href: tailwind_default,
      rel: "stylesheet"
    }
  ];
};
var meta = () => {
  return { title: "New Remix App" };
};
function App() {
  return /* @__PURE__ */ React.createElement("html", {
    lang: "en"
  }, /* @__PURE__ */ React.createElement("head", null, /* @__PURE__ */ React.createElement("meta", {
    charSet: "utf-8"
  }), /* @__PURE__ */ React.createElement("meta", {
    name: "viewport",
    content: "width=device-width,initial-scale=1"
  }), /* @__PURE__ */ React.createElement(Meta, null), /* @__PURE__ */ React.createElement(Links, null)), /* @__PURE__ */ React.createElement("body", {
    className: "bg-surface"
  }, /* @__PURE__ */ React.createElement(NavBar, null), /* @__PURE__ */ React.createElement("div", {
    className: "mt-16 mx-auto max-w-6xl p-4"
  }, /* @__PURE__ */ React.createElement(Outlet, null)), /* @__PURE__ */ React.createElement(ScrollRestoration, null), /* @__PURE__ */ React.createElement(Scripts, null), /* @__PURE__ */ React.createElement(LiveReload, null)));
}

// route:D:\Github\Projects\alongvili.dev\app\routes\projects.tsx
var projects_exports = {};
__export(projects_exports, {
  default: () => Projects
});
init_react();
function Projects() {
  return /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement("h1", {
    className: "text-6xl max-w-2xl text-[#394359] uppercase font-bold"
  }, "Some ", /* @__PURE__ */ React.createElement("span", {
    className: "text-[#A266CA]"
  }, "things "), "that i've ", /* @__PURE__ */ React.createElement("span", {
    className: "text-[#CBADCC]"
  }, "build")));
}

// route:D:\Github\Projects\alongvili.dev\app\routes\index.tsx
var routes_exports = {};
__export(routes_exports, {
  default: () => Index
});
init_react();
function Index() {
  return /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement("h1", {
    className: "text-2xl text-[#394359]"
  }, "Welcome to Alon Gvili site"));
}

// route:D:\Github\Projects\alongvili.dev\app\routes\lists.tsx
var lists_exports = {};
__export(lists_exports, {
  default: () => Projects2
});
init_react();
function Projects2() {
  return /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement("h1", {
    className: "text-2xl text-[#394359]"
  }, "Projects"));
}

// route:D:\Github\Projects\alongvili.dev\app\routes\me.tsx
var me_exports = {};
__export(me_exports, {
  default: () => Projects3
});
init_react();
function Projects3() {
  return /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement("h1", {
    className: "text-2xl text-[#394359]"
  }, "Projects"));
}

// server-assets-manifest:@remix-run/dev/assets-manifest
init_react();
var assets_manifest_default = { "version": "dff0a68c", "entry": { "module": "/build/entry.client-6JGKFKDY.js", "imports": ["/build/_shared/chunk-L5DD64YK.js", "/build/_shared/chunk-WE4I4FD6.js"] }, "routes": { "root": { "id": "root", "parentId": void 0, "path": "", "index": void 0, "caseSensitive": void 0, "module": "/build/root-YOU3ENZY.js", "imports": void 0, "hasAction": false, "hasLoader": false, "hasCatchBoundary": false, "hasErrorBoundary": false }, "routes/index": { "id": "routes/index", "parentId": "root", "path": void 0, "index": true, "caseSensitive": void 0, "module": "/build/routes/index-BJJRPD7D.js", "imports": void 0, "hasAction": false, "hasLoader": false, "hasCatchBoundary": false, "hasErrorBoundary": false }, "routes/lists": { "id": "routes/lists", "parentId": "root", "path": "lists", "index": void 0, "caseSensitive": void 0, "module": "/build/routes/lists-3RHF3UWT.js", "imports": void 0, "hasAction": false, "hasLoader": false, "hasCatchBoundary": false, "hasErrorBoundary": false }, "routes/me": { "id": "routes/me", "parentId": "root", "path": "me", "index": void 0, "caseSensitive": void 0, "module": "/build/routes/me-RAEXHZ7H.js", "imports": void 0, "hasAction": false, "hasLoader": false, "hasCatchBoundary": false, "hasErrorBoundary": false }, "routes/projects": { "id": "routes/projects", "parentId": "root", "path": "projects", "index": void 0, "caseSensitive": void 0, "module": "/build/routes/projects-ZR4RTGTO.js", "imports": void 0, "hasAction": false, "hasLoader": false, "hasCatchBoundary": false, "hasErrorBoundary": false } }, "url": "/build/manifest-DFF0A68C.js" };

// server-entry-module:@remix-run/dev/server-build
var entry = { module: entry_server_exports };
var routes = {
  "root": {
    id: "root",
    parentId: void 0,
    path: "",
    index: void 0,
    caseSensitive: void 0,
    module: root_exports
  },
  "routes/projects": {
    id: "routes/projects",
    parentId: "root",
    path: "projects",
    index: void 0,
    caseSensitive: void 0,
    module: projects_exports
  },
  "routes/index": {
    id: "routes/index",
    parentId: "root",
    path: void 0,
    index: true,
    caseSensitive: void 0,
    module: routes_exports
  },
  "routes/lists": {
    id: "routes/lists",
    parentId: "root",
    path: "lists",
    index: void 0,
    caseSensitive: void 0,
    module: lists_exports
  },
  "routes/me": {
    id: "routes/me",
    parentId: "root",
    path: "me",
    index: void 0,
    caseSensitive: void 0,
    module: me_exports
  }
};

// server.js
var handleRequest2 = createPagesFunctionHandler({
  build: server_build_exports,
  mode: "development",
  getLoadContext: (context) => context.env
});
function onRequest(context) {
  return handleRequest2(context);
}
export {
  onRequest
};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/**
 * @remix-run/cloudflare-pages v1.2.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
/**
 * @remix-run/react v1.2.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
/**
 * @remix-run/server-runtime v1.2.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
/**
 * React Router DOM v6.2.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
/**
 * React Router v6.2.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
/** @license React v17.0.2
 * react-dom-server.node.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v17.0.2
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanMiLCAiLi4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcyIsICIuLi9ub2RlX21vZHVsZXMvcmVhY3QvaW5kZXguanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vZGV2L2NvbXBpbGVyL3NoaW1zL3JlYWN0LnRzIiwgIi4uL25vZGVfbW9kdWxlcy9zZXQtY29va2llLXBhcnNlci9saWIvc2V0LWNvb2tpZS5qcyIsICIuLi9ub2RlX21vZHVsZXMvanNlc2MvanNlc2MuanMiLCAibm9kZS1tb2R1bGVzLXBvbHlmaWxsczpldmVudHMiLCAibm9kZS1tb2R1bGVzLXBvbHlmaWxsczpwcm9jZXNzIiwgIi4uL25vZGVfbW9kdWxlcy9yb2xsdXAtcGx1Z2luLW5vZGUtcG9seWZpbGxzL3BvbHlmaWxscy9pbmhlcml0cy5qcyIsICJub2RlLW1vZHVsZXMtcG9seWZpbGxzOnV0aWwiLCAibm9kZS1tb2R1bGVzLXBvbHlmaWxsczpidWZmZXIiLCAiLi4vbm9kZV9tb2R1bGVzL3JvbGx1cC1wbHVnaW4tbm9kZS1wb2x5ZmlsbHMvcG9seWZpbGxzL3JlYWRhYmxlLXN0cmVhbS9idWZmZXItbGlzdC5qcyIsICJub2RlLW1vZHVsZXMtcG9seWZpbGxzOnN0cmluZ19kZWNvZGVyIiwgIi4uL25vZGVfbW9kdWxlcy9yb2xsdXAtcGx1Z2luLW5vZGUtcG9seWZpbGxzL3BvbHlmaWxscy9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3JvbGx1cC1wbHVnaW4tbm9kZS1wb2x5ZmlsbHMvcG9seWZpbGxzL3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS5qcyIsICIuLi9ub2RlX21vZHVsZXMvcm9sbHVwLXBsdWdpbi1ub2RlLXBvbHlmaWxscy9wb2x5ZmlsbHMvcmVhZGFibGUtc3RyZWFtL2R1cGxleC5qcyIsICIuLi9ub2RlX21vZHVsZXMvcm9sbHVwLXBsdWdpbi1ub2RlLXBvbHlmaWxscy9wb2x5ZmlsbHMvcmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcyIsICIuLi9ub2RlX21vZHVsZXMvcm9sbHVwLXBsdWdpbi1ub2RlLXBvbHlmaWxscy9wb2x5ZmlsbHMvcmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzIiwgIm5vZGUtbW9kdWxlcy1wb2x5ZmlsbHM6c3RyZWFtIiwgIm5vZGUtbW9kdWxlcy1wb2x5ZmlsbHMtY29tbW9uanM6c3RyZWFtIiwgIi4uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vY2pzL3JlYWN0LWRvbS1zZXJ2ZXIubm9kZS5kZXZlbG9wbWVudC5qcyIsICIuLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL3NlcnZlci5ub2RlLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vc2VydmVyLmpzIiwgIi4uL3NlcnZlci5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9jbG91ZGZsYXJlLXBhZ2VzL2VzbS9pbmRleC5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9jbG91ZGZsYXJlLXBhZ2VzL2VzbS9nbG9iYWxzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL2Nsb3VkZmxhcmUtcGFnZXMvZXNtL2Nvb2tpZVNpZ25pbmcuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vY2xvdWRmbGFyZS1wYWdlcy9lc20vc2Vzc2lvbnMvY2xvdWRmbGFyZUtWU2Vzc2lvblN0b3JhZ2UuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUvZXNtL2luZGV4LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL3NlcnZlci1ydW50aW1lL2VzbS9yZXNwb25zZXMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUvZXNtL3NlcnZlci5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZS9lc20vZGF0YS5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZS9lc20vZW50cnkuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUvZXNtL2Vycm9ycy5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZS9lc20vaGVhZGVycy5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZS9lc20vcm91dGVNYXRjaGluZy5qcyIsICIuLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9pbmRleC5qcyIsICIuLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcy5qcyIsICIuLi8uLi9wYWNrYWdlcy9yZWFjdC1yb3V0ZXIvaW5kZXgudHN4IiwgIi4uLy4uL3BhY2thZ2VzL3JlYWN0LXJvdXRlci1kb20vaW5kZXgudHN4IiwgIi4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL3NlcnZlci1ydW50aW1lL2VzbS9tb2RlLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL3NlcnZlci1ydW50aW1lL2VzbS9yb3V0ZXMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUvZXNtL3NlcnZlckhhbmRvZmYuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vY2xvdWRmbGFyZS1wYWdlcy9lc20vd29ya2VyLmpzIiwgInNlcnZlci1lbnRyeS1tb2R1bGU6QHJlbWl4LXJ1bi9kZXYvc2VydmVyLWJ1aWxkIiwgIi4uL2FwcC9lbnRyeS5zZXJ2ZXIudHN4IiwgIi4uL25vZGVfbW9kdWxlcy9yZW1peC9lc20vaW5kZXguanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vcmVhY3QvZXNtL2luZGV4LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL3JlYWN0L2VzbS9jb21wb25lbnRzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL3JlYWN0L2VzbS9fdmlydHVhbC9fcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL3JlYWN0L2VzbS9lcnJvckJvdW5kYXJpZXMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vcmVhY3QvZXNtL2ludmFyaWFudC5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9yZWFjdC9lc20vbGlua3MuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vcmVhY3QvZXNtL3JvdXRlTW9kdWxlcy5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9yZWFjdC9lc20vbWFya3VwLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL3JlYWN0L2VzbS9yb3V0ZXMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vcmVhY3QvZXNtL2RhdGEuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vcmVhY3QvZXNtL3RyYW5zaXRpb24uanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vcmVhY3QvZXNtL3JvdXRlTWF0Y2hpbmcuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vcmVhY3QvZXNtL3Njcm9sbC1yZXN0b3JhdGlvbi5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9yZWFjdC9lc20vc2VydmVyLmpzIiwgInJvdXRlOkQ6XFxHaXRodWJcXFByb2plY3RzXFxhbG9uZ3ZpbGkuZGV2XFxhcHBcXHJvb3QudHN4IiwgIi4uL2FwcC9jb21wb25lbnRzL25hdmJhci50c3giLCAicm91dGU6RDpcXEdpdGh1YlxcUHJvamVjdHNcXGFsb25ndmlsaS5kZXZcXGFwcFxccm91dGVzXFxwcm9qZWN0cy50c3giLCAicm91dGU6RDpcXEdpdGh1YlxcUHJvamVjdHNcXGFsb25ndmlsaS5kZXZcXGFwcFxccm91dGVzXFxpbmRleC50c3giLCAicm91dGU6RDpcXEdpdGh1YlxcUHJvamVjdHNcXGFsb25ndmlsaS5kZXZcXGFwcFxccm91dGVzXFxsaXN0cy50c3giLCAicm91dGU6RDpcXEdpdGh1YlxcUHJvamVjdHNcXGFsb25ndmlsaS5kZXZcXGFwcFxccm91dGVzXFxtZS50c3giLCAic2VydmVyLWFzc2V0cy1tYW5pZmVzdDpAcmVtaXgtcnVuL2Rldi9hc3NldHMtbWFuaWZlc3QiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuXG4ndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG4iLCAiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNy4wLjJcbiAqIHJlYWN0LmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbi8vIFRPRE86IHRoaXMgaXMgc3BlY2lhbCBiZWNhdXNlIGl0IGdldHMgaW1wb3J0ZWQgZHVyaW5nIGJ1aWxkLlxudmFyIFJlYWN0VmVyc2lvbiA9ICcxNy4wLjInO1xuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gMHhlYWM3O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gMHhlYWNhO1xuZXhwb3J0cy5GcmFnbWVudCA9IDB4ZWFjYjtcbmV4cG9ydHMuU3RyaWN0TW9kZSA9IDB4ZWFjYztcbmV4cG9ydHMuUHJvZmlsZXIgPSAweGVhZDI7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IDB4ZWFjZDtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSAweGVhY2U7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IDB4ZWFkMDtcbmV4cG9ydHMuU3VzcGVuc2UgPSAweGVhZDE7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gMHhlYWQ4O1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IDB4ZWFkMztcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSAweGVhZDQ7XG52YXIgUkVBQ1RfQkxPQ0tfVFlQRSA9IDB4ZWFkOTtcbnZhciBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSA9IDB4ZWFkYTtcbnZhciBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gMHhlYWQ1O1xudmFyIFJFQUNUX1NDT1BFX1RZUEUgPSAweGVhZDc7XG52YXIgUkVBQ1RfT1BBUVVFX0lEX1RZUEUgPSAweGVhZTA7XG52YXIgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSAweGVhZTE7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSAweGVhZTI7XG52YXIgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gMHhlYWUzO1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yKSB7XG4gIHZhciBzeW1ib2xGb3IgPSBTeW1ib2wuZm9yO1xuICBSRUFDVF9FTEVNRU5UX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbiAgUkVBQ1RfUE9SVEFMX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnBvcnRhbCcpO1xuICBleHBvcnRzLkZyYWdtZW50ID0gc3ltYm9sRm9yKCdyZWFjdC5mcmFnbWVudCcpO1xuICBleHBvcnRzLlN0cmljdE1vZGUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG4gIGV4cG9ydHMuUHJvZmlsZXIgPSBzeW1ib2xGb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG4gIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG4gIFJFQUNUX0NPTlRFWFRfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuY29udGV4dCcpO1xuICBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xuICBleHBvcnRzLlN1c3BlbnNlID0gc3ltYm9sRm9yKCdyZWFjdC5zdXNwZW5zZScpO1xuICBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbiAgUkVBQ1RfTUVNT19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5tZW1vJyk7XG4gIFJFQUNUX0xBWllfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubGF6eScpO1xuICBSRUFDVF9CTE9DS19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5ibG9jaycpO1xuICBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc2VydmVyLmJsb2NrJyk7XG4gIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmZ1bmRhbWVudGFsJyk7XG4gIFJFQUNUX1NDT1BFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnNjb3BlJyk7XG4gIFJFQUNUX09QQVFVRV9JRF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5vcGFxdWUuaWQnKTtcbiAgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmRlYnVnX3RyYWNlX21vZGUnKTtcbiAgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xuICBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmxlZ2FjeV9oaWRkZW4nKTtcbn1cblxudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgZGlzcGF0Y2hlci5cbiAqL1xudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHR5cGUge1JlYWN0Q29tcG9uZW50fVxuICAgKi9cbiAgY3VycmVudDogbnVsbFxufTtcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBiYXRjaCdzIGNvbmZpZ3VyYXRpb24gc3VjaCBhcyBob3cgbG9uZyBhbiB1cGRhdGVcbiAqIHNob3VsZCBzdXNwZW5kIGZvciBpZiBpdCBuZWVkcyB0by5cbiAqL1xudmFyIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnID0ge1xuICB0cmFuc2l0aW9uOiAwXG59O1xuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IG93bmVyLlxuICpcbiAqIFRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBjb21wb25lbnQgd2hvIHNob3VsZCBvd24gYW55IGNvbXBvbmVudHMgdGhhdCBhcmVcbiAqIGN1cnJlbnRseSBiZWluZyBjb25zdHJ1Y3RlZC5cbiAqL1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEB0eXBlIHtSZWFjdENvbXBvbmVudH1cbiAgICovXG4gIGN1cnJlbnQ6IG51bGxcbn07XG5cbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0ge307XG52YXIgY3VycmVudEV4dHJhU3RhY2tGcmFtZSA9IG51bGw7XG5mdW5jdGlvbiBzZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spIHtcbiAge1xuICAgIGN1cnJlbnRFeHRyYVN0YWNrRnJhbWUgPSBzdGFjaztcbiAgfVxufVxuXG57XG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lID0gZnVuY3Rpb24gKHN0YWNrKSB7XG4gICAge1xuICAgICAgY3VycmVudEV4dHJhU3RhY2tGcmFtZSA9IHN0YWNrO1xuICAgIH1cbiAgfTsgLy8gU3RhY2sgaW1wbGVtZW50YXRpb24gaW5qZWN0ZWQgYnkgdGhlIGN1cnJlbnQgcmVuZGVyZXIuXG5cblxuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjayA9IG51bGw7XG5cbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGFjayA9ICcnOyAvLyBBZGQgYW4gZXh0cmEgdG9wIGZyYW1lIHdoaWxlIGFuIGVsZW1lbnQgaXMgYmVpbmcgdmFsaWRhdGVkXG5cbiAgICBpZiAoY3VycmVudEV4dHJhU3RhY2tGcmFtZSkge1xuICAgICAgc3RhY2sgKz0gY3VycmVudEV4dHJhU3RhY2tGcmFtZTtcbiAgICB9IC8vIERlbGVnYXRlIHRvIHRoZSBpbmplY3RlZCByZW5kZXJlci1zcGVjaWZpYyBpbXBsZW1lbnRhdGlvblxuXG5cbiAgICB2YXIgaW1wbCA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrO1xuXG4gICAgaWYgKGltcGwpIHtcbiAgICAgIHN0YWNrICs9IGltcGwoKSB8fCAnJztcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhY2s7XG4gIH07XG59XG5cbi8qKlxuICogVXNlZCBieSBhY3QoKSB0byB0cmFjayB3aGV0aGVyIHlvdSdyZSBpbnNpZGUgYW4gYWN0KCkgc2NvcGUuXG4gKi9cbnZhciBJc1NvbWVSZW5kZXJlckFjdGluZyA9IHtcbiAgY3VycmVudDogZmFsc2Vcbn07XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IHtcbiAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjogUmVhY3RDdXJyZW50RGlzcGF0Y2hlcixcbiAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWc6IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLFxuICBSZWFjdEN1cnJlbnRPd25lcjogUmVhY3RDdXJyZW50T3duZXIsXG4gIElzU29tZVJlbmRlcmVyQWN0aW5nOiBJc1NvbWVSZW5kZXJlckFjdGluZyxcbiAgLy8gVXNlZCBieSByZW5kZXJlcnMgdG8gYXZvaWQgYnVuZGxpbmcgb2JqZWN0LWFzc2lnbiB0d2ljZSBpbiBVTUQgYnVuZGxlczpcbiAgYXNzaWduOiBfYXNzaWduXG59O1xuXG57XG4gIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lO1xufVxuXG4vLyBieSBjYWxscyB0byB0aGVzZSBtZXRob2RzIGJ5IGEgQmFiZWwgcGx1Z2luLlxuLy9cbi8vIEluIFBST0QgKG9yIGluIHBhY2thZ2VzIHdpdGhvdXQgYWNjZXNzIHRvIFJlYWN0IGludGVybmFscyksXG4vLyB0aGV5IGFyZSBsZWZ0IGFzIHRoZXkgYXJlIGluc3RlYWQuXG5cbmZ1bmN0aW9uIHdhcm4oZm9ybWF0KSB7XG4gIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBwcmludFdhcm5pbmcoJ3dhcm4nLCBmb3JtYXQsIGFyZ3MpO1xuICB9XG59XG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cbiAge1xuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuICAgIGlmIChzdGFjayAhPT0gJycpIHtcbiAgICAgIGZvcm1hdCArPSAnJXMnO1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgIH1cblxuICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gJycgKyBpdGVtO1xuICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuXG4gICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gIH1cbn1cblxudmFyIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudCA9IHt9O1xuXG5mdW5jdGlvbiB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgY2FsbGVyTmFtZSkge1xuICB7XG4gICAgdmFyIF9jb25zdHJ1Y3RvciA9IHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgIHZhciBjb21wb25lbnROYW1lID0gX2NvbnN0cnVjdG9yICYmIChfY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgX2NvbnN0cnVjdG9yLm5hbWUpIHx8ICdSZWFjdENsYXNzJztcbiAgICB2YXIgd2FybmluZ0tleSA9IGNvbXBvbmVudE5hbWUgKyBcIi5cIiArIGNhbGxlck5hbWU7XG5cbiAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXJyb3IoXCJDYW4ndCBjYWxsICVzIG9uIGEgY29tcG9uZW50IHRoYXQgaXMgbm90IHlldCBtb3VudGVkLiBcIiArICdUaGlzIGlzIGEgbm8tb3AsIGJ1dCBpdCBtaWdodCBpbmRpY2F0ZSBhIGJ1ZyBpbiB5b3VyIGFwcGxpY2F0aW9uLiAnICsgJ0luc3RlYWQsIGFzc2lnbiB0byBgdGhpcy5zdGF0ZWAgZGlyZWN0bHkgb3IgZGVmaW5lIGEgYHN0YXRlID0ge307YCAnICsgJ2NsYXNzIHByb3BlcnR5IHdpdGggdGhlIGRlc2lyZWQgc3RhdGUgaW4gdGhlICVzIGNvbXBvbmVudC4nLCBjYWxsZXJOYW1lLCBjb21wb25lbnROYW1lKTtcblxuICAgIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFt3YXJuaW5nS2V5XSA9IHRydWU7XG4gIH1cbn1cbi8qKlxuICogVGhpcyBpcyB0aGUgYWJzdHJhY3QgQVBJIGZvciBhbiB1cGRhdGUgcXVldWUuXG4gKi9cblxuXG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSB7XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBjYWxsZXJOYW1lIG5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdmb3JjZVVwZGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgb3IgYHNldFN0YXRlYCB0byBtdXRhdGUgc3RhdGUuXG4gICAqIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAgICpcbiAgICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAgICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb21wbGV0ZVN0YXRlIE5leHQgc3RhdGUuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY2FsbGVyTmFtZSBuYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3JlcGxhY2VTdGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gVGhpcyBvbmx5IGV4aXN0cyBiZWNhdXNlIF9wZW5kaW5nU3RhdGUgaXNcbiAgICogaW50ZXJuYWwuIFRoaXMgcHJvdmlkZXMgYSBtZXJnaW5nIHN0cmF0ZWd5IHRoYXQgaXMgbm90IGF2YWlsYWJsZSB0byBkZWVwXG4gICAqIHByb3BlcnRpZXMgd2hpY2ggaXMgY29uZnVzaW5nLiBUT0RPOiBFeHBvc2UgcGVuZGluZ1N0YXRlIG9yIGRvbid0IHVzZSBpdFxuICAgKiBkdXJpbmcgdGhlIG1lcmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggc3RhdGUuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gTmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcbiAgfVxufTtcblxudmFyIGVtcHR5T2JqZWN0ID0ge307XG5cbntcbiAgT2JqZWN0LmZyZWV6ZShlbXB0eU9iamVjdCk7XG59XG4vKipcbiAqIEJhc2UgY2xhc3MgaGVscGVycyBmb3IgdGhlIHVwZGF0aW5nIHN0YXRlIG9mIGEgY29tcG9uZW50LlxuICovXG5cblxuZnVuY3Rpb24gQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDsgLy8gSWYgYSBjb21wb25lbnQgaGFzIHN0cmluZyByZWZzLCB3ZSB3aWxsIGFzc2lnbiBhIGRpZmZlcmVudCBvYmplY3QgbGF0ZXIuXG5cbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7IC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXG4gIC8vIHJlbmRlcmVyLlxuXG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cbkNvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHt9O1xuLyoqXG4gKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIHRvIG11dGF0ZVxuICogc3RhdGUuIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBjYWxscyB0byBgc2V0U3RhdGVgIHdpbGwgcnVuIHN5bmNocm9ub3VzbHksXG4gKiBhcyB0aGV5IG1heSBldmVudHVhbGx5IGJlIGJhdGNoZWQgdG9nZXRoZXIuICBZb3UgY2FuIHByb3ZpZGUgYW4gb3B0aW9uYWxcbiAqIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIHRoZSBjYWxsIHRvIHNldFN0YXRlIGlzIGFjdHVhbGx5XG4gKiBjb21wbGV0ZWQuXG4gKlxuICogV2hlbiBhIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIHRvIHNldFN0YXRlLCBpdCB3aWxsIGJlIGNhbGxlZCBhdCBzb21lIHBvaW50IGluXG4gKiB0aGUgZnV0dXJlIChub3Qgc3luY2hyb25vdXNseSkuIEl0IHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIHVwIHRvIGRhdGVcbiAqIGNvbXBvbmVudCBhcmd1bWVudHMgKHN0YXRlLCBwcm9wcywgY29udGV4dCkuIFRoZXNlIHZhbHVlcyBjYW4gYmUgZGlmZmVyZW50XG4gKiBmcm9tIHRoaXMuKiBiZWNhdXNlIHlvdXIgZnVuY3Rpb24gbWF5IGJlIGNhbGxlZCBhZnRlciByZWNlaXZlUHJvcHMgYnV0IGJlZm9yZVxuICogc2hvdWxkQ29tcG9uZW50VXBkYXRlLCBhbmQgdGhpcyBuZXcgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCB3aWxsIG5vdCB5ZXQgYmVcbiAqIGFzc2lnbmVkIHRvIHRoaXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgb3IgZnVuY3Rpb24gdG9cbiAqICAgICAgICBwcm9kdWNlIG5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBjdXJyZW50IHN0YXRlLlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cblxuQ29tcG9uZW50LnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrKSB7XG4gIGlmICghKHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdmdW5jdGlvbicgfHwgcGFydGlhbFN0YXRlID09IG51bGwpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwic2V0U3RhdGUoLi4uKTogdGFrZXMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcyB0byB1cGRhdGUgb3IgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMuXCIgKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssICdzZXRTdGF0ZScpO1xufTtcbi8qKlxuICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gKlxuICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gKlxuICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAqXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHVwZGF0ZSBpcyBjb21wbGV0ZS5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5cblxuQ29tcG9uZW50LnByb3RvdHlwZS5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUZvcmNlVXBkYXRlKHRoaXMsIGNhbGxiYWNrLCAnZm9yY2VVcGRhdGUnKTtcbn07XG4vKipcbiAqIERlcHJlY2F0ZWQgQVBJcy4gVGhlc2UgQVBJcyB1c2VkIHRvIGV4aXN0IG9uIGNsYXNzaWMgUmVhY3QgY2xhc3NlcyBidXQgc2luY2VcbiAqIHdlIHdvdWxkIGxpa2UgdG8gZGVwcmVjYXRlIHRoZW0sIHdlJ3JlIG5vdCBnb2luZyB0byBtb3ZlIHRoZW0gb3ZlciB0byB0aGlzXG4gKiBtb2Rlcm4gYmFzZSBjbGFzcy4gSW5zdGVhZCwgd2UgZGVmaW5lIGEgZ2V0dGVyIHRoYXQgd2FybnMgaWYgaXQncyBhY2Nlc3NlZC5cbiAqL1xuXG5cbntcbiAgdmFyIGRlcHJlY2F0ZWRBUElzID0ge1xuICAgIGlzTW91bnRlZDogWydpc01vdW50ZWQnLCAnSW5zdGVhZCwgbWFrZSBzdXJlIHRvIGNsZWFuIHVwIHN1YnNjcmlwdGlvbnMgYW5kIHBlbmRpbmcgcmVxdWVzdHMgaW4gJyArICdjb21wb25lbnRXaWxsVW5tb3VudCB0byBwcmV2ZW50IG1lbW9yeSBsZWFrcy4nXSxcbiAgICByZXBsYWNlU3RhdGU6IFsncmVwbGFjZVN0YXRlJywgJ1JlZmFjdG9yIHlvdXIgY29kZSB0byB1c2Ugc2V0U3RhdGUgaW5zdGVhZCAoc2VlICcgKyAnaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zMjM2KS4nXVxuICB9O1xuXG4gIHZhciBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSwgaW5mbykge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCBtZXRob2ROYW1lLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2FybignJXMoLi4uKSBpcyBkZXByZWNhdGVkIGluIHBsYWluIEphdmFTY3JpcHQgUmVhY3QgY2xhc3Nlcy4gJXMnLCBpbmZvWzBdLCBpbmZvWzFdKTtcblxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIGZvciAodmFyIGZuTmFtZSBpbiBkZXByZWNhdGVkQVBJcykge1xuICAgIGlmIChkZXByZWNhdGVkQVBJcy5oYXNPd25Qcm9wZXJ0eShmbk5hbWUpKSB7XG4gICAgICBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcoZm5OYW1lLCBkZXByZWNhdGVkQVBJc1tmbk5hbWVdKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gQ29tcG9uZW50RHVtbXkoKSB7fVxuXG5Db21wb25lbnREdW1teS5wcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuLyoqXG4gKiBDb252ZW5pZW5jZSBjb21wb25lbnQgd2l0aCBkZWZhdWx0IHNoYWxsb3cgZXF1YWxpdHkgY2hlY2sgZm9yIHNDVS5cbiAqL1xuXG5mdW5jdGlvbiBQdXJlQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDsgLy8gSWYgYSBjb21wb25lbnQgaGFzIHN0cmluZyByZWZzLCB3ZSB3aWxsIGFzc2lnbiBhIGRpZmZlcmVudCBvYmplY3QgbGF0ZXIuXG5cbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cbnZhciBwdXJlQ29tcG9uZW50UHJvdG90eXBlID0gUHVyZUNvbXBvbmVudC5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50RHVtbXkoKTtcbnB1cmVDb21wb25lbnRQcm90b3R5cGUuY29uc3RydWN0b3IgPSBQdXJlQ29tcG9uZW50OyAvLyBBdm9pZCBhbiBleHRyYSBwcm90b3R5cGUganVtcCBmb3IgdGhlc2UgbWV0aG9kcy5cblxuX2Fzc2lnbihwdXJlQ29tcG9uZW50UHJvdG90eXBlLCBDb21wb25lbnQucHJvdG90eXBlKTtcblxucHVyZUNvbXBvbmVudFByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCA9IHRydWU7XG5cbi8vIGFuIGltbXV0YWJsZSBvYmplY3Qgd2l0aCBhIHNpbmdsZSBtdXRhYmxlIHZhbHVlXG5mdW5jdGlvbiBjcmVhdGVSZWYoKSB7XG4gIHZhciByZWZPYmplY3QgPSB7XG4gICAgY3VycmVudDogbnVsbFxuICB9O1xuXG4gIHtcbiAgICBPYmplY3Quc2VhbChyZWZPYmplY3QpO1xuICB9XG5cbiAgcmV0dXJuIHJlZk9iamVjdDtcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XG4gIHJldHVybiBvdXRlclR5cGUuZGlzcGxheU5hbWUgfHwgKGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZSk7XG59XG5cbmZ1bmN0aW9uIGdldENvbnRleHROYW1lKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnO1xufVxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAge1xuICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgZXhwb3J0cy5GcmFnbWVudDpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgZXhwb3J0cy5Qcm9maWxlcjpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG4gICAgY2FzZSBleHBvcnRzLlN0cmljdE1vZGU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBleHBvcnRzLlN1c3BlbnNlOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSArICcuQ29uc3VtZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZSh0eXBlLnR5cGUpO1xuXG4gICAgICBjYXNlIFJFQUNUX0JMT0NLX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKHR5cGUuX3JlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duLCBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biwgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgY29uZmlnLl9fc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gY29uZmlnLl9fc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSkge1xuICAgICAgICBlcnJvcignQ29tcG9uZW50IFwiJXNcIiBjb250YWlucyB0aGUgc3RyaW5nIHJlZiBcIiVzXCIuICcgKyAnU3VwcG9ydCBmb3Igc3RyaW5nIHJlZnMgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuICcgKyAnVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gJyArICdXZSBhc2sgeW91IHRvIG1hbnVhbGx5IGZpeCB0aGlzIGNhc2UgYnkgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBjb21wb25lbnROYW1lLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxudmFyIFJlYWN0RWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn07XG4vKipcbiAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY3JlYXRlZWxlbWVudFxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodHlwZSwgY29uZmlnLCBjaGlsZHJlbikge1xuICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICB2YXIgcHJvcHMgPSB7fTtcbiAgdmFyIGtleSA9IG51bGw7XG4gIHZhciByZWYgPSBudWxsO1xuICB2YXIgc2VsZiA9IG51bGw7XG4gIHZhciBzb3VyY2UgPSBudWxsO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuXG4gICAgICB7XG4gICAgICAgIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgc2VsZiA9IGNvbmZpZy5fX3NlbGYgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zZWxmO1xuICAgIHNvdXJjZSA9IGNvbmZpZy5fX3NvdXJjZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NvdXJjZTsgLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cblxuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuXG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRBcnJheSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAge1xuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xufVxuZnVuY3Rpb24gY2xvbmVBbmRSZXBsYWNlS2V5KG9sZEVsZW1lbnQsIG5ld0tleSkge1xuICB2YXIgbmV3RWxlbWVudCA9IFJlYWN0RWxlbWVudChvbGRFbGVtZW50LnR5cGUsIG5ld0tleSwgb2xkRWxlbWVudC5yZWYsIG9sZEVsZW1lbnQuX3NlbGYsIG9sZEVsZW1lbnQuX3NvdXJjZSwgb2xkRWxlbWVudC5fb3duZXIsIG9sZEVsZW1lbnQucHJvcHMpO1xuICByZXR1cm4gbmV3RWxlbWVudDtcbn1cbi8qKlxuICogQ2xvbmUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgdXNpbmcgZWxlbWVudCBhcyB0aGUgc3RhcnRpbmcgcG9pbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2Nsb25lZWxlbWVudFxuICovXG5cbmZ1bmN0aW9uIGNsb25lRWxlbWVudChlbGVtZW50LCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIGlmICghIShlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IHVuZGVmaW5lZCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJSZWFjdC5jbG9uZUVsZW1lbnQoLi4uKTogVGhlIGFyZ3VtZW50IG11c3QgYmUgYSBSZWFjdCBlbGVtZW50LCBidXQgeW91IHBhc3NlZCBcIiArIGVsZW1lbnQgKyBcIi5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm9wTmFtZTsgLy8gT3JpZ2luYWwgcHJvcHMgYXJlIGNvcGllZFxuXG4gIHZhciBwcm9wcyA9IF9hc3NpZ24oe30sIGVsZW1lbnQucHJvcHMpOyAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG5cblxuICB2YXIga2V5ID0gZWxlbWVudC5rZXk7XG4gIHZhciByZWYgPSBlbGVtZW50LnJlZjsgLy8gU2VsZiBpcyBwcmVzZXJ2ZWQgc2luY2UgdGhlIG93bmVyIGlzIHByZXNlcnZlZC5cblxuICB2YXIgc2VsZiA9IGVsZW1lbnQuX3NlbGY7IC8vIFNvdXJjZSBpcyBwcmVzZXJ2ZWQgc2luY2UgY2xvbmVFbGVtZW50IGlzIHVubGlrZWx5IHRvIGJlIHRhcmdldGVkIGJ5IGFcbiAgLy8gdHJhbnNwaWxlciwgYW5kIHRoZSBvcmlnaW5hbCBzb3VyY2UgaXMgcHJvYmFibHkgYSBiZXR0ZXIgaW5kaWNhdG9yIG9mIHRoZVxuICAvLyB0cnVlIG93bmVyLlxuXG4gIHZhciBzb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7IC8vIE93bmVyIHdpbGwgYmUgcHJlc2VydmVkLCB1bmxlc3MgcmVmIGlzIG92ZXJyaWRkZW5cblxuICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgLy8gU2lsZW50bHkgc3RlYWwgdGhlIHJlZiBmcm9tIHRoZSBwYXJlbnQuXG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBvdmVycmlkZSBleGlzdGluZyBwcm9wc1xuXG5cbiAgICB2YXIgZGVmYXVsdFByb3BzO1xuXG4gICAgaWYgKGVsZW1lbnQudHlwZSAmJiBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICBkZWZhdWx0UHJvcHMgPSBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzO1xuICAgIH1cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIGlmIChjb25maWdbcHJvcE5hbWVdID09PSB1bmRlZmluZWQgJiYgZGVmYXVsdFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cblxuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuXG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cblxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfVxuXG4gIHJldHVybiBSZWFjdEVsZW1lbnQoZWxlbWVudC50eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn1cblxudmFyIFNFUEFSQVRPUiA9ICcuJztcbnZhciBTVUJTRVBBUkFUT1IgPSAnOic7XG4vKipcbiAqIEVzY2FwZSBhbmQgd3JhcCBrZXkgc28gaXQgaXMgc2FmZSB0byB1c2UgYXMgYSByZWFjdGlkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSB0byBiZSBlc2NhcGVkLlxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgZXNjYXBlZCBrZXkuXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlKGtleSkge1xuICB2YXIgZXNjYXBlUmVnZXggPSAvWz06XS9nO1xuICB2YXIgZXNjYXBlckxvb2t1cCA9IHtcbiAgICAnPSc6ICc9MCcsXG4gICAgJzonOiAnPTInXG4gIH07XG4gIHZhciBlc2NhcGVkU3RyaW5nID0ga2V5LnJlcGxhY2UoZXNjYXBlUmVnZXgsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHJldHVybiBlc2NhcGVyTG9va3VwW21hdGNoXTtcbiAgfSk7XG4gIHJldHVybiAnJCcgKyBlc2NhcGVkU3RyaW5nO1xufVxuLyoqXG4gKiBUT0RPOiBUZXN0IHRoYXQgYSBzaW5nbGUgY2hpbGQgYW5kIGFuIGFycmF5IHdpdGggb25lIGl0ZW0gaGF2ZSB0aGUgc2FtZSBrZXlcbiAqIHBhdHRlcm4uXG4gKi9cblxuXG52YXIgZGlkV2FybkFib3V0TWFwcyA9IGZhbHNlO1xudmFyIHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4ID0gL1xcLysvZztcblxuZnVuY3Rpb24gZXNjYXBlVXNlclByb3ZpZGVkS2V5KHRleHQpIHtcbiAgcmV0dXJuIHRleHQucmVwbGFjZSh1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCwgJyQmLycpO1xufVxuLyoqXG4gKiBHZW5lcmF0ZSBhIGtleSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIGEgZWxlbWVudCB3aXRoaW4gYSBzZXQuXG4gKlxuICogQHBhcmFtIHsqfSBlbGVtZW50IEEgZWxlbWVudCB0aGF0IGNvdWxkIGNvbnRhaW4gYSBtYW51YWwga2V5LlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IHRoYXQgaXMgdXNlZCBpZiBhIG1hbnVhbCBrZXkgaXMgbm90IHByb3ZpZGVkLlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5cblxuZnVuY3Rpb24gZ2V0RWxlbWVudEtleShlbGVtZW50LCBpbmRleCkge1xuICAvLyBEbyBzb21lIHR5cGVjaGVja2luZyBoZXJlIHNpbmNlIHdlIGNhbGwgdGhpcyBibGluZGx5LiBXZSB3YW50IHRvIGVuc3VyZVxuICAvLyB0aGF0IHdlIGRvbid0IGJsb2NrIHBvdGVudGlhbCBmdXR1cmUgRVMgQVBJcy5cbiAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnb2JqZWN0JyAmJiBlbGVtZW50ICE9PSBudWxsICYmIGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICAvLyBFeHBsaWNpdCBrZXlcbiAgICByZXR1cm4gZXNjYXBlKCcnICsgZWxlbWVudC5rZXkpO1xuICB9IC8vIEltcGxpY2l0IGtleSBkZXRlcm1pbmVkIGJ5IHRoZSBpbmRleCBpbiB0aGUgc2V0XG5cblxuICByZXR1cm4gaW5kZXgudG9TdHJpbmcoMzYpO1xufVxuXG5mdW5jdGlvbiBtYXBJbnRvQXJyYXkoY2hpbGRyZW4sIGFycmF5LCBlc2NhcGVkUHJlZml4LCBuYW1lU29GYXIsIGNhbGxiYWNrKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIGNoaWxkcmVuO1xuXG4gIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCB0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAvLyBBbGwgb2YgdGhlIGFib3ZlIGFyZSBwZXJjZWl2ZWQgYXMgbnVsbC5cbiAgICBjaGlsZHJlbiA9IG51bGw7XG4gIH1cblxuICB2YXIgaW52b2tlQ2FsbGJhY2sgPSBmYWxzZTtcblxuICBpZiAoY2hpbGRyZW4gPT09IG51bGwpIHtcbiAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgc3dpdGNoIChjaGlsZHJlbi4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gICAgICAgIH1cblxuICAgIH1cbiAgfVxuXG4gIGlmIChpbnZva2VDYWxsYmFjaykge1xuICAgIHZhciBfY2hpbGQgPSBjaGlsZHJlbjtcbiAgICB2YXIgbWFwcGVkQ2hpbGQgPSBjYWxsYmFjayhfY2hpbGQpOyAvLyBJZiBpdCdzIHRoZSBvbmx5IGNoaWxkLCB0cmVhdCB0aGUgbmFtZSBhcyBpZiBpdCB3YXMgd3JhcHBlZCBpbiBhbiBhcnJheVxuICAgIC8vIHNvIHRoYXQgaXQncyBjb25zaXN0ZW50IGlmIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gZ3Jvd3M6XG5cbiAgICB2YXIgY2hpbGRLZXkgPSBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SICsgZ2V0RWxlbWVudEtleShfY2hpbGQsIDApIDogbmFtZVNvRmFyO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkobWFwcGVkQ2hpbGQpKSB7XG4gICAgICB2YXIgZXNjYXBlZENoaWxkS2V5ID0gJyc7XG5cbiAgICAgIGlmIChjaGlsZEtleSAhPSBudWxsKSB7XG4gICAgICAgIGVzY2FwZWRDaGlsZEtleSA9IGVzY2FwZVVzZXJQcm92aWRlZEtleShjaGlsZEtleSkgKyAnLyc7XG4gICAgICB9XG5cbiAgICAgIG1hcEludG9BcnJheShtYXBwZWRDaGlsZCwgYXJyYXksIGVzY2FwZWRDaGlsZEtleSwgJycsIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBjO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChtYXBwZWRDaGlsZCAhPSBudWxsKSB7XG4gICAgICBpZiAoaXNWYWxpZEVsZW1lbnQobWFwcGVkQ2hpbGQpKSB7XG4gICAgICAgIG1hcHBlZENoaWxkID0gY2xvbmVBbmRSZXBsYWNlS2V5KG1hcHBlZENoaWxkLCAvLyBLZWVwIGJvdGggdGhlIChtYXBwZWQpIGFuZCBvbGQga2V5cyBpZiB0aGV5IGRpZmZlciwganVzdCBhc1xuICAgICAgICAvLyB0cmF2ZXJzZUFsbENoaWxkcmVuIHVzZWQgdG8gZG8gZm9yIG9iamVjdHMgYXMgY2hpbGRyZW5cbiAgICAgICAgZXNjYXBlZFByZWZpeCArICggLy8gJEZsb3dGaXhNZSBGbG93IGluY29ycmVjdGx5IHRoaW5rcyBSZWFjdC5Qb3J0YWwgZG9lc24ndCBoYXZlIGEga2V5XG4gICAgICAgIG1hcHBlZENoaWxkLmtleSAmJiAoIV9jaGlsZCB8fCBfY2hpbGQua2V5ICE9PSBtYXBwZWRDaGlsZC5rZXkpID8gLy8gJEZsb3dGaXhNZSBGbG93IGluY29ycmVjdGx5IHRoaW5rcyBleGlzdGluZyBlbGVtZW50J3Mga2V5IGNhbiBiZSBhIG51bWJlclxuICAgICAgICBlc2NhcGVVc2VyUHJvdmlkZWRLZXkoJycgKyBtYXBwZWRDaGlsZC5rZXkpICsgJy8nIDogJycpICsgY2hpbGRLZXkpO1xuICAgICAgfVxuXG4gICAgICBhcnJheS5wdXNoKG1hcHBlZENoaWxkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHZhciBjaGlsZDtcbiAgdmFyIG5leHROYW1lO1xuICB2YXIgc3VidHJlZUNvdW50ID0gMDsgLy8gQ291bnQgb2YgY2hpbGRyZW4gZm91bmQgaW4gdGhlIGN1cnJlbnQgc3VidHJlZS5cblxuICB2YXIgbmV4dE5hbWVQcmVmaXggPSBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SIDogbmFtZVNvRmFyICsgU1VCU0VQQVJBVE9SO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0RWxlbWVudEtleShjaGlsZCwgaSk7XG4gICAgICBzdWJ0cmVlQ291bnQgKz0gbWFwSW50b0FycmF5KGNoaWxkLCBhcnJheSwgZXNjYXBlZFByZWZpeCwgbmV4dE5hbWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKGNoaWxkcmVuKTtcblxuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIGl0ZXJhYmxlQ2hpbGRyZW4gPSBjaGlsZHJlbjtcblxuICAgICAge1xuICAgICAgICAvLyBXYXJuIGFib3V0IHVzaW5nIE1hcHMgYXMgY2hpbGRyZW5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gPT09IGl0ZXJhYmxlQ2hpbGRyZW4uZW50cmllcykge1xuICAgICAgICAgIGlmICghZGlkV2FybkFib3V0TWFwcykge1xuICAgICAgICAgICAgd2FybignVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ1VzZSBhbiBhcnJheSBvZiBrZXllZCBSZWFjdEVsZW1lbnRzIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKGl0ZXJhYmxlQ2hpbGRyZW4pO1xuICAgICAgdmFyIHN0ZXA7XG4gICAgICB2YXIgaWkgPSAwO1xuXG4gICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgIGNoaWxkID0gc3RlcC52YWx1ZTtcbiAgICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldEVsZW1lbnRLZXkoY2hpbGQsIGlpKyspO1xuICAgICAgICBzdWJ0cmVlQ291bnQgKz0gbWFwSW50b0FycmF5KGNoaWxkLCBhcnJheSwgZXNjYXBlZFByZWZpeCwgbmV4dE5hbWUsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgY2hpbGRyZW5TdHJpbmcgPSAnJyArIGNoaWxkcmVuO1xuXG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvciggXCJPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6IFwiICsgKGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZykgKyBcIikuIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgaW5zdGVhZC5cIiApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN1YnRyZWVDb3VudDtcbn1cblxuLyoqXG4gKiBNYXBzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5tYXBcbiAqXG4gKiBUaGUgcHJvdmlkZWQgbWFwRnVuY3Rpb24oY2hpbGQsIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZnVuYyBUaGUgbWFwIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IENvbnRleHQgZm9yIG1hcEZ1bmN0aW9uLlxuICogQHJldHVybiB7b2JqZWN0fSBPYmplY3QgY29udGFpbmluZyB0aGUgb3JkZXJlZCBtYXAgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmMsIGNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBjb3VudCA9IDA7XG4gIG1hcEludG9BcnJheShjaGlsZHJlbiwgcmVzdWx0LCAnJywgJycsIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgY2hpbGQsIGNvdW50KyspO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQ291bnQgdGhlIG51bWJlciBvZiBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzXG4gKiBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbmNvdW50XG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4uXG4gKi9cblxuXG5mdW5jdGlvbiBjb3VudENoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIHZhciBuID0gMDtcbiAgbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmN0aW9uICgpIHtcbiAgICBuKys7IC8vIERvbid0IHJldHVybiBhbnl0aGluZ1xuICB9KTtcbiAgcmV0dXJuIG47XG59XG5cbi8qKlxuICogSXRlcmF0ZXMgdGhyb3VnaCBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVuZm9yZWFjaFxuICpcbiAqIFRoZSBwcm92aWRlZCBmb3JFYWNoRnVuYyhjaGlsZCwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmb3JFYWNoRnVuY1xuICogQHBhcmFtIHsqfSBmb3JFYWNoQ29udGV4dCBDb250ZXh0IGZvciBmb3JFYWNoQ29udGV4dC5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpIHtcbiAgbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmN0aW9uICgpIHtcbiAgICBmb3JFYWNoRnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBEb24ndCByZXR1cm4gYW55dGhpbmcuXG4gIH0sIGZvckVhY2hDb250ZXh0KTtcbn1cbi8qKlxuICogRmxhdHRlbiBhIGNoaWxkcmVuIG9iamVjdCAodHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gKSBhbmRcbiAqIHJldHVybiBhbiBhcnJheSB3aXRoIGFwcHJvcHJpYXRlbHkgcmUta2V5ZWQgY2hpbGRyZW4uXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVudG9hcnJheVxuICovXG5cblxuZnVuY3Rpb24gdG9BcnJheShjaGlsZHJlbikge1xuICByZXR1cm4gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHJldHVybiBjaGlsZDtcbiAgfSkgfHwgW107XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGNoaWxkIGluIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiBhbmQgdmVyaWZpZXMgdGhhdCB0aGVyZVxuICogaXMgb25seSBvbmUgY2hpbGQgaW4gdGhlIGNvbGxlY3Rpb24uXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVub25seVxuICpcbiAqIFRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IGEgc2luZ2xlIGNoaWxkIGdldHNcbiAqIHBhc3NlZCB3aXRob3V0IGEgd3JhcHBlciwgYnV0IHRoZSBwdXJwb3NlIG9mIHRoaXMgaGVscGVyIGZ1bmN0aW9uIGlzIHRvXG4gKiBhYnN0cmFjdCBhd2F5IHRoZSBwYXJ0aWN1bGFyIHN0cnVjdHVyZSBvZiBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGNoaWxkcmVuIENoaWxkIGNvbGxlY3Rpb24gc3RydWN0dXJlLlxuICogQHJldHVybiB7UmVhY3RFbGVtZW50fSBUaGUgZmlyc3QgYW5kIG9ubHkgYFJlYWN0RWxlbWVudGAgY29udGFpbmVkIGluIHRoZVxuICogc3RydWN0dXJlLlxuICovXG5cblxuZnVuY3Rpb24gb25seUNoaWxkKGNoaWxkcmVuKSB7XG4gIGlmICghaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiUmVhY3QuQ2hpbGRyZW4ub25seSBleHBlY3RlZCB0byByZWNlaXZlIGEgc2luZ2xlIFJlYWN0IGVsZW1lbnQgY2hpbGQuXCIgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQoZGVmYXVsdFZhbHVlLCBjYWxjdWxhdGVDaGFuZ2VkQml0cykge1xuICBpZiAoY2FsY3VsYXRlQ2hhbmdlZEJpdHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGNhbGN1bGF0ZUNoYW5nZWRCaXRzID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICB7XG4gICAgICBpZiAoY2FsY3VsYXRlQ2hhbmdlZEJpdHMgIT09IG51bGwgJiYgdHlwZW9mIGNhbGN1bGF0ZUNoYW5nZWRCaXRzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVycm9yKCdjcmVhdGVDb250ZXh0OiBFeHBlY3RlZCB0aGUgb3B0aW9uYWwgc2Vjb25kIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMnLCBjYWxjdWxhdGVDaGFuZ2VkQml0cyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRleHQgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0NPTlRFWFRfVFlQRSxcbiAgICBfY2FsY3VsYXRlQ2hhbmdlZEJpdHM6IGNhbGN1bGF0ZUNoYW5nZWRCaXRzLFxuICAgIC8vIEFzIGEgd29ya2Fyb3VuZCB0byBzdXBwb3J0IG11bHRpcGxlIGNvbmN1cnJlbnQgcmVuZGVyZXJzLCB3ZSBjYXRlZ29yaXplXG4gICAgLy8gc29tZSByZW5kZXJlcnMgYXMgcHJpbWFyeSBhbmQgb3RoZXJzIGFzIHNlY29uZGFyeS4gV2Ugb25seSBleHBlY3RcbiAgICAvLyB0aGVyZSB0byBiZSB0d28gY29uY3VycmVudCByZW5kZXJlcnMgYXQgbW9zdDogUmVhY3QgTmF0aXZlIChwcmltYXJ5KSBhbmRcbiAgICAvLyBGYWJyaWMgKHNlY29uZGFyeSk7IFJlYWN0IERPTSAocHJpbWFyeSkgYW5kIFJlYWN0IEFSVCAoc2Vjb25kYXJ5KS5cbiAgICAvLyBTZWNvbmRhcnkgcmVuZGVyZXJzIHN0b3JlIHRoZWlyIGNvbnRleHQgdmFsdWVzIG9uIHNlcGFyYXRlIGZpZWxkcy5cbiAgICBfY3VycmVudFZhbHVlOiBkZWZhdWx0VmFsdWUsXG4gICAgX2N1cnJlbnRWYWx1ZTI6IGRlZmF1bHRWYWx1ZSxcbiAgICAvLyBVc2VkIHRvIHRyYWNrIGhvdyBtYW55IGNvbmN1cnJlbnQgcmVuZGVyZXJzIHRoaXMgY29udGV4dCBjdXJyZW50bHlcbiAgICAvLyBzdXBwb3J0cyB3aXRoaW4gaW4gYSBzaW5nbGUgcmVuZGVyZXIuIFN1Y2ggYXMgcGFyYWxsZWwgc2VydmVyIHJlbmRlcmluZy5cbiAgICBfdGhyZWFkQ291bnQ6IDAsXG4gICAgLy8gVGhlc2UgYXJlIGNpcmN1bGFyXG4gICAgUHJvdmlkZXI6IG51bGwsXG4gICAgQ29uc3VtZXI6IG51bGxcbiAgfTtcbiAgY29udGV4dC5Qcm92aWRlciA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfUFJPVklERVJfVFlQRSxcbiAgICBfY29udGV4dDogY29udGV4dFxuICB9O1xuICB2YXIgaGFzV2FybmVkQWJvdXRVc2luZ05lc3RlZENvbnRleHRDb25zdW1lcnMgPSBmYWxzZTtcbiAgdmFyIGhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lclByb3ZpZGVyID0gZmFsc2U7XG4gIHZhciBoYXNXYXJuZWRBYm91dERpc3BsYXlOYW1lT25Db25zdW1lciA9IGZhbHNlO1xuXG4gIHtcbiAgICAvLyBBIHNlcGFyYXRlIG9iamVjdCwgYnV0IHByb3hpZXMgYmFjayB0byB0aGUgb3JpZ2luYWwgY29udGV4dCBvYmplY3QgZm9yXG4gICAgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIEl0IGhhcyBhIGRpZmZlcmVudCAkJHR5cGVvZiwgc28gd2UgY2FuIHByb3Blcmx5XG4gICAgLy8gd2FybiBmb3IgdGhlIGluY29ycmVjdCB1c2FnZSBvZiBDb250ZXh0IGFzIGEgQ29uc3VtZXIuXG4gICAgdmFyIENvbnN1bWVyID0ge1xuICAgICAgJCR0eXBlb2Y6IFJFQUNUX0NPTlRFWFRfVFlQRSxcbiAgICAgIF9jb250ZXh0OiBjb250ZXh0LFxuICAgICAgX2NhbGN1bGF0ZUNoYW5nZWRCaXRzOiBjb250ZXh0Ll9jYWxjdWxhdGVDaGFuZ2VkQml0c1xuICAgIH07IC8vICRGbG93Rml4TWU6IEZsb3cgY29tcGxhaW5zIGFib3V0IG5vdCBzZXR0aW5nIGEgdmFsdWUsIHdoaWNoIGlzIGludGVudGlvbmFsIGhlcmVcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENvbnN1bWVyLCB7XG4gICAgICBQcm92aWRlcjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lclByb3ZpZGVyKSB7XG4gICAgICAgICAgICBoYXNXYXJuZWRBYm91dFVzaW5nQ29uc3VtZXJQcm92aWRlciA9IHRydWU7XG5cbiAgICAgICAgICAgIGVycm9yKCdSZW5kZXJpbmcgPENvbnRleHQuQ29uc3VtZXIuUHJvdmlkZXI+IGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byByZW5kZXIgPENvbnRleHQuUHJvdmlkZXI+IGluc3RlYWQ/Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuUHJvdmlkZXI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF9Qcm92aWRlcikge1xuICAgICAgICAgIGNvbnRleHQuUHJvdmlkZXIgPSBfUHJvdmlkZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfY3VycmVudFZhbHVlOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Ll9jdXJyZW50VmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF9jdXJyZW50VmFsdWUpIHtcbiAgICAgICAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUgPSBfY3VycmVudFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX2N1cnJlbnRWYWx1ZTI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF9jdXJyZW50VmFsdWUyKSB7XG4gICAgICAgICAgY29udGV4dC5fY3VycmVudFZhbHVlMiA9IF9jdXJyZW50VmFsdWUyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX3RocmVhZENvdW50OiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Ll90aHJlYWRDb3VudDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoX3RocmVhZENvdW50KSB7XG4gICAgICAgICAgY29udGV4dC5fdGhyZWFkQ291bnQgPSBfdGhyZWFkQ291bnQ7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBDb25zdW1lcjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0VXNpbmdOZXN0ZWRDb250ZXh0Q29uc3VtZXJzKSB7XG4gICAgICAgICAgICBoYXNXYXJuZWRBYm91dFVzaW5nTmVzdGVkQ29udGV4dENvbnN1bWVycyA9IHRydWU7XG5cbiAgICAgICAgICAgIGVycm9yKCdSZW5kZXJpbmcgPENvbnRleHQuQ29uc3VtZXIuQ29uc3VtZXI+IGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byByZW5kZXIgPENvbnRleHQuQ29uc3VtZXI+IGluc3RlYWQ/Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuQ29uc3VtZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkaXNwbGF5TmFtZToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5kaXNwbGF5TmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0RGlzcGxheU5hbWVPbkNvbnN1bWVyKSB7XG4gICAgICAgICAgICB3YXJuKCdTZXR0aW5nIGBkaXNwbGF5TmFtZWAgb24gQ29udGV4dC5Db25zdW1lciBoYXMgbm8gZWZmZWN0LiAnICsgXCJZb3Ugc2hvdWxkIHNldCBpdCBkaXJlY3RseSBvbiB0aGUgY29udGV4dCB3aXRoIENvbnRleHQuZGlzcGxheU5hbWUgPSAnJXMnLlwiLCBkaXNwbGF5TmFtZSk7XG5cbiAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0RGlzcGxheU5hbWVPbkNvbnN1bWVyID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTsgLy8gJEZsb3dGaXhNZTogRmxvdyBjb21wbGFpbnMgYWJvdXQgbWlzc2luZyBwcm9wZXJ0aWVzIGJlY2F1c2UgaXQgZG9lc24ndCB1bmRlcnN0YW5kIGRlZmluZVByb3BlcnR5XG5cbiAgICBjb250ZXh0LkNvbnN1bWVyID0gQ29uc3VtZXI7XG4gIH1cblxuICB7XG4gICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyID0gbnVsbDtcbiAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyID0gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBjb250ZXh0O1xufVxuXG52YXIgVW5pbml0aWFsaXplZCA9IC0xO1xudmFyIFBlbmRpbmcgPSAwO1xudmFyIFJlc29sdmVkID0gMTtcbnZhciBSZWplY3RlZCA9IDI7XG5cbmZ1bmN0aW9uIGxhenlJbml0aWFsaXplcihwYXlsb2FkKSB7XG4gIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFVuaW5pdGlhbGl6ZWQpIHtcbiAgICB2YXIgY3RvciA9IHBheWxvYWQuX3Jlc3VsdDtcbiAgICB2YXIgdGhlbmFibGUgPSBjdG9yKCk7IC8vIFRyYW5zaXRpb24gdG8gdGhlIG5leHQgc3RhdGUuXG5cbiAgICB2YXIgcGVuZGluZyA9IHBheWxvYWQ7XG4gICAgcGVuZGluZy5fc3RhdHVzID0gUGVuZGluZztcbiAgICBwZW5kaW5nLl9yZXN1bHQgPSB0aGVuYWJsZTtcbiAgICB0aGVuYWJsZS50aGVuKGZ1bmN0aW9uIChtb2R1bGVPYmplY3QpIHtcbiAgICAgIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFBlbmRpbmcpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRFeHBvcnQgPSBtb2R1bGVPYmplY3QuZGVmYXVsdDtcblxuICAgICAgICB7XG4gICAgICAgICAgaWYgKGRlZmF1bHRFeHBvcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXJyb3IoJ2xhenk6IEV4cGVjdGVkIHRoZSByZXN1bHQgb2YgYSBkeW5hbWljIGltcG9ydCgpIGNhbGwuICcgKyAnSW5zdGVhZCByZWNlaXZlZDogJXNcXG5cXG5Zb3VyIGNvZGUgc2hvdWxkIGxvb2sgbGlrZTogXFxuICAnICsgLy8gQnJlYWsgdXAgaW1wb3J0cyB0byBhdm9pZCBhY2NpZGVudGFsbHkgcGFyc2luZyB0aGVtIGFzIGRlcGVuZGVuY2llcy5cbiAgICAgICAgICAgICdjb25zdCBNeUNvbXBvbmVudCA9IGxhenkoKCkgPT4gaW1wJyArIFwib3J0KCcuL015Q29tcG9uZW50JykpXCIsIG1vZHVsZU9iamVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIFRyYW5zaXRpb24gdG8gdGhlIG5leHQgc3RhdGUuXG5cblxuICAgICAgICB2YXIgcmVzb2x2ZWQgPSBwYXlsb2FkO1xuICAgICAgICByZXNvbHZlZC5fc3RhdHVzID0gUmVzb2x2ZWQ7XG4gICAgICAgIHJlc29sdmVkLl9yZXN1bHQgPSBkZWZhdWx0RXhwb3J0O1xuICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gUGVuZGluZykge1xuICAgICAgICAvLyBUcmFuc2l0aW9uIHRvIHRoZSBuZXh0IHN0YXRlLlxuICAgICAgICB2YXIgcmVqZWN0ZWQgPSBwYXlsb2FkO1xuICAgICAgICByZWplY3RlZC5fc3RhdHVzID0gUmVqZWN0ZWQ7XG4gICAgICAgIHJlamVjdGVkLl9yZXN1bHQgPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFJlc29sdmVkKSB7XG4gICAgcmV0dXJuIHBheWxvYWQuX3Jlc3VsdDtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBwYXlsb2FkLl9yZXN1bHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGF6eShjdG9yKSB7XG4gIHZhciBwYXlsb2FkID0ge1xuICAgIC8vIFdlIHVzZSB0aGVzZSBmaWVsZHMgdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAgICBfc3RhdHVzOiAtMSxcbiAgICBfcmVzdWx0OiBjdG9yXG4gIH07XG4gIHZhciBsYXp5VHlwZSA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfTEFaWV9UWVBFLFxuICAgIF9wYXlsb2FkOiBwYXlsb2FkLFxuICAgIF9pbml0OiBsYXp5SW5pdGlhbGl6ZXJcbiAgfTtcblxuICB7XG4gICAgLy8gSW4gcHJvZHVjdGlvbiwgdGhpcyB3b3VsZCBqdXN0IHNldCBpdCBvbiB0aGUgb2JqZWN0LlxuICAgIHZhciBkZWZhdWx0UHJvcHM7XG4gICAgdmFyIHByb3BUeXBlczsgLy8gJEZsb3dGaXhNZVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMobGF6eVR5cGUsIHtcbiAgICAgIGRlZmF1bHRQcm9wczoge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBkZWZhdWx0UHJvcHM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld0RlZmF1bHRQcm9wcykge1xuICAgICAgICAgIGVycm9yKCdSZWFjdC5sYXp5KC4uLik6IEl0IGlzIG5vdCBzdXBwb3J0ZWQgdG8gYXNzaWduIGBkZWZhdWx0UHJvcHNgIHRvICcgKyAnYSBsYXp5IGNvbXBvbmVudCBpbXBvcnQuIEVpdGhlciBzcGVjaWZ5IHRoZW0gd2hlcmUgdGhlIGNvbXBvbmVudCAnICsgJ2lzIGRlZmluZWQsIG9yIGNyZWF0ZSBhIHdyYXBwaW5nIGNvbXBvbmVudCBhcm91bmQgaXQuJyk7XG5cbiAgICAgICAgICBkZWZhdWx0UHJvcHMgPSBuZXdEZWZhdWx0UHJvcHM7IC8vIE1hdGNoIHByb2R1Y3Rpb24gYmVoYXZpb3IgbW9yZSBjbG9zZWx5OlxuICAgICAgICAgIC8vICRGbG93Rml4TWVcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsYXp5VHlwZSwgJ2RlZmF1bHRQcm9wcycsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHByb3BUeXBlczoge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBwcm9wVHlwZXM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld1Byb3BUeXBlcykge1xuICAgICAgICAgIGVycm9yKCdSZWFjdC5sYXp5KC4uLik6IEl0IGlzIG5vdCBzdXBwb3J0ZWQgdG8gYXNzaWduIGBwcm9wVHlwZXNgIHRvICcgKyAnYSBsYXp5IGNvbXBvbmVudCBpbXBvcnQuIEVpdGhlciBzcGVjaWZ5IHRoZW0gd2hlcmUgdGhlIGNvbXBvbmVudCAnICsgJ2lzIGRlZmluZWQsIG9yIGNyZWF0ZSBhIHdyYXBwaW5nIGNvbXBvbmVudCBhcm91bmQgaXQuJyk7XG5cbiAgICAgICAgICBwcm9wVHlwZXMgPSBuZXdQcm9wVHlwZXM7IC8vIE1hdGNoIHByb2R1Y3Rpb24gYmVoYXZpb3IgbW9yZSBjbG9zZWx5OlxuICAgICAgICAgIC8vICRGbG93Rml4TWVcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsYXp5VHlwZSwgJ3Byb3BUeXBlcycsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGxhenlUeXBlO1xufVxuXG5mdW5jdGlvbiBmb3J3YXJkUmVmKHJlbmRlcikge1xuICB7XG4gICAgaWYgKHJlbmRlciAhPSBudWxsICYmIHJlbmRlci4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSB7XG4gICAgICBlcnJvcignZm9yd2FyZFJlZiByZXF1aXJlcyBhIHJlbmRlciBmdW5jdGlvbiBidXQgcmVjZWl2ZWQgYSBgbWVtb2AgJyArICdjb21wb25lbnQuIEluc3RlYWQgb2YgZm9yd2FyZFJlZihtZW1vKC4uLikpLCB1c2UgJyArICdtZW1vKGZvcndhcmRSZWYoLi4uKSkuJyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcmVuZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignZm9yd2FyZFJlZiByZXF1aXJlcyBhIHJlbmRlciBmdW5jdGlvbiBidXQgd2FzIGdpdmVuICVzLicsIHJlbmRlciA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiByZW5kZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocmVuZGVyLmxlbmd0aCAhPT0gMCAmJiByZW5kZXIubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlbmRlciBmdW5jdGlvbnMgYWNjZXB0IGV4YWN0bHkgdHdvIHBhcmFtZXRlcnM6IHByb3BzIGFuZCByZWYuICVzJywgcmVuZGVyLmxlbmd0aCA9PT0gMSA/ICdEaWQgeW91IGZvcmdldCB0byB1c2UgdGhlIHJlZiBwYXJhbWV0ZXI/JyA6ICdBbnkgYWRkaXRpb25hbCBwYXJhbWV0ZXIgd2lsbCBiZSB1bmRlZmluZWQuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlbmRlciAhPSBudWxsKSB7XG4gICAgICBpZiAocmVuZGVyLmRlZmF1bHRQcm9wcyAhPSBudWxsIHx8IHJlbmRlci5wcm9wVHlwZXMgIT0gbnVsbCkge1xuICAgICAgICBlcnJvcignZm9yd2FyZFJlZiByZW5kZXIgZnVuY3Rpb25zIGRvIG5vdCBzdXBwb3J0IHByb3BUeXBlcyBvciBkZWZhdWx0UHJvcHMuICcgKyAnRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyBhIFJlYWN0IGNvbXBvbmVudD8nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZWxlbWVudFR5cGUgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUsXG4gICAgcmVuZGVyOiByZW5kZXJcbiAgfTtcblxuICB7XG4gICAgdmFyIG93bk5hbWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnRUeXBlLCAnZGlzcGxheU5hbWUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gb3duTmFtZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIG93bk5hbWUgPSBuYW1lO1xuXG4gICAgICAgIGlmIChyZW5kZXIuZGlzcGxheU5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgIHJlbmRlci5kaXNwbGF5TmFtZSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50VHlwZTtcbn1cblxuLy8gRmlsdGVyIGNlcnRhaW4gRE9NIGF0dHJpYnV0ZXMgKGUuZy4gc3JjLCBocmVmKSBpZiB0aGVpciB2YWx1ZXMgYXJlIGVtcHR5IHN0cmluZ3MuXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBOb3RlOiB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyAoZS5nLiBpZiBpdCdzIGEgcG9seWZpbGwpLlxuXG5cbiAgaWYgKHR5cGUgPT09IGV4cG9ydHMuRnJhZ21lbnQgfHwgdHlwZSA9PT0gZXhwb3J0cy5Qcm9maWxlciB8fCB0eXBlID09PSBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSB8fCB0eXBlID09PSBleHBvcnRzLlN0cmljdE1vZGUgfHwgdHlwZSA9PT0gZXhwb3J0cy5TdXNwZW5zZSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0JMT0NLX1RZUEUgfHwgdHlwZVswXSA9PT0gUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbWVtbyh0eXBlLCBjb21wYXJlKSB7XG4gIHtcbiAgICBpZiAoIWlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSkge1xuICAgICAgZXJyb3IoJ21lbW86IFRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgY29tcG9uZW50LiBJbnN0ZWFkICcgKyAncmVjZWl2ZWQ6ICVzJywgdHlwZSA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiB0eXBlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZWxlbWVudFR5cGUgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX01FTU9fVFlQRSxcbiAgICB0eXBlOiB0eXBlLFxuICAgIGNvbXBhcmU6IGNvbXBhcmUgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb21wYXJlXG4gIH07XG5cbiAge1xuICAgIHZhciBvd25OYW1lO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50VHlwZSwgJ2Rpc3BsYXlOYW1lJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG93bk5hbWU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBvd25OYW1lID0gbmFtZTtcblxuICAgICAgICBpZiAodHlwZS5kaXNwbGF5TmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgdHlwZS5kaXNwbGF5TmFtZSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50VHlwZTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZURpc3BhdGNoZXIoKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50O1xuXG4gIGlmICghKGRpc3BhdGNoZXIgIT09IG51bGwpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiSW52YWxpZCBob29rIGNhbGwuIEhvb2tzIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgb2YgdGhlIGJvZHkgb2YgYSBmdW5jdGlvbiBjb21wb25lbnQuIFRoaXMgY291bGQgaGFwcGVuIGZvciBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbjEuIFlvdSBtaWdodCBoYXZlIG1pc21hdGNoaW5nIHZlcnNpb25zIG9mIFJlYWN0IGFuZCB0aGUgcmVuZGVyZXIgKHN1Y2ggYXMgUmVhY3QgRE9NKVxcbjIuIFlvdSBtaWdodCBiZSBicmVha2luZyB0aGUgUnVsZXMgb2YgSG9va3NcXG4zLiBZb3UgbWlnaHQgaGF2ZSBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QgaW4gdGhlIHNhbWUgYXBwXFxuU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9pbnZhbGlkLWhvb2stY2FsbCBmb3IgdGlwcyBhYm91dCBob3cgdG8gZGVidWcgYW5kIGZpeCB0aGlzIHByb2JsZW0uXCIgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGlzcGF0Y2hlcjtcbn1cblxuZnVuY3Rpb24gdXNlQ29udGV4dChDb250ZXh0LCB1bnN0YWJsZV9vYnNlcnZlZEJpdHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuXG4gIHtcbiAgICBpZiAodW5zdGFibGVfb2JzZXJ2ZWRCaXRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yKCd1c2VDb250ZXh0KCkgc2Vjb25kIGFyZ3VtZW50IGlzIHJlc2VydmVkIGZvciBmdXR1cmUgJyArICd1c2UgaW4gUmVhY3QuIFBhc3NpbmcgaXQgaXMgbm90IHN1cHBvcnRlZC4gJyArICdZb3UgcGFzc2VkOiAlcy4lcycsIHVuc3RhYmxlX29ic2VydmVkQml0cywgdHlwZW9mIHVuc3RhYmxlX29ic2VydmVkQml0cyA9PT0gJ251bWJlcicgJiYgQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMl0pID8gJ1xcblxcbkRpZCB5b3UgY2FsbCBhcnJheS5tYXAodXNlQ29udGV4dCk/ICcgKyAnQ2FsbGluZyBIb29rcyBpbnNpZGUgYSBsb29wIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnTGVhcm4gbW9yZSBhdCBodHRwczovL3JlYWN0anMub3JnL2xpbmsvcnVsZXMtb2YtaG9va3MnIDogJycpO1xuICAgIH0gLy8gVE9ETzogYWRkIGEgbW9yZSBnZW5lcmljIHdhcm5pbmcgZm9yIGludmFsaWQgdmFsdWVzLlxuXG5cbiAgICBpZiAoQ29udGV4dC5fY29udGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgcmVhbENvbnRleHQgPSBDb250ZXh0Ll9jb250ZXh0OyAvLyBEb24ndCBkZWR1cGxpY2F0ZSBiZWNhdXNlIHRoaXMgbGVnaXRpbWF0ZWx5IGNhdXNlcyBidWdzXG4gICAgICAvLyBhbmQgbm9ib2R5IHNob3VsZCBiZSB1c2luZyB0aGlzIGluIGV4aXN0aW5nIGNvZGUuXG5cbiAgICAgIGlmIChyZWFsQ29udGV4dC5Db25zdW1lciA9PT0gQ29udGV4dCkge1xuICAgICAgICBlcnJvcignQ2FsbGluZyB1c2VDb250ZXh0KENvbnRleHQuQ29uc3VtZXIpIGlzIG5vdCBzdXBwb3J0ZWQsIG1heSBjYXVzZSBidWdzLCBhbmQgd2lsbCBiZSAnICsgJ3JlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIGNhbGwgdXNlQ29udGV4dChDb250ZXh0KSBpbnN0ZWFkPycpO1xuICAgICAgfSBlbHNlIGlmIChyZWFsQ29udGV4dC5Qcm92aWRlciA9PT0gQ29udGV4dCkge1xuICAgICAgICBlcnJvcignQ2FsbGluZyB1c2VDb250ZXh0KENvbnRleHQuUHJvdmlkZXIpIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnRGlkIHlvdSBtZWFuIHRvIGNhbGwgdXNlQ29udGV4dChDb250ZXh0KSBpbnN0ZWFkPycpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUNvbnRleHQoQ29udGV4dCwgdW5zdGFibGVfb2JzZXJ2ZWRCaXRzKTtcbn1cbmZ1bmN0aW9uIHVzZVN0YXRlKGluaXRpYWxTdGF0ZSkge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZVN0YXRlKGluaXRpYWxTdGF0ZSk7XG59XG5mdW5jdGlvbiB1c2VSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xufVxuZnVuY3Rpb24gdXNlUmVmKGluaXRpYWxWYWx1ZSkge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZVJlZihpbml0aWFsVmFsdWUpO1xufVxuZnVuY3Rpb24gdXNlRWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUVmZmVjdChjcmVhdGUsIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VNZW1vKGNyZWF0ZSwgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZU1lbW8oY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZURlYnVnVmFsdWUodmFsdWUsIGZvcm1hdHRlckZuKSB7XG4gIHtcbiAgICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gICAgcmV0dXJuIGRpc3BhdGNoZXIudXNlRGVidWdWYWx1ZSh2YWx1ZSwgZm9ybWF0dGVyRm4pO1xuICB9XG59XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGxvZzogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZXYXJuXG4gICAgICAgIH0pLFxuICAgICAgICBlcnJvcjogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cEVuZDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xudmFyIHByZWZpeDtcbmZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG4gIC8vIElmIHNvbWV0aGluZyBhc2tlZCBmb3IgYSBzdGFjayBpbnNpZGUgYSBmYWtlIHJlbmRlciwgaXQgc2hvdWxkIGdldCBpZ25vcmVkLlxuICBpZiAoIWZuIHx8IHJlZW50cnkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB7XG4gICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xuXG4gICAgaWYgKGZyYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmcmFtZTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29udHJvbDtcbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWUgSXQgZG9lcyBhY2NlcHQgdW5kZWZpbmVkLlxuXG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdW5kZWZpbmVkO1xuICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyO1xuXG4gIHtcbiAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBzaG91bGQgYmUgc2V0dGluZyB0aGUgcHJvcHMgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lXG5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICBjb250cm9sID0geDtcbiAgICAgIH1cblxuICAgICAgZm4oKTtcbiAgICB9XG4gIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGUuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2wuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxuICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxuICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgYy0tO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG4gICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG4gICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBzLS07XG4gICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cblxuICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgICAgICAgIC8vIFY4IGFkZHMgYSBcIm5ld1wiIHByZWZpeCBmb3IgbmF0aXZlIGNsYXNzZXMuIExldCdzIHJlbW92ZSBpdCB0byBtYWtlIGl0IHByZXR0aWVyLlxuICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTtcblxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSwgc291cmNlLCBvd25lckZuKSB7XG5cbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUsIHNob3VsZENvbnN0cnVjdCh0eXBlKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh0eXBlKTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgZXhwb3J0cy5TdXNwZW5zZTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLnJlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAvLyBNZW1vIG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSwgc291cmNlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9CTE9DS19UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUuX3JlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQpIHtcbiAge1xuICAgIC8vICRGbG93Rml4TWUgVGhpcyBpcyBva2F5IGJ1dCBGbG93IGRvZXNuJ3Qga25vdyBpdC5cbiAgICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcigoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgKyAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICsgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLicpO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IkMSA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IkMSA9IGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgJiYgIShlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yJDEubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IkMS5tZXNzYWdlXSA9IHRydWU7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignRmFpbGVkICVzIHR5cGU6ICVzJywgbG9jYXRpb24sIGVycm9yJDEubWVzc2FnZSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBzZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XG5cbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKSB7XG4gIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG4gICAgdmFyIGxpbmVOdW1iZXIgPSBzb3VyY2UubGluZU51bWJlcjtcbiAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bUZvclByb3BzKGVsZW1lbnRQcm9wcykge1xuICBpZiAoZWxlbWVudFByb3BzICE9PSBudWxsICYmIGVsZW1lbnRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKGVsZW1lbnRQcm9wcy5fX3NvdXJjZSk7XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xuXG5cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgaWYgKCFpbmZvKSB7XG4gICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG5cbiAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgaW5mbyA9IFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnROYW1lICsgXCI+LlwiO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbmZvO1xufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlOyAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICB2YXIgY2hpbGRPd25lciA9ICcnO1xuXG4gIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgY2hpbGRPd25lciA9IFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgZ2V0Q29tcG9uZW50TmFtZShlbGVtZW50Ll9vd25lci50eXBlKSArIFwiLlwiO1xuICB9XG5cbiAge1xuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICBlcnJvcignRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLCBjaGlsZE93bmVyKTtcblxuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcbiAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xuICB7XG4gICAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG5cbiAgICBpZiAodHlwZSA9PT0gbnVsbCB8fCB0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKTtcbiAgICAgIGNoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgJ3Byb3AnLCBuYW1lLCBlbGVtZW50KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUuUHJvcFR5cGVzICE9PSB1bmRlZmluZWQgJiYgIXByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duKSB7XG4gICAgICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IHRydWU7IC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG5cbiAgICAgIHZhciBfbmFtZSA9IGdldENvbXBvbmVudE5hbWUodHlwZSk7XG5cbiAgICAgIGVycm9yKCdDb21wb25lbnQgJXMgZGVjbGFyZWQgYFByb3BUeXBlc2AgaW5zdGVhZCBvZiBgcHJvcFR5cGVzYC4gRGlkIHlvdSBtaXNzcGVsbCB0aGUgcHJvcGVydHkgYXNzaWdubWVudD8nLCBfbmFtZSB8fCAnVW5rbm93bicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdHlwZS5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicgJiYgIXR5cGUuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkKSB7XG4gICAgICBlcnJvcignZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhIGZyYWdtZW50LCB2YWxpZGF0ZSB0aGF0IGl0IGNhbiBvbmx5IGJlIHByb3ZpZGVkIHdpdGggZnJhZ21lbnQgcHJvcHNcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBmcmFnbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyYWdtZW50LnByb3BzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmIChrZXkgIT09ICdjaGlsZHJlbicgJiYga2V5ICE9PSAna2V5Jykge1xuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgIGVycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLicpO1xuXG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBjaGlsZHJlbikge1xuICB2YXIgdmFsaWRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpOyAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xuICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gIGlmICghdmFsaWRUeXBlKSB7XG4gICAgdmFyIGluZm8gPSAnJztcblxuICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgIH1cblxuICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW1Gb3JQcm9wcyhwcm9wcyk7XG5cbiAgICBpZiAoc291cmNlSW5mbykge1xuICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmZvICs9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICAgIH1cblxuICAgIHZhciB0eXBlU3RyaW5nO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlU3RyaW5nID0gJ2FycmF5JztcbiAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSBcIjxcIiArIChnZXRDb21wb25lbnROYW1lKHR5cGUudHlwZSkgfHwgJ1Vua25vd24nKSArIFwiIC8+XCI7XG4gICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGVTdHJpbmcgPSB0eXBlb2YgdHlwZTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBlcnJvcignUmVhY3QuY3JlYXRlRWxlbWVudDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgJyArICdidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlICcgKyAnY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlU3RyaW5nLCBpbmZvKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuXG4gIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfSAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgaWYgKHZhbGlkVHlwZSkge1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIHR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlID09PSBleHBvcnRzLkZyYWdtZW50KSB7XG4gICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG52YXIgZGlkV2FybkFib3V0RGVwcmVjYXRlZENyZWF0ZUZhY3RvcnkgPSBmYWxzZTtcbmZ1bmN0aW9uIGNyZWF0ZUZhY3RvcnlXaXRoVmFsaWRhdGlvbih0eXBlKSB7XG4gIHZhciB2YWxpZGF0ZWRGYWN0b3J5ID0gY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uLmJpbmQobnVsbCwgdHlwZSk7XG4gIHZhbGlkYXRlZEZhY3RvcnkudHlwZSA9IHR5cGU7XG5cbiAge1xuICAgIGlmICghZGlkV2FybkFib3V0RGVwcmVjYXRlZENyZWF0ZUZhY3RvcnkpIHtcbiAgICAgIGRpZFdhcm5BYm91dERlcHJlY2F0ZWRDcmVhdGVGYWN0b3J5ID0gdHJ1ZTtcblxuICAgICAgd2FybignUmVhY3QuY3JlYXRlRmFjdG9yeSgpIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIENvbnNpZGVyIHVzaW5nIEpTWCAnICsgJ29yIHVzZSBSZWFjdC5jcmVhdGVFbGVtZW50KCkgZGlyZWN0bHkgaW5zdGVhZC4nKTtcbiAgICB9IC8vIExlZ2FjeSBob29rOiByZW1vdmUgaXRcblxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbGlkYXRlZEZhY3RvcnksICd0eXBlJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2FybignRmFjdG9yeS50eXBlIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB0aGUgY2xhc3MgZGlyZWN0bHkgJyArICdiZWZvcmUgcGFzc2luZyBpdCB0byBjcmVhdGVGYWN0b3J5LicpO1xuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndHlwZScsIHtcbiAgICAgICAgICB2YWx1ZTogdHlwZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdmFsaWRhdGVkRmFjdG9yeTtcbn1cbmZ1bmN0aW9uIGNsb25lRWxlbWVudFdpdGhWYWxpZGF0aW9uKGVsZW1lbnQsIHByb3BzLCBjaGlsZHJlbikge1xuICB2YXIgbmV3RWxlbWVudCA9IGNsb25lRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCBuZXdFbGVtZW50LnR5cGUpO1xuICB9XG5cbiAgdmFsaWRhdGVQcm9wVHlwZXMobmV3RWxlbWVudCk7XG4gIHJldHVybiBuZXdFbGVtZW50O1xufVxuXG57XG5cbiAgdHJ5IHtcbiAgICB2YXIgZnJvemVuT2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tbmV3ICovXG5cbiAgICBuZXcgTWFwKFtbZnJvemVuT2JqZWN0LCBudWxsXV0pO1xuICAgIG5ldyBTZXQoW2Zyb3plbk9iamVjdF0pO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tbmV3ICovXG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxufVxuXG52YXIgY3JlYXRlRWxlbWVudCQxID0gIGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbiA7XG52YXIgY2xvbmVFbGVtZW50JDEgPSAgY2xvbmVFbGVtZW50V2l0aFZhbGlkYXRpb24gO1xudmFyIGNyZWF0ZUZhY3RvcnkgPSAgY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uIDtcbnZhciBDaGlsZHJlbiA9IHtcbiAgbWFwOiBtYXBDaGlsZHJlbixcbiAgZm9yRWFjaDogZm9yRWFjaENoaWxkcmVuLFxuICBjb3VudDogY291bnRDaGlsZHJlbixcbiAgdG9BcnJheTogdG9BcnJheSxcbiAgb25seTogb25seUNoaWxkXG59O1xuXG5leHBvcnRzLkNoaWxkcmVuID0gQ2hpbGRyZW47XG5leHBvcnRzLkNvbXBvbmVudCA9IENvbXBvbmVudDtcbmV4cG9ydHMuUHVyZUNvbXBvbmVudCA9IFB1cmVDb21wb25lbnQ7XG5leHBvcnRzLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEID0gUmVhY3RTaGFyZWRJbnRlcm5hbHM7XG5leHBvcnRzLmNsb25lRWxlbWVudCA9IGNsb25lRWxlbWVudCQxO1xuZXhwb3J0cy5jcmVhdGVDb250ZXh0ID0gY3JlYXRlQ29udGV4dDtcbmV4cG9ydHMuY3JlYXRlRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQkMTtcbmV4cG9ydHMuY3JlYXRlRmFjdG9yeSA9IGNyZWF0ZUZhY3Rvcnk7XG5leHBvcnRzLmNyZWF0ZVJlZiA9IGNyZWF0ZVJlZjtcbmV4cG9ydHMuZm9yd2FyZFJlZiA9IGZvcndhcmRSZWY7XG5leHBvcnRzLmlzVmFsaWRFbGVtZW50ID0gaXNWYWxpZEVsZW1lbnQ7XG5leHBvcnRzLmxhenkgPSBsYXp5O1xuZXhwb3J0cy5tZW1vID0gbWVtbztcbmV4cG9ydHMudXNlQ2FsbGJhY2sgPSB1c2VDYWxsYmFjaztcbmV4cG9ydHMudXNlQ29udGV4dCA9IHVzZUNvbnRleHQ7XG5leHBvcnRzLnVzZURlYnVnVmFsdWUgPSB1c2VEZWJ1Z1ZhbHVlO1xuZXhwb3J0cy51c2VFZmZlY3QgPSB1c2VFZmZlY3Q7XG5leHBvcnRzLnVzZUltcGVyYXRpdmVIYW5kbGUgPSB1c2VJbXBlcmF0aXZlSGFuZGxlO1xuZXhwb3J0cy51c2VMYXlvdXRFZmZlY3QgPSB1c2VMYXlvdXRFZmZlY3Q7XG5leHBvcnRzLnVzZU1lbW8gPSB1c2VNZW1vO1xuZXhwb3J0cy51c2VSZWR1Y2VyID0gdXNlUmVkdWNlcjtcbmV4cG9ydHMudXNlUmVmID0gdXNlUmVmO1xuZXhwb3J0cy51c2VTdGF0ZSA9IHVzZVN0YXRlO1xuZXhwb3J0cy52ZXJzaW9uID0gUmVhY3RWZXJzaW9uO1xuICB9KSgpO1xufVxuIiwgIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcycpO1xufVxuIiwgImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuZXhwb3J0IHsgUmVhY3QgfTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxudmFyIGRlZmF1bHRQYXJzZU9wdGlvbnMgPSB7XG4gIGRlY29kZVZhbHVlczogdHJ1ZSxcbiAgbWFwOiBmYWxzZSxcbiAgc2lsZW50OiBmYWxzZSxcbn07XG5cbmZ1bmN0aW9uIGlzTm9uRW1wdHlTdHJpbmcoc3RyKSB7XG4gIHJldHVybiB0eXBlb2Ygc3RyID09PSBcInN0cmluZ1wiICYmICEhc3RyLnRyaW0oKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VTdHJpbmcoc2V0Q29va2llVmFsdWUsIG9wdGlvbnMpIHtcbiAgdmFyIHBhcnRzID0gc2V0Q29va2llVmFsdWUuc3BsaXQoXCI7XCIpLmZpbHRlcihpc05vbkVtcHR5U3RyaW5nKTtcbiAgdmFyIG5hbWVWYWx1ZSA9IHBhcnRzLnNoaWZ0KCkuc3BsaXQoXCI9XCIpO1xuICB2YXIgbmFtZSA9IG5hbWVWYWx1ZS5zaGlmdCgpO1xuICB2YXIgdmFsdWUgPSBuYW1lVmFsdWUuam9pbihcIj1cIik7IC8vIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0ID0sIGpvaW5lZCBieSBhIFwiPVwiIGlmIHRoZXJlIHdhcyBtb3JlIHRoYW4gb25lIHBhcnRcblxuICBvcHRpb25zID0gb3B0aW9uc1xuICAgID8gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFBhcnNlT3B0aW9ucywgb3B0aW9ucylcbiAgICA6IGRlZmF1bHRQYXJzZU9wdGlvbnM7XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZSA9IG9wdGlvbnMuZGVjb2RlVmFsdWVzID8gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSA6IHZhbHVlOyAvLyBkZWNvZGUgY29va2llIHZhbHVlXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmVycm9yKFxuICAgICAgXCJzZXQtY29va2llLXBhcnNlciBlbmNvdW50ZXJlZCBhbiBlcnJvciB3aGlsZSBkZWNvZGluZyBhIGNvb2tpZSB3aXRoIHZhbHVlICdcIiArXG4gICAgICAgIHZhbHVlICtcbiAgICAgICAgXCInLiBTZXQgb3B0aW9ucy5kZWNvZGVWYWx1ZXMgdG8gZmFsc2UgdG8gZGlzYWJsZSB0aGlzIGZlYXR1cmUuXCIsXG4gICAgICBlXG4gICAgKTtcbiAgfVxuXG4gIHZhciBjb29raWUgPSB7XG4gICAgbmFtZTogbmFtZSwgLy8gZ3JhYiBldmVyeXRoaW5nIGJlZm9yZSB0aGUgZmlyc3QgPVxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgfTtcblxuICBwYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgdmFyIHNpZGVzID0gcGFydC5zcGxpdChcIj1cIik7XG4gICAgdmFyIGtleSA9IHNpZGVzLnNoaWZ0KCkudHJpbUxlZnQoKS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciB2YWx1ZSA9IHNpZGVzLmpvaW4oXCI9XCIpO1xuICAgIGlmIChrZXkgPT09IFwiZXhwaXJlc1wiKSB7XG4gICAgICBjb29raWUuZXhwaXJlcyA9IG5ldyBEYXRlKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJtYXgtYWdlXCIpIHtcbiAgICAgIGNvb2tpZS5tYXhBZ2UgPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcInNlY3VyZVwiKSB7XG4gICAgICBjb29raWUuc2VjdXJlID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJodHRwb25seVwiKSB7XG4gICAgICBjb29raWUuaHR0cE9ubHkgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcInNhbWVzaXRlXCIpIHtcbiAgICAgIGNvb2tpZS5zYW1lU2l0ZSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb29raWVba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGNvb2tpZTtcbn1cblxuZnVuY3Rpb24gcGFyc2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnNcbiAgICA/IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRQYXJzZU9wdGlvbnMsIG9wdGlvbnMpXG4gICAgOiBkZWZhdWx0UGFyc2VPcHRpb25zO1xuXG4gIGlmICghaW5wdXQpIHtcbiAgICBpZiAoIW9wdGlvbnMubWFwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH1cblxuICBpZiAoaW5wdXQuaGVhZGVycyAmJiBpbnB1dC5oZWFkZXJzW1wic2V0LWNvb2tpZVwiXSkge1xuICAgIC8vIGZhc3QtcGF0aCBmb3Igbm9kZS5qcyAod2hpY2ggYXV0b21hdGljYWxseSBub3JtYWxpemVzIGhlYWRlciBuYW1lcyB0byBsb3dlci1jYXNlXG4gICAgaW5wdXQgPSBpbnB1dC5oZWFkZXJzW1wic2V0LWNvb2tpZVwiXTtcbiAgfSBlbHNlIGlmIChpbnB1dC5oZWFkZXJzKSB7XG4gICAgLy8gc2xvdy1wYXRoIGZvciBvdGhlciBlbnZpcm9ubWVudHMgLSBzZWUgIzI1XG4gICAgdmFyIHNjaCA9XG4gICAgICBpbnB1dC5oZWFkZXJzW1xuICAgICAgICBPYmplY3Qua2V5cyhpbnB1dC5oZWFkZXJzKS5maW5kKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICByZXR1cm4ga2V5LnRvTG93ZXJDYXNlKCkgPT09IFwic2V0LWNvb2tpZVwiO1xuICAgICAgICB9KVxuICAgICAgXTtcbiAgICAvLyB3YXJuIGlmIGNhbGxlZCBvbiBhIHJlcXVlc3QtbGlrZSBvYmplY3Qgd2l0aCBhIGNvb2tpZSBoZWFkZXIgcmF0aGVyIHRoYW4gYSBzZXQtY29va2llIGhlYWRlciAtIHNlZSAjMzQsIDM2XG4gICAgaWYgKCFzY2ggJiYgaW5wdXQuaGVhZGVycy5jb29raWUgJiYgIW9wdGlvbnMuc2lsZW50KSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIFwiV2FybmluZzogc2V0LWNvb2tpZS1wYXJzZXIgYXBwZWFycyB0byBoYXZlIGJlZW4gY2FsbGVkIG9uIGEgcmVxdWVzdCBvYmplY3QuIEl0IGlzIGRlc2lnbmVkIHRvIHBhcnNlIFNldC1Db29raWUgaGVhZGVycyBmcm9tIHJlc3BvbnNlcywgbm90IENvb2tpZSBoZWFkZXJzIGZyb20gcmVxdWVzdHMuIFNldCB0aGUgb3B0aW9uIHtzaWxlbnQ6IHRydWV9IHRvIHN1cHByZXNzIHRoaXMgd2FybmluZy5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgaW5wdXQgPSBzY2g7XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgIGlucHV0ID0gW2lucHV0XTtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zXG4gICAgPyBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0UGFyc2VPcHRpb25zLCBvcHRpb25zKVxuICAgIDogZGVmYXVsdFBhcnNlT3B0aW9ucztcblxuICBpZiAoIW9wdGlvbnMubWFwKSB7XG4gICAgcmV0dXJuIGlucHV0LmZpbHRlcihpc05vbkVtcHR5U3RyaW5nKS5tYXAoZnVuY3Rpb24gKHN0cikge1xuICAgICAgcmV0dXJuIHBhcnNlU3RyaW5nKHN0ciwgb3B0aW9ucyk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvb2tpZXMgPSB7fTtcbiAgICByZXR1cm4gaW5wdXQuZmlsdGVyKGlzTm9uRW1wdHlTdHJpbmcpLnJlZHVjZShmdW5jdGlvbiAoY29va2llcywgc3RyKSB7XG4gICAgICB2YXIgY29va2llID0gcGFyc2VTdHJpbmcoc3RyLCBvcHRpb25zKTtcbiAgICAgIGNvb2tpZXNbY29va2llLm5hbWVdID0gY29va2llO1xuICAgICAgcmV0dXJuIGNvb2tpZXM7XG4gICAgfSwgY29va2llcyk7XG4gIH1cbn1cblxuLypcbiAgU2V0LUNvb2tpZSBoZWFkZXIgZmllbGQtdmFsdWVzIGFyZSBzb21ldGltZXMgY29tbWEgam9pbmVkIGluIG9uZSBzdHJpbmcuIFRoaXMgc3BsaXRzIHRoZW0gd2l0aG91dCBjaG9raW5nIG9uIGNvbW1hc1xuICB0aGF0IGFyZSB3aXRoaW4gYSBzaW5nbGUgc2V0LWNvb2tpZSBmaWVsZC12YWx1ZSwgc3VjaCBhcyBpbiB0aGUgRXhwaXJlcyBwb3J0aW9uLlxuXG4gIFRoaXMgaXMgdW5jb21tb24sIGJ1dCBleHBsaWNpdGx5IGFsbG93ZWQgLSBzZWUgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzI2MTYjc2VjdGlvbi00LjJcbiAgTm9kZS5qcyBkb2VzIHRoaXMgZm9yIGV2ZXJ5IGhlYWRlciAqZXhjZXB0KiBzZXQtY29va2llIC0gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL2Q1ZTM2M2I3N2ViYWYxY2FmNjdjZDc1MjgyMjRiNjUxYzg2ODE1YzEvbGliL19odHRwX2luY29taW5nLmpzI0wxMjhcbiAgUmVhY3QgTmF0aXZlJ3MgZmV0Y2ggZG9lcyB0aGlzIGZvciAqZXZlcnkqIGhlYWRlciwgaW5jbHVkaW5nIHNldC1jb29raWUuXG5cbiAgQmFzZWQgb246IGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvajJvYmpjL2NvbW1pdC8xNjgyMGZkYmM4Zjc2Y2EwYzMzNDcyODEwY2UwY2IwM2QyMGVmZTI1XG4gIENyZWRpdHMgdG86IGh0dHBzOi8vZ2l0aHViLmNvbS90b21iYWxsIGZvciBvcmlnaW5hbCBhbmQgaHR0cHM6Ly9naXRodWIuY29tL2NocnVzYXJ0IGZvciBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uXG4qL1xuZnVuY3Rpb24gc3BsaXRDb29raWVzU3RyaW5nKGNvb2tpZXNTdHJpbmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY29va2llc1N0cmluZykpIHtcbiAgICByZXR1cm4gY29va2llc1N0cmluZztcbiAgfVxuICBpZiAodHlwZW9mIGNvb2tpZXNTdHJpbmcgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgY29va2llc1N0cmluZ3MgPSBbXTtcbiAgdmFyIHBvcyA9IDA7XG4gIHZhciBzdGFydDtcbiAgdmFyIGNoO1xuICB2YXIgbGFzdENvbW1hO1xuICB2YXIgbmV4dFN0YXJ0O1xuICB2YXIgY29va2llc1NlcGFyYXRvckZvdW5kO1xuXG4gIGZ1bmN0aW9uIHNraXBXaGl0ZXNwYWNlKCkge1xuICAgIHdoaWxlIChwb3MgPCBjb29raWVzU3RyaW5nLmxlbmd0aCAmJiAvXFxzLy50ZXN0KGNvb2tpZXNTdHJpbmcuY2hhckF0KHBvcykpKSB7XG4gICAgICBwb3MgKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHBvcyA8IGNvb2tpZXNTdHJpbmcubGVuZ3RoO1xuICB9XG5cbiAgZnVuY3Rpb24gbm90U3BlY2lhbENoYXIoKSB7XG4gICAgY2ggPSBjb29raWVzU3RyaW5nLmNoYXJBdChwb3MpO1xuXG4gICAgcmV0dXJuIGNoICE9PSBcIj1cIiAmJiBjaCAhPT0gXCI7XCIgJiYgY2ggIT09IFwiLFwiO1xuICB9XG5cbiAgd2hpbGUgKHBvcyA8IGNvb2tpZXNTdHJpbmcubGVuZ3RoKSB7XG4gICAgc3RhcnQgPSBwb3M7XG4gICAgY29va2llc1NlcGFyYXRvckZvdW5kID0gZmFsc2U7XG5cbiAgICB3aGlsZSAoc2tpcFdoaXRlc3BhY2UoKSkge1xuICAgICAgY2ggPSBjb29raWVzU3RyaW5nLmNoYXJBdChwb3MpO1xuICAgICAgaWYgKGNoID09PSBcIixcIikge1xuICAgICAgICAvLyAnLCcgaXMgYSBjb29raWUgc2VwYXJhdG9yIGlmIHdlIGhhdmUgbGF0ZXIgZmlyc3QgJz0nLCBub3QgJzsnIG9yICcsJ1xuICAgICAgICBsYXN0Q29tbWEgPSBwb3M7XG4gICAgICAgIHBvcyArPSAxO1xuXG4gICAgICAgIHNraXBXaGl0ZXNwYWNlKCk7XG4gICAgICAgIG5leHRTdGFydCA9IHBvcztcblxuICAgICAgICB3aGlsZSAocG9zIDwgY29va2llc1N0cmluZy5sZW5ndGggJiYgbm90U3BlY2lhbENoYXIoKSkge1xuICAgICAgICAgIHBvcyArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3VycmVudGx5IHNwZWNpYWwgY2hhcmFjdGVyXG4gICAgICAgIGlmIChwb3MgPCBjb29raWVzU3RyaW5nLmxlbmd0aCAmJiBjb29raWVzU3RyaW5nLmNoYXJBdChwb3MpID09PSBcIj1cIikge1xuICAgICAgICAgIC8vIHdlIGZvdW5kIGNvb2tpZXMgc2VwYXJhdG9yXG4gICAgICAgICAgY29va2llc1NlcGFyYXRvckZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAvLyBwb3MgaXMgaW5zaWRlIHRoZSBuZXh0IGNvb2tpZSwgc28gYmFjayB1cCBhbmQgcmV0dXJuIGl0LlxuICAgICAgICAgIHBvcyA9IG5leHRTdGFydDtcbiAgICAgICAgICBjb29raWVzU3RyaW5ncy5wdXNoKGNvb2tpZXNTdHJpbmcuc3Vic3RyaW5nKHN0YXJ0LCBsYXN0Q29tbWEpKTtcbiAgICAgICAgICBzdGFydCA9IHBvcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpbiBwYXJhbSAnLCcgb3IgcGFyYW0gc2VwYXJhdG9yICc7JyxcbiAgICAgICAgICAvLyB3ZSBjb250aW51ZSBmcm9tIHRoYXQgY29tbWFcbiAgICAgICAgICBwb3MgPSBsYXN0Q29tbWEgKyAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3MgKz0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWNvb2tpZXNTZXBhcmF0b3JGb3VuZCB8fCBwb3MgPj0gY29va2llc1N0cmluZy5sZW5ndGgpIHtcbiAgICAgIGNvb2tpZXNTdHJpbmdzLnB1c2goY29va2llc1N0cmluZy5zdWJzdHJpbmcoc3RhcnQsIGNvb2tpZXNTdHJpbmcubGVuZ3RoKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvb2tpZXNTdHJpbmdzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlO1xubW9kdWxlLmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbm1vZHVsZS5leHBvcnRzLnBhcnNlU3RyaW5nID0gcGFyc2VTdHJpbmc7XG5tb2R1bGUuZXhwb3J0cy5zcGxpdENvb2tpZXNTdHJpbmcgPSBzcGxpdENvb2tpZXNTdHJpbmc7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBvYmplY3QgPSB7fTtcbmNvbnN0IGhhc093blByb3BlcnR5ID0gb2JqZWN0Lmhhc093blByb3BlcnR5O1xuY29uc3QgZm9yT3duID0gKG9iamVjdCwgY2FsbGJhY2spID0+IHtcblx0Zm9yIChjb25zdCBrZXkgaW4gb2JqZWN0KSB7XG5cdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG5cdFx0XHRjYWxsYmFjayhrZXksIG9iamVjdFtrZXldKTtcblx0XHR9XG5cdH1cbn07XG5cbmNvbnN0IGV4dGVuZCA9IChkZXN0aW5hdGlvbiwgc291cmNlKSA9PiB7XG5cdGlmICghc291cmNlKSB7XG5cdFx0cmV0dXJuIGRlc3RpbmF0aW9uO1xuXHR9XG5cdGZvck93bihzb3VyY2UsIChrZXksIHZhbHVlKSA9PiB7XG5cdFx0ZGVzdGluYXRpb25ba2V5XSA9IHZhbHVlO1xuXHR9KTtcblx0cmV0dXJuIGRlc3RpbmF0aW9uO1xufTtcblxuY29uc3QgZm9yRWFjaCA9IChhcnJheSwgY2FsbGJhY2spID0+IHtcblx0Y29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRsZXQgaW5kZXggPSAtMTtcblx0d2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0XHRjYWxsYmFjayhhcnJheVtpbmRleF0pO1xuXHR9XG59O1xuXG5jb25zdCBmb3VySGV4RXNjYXBlID0gKGhleCkgPT4ge1xuXHRyZXR1cm4gJ1xcXFx1JyArICgnMDAwMCcgKyBoZXgpLnNsaWNlKC00KTtcbn1cblxuY29uc3QgaGV4YWRlY2ltYWwgPSAoY29kZSwgbG93ZXJjYXNlKSA9PiB7XG5cdGxldCBoZXhhZGVjaW1hbCA9IGNvZGUudG9TdHJpbmcoMTYpO1xuXHRpZiAobG93ZXJjYXNlKSByZXR1cm4gaGV4YWRlY2ltYWw7XG5cdHJldHVybiBoZXhhZGVjaW1hbC50b1VwcGVyQ2FzZSgpO1xufTtcblxuY29uc3QgdG9TdHJpbmcgPSBvYmplY3QudG9TdHJpbmc7XG5jb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbmNvbnN0IGlzQnVmZmVyID0gKHZhbHVlKSA9PiB7XG5cdHJldHVybiB0eXBlb2YgQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSk7XG59O1xuY29uc3QgaXNPYmplY3QgPSAodmFsdWUpID0+IHtcblx0Ly8gVGhpcyBpcyBhIHZlcnkgc2ltcGxlIGNoZWNrLCBidXQgaXRcdTIwMTlzIGdvb2QgZW5vdWdoIGZvciB3aGF0IHdlIG5lZWQuXG5cdHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSAnW29iamVjdCBPYmplY3RdJztcbn07XG5jb25zdCBpc1N0cmluZyA9ICh2YWx1ZSkgPT4ge1xuXHRyZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8XG5cdFx0dG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gJ1tvYmplY3QgU3RyaW5nXSc7XG59O1xuY29uc3QgaXNOdW1iZXIgPSAodmFsdWUpID0+IHtcblx0cmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fFxuXHRcdHRvU3RyaW5nLmNhbGwodmFsdWUpID09ICdbb2JqZWN0IE51bWJlcl0nO1xufTtcbmNvbnN0IGlzRnVuY3Rpb24gPSAodmFsdWUpID0+IHtcblx0cmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nO1xufTtcbmNvbnN0IGlzTWFwID0gKHZhbHVlKSA9PiB7XG5cdHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSAnW29iamVjdCBNYXBdJztcbn07XG5jb25zdCBpc1NldCA9ICh2YWx1ZSkgPT4ge1xuXHRyZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gJ1tvYmplY3QgU2V0XSc7XG59O1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuLy8gaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZXNjYXBlcyNzaW5nbGVcbmNvbnN0IHNpbmdsZUVzY2FwZXMgPSB7XG5cdCdcXFxcJzogJ1xcXFxcXFxcJyxcblx0J1xcYic6ICdcXFxcYicsXG5cdCdcXGYnOiAnXFxcXGYnLFxuXHQnXFxuJzogJ1xcXFxuJyxcblx0J1xccic6ICdcXFxccicsXG5cdCdcXHQnOiAnXFxcXHQnXG5cdC8vIGBcXHZgIGlzIG9taXR0ZWQgaW50ZW50aW9uYWxseSwgYmVjYXVzZSBpbiBJRSA8IDksICdcXHYnID09ICd2Jy5cblx0Ly8gJ1xcdic6ICdcXFxceDBCJ1xufTtcbmNvbnN0IHJlZ2V4U2luZ2xlRXNjYXBlID0gL1tcXFxcXFxiXFxmXFxuXFxyXFx0XS87XG5cbmNvbnN0IHJlZ2V4RGlnaXQgPSAvWzAtOV0vO1xuY29uc3QgcmVnZXhXaGl0ZXNwYWNlID0gL1tcXHhBMFxcdTE2ODBcXHUyMDAwLVxcdTIwMEFcXHUyMDI4XFx1MjAyOVxcdTIwMkZcXHUyMDVGXFx1MzAwMF0vO1xuXG5jb25zdCBlc2NhcGVFdmVyeXRoaW5nUmVnZXggPSAvKFtcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl0pfChbXFx1RDgwMC1cXHVERkZGXSl8KFsnXCJgXSl8W15dL2c7XG5jb25zdCBlc2NhcGVOb25Bc2NpaVJlZ2V4ID0gLyhbXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdKXwoW1xcdUQ4MDAtXFx1REZGRl0pfChbJ1wiYF0pfFteICEjLSZcXCgtXFxbXFxdLV9hLX5dL2c7XG5cbmNvbnN0IGpzZXNjID0gKGFyZ3VtZW50LCBvcHRpb25zKSA9PiB7XG5cdGNvbnN0IGluY3JlYXNlSW5kZW50YXRpb24gPSAoKSA9PiB7XG5cdFx0b2xkSW5kZW50ID0gaW5kZW50O1xuXHRcdCsrb3B0aW9ucy5pbmRlbnRMZXZlbDtcblx0XHRpbmRlbnQgPSBvcHRpb25zLmluZGVudC5yZXBlYXQob3B0aW9ucy5pbmRlbnRMZXZlbClcblx0fTtcblx0Ly8gSGFuZGxlIG9wdGlvbnNcblx0Y29uc3QgZGVmYXVsdHMgPSB7XG5cdFx0J2VzY2FwZUV2ZXJ5dGhpbmcnOiBmYWxzZSxcblx0XHQnbWluaW1hbCc6IGZhbHNlLFxuXHRcdCdpc1NjcmlwdENvbnRleHQnOiBmYWxzZSxcblx0XHQncXVvdGVzJzogJ3NpbmdsZScsXG5cdFx0J3dyYXAnOiBmYWxzZSxcblx0XHQnZXM2JzogZmFsc2UsXG5cdFx0J2pzb24nOiBmYWxzZSxcblx0XHQnY29tcGFjdCc6IHRydWUsXG5cdFx0J2xvd2VyY2FzZUhleCc6IGZhbHNlLFxuXHRcdCdudW1iZXJzJzogJ2RlY2ltYWwnLFxuXHRcdCdpbmRlbnQnOiAnXFx0Jyxcblx0XHQnaW5kZW50TGV2ZWwnOiAwLFxuXHRcdCdfX2lubGluZTFfXyc6IGZhbHNlLFxuXHRcdCdfX2lubGluZTJfXyc6IGZhbHNlXG5cdH07XG5cdGNvbnN0IGpzb24gPSBvcHRpb25zICYmIG9wdGlvbnMuanNvbjtcblx0aWYgKGpzb24pIHtcblx0XHRkZWZhdWx0cy5xdW90ZXMgPSAnZG91YmxlJztcblx0XHRkZWZhdWx0cy53cmFwID0gdHJ1ZTtcblx0fVxuXHRvcHRpb25zID0gZXh0ZW5kKGRlZmF1bHRzLCBvcHRpb25zKTtcblx0aWYgKFxuXHRcdG9wdGlvbnMucXVvdGVzICE9ICdzaW5nbGUnICYmXG5cdFx0b3B0aW9ucy5xdW90ZXMgIT0gJ2RvdWJsZScgJiZcblx0XHRvcHRpb25zLnF1b3RlcyAhPSAnYmFja3RpY2snXG5cdCkge1xuXHRcdG9wdGlvbnMucXVvdGVzID0gJ3NpbmdsZSc7XG5cdH1cblx0Y29uc3QgcXVvdGUgPSBvcHRpb25zLnF1b3RlcyA9PSAnZG91YmxlJyA/XG5cdFx0J1wiJyA6XG5cdFx0KG9wdGlvbnMucXVvdGVzID09ICdiYWNrdGljaycgP1xuXHRcdFx0J2AnIDpcblx0XHRcdCdcXCcnXG5cdFx0KTtcblx0Y29uc3QgY29tcGFjdCA9IG9wdGlvbnMuY29tcGFjdDtcblx0Y29uc3QgbG93ZXJjYXNlSGV4ID0gb3B0aW9ucy5sb3dlcmNhc2VIZXg7XG5cdGxldCBpbmRlbnQgPSBvcHRpb25zLmluZGVudC5yZXBlYXQob3B0aW9ucy5pbmRlbnRMZXZlbCk7XG5cdGxldCBvbGRJbmRlbnQgPSAnJztcblx0Y29uc3QgaW5saW5lMSA9IG9wdGlvbnMuX19pbmxpbmUxX187XG5cdGNvbnN0IGlubGluZTIgPSBvcHRpb25zLl9faW5saW5lMl9fO1xuXHRjb25zdCBuZXdMaW5lID0gY29tcGFjdCA/ICcnIDogJ1xcbic7XG5cdGxldCByZXN1bHQ7XG5cdGxldCBpc0VtcHR5ID0gdHJ1ZTtcblx0Y29uc3QgdXNlQmluTnVtYmVycyA9IG9wdGlvbnMubnVtYmVycyA9PSAnYmluYXJ5Jztcblx0Y29uc3QgdXNlT2N0TnVtYmVycyA9IG9wdGlvbnMubnVtYmVycyA9PSAnb2N0YWwnO1xuXHRjb25zdCB1c2VEZWNOdW1iZXJzID0gb3B0aW9ucy5udW1iZXJzID09ICdkZWNpbWFsJztcblx0Y29uc3QgdXNlSGV4TnVtYmVycyA9IG9wdGlvbnMubnVtYmVycyA9PSAnaGV4YWRlY2ltYWwnO1xuXG5cdGlmIChqc29uICYmIGFyZ3VtZW50ICYmIGlzRnVuY3Rpb24oYXJndW1lbnQudG9KU09OKSkge1xuXHRcdGFyZ3VtZW50ID0gYXJndW1lbnQudG9KU09OKCk7XG5cdH1cblxuXHRpZiAoIWlzU3RyaW5nKGFyZ3VtZW50KSkge1xuXHRcdGlmIChpc01hcChhcmd1bWVudCkpIHtcblx0XHRcdGlmIChhcmd1bWVudC5zaXplID09IDApIHtcblx0XHRcdFx0cmV0dXJuICduZXcgTWFwKCknO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFjb21wYWN0KSB7XG5cdFx0XHRcdG9wdGlvbnMuX19pbmxpbmUxX18gPSB0cnVlO1xuXHRcdFx0XHRvcHRpb25zLl9faW5saW5lMl9fID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gJ25ldyBNYXAoJyArIGpzZXNjKEFycmF5LmZyb20oYXJndW1lbnQpLCBvcHRpb25zKSArICcpJztcblx0XHR9XG5cdFx0aWYgKGlzU2V0KGFyZ3VtZW50KSkge1xuXHRcdFx0aWYgKGFyZ3VtZW50LnNpemUgPT0gMCkge1xuXHRcdFx0XHRyZXR1cm4gJ25ldyBTZXQoKSc7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gJ25ldyBTZXQoJyArIGpzZXNjKEFycmF5LmZyb20oYXJndW1lbnQpLCBvcHRpb25zKSArICcpJztcblx0XHR9XG5cdFx0aWYgKGlzQnVmZmVyKGFyZ3VtZW50KSkge1xuXHRcdFx0aWYgKGFyZ3VtZW50Lmxlbmd0aCA9PSAwKSB7XG5cdFx0XHRcdHJldHVybiAnQnVmZmVyLmZyb20oW10pJztcblx0XHRcdH1cblx0XHRcdHJldHVybiAnQnVmZmVyLmZyb20oJyArIGpzZXNjKEFycmF5LmZyb20oYXJndW1lbnQpLCBvcHRpb25zKSArICcpJztcblx0XHR9XG5cdFx0aWYgKGlzQXJyYXkoYXJndW1lbnQpKSB7XG5cdFx0XHRyZXN1bHQgPSBbXTtcblx0XHRcdG9wdGlvbnMud3JhcCA9IHRydWU7XG5cdFx0XHRpZiAoaW5saW5lMSkge1xuXHRcdFx0XHRvcHRpb25zLl9faW5saW5lMV9fID0gZmFsc2U7XG5cdFx0XHRcdG9wdGlvbnMuX19pbmxpbmUyX18gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFpbmxpbmUyKSB7XG5cdFx0XHRcdGluY3JlYXNlSW5kZW50YXRpb24oKTtcblx0XHRcdH1cblx0XHRcdGZvckVhY2goYXJndW1lbnQsICh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRpc0VtcHR5ID0gZmFsc2U7XG5cdFx0XHRcdGlmIChpbmxpbmUyKSB7XG5cdFx0XHRcdFx0b3B0aW9ucy5fX2lubGluZTJfXyA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJlc3VsdC5wdXNoKFxuXHRcdFx0XHRcdChjb21wYWN0IHx8IGlubGluZTIgPyAnJyA6IGluZGVudCkgK1xuXHRcdFx0XHRcdGpzZXNjKHZhbHVlLCBvcHRpb25zKVxuXHRcdFx0XHQpO1xuXHRcdFx0fSk7XG5cdFx0XHRpZiAoaXNFbXB0eSkge1xuXHRcdFx0XHRyZXR1cm4gJ1tdJztcblx0XHRcdH1cblx0XHRcdGlmIChpbmxpbmUyKSB7XG5cdFx0XHRcdHJldHVybiAnWycgKyByZXN1bHQuam9pbignLCAnKSArICddJztcblx0XHRcdH1cblx0XHRcdHJldHVybiAnWycgKyBuZXdMaW5lICsgcmVzdWx0LmpvaW4oJywnICsgbmV3TGluZSkgKyBuZXdMaW5lICtcblx0XHRcdFx0KGNvbXBhY3QgPyAnJyA6IG9sZEluZGVudCkgKyAnXSc7XG5cdFx0fSBlbHNlIGlmIChpc051bWJlcihhcmd1bWVudCkpIHtcblx0XHRcdGlmIChqc29uKSB7XG5cdFx0XHRcdC8vIFNvbWUgbnVtYmVyIHZhbHVlcyAoZS5nLiBgSW5maW5pdHlgKSBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgaW4gSlNPTi5cblx0XHRcdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3VtZW50KTtcblx0XHRcdH1cblx0XHRcdGlmICh1c2VEZWNOdW1iZXJzKSB7XG5cdFx0XHRcdHJldHVybiBTdHJpbmcoYXJndW1lbnQpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHVzZUhleE51bWJlcnMpIHtcblx0XHRcdFx0bGV0IGhleGFkZWNpbWFsID0gYXJndW1lbnQudG9TdHJpbmcoMTYpO1xuXHRcdFx0XHRpZiAoIWxvd2VyY2FzZUhleCkge1xuXHRcdFx0XHRcdGhleGFkZWNpbWFsID0gaGV4YWRlY2ltYWwudG9VcHBlckNhc2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gJzB4JyArIGhleGFkZWNpbWFsO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHVzZUJpbk51bWJlcnMpIHtcblx0XHRcdFx0cmV0dXJuICcwYicgKyBhcmd1bWVudC50b1N0cmluZygyKTtcblx0XHRcdH1cblx0XHRcdGlmICh1c2VPY3ROdW1iZXJzKSB7XG5cdFx0XHRcdHJldHVybiAnMG8nICsgYXJndW1lbnQudG9TdHJpbmcoOCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICghaXNPYmplY3QoYXJndW1lbnQpKSB7XG5cdFx0XHRpZiAoanNvbikge1xuXHRcdFx0XHQvLyBGb3Igc29tZSB2YWx1ZXMgKGUuZy4gYHVuZGVmaW5lZGAsIGBmdW5jdGlvbmAgb2JqZWN0cyksXG5cdFx0XHRcdC8vIGBKU09OLnN0cmluZ2lmeSh2YWx1ZSlgIHJldHVybnMgYHVuZGVmaW5lZGAgKHdoaWNoIGlzblx1MjAxOXQgdmFsaWRcblx0XHRcdFx0Ly8gSlNPTikgaW5zdGVhZCBvZiBgJ251bGwnYC5cblx0XHRcdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3VtZW50KSB8fCAnbnVsbCc7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gU3RyaW5nKGFyZ3VtZW50KTtcblx0XHR9IGVsc2UgeyAvLyBpdFx1MjAxOXMgYW4gb2JqZWN0XG5cdFx0XHRyZXN1bHQgPSBbXTtcblx0XHRcdG9wdGlvbnMud3JhcCA9IHRydWU7XG5cdFx0XHRpbmNyZWFzZUluZGVudGF0aW9uKCk7XG5cdFx0XHRmb3JPd24oYXJndW1lbnQsIChrZXksIHZhbHVlKSA9PiB7XG5cdFx0XHRcdGlzRW1wdHkgPSBmYWxzZTtcblx0XHRcdFx0cmVzdWx0LnB1c2goXG5cdFx0XHRcdFx0KGNvbXBhY3QgPyAnJyA6IGluZGVudCkgK1xuXHRcdFx0XHRcdGpzZXNjKGtleSwgb3B0aW9ucykgKyAnOicgK1xuXHRcdFx0XHRcdChjb21wYWN0ID8gJycgOiAnICcpICtcblx0XHRcdFx0XHRqc2VzYyh2YWx1ZSwgb3B0aW9ucylcblx0XHRcdFx0KTtcblx0XHRcdH0pO1xuXHRcdFx0aWYgKGlzRW1wdHkpIHtcblx0XHRcdFx0cmV0dXJuICd7fSc7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gJ3snICsgbmV3TGluZSArIHJlc3VsdC5qb2luKCcsJyArIG5ld0xpbmUpICsgbmV3TGluZSArXG5cdFx0XHRcdChjb21wYWN0ID8gJycgOiBvbGRJbmRlbnQpICsgJ30nO1xuXHRcdH1cblx0fVxuXG5cdGNvbnN0IHJlZ2V4ID0gb3B0aW9ucy5lc2NhcGVFdmVyeXRoaW5nID8gZXNjYXBlRXZlcnl0aGluZ1JlZ2V4IDogZXNjYXBlTm9uQXNjaWlSZWdleDtcblx0cmVzdWx0ID0gYXJndW1lbnQucmVwbGFjZShyZWdleCwgKGNoYXIsIHBhaXIsIGxvbmUsIHF1b3RlQ2hhciwgaW5kZXgsIHN0cmluZykgPT4ge1xuXHRcdGlmIChwYWlyKSB7XG5cdFx0XHRpZiAob3B0aW9ucy5taW5pbWFsKSByZXR1cm4gcGFpcjtcblx0XHRcdGNvbnN0IGZpcnN0ID0gcGFpci5jaGFyQ29kZUF0KDApO1xuXHRcdFx0Y29uc3Qgc2Vjb25kID0gcGFpci5jaGFyQ29kZUF0KDEpO1xuXHRcdFx0aWYgKG9wdGlvbnMuZXM2KSB7XG5cdFx0XHRcdC8vIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nI3N1cnJvZ2F0ZS1mb3JtdWxhZVxuXHRcdFx0XHRjb25zdCBjb2RlUG9pbnQgPSAoZmlyc3QgLSAweEQ4MDApICogMHg0MDAgKyBzZWNvbmQgLSAweERDMDAgKyAweDEwMDAwO1xuXHRcdFx0XHRjb25zdCBoZXggPSBoZXhhZGVjaW1hbChjb2RlUG9pbnQsIGxvd2VyY2FzZUhleCk7XG5cdFx0XHRcdHJldHVybiAnXFxcXHV7JyArIGhleCArICd9Jztcblx0XHRcdH1cblx0XHRcdHJldHVybiBmb3VySGV4RXNjYXBlKGhleGFkZWNpbWFsKGZpcnN0LCBsb3dlcmNhc2VIZXgpKSArIGZvdXJIZXhFc2NhcGUoaGV4YWRlY2ltYWwoc2Vjb25kLCBsb3dlcmNhc2VIZXgpKTtcblx0XHR9XG5cblx0XHRpZiAobG9uZSkge1xuXHRcdFx0cmV0dXJuIGZvdXJIZXhFc2NhcGUoaGV4YWRlY2ltYWwobG9uZS5jaGFyQ29kZUF0KDApLCBsb3dlcmNhc2VIZXgpKTtcblx0XHR9XG5cblx0XHRpZiAoXG5cdFx0XHRjaGFyID09ICdcXDAnICYmXG5cdFx0XHQhanNvbiAmJlxuXHRcdFx0IXJlZ2V4RGlnaXQudGVzdChzdHJpbmcuY2hhckF0KGluZGV4ICsgMSkpXG5cdFx0KSB7XG5cdFx0XHRyZXR1cm4gJ1xcXFwwJztcblx0XHR9XG5cblx0XHRpZiAocXVvdGVDaGFyKSB7XG5cdFx0XHRpZiAocXVvdGVDaGFyID09IHF1b3RlIHx8IG9wdGlvbnMuZXNjYXBlRXZlcnl0aGluZykge1xuXHRcdFx0XHRyZXR1cm4gJ1xcXFwnICsgcXVvdGVDaGFyO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHF1b3RlQ2hhcjtcblx0XHR9XG5cblx0XHRpZiAocmVnZXhTaW5nbGVFc2NhcGUudGVzdChjaGFyKSkge1xuXHRcdFx0Ly8gbm8gbmVlZCBmb3IgYSBgaGFzT3duUHJvcGVydHlgIGNoZWNrIGhlcmVcblx0XHRcdHJldHVybiBzaW5nbGVFc2NhcGVzW2NoYXJdO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLm1pbmltYWwgJiYgIXJlZ2V4V2hpdGVzcGFjZS50ZXN0KGNoYXIpKSB7XG5cdFx0XHRyZXR1cm4gY2hhcjtcblx0XHR9XG5cblx0XHRjb25zdCBoZXggPSBoZXhhZGVjaW1hbChjaGFyLmNoYXJDb2RlQXQoMCksIGxvd2VyY2FzZUhleCk7XG5cdFx0aWYgKGpzb24gfHwgaGV4Lmxlbmd0aCA+IDIpIHtcblx0XHRcdHJldHVybiBmb3VySGV4RXNjYXBlKGhleCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICdcXFxceCcgKyAoJzAwJyArIGhleCkuc2xpY2UoLTIpO1xuXHR9KTtcblxuXHRpZiAocXVvdGUgPT0gJ2AnKSB7XG5cdFx0cmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoL1xcJFxcey9nLCAnXFxcXCR7Jyk7XG5cdH1cblx0aWYgKG9wdGlvbnMuaXNTY3JpcHRDb250ZXh0KSB7XG5cdFx0Ly8gaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2V0YWdvXG5cdFx0cmVzdWx0ID0gcmVzdWx0XG5cdFx0XHQucmVwbGFjZSgvPFxcLyhzY3JpcHR8c3R5bGUpL2dpLCAnPFxcXFwvJDEnKVxuXHRcdFx0LnJlcGxhY2UoLzwhLS0vZywganNvbiA/ICdcXFxcdTAwM0MhLS0nIDogJ1xcXFx4M0MhLS0nKTtcblx0fVxuXHRpZiAob3B0aW9ucy53cmFwKSB7XG5cdFx0cmVzdWx0ID0gcXVvdGUgKyByZXN1bHQgKyBxdW90ZTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufTtcblxuanNlc2MudmVyc2lvbiA9ICczLjAuMic7XG5cbm1vZHVsZS5leHBvcnRzID0ganNlc2M7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZG9tYWluO1xuXG4vLyBUaGlzIGNvbnN0cnVjdG9yIGlzIHVzZWQgdG8gc3RvcmUgZXZlbnQgaGFuZGxlcnMuIEluc3RhbnRpYXRpbmcgdGhpcyBpc1xuLy8gZmFzdGVyIHRoYW4gZXhwbGljaXRseSBjYWxsaW5nIGBPYmplY3QuY3JlYXRlKG51bGwpYCB0byBnZXQgYSBcImNsZWFuXCIgZW1wdHlcbi8vIG9iamVjdCAodGVzdGVkIHdpdGggdjggdjQuOSkuXG5mdW5jdGlvbiBFdmVudEhhbmRsZXJzKCkge31cbkV2ZW50SGFuZGxlcnMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xufVxuZXhwb3J0IGRlZmF1bHQgRXZlbnRFbWl0dGVyO1xuZXhwb3J0IHtFdmVudEVtaXR0ZXJ9O1xuXG4vLyBub2RlanMgb2RkaXR5XG4vLyByZXF1aXJlKCdldmVudHMnKSA9PT0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyXG5cbkV2ZW50RW1pdHRlci51c2luZ0RvbWFpbnMgPSBmYWxzZTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5kb21haW4gPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbkV2ZW50RW1pdHRlci5pbml0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZG9tYWluID0gbnVsbDtcbiAgaWYgKEV2ZW50RW1pdHRlci51c2luZ0RvbWFpbnMpIHtcbiAgICAvLyBpZiB0aGVyZSBpcyBhbiBhY3RpdmUgZG9tYWluLCB0aGVuIGF0dGFjaCB0byBpdC5cbiAgICBpZiAoZG9tYWluLmFjdGl2ZSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBkb21haW4uRG9tYWluKSkge1xuICAgICAgdGhpcy5kb21haW4gPSBkb21haW4uYWN0aXZlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8IHRoaXMuX2V2ZW50cyA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHMpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRIYW5kbGVycygpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59O1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiblwiIGFyZ3VtZW50IG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiAkZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiAkZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcblxuLy8gVGhlc2Ugc3RhbmRhbG9uZSBlbWl0KiBmdW5jdGlvbnMgYXJlIHVzZWQgdG8gb3B0aW1pemUgY2FsbGluZyBvZiBldmVudFxuLy8gaGFuZGxlcnMgZm9yIGZhc3QgY2FzZXMgYmVjYXVzZSBlbWl0KCkgaXRzZWxmIG9mdGVuIGhhcyBhIHZhcmlhYmxlIG51bWJlciBvZlxuLy8gYXJndW1lbnRzIGFuZCBjYW4gYmUgZGVvcHRpbWl6ZWQgYmVjYXVzZSBvZiB0aGF0LiBUaGVzZSBmdW5jdGlvbnMgYWx3YXlzIGhhdmVcbi8vIHRoZSBzYW1lIG51bWJlciBvZiBhcmd1bWVudHMgYW5kIHRodXMgZG8gbm90IGdldCBkZW9wdGltaXplZCwgc28gdGhlIGNvZGVcbi8vIGluc2lkZSB0aGVtIGNhbiBleGVjdXRlIGZhc3Rlci5cbmZ1bmN0aW9uIGVtaXROb25lKGhhbmRsZXIsIGlzRm4sIHNlbGYpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5jYWxsKHNlbGYpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZik7XG4gIH1cbn1cbmZ1bmN0aW9uIGVtaXRPbmUoaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJnMSkge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZiwgYXJnMSk7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmLCBhcmcxKTtcbiAgfVxufVxuZnVuY3Rpb24gZW1pdFR3byhoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmcxLCBhcmcyKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuY2FsbChzZWxmLCBhcmcxLCBhcmcyKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYsIGFyZzEsIGFyZzIpO1xuICB9XG59XG5mdW5jdGlvbiBlbWl0VGhyZWUoaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJnMSwgYXJnMiwgYXJnMykge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZiwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0TWFueShoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmdzKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuYXBwbHkoc2VsZiwgYXJncyk7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBldmVudHMsIGRvbWFpbjtcbiAgdmFyIG5lZWREb21haW5FeGl0ID0gZmFsc2U7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cylcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09IG51bGwpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgZG9tYWluID0gdGhpcy5kb21haW47XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgIGlmIChkb21haW4pIHtcbiAgICAgIGlmICghZXIpXG4gICAgICAgIGVyID0gbmV3IEVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50Jyk7XG4gICAgICBlci5kb21haW5FbWl0dGVyID0gdGhpcztcbiAgICAgIGVyLmRvbWFpbiA9IGRvbWFpbjtcbiAgICAgIGVyLmRvbWFpblRocm93biA9IGZhbHNlO1xuICAgICAgZG9tYWluLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIH0gZWxzZSBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuICgnICsgZXIgKyAnKScpO1xuICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoIWhhbmRsZXIpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBpc0ZuID0gdHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbic7XG4gIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHN3aXRjaCAobGVuKSB7XG4gICAgLy8gZmFzdCBjYXNlc1xuICAgIGNhc2UgMTpcbiAgICAgIGVtaXROb25lKGhhbmRsZXIsIGlzRm4sIHRoaXMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyOlxuICAgICAgZW1pdE9uZShoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOlxuICAgICAgZW1pdFR3byhoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDQ6XG4gICAgICBlbWl0VGhyZWUoaGFuZGxlciwgaXNGbiwgdGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0sIGFyZ3VtZW50c1szXSk7XG4gICAgICBicmVhaztcbiAgICAvLyBzbG93ZXJcbiAgICBkZWZhdWx0OlxuICAgICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICBlbWl0TWFueShoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIGlmIChuZWVkRG9tYWluRXhpdClcbiAgICBkb21haW4uZXhpdCgpO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKCFldmVudHMpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IG5ldyBFdmVudEhhbmRsZXJzKCk7XG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lcikge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmICghZXhpc3RpbmcpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgICBpZiAocHJlcGVuZCkge1xuICAgICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgaWYgKCFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIG0gPSAkZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgICBpZiAobSAmJiBtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtKSB7XG4gICAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgJyArIHR5cGUgKyAnIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0Jyk7XG4gICAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICAgIGVtaXRXYXJuaW5nKHcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBlbWl0V2FybmluZyhlKSB7XG4gIHR5cGVvZiBjb25zb2xlLndhcm4gPT09ICdmdW5jdGlvbicgPyBjb25zb2xlLndhcm4oZSkgOiBjb25zb2xlLmxvZyhlKTtcbn1cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGZpcmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRhcmdldCwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICByZXR1cm4gZztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoIWV2ZW50cylcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAoIWxpc3QpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgKGxpc3QubGlzdGVuZXIgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBsaXN0WzBdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRIYW5kbGVycygpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzLCBldmVudHM7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmICghZXZlbnRzKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICAgICAgaWYgKCFldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRIYW5kbGVycygpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0pIHtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50cyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBrZXk7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRIYW5kbGVycygpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgICAgZG8ge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gICAgICAgIH0gd2hpbGUgKGxpc3RlbmVyc1swXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgdmFyIGV2bGlzdGVuZXI7XG4gIHZhciByZXQ7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKCFldmVudHMpXG4gICAgcmV0ID0gW107XG4gIGVsc2Uge1xuICAgIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gICAgaWYgKCFldmxpc3RlbmVyKVxuICAgICAgcmV0ID0gW107XG4gICAgZWxzZSBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgICByZXQgPSBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXTtcbiAgICBlbHNlXG4gICAgICByZXQgPSB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cykge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3Qub3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuXG4vLyBBYm91dCAxLjV4IGZhc3RlciB0aGFuIHRoZSB0d28tYXJnIHZlcnNpb24gb2YgQXJyYXkjc3BsaWNlKCkuXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICh2YXIgaSA9IGluZGV4LCBrID0gaSArIDEsIG4gPSBsaXN0Lmxlbmd0aDsgayA8IG47IGkgKz0gMSwgayArPSAxKVxuICAgIGxpc3RbaV0gPSBsaXN0W2tdO1xuICBsaXN0LnBvcCgpO1xufVxuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgaSkge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShpKTtcbiAgd2hpbGUgKGktLSlcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbiIsICIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbi8vIGJhc2VkIG9mZiBodHRwczovL2dpdGh1Yi5jb20vZGVmdW5jdHpvbWJpZS9ub2RlLXByb2Nlc3MvYmxvYi9tYXN0ZXIvYnJvd3Nlci5qc1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbnZhciBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuaWYgKHR5cGVvZiBnbG9iYWwuc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xufVxuaWYgKHR5cGVvZiBnbG9iYWwuY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xufVxuXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5mdW5jdGlvbiBuZXh0VGljayhmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufVxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnZhciB0aXRsZSA9ICdicm93c2VyJztcbnZhciBwbGF0Zm9ybSA9ICdicm93c2VyJztcbnZhciBicm93c2VyID0gdHJ1ZTtcbnZhciBlbnYgPSB7fTtcbnZhciBhcmd2ID0gW107XG52YXIgdmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xudmFyIHZlcnNpb25zID0ge307XG52YXIgcmVsZWFzZSA9IHt9O1xudmFyIGNvbmZpZyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxudmFyIG9uID0gbm9vcDtcbnZhciBhZGRMaXN0ZW5lciA9IG5vb3A7XG52YXIgb25jZSA9IG5vb3A7XG52YXIgb2ZmID0gbm9vcDtcbnZhciByZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG52YXIgcmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnZhciBlbWl0ID0gbm9vcDtcblxuZnVuY3Rpb24gYmluZGluZyhuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufVxuXG5mdW5jdGlvbiBjd2QgKCkgeyByZXR1cm4gJy8nIH1cbmZ1bmN0aW9uIGNoZGlyIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufWZ1bmN0aW9uIHVtYXNrKCkgeyByZXR1cm4gMDsgfVxuXG4vLyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9rdW1hdmlzL2Jyb3dzZXItcHJvY2Vzcy1ocnRpbWUvYmxvYi9tYXN0ZXIvaW5kZXguanNcbnZhciBwZXJmb3JtYW5jZSA9IGdsb2JhbC5wZXJmb3JtYW5jZSB8fCB7fTtcbnZhciBwZXJmb3JtYW5jZU5vdyA9XG4gIHBlcmZvcm1hbmNlLm5vdyAgICAgICAgfHxcbiAgcGVyZm9ybWFuY2UubW96Tm93ICAgICB8fFxuICBwZXJmb3JtYW5jZS5tc05vdyAgICAgIHx8XG4gIHBlcmZvcm1hbmNlLm9Ob3cgICAgICAgfHxcbiAgcGVyZm9ybWFuY2Uud2Via2l0Tm93ICB8fFxuICBmdW5jdGlvbigpeyByZXR1cm4gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSB9O1xuXG4vLyBnZW5lcmF0ZSB0aW1lc3RhbXAgb3IgZGVsdGFcbi8vIHNlZSBodHRwOi8vbm9kZWpzLm9yZy9hcGkvcHJvY2Vzcy5odG1sI3Byb2Nlc3NfcHJvY2Vzc19ocnRpbWVcbmZ1bmN0aW9uIGhydGltZShwcmV2aW91c1RpbWVzdGFtcCl7XG4gIHZhciBjbG9ja3RpbWUgPSBwZXJmb3JtYW5jZU5vdy5jYWxsKHBlcmZvcm1hbmNlKSoxZS0zO1xuICB2YXIgc2Vjb25kcyA9IE1hdGguZmxvb3IoY2xvY2t0aW1lKTtcbiAgdmFyIG5hbm9zZWNvbmRzID0gTWF0aC5mbG9vcigoY2xvY2t0aW1lJTEpKjFlOSk7XG4gIGlmIChwcmV2aW91c1RpbWVzdGFtcCkge1xuICAgIHNlY29uZHMgPSBzZWNvbmRzIC0gcHJldmlvdXNUaW1lc3RhbXBbMF07XG4gICAgbmFub3NlY29uZHMgPSBuYW5vc2Vjb25kcyAtIHByZXZpb3VzVGltZXN0YW1wWzFdO1xuICAgIGlmIChuYW5vc2Vjb25kczwwKSB7XG4gICAgICBzZWNvbmRzLS07XG4gICAgICBuYW5vc2Vjb25kcyArPSAxZTk7XG4gICAgfVxuICB9XG4gIHJldHVybiBbc2Vjb25kcyxuYW5vc2Vjb25kc11cbn1cblxudmFyIHN0YXJ0VGltZSA9IG5ldyBEYXRlKCk7XG5mdW5jdGlvbiB1cHRpbWUoKSB7XG4gIHZhciBjdXJyZW50VGltZSA9IG5ldyBEYXRlKCk7XG4gIHZhciBkaWYgPSBjdXJyZW50VGltZSAtIHN0YXJ0VGltZTtcbiAgcmV0dXJuIGRpZiAvIDEwMDA7XG59XG5cbnZhciBicm93c2VyJDEgPSB7XG4gIG5leHRUaWNrOiBuZXh0VGljayxcbiAgdGl0bGU6IHRpdGxlLFxuICBicm93c2VyOiBicm93c2VyLFxuICBlbnY6IGVudixcbiAgYXJndjogYXJndixcbiAgdmVyc2lvbjogdmVyc2lvbixcbiAgdmVyc2lvbnM6IHZlcnNpb25zLFxuICBvbjogb24sXG4gIGFkZExpc3RlbmVyOiBhZGRMaXN0ZW5lcixcbiAgb25jZTogb25jZSxcbiAgb2ZmOiBvZmYsXG4gIHJlbW92ZUxpc3RlbmVyOiByZW1vdmVMaXN0ZW5lcixcbiAgcmVtb3ZlQWxsTGlzdGVuZXJzOiByZW1vdmVBbGxMaXN0ZW5lcnMsXG4gIGVtaXQ6IGVtaXQsXG4gIGJpbmRpbmc6IGJpbmRpbmcsXG4gIGN3ZDogY3dkLFxuICBjaGRpcjogY2hkaXIsXG4gIHVtYXNrOiB1bWFzayxcbiAgaHJ0aW1lOiBocnRpbWUsXG4gIHBsYXRmb3JtOiBwbGF0Zm9ybSxcbiAgcmVsZWFzZTogcmVsZWFzZSxcbiAgY29uZmlnOiBjb25maWcsXG4gIHVwdGltZTogdXB0aW1lXG59O1xuXG5leHBvcnQgZGVmYXVsdCBicm93c2VyJDE7XG5leHBvcnQgeyBhZGRMaXN0ZW5lciwgYXJndiwgYmluZGluZywgYnJvd3NlciwgY2hkaXIsIGNvbmZpZywgY3dkLCBlbWl0LCBlbnYsIGhydGltZSwgbmV4dFRpY2ssIG9mZiwgb24sIG9uY2UsIHBsYXRmb3JtLCByZWxlYXNlLCByZW1vdmVBbGxMaXN0ZW5lcnMsIHJlbW92ZUxpc3RlbmVyLCB0aXRsZSwgdW1hc2ssIHVwdGltZSwgdmVyc2lvbiwgdmVyc2lvbnMgfTtcbiIsICJcbnZhciBpbmhlcml0cztcbmlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJyl7XG4gIGluaGVyaXRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIGluaGVyaXRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cbmV4cG9ydCBkZWZhdWx0IGluaGVyaXRzO1xuIiwgIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuaW1wb3J0IHByb2Nlc3MgZnJvbSAncHJvY2Vzcyc7XG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXQoZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnQgZnVuY3Rpb24gZGVwcmVjYXRlKGZuLCBtc2cpIHtcbiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC5cbiAgaWYgKGlzVW5kZWZpbmVkKGdsb2JhbC5wcm9jZXNzKSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0Vudmlyb247XG5leHBvcnQgZnVuY3Rpb24gZGVidWdsb2coc2V0KSB7XG4gIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxuICAgIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKG5ldyBSZWdFeHAoJ1xcXFxiJyArIHNldCArICdcXFxcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7XG4gICAgICB2YXIgcGlkID0gMDtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSBmb3JtYXQuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZXhwb3J0IGZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBfZXh0ZW5kKGN0eCwgb3B0cyk7XG4gIH1cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xufVxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3Ncbmluc3BlY3QuY29sb3JzID0ge1xuICAnYm9sZCcgOiBbMSwgMjJdLFxuICAnaXRhbGljJyA6IFszLCAyM10sXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxuICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICdncmVlbicgOiBbMzIsIDM5XSxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICdyZWQnIDogWzMxLCAzOV0sXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cbn07XG5cbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuaW5zcGVjdC5zdHlsZXMgPSB7XG4gICdzcGVjaWFsJzogJ2N5YW4nLFxuICAnbnVtYmVyJzogJ3llbGxvdycsXG4gICdib29sZWFuJzogJ3llbGxvdycsXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICdudWxsJzogJ2JvbGQnLFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICdyZWdleHAnOiAncmVkJ1xufTtcblxuXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICByZXR1cm4gc3RyO1xufVxuXG5cbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gIHZhciBoYXNoID0ge307XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBoYXNoO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgIHZhbHVlICYmXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmV4cG9ydCBmdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQnVmZmVyKG1heWJlQnVmKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIobWF5YmVCdWYpO1xufVxuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnQgZnVuY3Rpb24gbG9nKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBmb3JtYXQuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG59XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmltcG9ydCBpbmhlcml0cyBmcm9tICcuL2luaGVyaXRzJztcbmV4cG9ydCB7aW5oZXJpdHN9XG5cbmV4cG9ydCBmdW5jdGlvbiBfZXh0ZW5kKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGluaGVyaXRzOiBpbmhlcml0cyxcbiAgX2V4dGVuZDogX2V4dGVuZCxcbiAgbG9nOiBsb2csXG4gIGlzQnVmZmVyOiBpc0J1ZmZlcixcbiAgaXNQcmltaXRpdmU6IGlzUHJpbWl0aXZlLFxuICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuICBpc0Vycm9yOiBpc0Vycm9yLFxuICBpc0RhdGU6IGlzRGF0ZSxcbiAgaXNPYmplY3Q6IGlzT2JqZWN0LFxuICBpc1JlZ0V4cDogaXNSZWdFeHAsXG4gIGlzVW5kZWZpbmVkOiBpc1VuZGVmaW5lZCxcbiAgaXNTeW1ib2w6IGlzU3ltYm9sLFxuICBpc1N0cmluZzogaXNTdHJpbmcsXG4gIGlzTnVtYmVyOiBpc051bWJlcixcbiAgaXNOdWxsT3JVbmRlZmluZWQ6IGlzTnVsbE9yVW5kZWZpbmVkLFxuICBpc051bGw6IGlzTnVsbCxcbiAgaXNCb29sZWFuOiBpc0Jvb2xlYW4sXG4gIGlzQXJyYXk6IGlzQXJyYXksXG4gIGluc3BlY3Q6IGluc3BlY3QsXG4gIGRlcHJlY2F0ZTogZGVwcmVjYXRlLFxuICBmb3JtYXQ6IGZvcm1hdCxcbiAgZGVidWdsb2c6IGRlYnVnbG9nXG59XG4iLCAidmFyIGxvb2t1cCA9IFtdO1xudmFyIHJldkxvb2t1cCA9IFtdO1xudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheTtcbnZhciBpbml0ZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGluaXQgKCkge1xuICBpbml0ZWQgPSB0cnVlO1xuICB2YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBsb29rdXBbaV0gPSBjb2RlW2ldO1xuICAgIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaTtcbiAgfVxuXG4gIHJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MjtcbiAgcmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzO1xufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIGlmICghaW5pdGVkKSB7XG4gICAgaW5pdCgpO1xuICB9XG4gIHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyO1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aDtcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcbiAgLy8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuICAvLyByZXByZXNlbnQgb25lIGJ5dGVcbiAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG4gIC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2VcbiAgcGxhY2VIb2xkZXJzID0gYjY0W2xlbiAtIDJdID09PSAnPScgPyAyIDogYjY0W2xlbiAtIDFdID09PSAnPScgPyAxIDogMDtcblxuICAvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbiAgYXJyID0gbmV3IEFycihsZW4gKiAzIC8gNCAtIHBsYWNlSG9sZGVycyk7XG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICBsID0gcGxhY2VIb2xkZXJzID4gMCA/IGxlbiAtIDQgOiBsZW47XG5cbiAgdmFyIEwgPSAwO1xuXG4gIGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbDsgaSArPSA0LCBqICs9IDMpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV07XG4gICAgYXJyW0wrK10gPSAodG1wID4+IDE2KSAmIDB4RkY7XG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRjtcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkY7XG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNCk7XG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGO1xuICB9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKTtcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGO1xuICAgIGFycltMKytdID0gdG1wICYgMHhGRjtcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICsgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wO1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKTtcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSk7XG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICBpZiAoIWluaXRlZCkge1xuICAgIGluaXQoKTtcbiAgfVxuICB2YXIgdG1wO1xuICB2YXIgbGVuID0gdWludDgubGVuZ3RoO1xuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDM7IC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBvdXRwdXQgPSAnJztcbiAgdmFyIHBhcnRzID0gW107XG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzOyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKTtcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXTtcbiAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAyXTtcbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXTtcbiAgICBvdXRwdXQgKz0gJz09JztcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgKHVpbnQ4W2xlbiAtIDFdKTtcbiAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAxMF07XG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl07XG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl07XG4gICAgb3V0cHV0ICs9ICc9JztcbiAgfVxuXG4gIHBhcnRzLnB1c2gob3V0cHV0KTtcblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cblxuZnVuY3Rpb24gcmVhZCAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbTtcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDE7XG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxO1xuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDE7XG4gIHZhciBuQml0cyA9IC03O1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwO1xuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDE7XG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldO1xuXG4gIGkgKz0gZDtcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKTtcbiAgcyA+Pj0gKC1uQml0cyk7XG4gIG5CaXRzICs9IGVMZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XG4gIGUgPj49ICgtbkJpdHMpO1xuICBuQml0cyArPSBtTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhcztcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICBlID0gZSAtIGVCaWFzO1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmZ1bmN0aW9uIHdyaXRlIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgYztcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDE7XG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxO1xuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDE7XG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMCk7XG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSk7XG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMTtcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDA7XG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSk7XG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDA7XG4gICAgZSA9IGVNYXg7XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpO1xuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLTtcbiAgICAgIGMgKj0gMjtcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKys7XG4gICAgICBjIC89IDI7XG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMDtcbiAgICAgIGUgPSBlTWF4O1xuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSBlICsgZUJpYXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSAwO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbTtcbiAgZUxlbiArPSBtTGVuO1xuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4O1xufVxuXG52YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG52YXIgSU5TUEVDVF9NQVhfQllURVMgPSA1MDtcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgOiB0cnVlO1xuXG4vKlxuICogRXhwb3J0IGtNYXhMZW5ndGggYWZ0ZXIgdHlwZWQgYXJyYXkgc3VwcG9ydCBpcyBkZXRlcm1pbmVkLlxuICovXG52YXIgX2tNYXhMZW5ndGggPSBrTWF4TGVuZ3RoKCk7XG5cbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICA/IDB4N2ZmZmZmZmZcbiAgICA6IDB4M2ZmZmZmZmZcbn1cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyICh0aGF0LCBsZW5ndGgpIHtcbiAgaWYgKGtNYXhMZW5ndGgoKSA8IGxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpXG4gIH1cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlO1xuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICBpZiAodGhhdCA9PT0gbnVsbCkge1xuICAgICAgdGhhdCA9IG5ldyBCdWZmZXIobGVuZ3RoKTtcbiAgICB9XG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGg7XG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZSh0aGlzLCBhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTI7IC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuLy8gVE9ETzogTGVnYWN5LCBub3QgbmVlZGVkIGFueW1vcmUuIFJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb24uXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlO1xuICByZXR1cm4gYXJyXG59O1xuXG5mdW5jdGlvbiBmcm9tICh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhhdCwgdmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn07XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlO1xuICBCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jICh0aGF0LCBzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpO1xuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2MobnVsbCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59O1xuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAodGhhdCwgc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpO1xuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKTtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICB0aGF0W2ldID0gMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufTtcbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn07XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCc7XG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMDtcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpO1xuXG4gIHZhciBhY3R1YWwgPSB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpO1xuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgdGhhdCA9IHRoYXQuc2xpY2UoMCwgYWN0dWFsKTtcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDA7XG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NTtcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgYXJyYXkuYnl0ZUxlbmd0aDsgLy8gdGhpcyB0aHJvd3MgaWYgYGFycmF5YCBpcyBub3QgYSB2YWxpZCBBcnJheUJ1ZmZlclxuXG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5KTtcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpO1xuICB9IGVsc2Uge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH1cblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gYXJyYXk7XG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlO1xuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqKSB7XG4gIGlmIChpbnRlcm5hbElzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDA7XG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pO1xuXG4gICAgaWYgKHRoYXQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhhdFxuICAgIH1cblxuICAgIG9iai5jb3B5KHRoYXQsIDAsIDAsIGxlbik7XG4gICAgcmV0dXJuIHRoYXRcbiAgfVxuXG4gIGlmIChvYmopIHtcbiAgICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNuYW4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCAwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqKVxuICAgIH1cblxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iai5kYXRhKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aCgpYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDA7XG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuQnVmZmVyLmlzQnVmZmVyID0gaXNCdWZmZXI7XG5mdW5jdGlvbiBpbnRlcm5hbElzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIWludGVybmFsSXNCdWZmZXIoYSkgfHwgIWludGVybmFsSXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGg7XG4gIHZhciB5ID0gYi5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV07XG4gICAgICB5ID0gYltpXTtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufTtcblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn07XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGk7XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aCk7XG4gIHZhciBwb3MgPSAwO1xuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldO1xuICAgIGlmICghaW50ZXJuYWxJc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcyk7XG4gICAgcG9zICs9IGJ1Zi5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufTtcblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoaW50ZXJuYWxJc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmc7XG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aDtcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2U7XG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aDtcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZTtcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwO1xuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMDtcbiAgc3RhcnQgPj4+PSAwO1xuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZTtcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl07XG4gIGJbbl0gPSBiW21dO1xuICBiW21dID0gaTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSk7XG4gIH1cbiAgcmV0dXJuIHRoaXNcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpO1xuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKTtcbiAgfVxuICByZXR1cm4gdGhpc1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNyk7XG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpO1xuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KTtcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNCk7XG4gIH1cbiAgcmV0dXJuIHRoaXNcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDA7XG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJztcbiAgdmFyIG1heCA9IElOU1BFQ1RfTUFYX0JZVEVTO1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJyk7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJztcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwO1xuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwO1xuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDA7XG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDA7XG4gIGVuZCA+Pj49IDA7XG4gIHRoaXNTdGFydCA+Pj49IDA7XG4gIHRoaXNFbmQgPj4+PSAwO1xuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0O1xuICB2YXIgeSA9IGVuZCAtIHN0YXJ0O1xuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSk7XG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpO1xuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV07XG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXTtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufTtcblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0O1xuICAgIGJ5dGVPZmZzZXQgPSAwO1xuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmY7XG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwO1xuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldDsgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0O1xuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDE7XG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMDtcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKTtcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChpbnRlcm5hbElzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRjsgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJlxuICAgICAgICB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMTtcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGg7XG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoO1xuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMjtcbiAgICAgIGFyckxlbmd0aCAvPSAyO1xuICAgICAgdmFsTGVuZ3RoIC89IDI7XG4gICAgICBieXRlT2Zmc2V0IC89IDI7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpO1xuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMTtcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaTtcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4O1xuICAgICAgICBmb3VuZEluZGV4ID0gLTE7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoO1xuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59O1xuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDA7XG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0O1xuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKTtcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmc7XG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGg7XG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMjtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNik7XG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkO1xuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnO1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgIG9mZnNldCA9IDA7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXQ7XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgb2Zmc2V0ID0gMDtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMDtcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4JztcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGg7XG4gICAgICBsZW5ndGggPSB1bmRlZmluZWQ7XG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldDtcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nO1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnO1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlO1xuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59O1xuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZCk7XG4gIHZhciByZXMgPSBbXTtcblxuICB2YXIgaSA9IHN0YXJ0O1xuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV07XG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGw7XG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxO1xuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludDtcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV07XG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKTtcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV07XG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXTtcbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKTtcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdO1xuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl07XG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM107XG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKTtcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkQ7XG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMTtcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwO1xuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGO1xuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludCk7XG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlO1xuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwO1xuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoO1xuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJztcbiAgdmFyIGkgPSAwO1xuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnO1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpO1xuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3Rik7XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJztcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKTtcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSk7XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoO1xuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDA7XG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW47XG5cbiAgdmFyIG91dCA9ICcnO1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pO1xuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1Nik7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xuICBzdGFydCA9IH5+c3RhcnQ7XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmQ7XG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlbjtcbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDA7XG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlbjtcbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlbjtcbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMDtcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW47XG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0O1xuXG4gIHZhciBuZXdCdWY7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCk7XG4gICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnQ7XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmXG59O1xuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpO1xuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF07XG4gIHZhciBtdWwgPSAxO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWw7XG4gIH1cblxuICByZXR1cm4gdmFsXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpO1xuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXTtcbiAgdmFyIG11bCA9IDE7XG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWw7XG4gIH1cblxuICByZXR1cm4gdmFsXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKTtcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aCk7XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XTtcbiAgdmFyIG11bCA9IDE7XG4gIHZhciBpID0gMDtcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bDtcbiAgfVxuICBtdWwgKj0gMHg4MDtcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKTtcblxuICByZXR1cm4gdmFsXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpO1xuXG4gIHZhciBpID0gYnl0ZUxlbmd0aDtcbiAgdmFyIG11bCA9IDE7XG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV07XG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWw7XG4gIH1cbiAgbXVsICo9IDB4ODA7XG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCk7XG5cbiAgcmV0dXJuIHZhbFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpO1xuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpO1xuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCk7XG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTtcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpO1xuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTtcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuICByZXR1cm4gcmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuICByZXR1cm4gcmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpO1xuICByZXR1cm4gcmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiByZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufTtcblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIWludGVybmFsSXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDE7XG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApO1xuICB9XG5cbiAgdmFyIG11bCA9IDE7XG4gIHZhciBpID0gMDtcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGO1xuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRjtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxO1xuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKTtcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDE7XG4gIHZhciBtdWwgPSAxO1xuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGO1xuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkY7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApO1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpO1xuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKTtcbiAgcmV0dXJuIG9mZnNldCArIDFcbn07XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMTtcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDg7XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMCk7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpO1xuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KTtcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZik7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpO1xuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59O1xuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxO1xuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZjtcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMCk7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KTtcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNik7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCk7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZik7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNCk7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpO1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKTtcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KTtcbiAgfVxuXG4gIHZhciBpID0gMDtcbiAgdmFyIG11bCA9IDE7XG4gIHZhciBzdWIgPSAwO1xuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkY7XG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDE7XG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkY7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpO1xuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpO1xuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMTtcbiAgdmFyIG11bCA9IDE7XG4gIHZhciBzdWIgPSAwO1xuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGO1xuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMTtcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRjtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKTtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKTtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxO1xuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKTtcbiAgcmV0dXJuIG9mZnNldCArIDFcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZik7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KTtcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZik7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpO1xuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZik7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCk7XG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpO1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMCk7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNCk7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpO1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn07XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQpO1xuICB9XG4gIHdyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNCk7XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59O1xuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4KTtcbiAgfVxuICB3cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpO1xuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufTtcblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDA7XG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGg7XG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGg7XG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMDtcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0O1xuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnQ7XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnQ7XG4gIHZhciBpO1xuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gbGVuXG59O1xuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnQ7XG4gICAgICBzdGFydCA9IDA7XG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZDtcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKTtcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1O1xuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwO1xuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwO1xuXG4gIGlmICghdmFsKSB2YWwgPSAwO1xuXG4gIHZhciBpO1xuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBpbnRlcm5hbElzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSk7XG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn07XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nO1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpO1xuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSc7XG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHk7XG4gIHZhciBjb2RlUG9pbnQ7XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGw7XG4gIHZhciBieXRlcyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnQ7XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCk7XG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnQ7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwO1xuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpO1xuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsO1xuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludCk7XG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRik7XG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvO1xuICB2YXIgYnl0ZUFycmF5ID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgaGkgPSBjID4+IDg7XG4gICAgbG8gPSBjICUgMjU2O1xuICAgIGJ5dGVBcnJheS5wdXNoKGxvKTtcbiAgICBieXRlQXJyYXkucHVzaChoaSk7XG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiB0b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV07XG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cblxuXG4vLyB0aGUgZm9sbG93aW5nIGlzIGZyb20gaXMtYnVmZmVyLCBhbHNvIGJ5IEZlcm9zcyBBYm91a2hhZGlqZWggYW5kIHdpdGggc2FtZSBsaXNlbmNlXG4vLyBUaGUgX2lzQnVmZmVyIGNoZWNrIGlzIGZvciBTYWZhcmkgNS03IHN1cHBvcnQsIGJlY2F1c2UgaXQncyBtaXNzaW5nXG4vLyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yLiBSZW1vdmUgdGhpcyBldmVudHVhbGx5XG5mdW5jdGlvbiBpc0J1ZmZlcihvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmICghIW9iai5faXNCdWZmZXIgfHwgaXNGYXN0QnVmZmVyKG9iaikgfHwgaXNTbG93QnVmZmVyKG9iaikpXG59XG5cbmZ1bmN0aW9uIGlzRmFzdEJ1ZmZlciAob2JqKSB7XG4gIHJldHVybiAhIW9iai5jb25zdHJ1Y3RvciAmJiB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopXG59XG5cbi8vIEZvciBOb2RlIHYwLjEwIHN1cHBvcnQuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHkuXG5mdW5jdGlvbiBpc1Nsb3dCdWZmZXIgKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iai5yZWFkRmxvYXRMRSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLnNsaWNlID09PSAnZnVuY3Rpb24nICYmIGlzRmFzdEJ1ZmZlcihvYmouc2xpY2UoMCwgMCkpXG59XG5cbmV4cG9ydCB7IEJ1ZmZlciwgSU5TUEVDVF9NQVhfQllURVMsIFNsb3dCdWZmZXIsIGlzQnVmZmVyLCBfa01heExlbmd0aCBhcyBrTWF4TGVuZ3RoIH07XG4iLCAiaW1wb3J0IHtCdWZmZXJ9IGZyb20gJ2J1ZmZlcic7XG5cbmV4cG9ydCBkZWZhdWx0IEJ1ZmZlckxpc3Q7XG5cbmZ1bmN0aW9uIEJ1ZmZlckxpc3QoKSB7XG4gIHRoaXMuaGVhZCA9IG51bGw7XG4gIHRoaXMudGFpbCA9IG51bGw7XG4gIHRoaXMubGVuZ3RoID0gMDtcbn1cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICh2KSB7XG4gIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogbnVsbCB9O1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O2Vsc2UgdGhpcy5oZWFkID0gZW50cnk7XG4gIHRoaXMudGFpbCA9IGVudHJ5O1xuICArK3RoaXMubGVuZ3RoO1xufTtcblxuQnVmZmVyTGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uICh2KSB7XG4gIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogdGhpcy5oZWFkIH07XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgdGhpcy50YWlsID0gZW50cnk7XG4gIHRoaXMuaGVhZCA9IGVudHJ5O1xuICArK3RoaXMubGVuZ3RoO1xufTtcblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICB2YXIgcmV0ID0gdGhpcy5oZWFkLmRhdGE7XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0O1xuICAtLXRoaXMubGVuZ3RoO1xuICByZXR1cm4gcmV0O1xufTtcblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gIHRoaXMubGVuZ3RoID0gMDtcbn07XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiAocykge1xuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gIHZhciByZXQgPSAnJyArIHAuZGF0YTtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICByZXQgKz0gcyArIHAuZGF0YTtcbiAgfXJldHVybiByZXQ7XG59O1xuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiAobikge1xuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHRoaXMuaGVhZC5kYXRhO1xuICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4gPj4+IDApO1xuICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgdmFyIGkgPSAwO1xuICB3aGlsZSAocCkge1xuICAgIHAuZGF0YS5jb3B5KHJldCwgaSk7XG4gICAgaSArPSBwLmRhdGEubGVuZ3RoO1xuICAgIHAgPSBwLm5leHQ7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7QnVmZmVyfSBmcm9tICdidWZmZXInO1xudmFyIGlzQnVmZmVyRW5jb2RpbmcgPSBCdWZmZXIuaXNFbmNvZGluZ1xuICB8fCBmdW5jdGlvbihlbmNvZGluZykge1xuICAgICAgIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgY2FzZSAnaGV4JzogY2FzZSAndXRmOCc6IGNhc2UgJ3V0Zi04JzogY2FzZSAnYXNjaWknOiBjYXNlICdiaW5hcnknOiBjYXNlICdiYXNlNjQnOiBjYXNlICd1Y3MyJzogY2FzZSAndWNzLTInOiBjYXNlICd1dGYxNmxlJzogY2FzZSAndXRmLTE2bGUnOiBjYXNlICdyYXcnOiByZXR1cm4gdHJ1ZTtcbiAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBmYWxzZTtcbiAgICAgICB9XG4gICAgIH1cblxuXG5mdW5jdGlvbiBhc3NlcnRFbmNvZGluZyhlbmNvZGluZykge1xuICBpZiAoZW5jb2RpbmcgJiYgIWlzQnVmZmVyRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB9XG59XG5cbi8vIFN0cmluZ0RlY29kZXIgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBlZmZpY2llbnRseSBzcGxpdHRpbmcgYSBzZXJpZXMgb2Zcbi8vIGJ1ZmZlcnMgaW50byBhIHNlcmllcyBvZiBKUyBzdHJpbmdzIHdpdGhvdXQgYnJlYWtpbmcgYXBhcnQgbXVsdGktYnl0ZVxuLy8gY2hhcmFjdGVycy4gQ0VTVS04IGlzIGhhbmRsZWQgYXMgcGFydCBvZiB0aGUgVVRGLTggZW5jb2RpbmcuXG4vL1xuLy8gQFRPRE8gSGFuZGxpbmcgYWxsIGVuY29kaW5ncyBpbnNpZGUgYSBzaW5nbGUgb2JqZWN0IG1ha2VzIGl0IHZlcnkgZGlmZmljdWx0XG4vLyB0byByZWFzb24gYWJvdXQgdGhpcyBjb2RlLCBzbyBpdCBzaG91bGQgYmUgc3BsaXQgdXAgaW4gdGhlIGZ1dHVyZS5cbi8vIEBUT0RPIFRoZXJlIHNob3VsZCBiZSBhIHV0Zjgtc3RyaWN0IGVuY29kaW5nIHRoYXQgcmVqZWN0cyBpbnZhbGlkIFVURi04IGNvZGVcbi8vIHBvaW50cyBhcyB1c2VkIGJ5IENFU1UtOC5cbmV4cG9ydCBmdW5jdGlvbiBTdHJpbmdEZWNvZGVyKGVuY29kaW5nKSB7XG4gIHRoaXMuZW5jb2RpbmcgPSAoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1stX10vLCAnJyk7XG4gIGFzc2VydEVuY29kaW5nKGVuY29kaW5nKTtcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgY2FzZSAndXRmOCc6XG4gICAgICAvLyBDRVNVLTggcmVwcmVzZW50cyBlYWNoIG9mIFN1cnJvZ2F0ZSBQYWlyIGJ5IDMtYnl0ZXNcbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIC8vIFVURi0xNiByZXByZXNlbnRzIGVhY2ggb2YgU3Vycm9nYXRlIFBhaXIgYnkgMi1ieXRlc1xuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMjtcbiAgICAgIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSB1dGYxNkRldGVjdEluY29tcGxldGVDaGFyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIC8vIEJhc2UtNjQgc3RvcmVzIDMgYnl0ZXMgaW4gNCBjaGFycywgYW5kIHBhZHMgdGhlIHJlbWFpbmRlci5cbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDM7XG4gICAgICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyID0gYmFzZTY0RGV0ZWN0SW5jb21wbGV0ZUNoYXI7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy53cml0ZSA9IHBhc3NUaHJvdWdoV3JpdGU7XG4gICAgICByZXR1cm47XG4gIH1cblxuICAvLyBFbm91Z2ggc3BhY2UgdG8gc3RvcmUgYWxsIGJ5dGVzIG9mIGEgc2luZ2xlIGNoYXJhY3Rlci4gVVRGLTggbmVlZHMgNFxuICAvLyBieXRlcywgYnV0IENFU1UtOCBtYXkgcmVxdWlyZSB1cCB0byA2ICgzIGJ5dGVzIHBlciBzdXJyb2dhdGUpLlxuICB0aGlzLmNoYXJCdWZmZXIgPSBuZXcgQnVmZmVyKDYpO1xuICAvLyBOdW1iZXIgb2YgYnl0ZXMgcmVjZWl2ZWQgZm9yIHRoZSBjdXJyZW50IGluY29tcGxldGUgbXVsdGktYnl0ZSBjaGFyYWN0ZXIuXG4gIHRoaXMuY2hhclJlY2VpdmVkID0gMDtcbiAgLy8gTnVtYmVyIG9mIGJ5dGVzIGV4cGVjdGVkIGZvciB0aGUgY3VycmVudCBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgY2hhcmFjdGVyLlxuICB0aGlzLmNoYXJMZW5ndGggPSAwO1xufTtcblxuXG4vLyB3cml0ZSBkZWNvZGVzIHRoZSBnaXZlbiBidWZmZXIgYW5kIHJldHVybnMgaXQgYXMgSlMgc3RyaW5nIHRoYXQgaXNcbi8vIGd1YXJhbnRlZWQgdG8gbm90IGNvbnRhaW4gYW55IHBhcnRpYWwgbXVsdGktYnl0ZSBjaGFyYWN0ZXJzLiBBbnkgcGFydGlhbFxuLy8gY2hhcmFjdGVyIGZvdW5kIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciBpcyBidWZmZXJlZCB1cCwgYW5kIHdpbGwgYmVcbi8vIHJldHVybmVkIHdoZW4gY2FsbGluZyB3cml0ZSBhZ2FpbiB3aXRoIHRoZSByZW1haW5pbmcgYnl0ZXMuXG4vL1xuLy8gTm90ZTogQ29udmVydGluZyBhIEJ1ZmZlciBjb250YWluaW5nIGFuIG9ycGhhbiBzdXJyb2dhdGUgdG8gYSBTdHJpbmdcbi8vIGN1cnJlbnRseSB3b3JrcywgYnV0IGNvbnZlcnRpbmcgYSBTdHJpbmcgdG8gYSBCdWZmZXIgKHZpYSBgbmV3IEJ1ZmZlcmAsIG9yXG4vLyBCdWZmZXIjd3JpdGUpIHdpbGwgcmVwbGFjZSBpbmNvbXBsZXRlIHN1cnJvZ2F0ZXMgd2l0aCB0aGUgdW5pY29kZVxuLy8gcmVwbGFjZW1lbnQgY2hhcmFjdGVyLiBTZWUgaHR0cHM6Ly9jb2RlcmV2aWV3LmNocm9taXVtLm9yZy8xMjExNzMwMDkvIC5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHZhciBjaGFyU3RyID0gJyc7XG4gIC8vIGlmIG91ciBsYXN0IHdyaXRlIGVuZGVkIHdpdGggYW4gaW5jb21wbGV0ZSBtdWx0aWJ5dGUgY2hhcmFjdGVyXG4gIHdoaWxlICh0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAvLyBkZXRlcm1pbmUgaG93IG1hbnkgcmVtYWluaW5nIGJ5dGVzIHRoaXMgYnVmZmVyIGhhcyB0byBvZmZlciBmb3IgdGhpcyBjaGFyXG4gICAgdmFyIGF2YWlsYWJsZSA9IChidWZmZXIubGVuZ3RoID49IHRoaXMuY2hhckxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkKSA/XG4gICAgICAgIHRoaXMuY2hhckxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkIDpcbiAgICAgICAgYnVmZmVyLmxlbmd0aDtcblxuICAgIC8vIGFkZCB0aGUgbmV3IGJ5dGVzIHRvIHRoZSBjaGFyIGJ1ZmZlclxuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgdGhpcy5jaGFyUmVjZWl2ZWQsIDAsIGF2YWlsYWJsZSk7XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgKz0gYXZhaWxhYmxlO1xuXG4gICAgaWYgKHRoaXMuY2hhclJlY2VpdmVkIDwgdGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgICAvLyBzdGlsbCBub3QgZW5vdWdoIGNoYXJzIGluIHRoaXMgYnVmZmVyPyB3YWl0IGZvciBtb3JlIC4uLlxuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSBieXRlcyBiZWxvbmdpbmcgdG8gdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGZyb20gdGhlIGJ1ZmZlclxuICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZShhdmFpbGFibGUsIGJ1ZmZlci5sZW5ndGgpO1xuXG4gICAgLy8gZ2V0IHRoZSBjaGFyYWN0ZXIgdGhhdCB3YXMgc3BsaXRcbiAgICBjaGFyU3RyID0gdGhpcy5jaGFyQnVmZmVyLnNsaWNlKDAsIHRoaXMuY2hhckxlbmd0aCkudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG5cbiAgICAvLyBDRVNVLTg6IGxlYWQgc3Vycm9nYXRlIChEODAwLURCRkYpIGlzIGFsc28gdGhlIGluY29tcGxldGUgY2hhcmFjdGVyXG4gICAgdmFyIGNoYXJDb2RlID0gY2hhclN0ci5jaGFyQ29kZUF0KGNoYXJTdHIubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGNoYXJDb2RlID49IDB4RDgwMCAmJiBjaGFyQ29kZSA8PSAweERCRkYpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCArPSB0aGlzLnN1cnJvZ2F0ZVNpemU7XG4gICAgICBjaGFyU3RyID0gJyc7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgPSB0aGlzLmNoYXJMZW5ndGggPSAwO1xuXG4gICAgLy8gaWYgdGhlcmUgYXJlIG5vIG1vcmUgYnl0ZXMgaW4gdGhpcyBidWZmZXIsIGp1c3QgZW1pdCBvdXIgY2hhclxuICAgIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gY2hhclN0cjtcbiAgICB9XG4gICAgYnJlYWs7XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgYW5kIHNldCBjaGFyTGVuZ3RoIC8gY2hhclJlY2VpdmVkXG4gIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKTtcblxuICB2YXIgZW5kID0gYnVmZmVyLmxlbmd0aDtcbiAgaWYgKHRoaXMuY2hhckxlbmd0aCkge1xuICAgIC8vIGJ1ZmZlciB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXIgYnl0ZXMgd2UgZ290XG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCAwLCBidWZmZXIubGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQsIGVuZCk7XG4gICAgZW5kIC09IHRoaXMuY2hhclJlY2VpdmVkO1xuICB9XG5cbiAgY2hhclN0ciArPSBidWZmZXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgZW5kKTtcblxuICB2YXIgZW5kID0gY2hhclN0ci5sZW5ndGggLSAxO1xuICB2YXIgY2hhckNvZGUgPSBjaGFyU3RyLmNoYXJDb2RlQXQoZW5kKTtcbiAgLy8gQ0VTVS04OiBsZWFkIHN1cnJvZ2F0ZSAoRDgwMC1EQkZGKSBpcyBhbHNvIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlclxuICBpZiAoY2hhckNvZGUgPj0gMHhEODAwICYmIGNoYXJDb2RlIDw9IDB4REJGRikge1xuICAgIHZhciBzaXplID0gdGhpcy5zdXJyb2dhdGVTaXplO1xuICAgIHRoaXMuY2hhckxlbmd0aCArPSBzaXplO1xuICAgIHRoaXMuY2hhclJlY2VpdmVkICs9IHNpemU7XG4gICAgdGhpcy5jaGFyQnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCBzaXplLCAwLCBzaXplKTtcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIDAsIDAsIHNpemUpO1xuICAgIHJldHVybiBjaGFyU3RyLnN1YnN0cmluZygwLCBlbmQpO1xuICB9XG5cbiAgLy8gb3IganVzdCBlbWl0IHRoZSBjaGFyU3RyXG4gIHJldHVybiBjaGFyU3RyO1xufTtcblxuLy8gZGV0ZWN0SW5jb21wbGV0ZUNoYXIgZGV0ZXJtaW5lcyBpZiB0aGVyZSBpcyBhbiBpbmNvbXBsZXRlIFVURi04IGNoYXJhY3RlciBhdFxuLy8gdGhlIGVuZCBvZiB0aGUgZ2l2ZW4gYnVmZmVyLiBJZiBzbywgaXQgc2V0cyB0aGlzLmNoYXJMZW5ndGggdG8gdGhlIGJ5dGVcbi8vIGxlbmd0aCB0aGF0IGNoYXJhY3RlciwgYW5kIHNldHMgdGhpcy5jaGFyUmVjZWl2ZWQgdG8gdGhlIG51bWJlciBvZiBieXRlc1xuLy8gdGhhdCBhcmUgYXZhaWxhYmxlIGZvciB0aGlzIGNoYXJhY3Rlci5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmRldGVjdEluY29tcGxldGVDaGFyID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIC8vIGRldGVybWluZSBob3cgbWFueSBieXRlcyB3ZSBoYXZlIHRvIGNoZWNrIGF0IHRoZSBlbmQgb2YgdGhpcyBidWZmZXJcbiAgdmFyIGkgPSAoYnVmZmVyLmxlbmd0aCA+PSAzKSA/IDMgOiBidWZmZXIubGVuZ3RoO1xuXG4gIC8vIEZpZ3VyZSBvdXQgaWYgb25lIG9mIHRoZSBsYXN0IGkgYnl0ZXMgb2Ygb3VyIGJ1ZmZlciBhbm5vdW5jZXMgYW5cbiAgLy8gaW5jb21wbGV0ZSBjaGFyLlxuICBmb3IgKDsgaSA+IDA7IGktLSkge1xuICAgIHZhciBjID0gYnVmZmVyW2J1ZmZlci5sZW5ndGggLSBpXTtcblxuICAgIC8vIFNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VURi04I0Rlc2NyaXB0aW9uXG5cbiAgICAvLyAxMTBYWFhYWFxuICAgIGlmIChpID09IDEgJiYgYyA+PiA1ID09IDB4MDYpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDI7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyAxMTEwWFhYWFxuICAgIGlmIChpIDw9IDIgJiYgYyA+PiA0ID09IDB4MEUpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDM7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyAxMTExMFhYWFxuICAgIGlmIChpIDw9IDMgJiYgYyA+PiAzID09IDB4MUUpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDQ7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBpO1xufTtcblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHZhciByZXMgPSAnJztcbiAgaWYgKGJ1ZmZlciAmJiBidWZmZXIubGVuZ3RoKVxuICAgIHJlcyA9IHRoaXMud3JpdGUoYnVmZmVyKTtcblxuICBpZiAodGhpcy5jaGFyUmVjZWl2ZWQpIHtcbiAgICB2YXIgY3IgPSB0aGlzLmNoYXJSZWNlaXZlZDtcbiAgICB2YXIgYnVmID0gdGhpcy5jaGFyQnVmZmVyO1xuICAgIHZhciBlbmMgPSB0aGlzLmVuY29kaW5nO1xuICAgIHJlcyArPSBidWYuc2xpY2UoMCwgY3IpLnRvU3RyaW5nKGVuYyk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gcGFzc1Rocm91Z2hXcml0ZShidWZmZXIpIHtcbiAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gdXRmMTZEZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpIHtcbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBidWZmZXIubGVuZ3RoICUgMjtcbiAgdGhpcy5jaGFyTGVuZ3RoID0gdGhpcy5jaGFyUmVjZWl2ZWQgPyAyIDogMDtcbn1cblxuZnVuY3Rpb24gYmFzZTY0RGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKSB7XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gYnVmZmVyLmxlbmd0aCAlIDM7XG4gIHRoaXMuY2hhckxlbmd0aCA9IHRoaXMuY2hhclJlY2VpdmVkID8gMyA6IDA7XG59XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5cblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudHMnO1xuaW1wb3J0IHtpbmhlcml0cywgZGVidWdsb2d9IGZyb20gJ3V0aWwnO1xuaW1wb3J0IEJ1ZmZlckxpc3QgZnJvbSAnLi9idWZmZXItbGlzdCc7XG5pbXBvcnQge1N0cmluZ0RlY29kZXJ9IGZyb20gJ3N0cmluZ19kZWNvZGVyJztcbmltcG9ydCB7RHVwbGV4fSBmcm9tICcuL2R1cGxleCc7XG5pbXBvcnQge25leHRUaWNrfSBmcm9tICdwcm9jZXNzJztcblxudmFyIGRlYnVnID0gZGVidWdsb2coJ3N0cmVhbScpO1xuaW5oZXJpdHMoUmVhZGFibGUsIEV2ZW50RW1pdHRlcik7XG5cbmZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4pIHtcbiAgLy8gU2FkbHkgdGhpcyBpcyBub3QgY2FjaGVhYmxlIGFzIHNvbWUgbGlicmFyaWVzIGJ1bmRsZSB0aGVpciBvd25cbiAgLy8gZXZlbnQgZW1pdHRlciBpbXBsZW1lbnRhdGlvbiB3aXRoIHRoZW0uXG4gIGlmICh0eXBlb2YgZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnQsIGZuKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIGlzIGEgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgYW55XG4gICAgLy8gdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuIFRoaXMgaXMgaGVyZSBvbmx5IGJlY2F1c2UgdGhpcyBjb2RlIG5lZWRzXG4gICAgLy8gdG8gY29udGludWUgdG8gd29yayB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIE5vZGUuanMgdGhhdCBkbyBub3QgaW5jbHVkZVxuICAgIC8vIHRoZSBwcmVwZW5kTGlzdGVuZXIoKSBtZXRob2QuIFRoZSBnb2FsIGlzIHRvIGV2ZW50dWFsbHkgcmVtb3ZlIHRoaXMgaGFjay5cbiAgICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW2V2ZW50XSlcbiAgICAgIGVtaXR0ZXIub24oZXZlbnQsIGZuKTtcbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGVtaXR0ZXIuX2V2ZW50c1tldmVudF0pKVxuICAgICAgZW1pdHRlci5fZXZlbnRzW2V2ZW50XS51bnNoaWZ0KGZuKTtcbiAgICBlbHNlXG4gICAgICBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXTtcbiAgfVxufVxuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCAoZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufVxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bSB8fCBod20gPT09IDAgPyBod20gOiBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gfiB+dGhpcy5oaWdoV2F0ZXJNYXJrO1xuXG4gIC8vIEEgbGlua2VkIGxpc3QgaXMgdXNlZCB0byBzdG9yZSBkYXRhIGNodW5rcyBpbnN0ZWFkIG9mIGFuIGFycmF5IGJlY2F1c2UgdGhlXG4gIC8vIGxpbmtlZCBsaXN0IGNhbiByZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nIGZhc3RlciB0aGFuXG4gIC8vIGFycmF5LnNoaWZ0KClcbiAgdGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyTGlzdCgpO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuICB0aGlzLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIHdoZW4gcGlwaW5nLCB3ZSBvbmx5IGNhcmUgYWJvdXQgJ3JlYWRhYmxlJyBldmVudHMgdGhhdCBoYXBwZW5cbiAgLy8gYWZ0ZXIgcmVhZCgpaW5nIGFsbCB0aGUgYnl0ZXMgYW5kIG5vdCBnZXR0aW5nIGFueSBwdXNoYmFjay5cbiAgdGhpcy5yYW5PdXQgPSBmYWxzZTtcblxuICAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuICB0aGlzLmF3YWl0RHJhaW4gPSAwO1xuXG4gIC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuXG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICB9XG59XG5leHBvcnQgZGVmYXVsdCBSZWFkYWJsZTtcbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5XG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLnJlYWQgPT09ICdmdW5jdGlvbicpIHRoaXMuX3JlYWQgPSBvcHRpb25zLnJlYWQ7XG5cbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG59XG5cbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBmYWxzZSk7XG59O1xuXG4vLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCAnJywgdHJ1ZSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPT09IGZhbHNlO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQpIHtcbiAgdmFyIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XG4gIGlmIChlcikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfSBlbHNlIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgIGlmIChzdGF0ZS5lbmRlZCAmJiAhYWRkVG9Gcm9udCkge1xuICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ3N0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GJyk7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZEVtaXR0ZWQgJiYgYWRkVG9Gcm9udCkge1xuICAgICAgdmFyIF9lID0gbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpO1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgX2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc2tpcEFkZDtcbiAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFhZGRUb0Zyb250ICYmICFlbmNvZGluZykge1xuICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuICAgICAgICBza2lwQWRkID0gIXN0YXRlLm9iamVjdE1vZGUgJiYgY2h1bmsubGVuZ3RoID09PSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWFkZFRvRnJvbnQpIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcblxuICAgICAgLy8gRG9uJ3QgYWRkIHRvIHRoZSBidWZmZXIgaWYgd2UndmUgZGVjb2RlZCB0byBhbiBlbXB0eSBzdHJpbmcgY2h1bmsgYW5kXG4gICAgICAvLyB3ZSdyZSBub3QgaW4gb2JqZWN0IG1vZGVcbiAgICAgIGlmICghc2tpcEFkZCkge1xuICAgICAgICAvLyBpZiB3ZSB3YW50IHRoZSBkYXRhIG5vdywganVzdCBlbWl0IGl0LlxuICAgICAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMpIHtcbiAgICAgICAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgICAgICAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxuICAgICAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICAgICAgICBpZiAoYWRkVG9Gcm9udCkgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO2Vsc2Ugc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuXG4gICAgICAgICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSkgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gbmVlZE1vcmVEYXRhKHN0YXRlKTtcbn1cblxuLy8gaWYgaXQncyBwYXN0IHRoZSBoaWdoIHdhdGVyIG1hcmssIHdlIGNhbiBwdXNoIGluIHNvbWUgbW9yZS5cbi8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lXG4vLyBtb3JlIGJ5dGVzLiAgVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCxcbi8vIHN1Y2ggYXMgdGhlIHJlcGwuICBBbHNvLCBpZiB0aGUgcHVzaCgpIHRyaWdnZXJlZCBhXG4vLyByZWFkYWJsZSBldmVudCwgYW5kIHRoZSB1c2VyIGNhbGxlZCByZWFkKGxhcmdlTnVtYmVyKSBzdWNoIHRoYXRcbi8vIG5lZWRSZWFkYWJsZSB3YXMgc2V0LCB0aGVuIHdlIG91Z2h0IHRvIHB1c2ggbW9yZSwgc28gdGhhdCBhbm90aGVyXG4vLyAncmVhZGFibGUnIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkLlxuZnVuY3Rpb24gbmVlZE1vcmVEYXRhKHN0YXRlKSB7XG4gIHJldHVybiAhc3RhdGUuZW5kZWQgJiYgKHN0YXRlLm5lZWRSZWFkYWJsZSB8fCBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCk7XG59XG5cbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24gKGVuYykge1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gZW5jO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIERvbid0IHJhaXNlIHRoZSBod20gPiA4TUJcbnZhciBNQVhfSFdNID0gMHg4MDAwMDA7XG5mdW5jdGlvbiBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyIHRvIHByZXZlbnQgaW5jcmVhc2luZyBod20gZXhjZXNzaXZlbHkgaW5cbiAgICAvLyB0aW55IGFtb3VudHNcbiAgICBuLS07XG4gICAgbiB8PSBuID4+PiAxO1xuICAgIG4gfD0gbiA+Pj4gMjtcbiAgICBuIHw9IG4gPj4+IDQ7XG4gICAgbiB8PSBuID4+PiA4O1xuICAgIG4gfD0gbiA+Pj4gMTY7XG4gICAgbisrO1xuICB9XG4gIHJldHVybiBuO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKG4gPD0gMCB8fCBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIHJldHVybiAwO1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0dXJuIDE7XG4gIGlmIChuICE9PSBuKSB7XG4gICAgLy8gT25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoKSByZXR1cm4gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YS5sZW5ndGg7ZWxzZSByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG4gIC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSBjdXJyZW50IGh3bSwgdGhlbiByYWlzZSB0aGUgaHdtLlxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKTtcbiAgaWYgKG4gPD0gc3RhdGUubGVuZ3RoKSByZXR1cm4gbjtcbiAgLy8gRG9uJ3QgaGF2ZSBlbm91Z2hcbiAgaWYgKCFzdGF0ZS5lbmRlZCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbn1cblxuLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZGVidWcoJ3JlYWQnLCBuKTtcbiAgbiA9IHBhcnNlSW50KG4sIDEwKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIG5PcmlnID0gbjtcblxuICBpZiAobiAhPT0gMCkgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5uZWVkUmVhZGFibGUgJiYgKHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtlbHNlIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpO1xuXG4gIC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZTtcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xuICB9XG5cbiAgLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xuICAgIGRvUmVhZCA9IGZhbHNlO1xuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcbiAgfSBlbHNlIGlmIChkb1JlYWQpIHtcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlO1xuICAgIC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7XG4gICAgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSxcbiAgICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG4gICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpO1xuICB9XG5cbiAgdmFyIHJldDtcbiAgaWYgKG4gPiAwKSByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7ZWxzZSByZXQgPSBudWxsO1xuXG4gIGlmIChyZXQgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIG4gPSAwO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmxlbmd0aCAtPSBuO1xuICB9XG5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAgIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cbiAgICBpZiAoIXN0YXRlLmVuZGVkKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gICAgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxuICAgIGlmIChuT3JpZyAhPT0gbiAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7XG4gIH1cblxuICBpZiAocmV0ICE9PSBudWxsKSB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlciA9IG51bGw7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICByZXR1cm4gZXI7XG59XG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUuZW5kZWQpIHJldHVybjtcbiAgaWYgKHN0YXRlLmRlY29kZXIpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbn1cblxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBpZiAoc3RhdGUuc3luYykgbmV4dFRpY2soZW1pdFJlYWRhYmxlXywgc3RyZWFtKTtlbHNlIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICBkZWJ1ZygnZW1pdCByZWFkYWJsZScpO1xuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbiAgZmxvdyhzdHJlYW0pO1xufVxuXG4vLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xuICAgIG5leHRUaWNrKG1heWJlUmVhZE1vcmVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRlYnVnKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aClcbiAgICAgIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICBicmVhaztlbHNlIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgfVxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xufVxuXG4vLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuICBkZWJ1ZygncGlwZSBjb3VudD0lZCBvcHRzPSVqJywgc3RhdGUucGlwZXNDb3VudCwgcGlwZU9wdHMpO1xuXG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSk7XG5cbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IGNsZWFudXA7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBuZXh0VGljayhlbmRGbik7ZWxzZSBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuXG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUpIHtcbiAgICBkZWJ1Zygnb251bnBpcGUnKTtcbiAgICBpZiAocmVhZGFibGUgPT09IHNyYykge1xuICAgICAgY2xlYW51cCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcblxuICAgIGNsZWFuZWRVcCA9IHRydWU7XG5cbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpIG9uZHJhaW4oKTtcbiAgfVxuXG4gIC8vIElmIHRoZSB1c2VyIHB1c2hlcyBtb3JlIGRhdGEgd2hpbGUgd2UncmUgd3JpdGluZyB0byBkZXN0IHRoZW4gd2UnbGwgZW5kIHVwXG4gIC8vIGluIG9uZGF0YSBhZ2Fpbi4gSG93ZXZlciwgd2Ugb25seSB3YW50IHRvIGluY3JlYXNlIGF3YWl0RHJhaW4gb25jZSBiZWNhdXNlXG4gIC8vIGRlc3Qgd2lsbCBvbmx5IGVtaXQgb25lICdkcmFpbicgZXZlbnQgZm9yIHRoZSBtdWx0aXBsZSB3cml0ZXMuXG4gIC8vID0+IEludHJvZHVjZSBhIGd1YXJkIG9uIGluY3JlYXNpbmcgYXdhaXREcmFpbi5cbiAgdmFyIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgZGVidWcoJ29uZGF0YScpO1xuICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgaWYgKGZhbHNlID09PSByZXQgJiYgIWluY3JlYXNlZEF3YWl0RHJhaW4pIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIHVucGlwZWQgZHVyaW5nIGBkZXN0LndyaXRlKClgLCBpdCBpcyBwb3NzaWJsZVxuICAgICAgLy8gdG8gZ2V0IHN0dWNrIGluIGEgcGVybWFuZW50bHkgcGF1c2VkIHN0YXRlIGlmIHRoYXQgd3JpdGVcbiAgICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuXG4gICAgICAvLyA9PiBDaGVjayB3aGV0aGVyIGBkZXN0YCBpcyBzdGlsbCBhIHBpcGluZyBkZXN0aW5hdGlvbi5cbiAgICAgIGlmICgoc3RhdGUucGlwZXNDb3VudCA9PT0gMSAmJiBzdGF0ZS5waXBlcyA9PT0gZGVzdCB8fCBzdGF0ZS5waXBlc0NvdW50ID4gMSAmJiBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KSAhPT0gLTEpICYmICFjbGVhbmVkVXApIHtcbiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgICAgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBzcmMucGF1c2UoKTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBlcik7XG4gICAgdW5waXBlKCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBpZiAobGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMCkgZGVzdC5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgdXNlcmxhbmQgb25lcy5cbiAgcHJlcGVuZExpc3RlbmVyKGRlc3QsICdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgZGVidWcoJ29uZmluaXNoJyk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblxuICBmdW5jdGlvbiB1bnBpcGUoKSB7XG4gICAgZGVidWcoJ3VucGlwZScpO1xuICAgIHNyYy51bnBpcGUoZGVzdCk7XG4gIH1cblxuICAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpO1xuXG4gIC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BpcGUgcmVzdW1lJyk7XG4gICAgc3JjLnJlc3VtZSgpO1xuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gICAgZGVidWcoJ3BpcGVPbkRyYWluJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4pIHN0YXRlLmF3YWl0RHJhaW4tLTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMCAmJiBzcmMubGlzdGVuZXJzKCdkYXRhJykubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICAgIGZsb3coc3JjKTtcbiAgICB9XG4gIH07XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbiAoZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApIHJldHVybiB0aGlzO1xuXG4gIC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcykgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAoIWRlc3QpIGRlc3QgPSBzdGF0ZS5waXBlcztcblxuICAgIC8vIGdvdCBhIG1hdGNoLlxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsZW47IF9pKyspIHtcbiAgICAgIGRlc3RzW19pXS5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcbiAgICB9cmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgb25lLlxuICB2YXIgaSA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaSA9PT0gLTEpIHJldHVybiB0aGlzO1xuXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpLCAxKTtcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkgc3RhdGUucGlwZXMgPSBzdGF0ZS5waXBlc1swXTtcblxuICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gc2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvclxuLy8gRW5zdXJlIHJlYWRhYmxlIGxpc3RlbmVycyBldmVudHVhbGx5IGdldCBzb21ldGhpbmdcblJlYWRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldiwgZm4pIHtcbiAgdmFyIHJlcyA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pO1xuXG4gIGlmIChldiA9PT0gJ2RhdGEnKSB7XG4gICAgLy8gU3RhcnQgZmxvd2luZyBvbiBuZXh0IHRpY2sgaWYgc3RyZWFtIGlzbid0IGV4cGxpY2l0bHkgcGF1c2VkXG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHRoaXMucmVzdW1lKCk7XG4gIH0gZWxzZSBpZiAoZXYgPT09ICdyZWFkYWJsZScpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICAgIG5leHRUaWNrKG5SZWFkaW5nTmV4dFRpY2ssIHRoaXMpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMsIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcblxuZnVuY3Rpb24gblJlYWRpbmdOZXh0VGljayhzZWxmKSB7XG4gIGRlYnVnKCdyZWFkYWJsZSBuZXh0dGljayByZWFkIDAnKTtcbiAgc2VsZi5yZWFkKDApO1xufVxuXG4vLyBwYXVzZSgpIGFuZCByZXN1bWUoKSBhcmUgcmVtbmFudHMgb2YgdGhlIGxlZ2FjeSByZWFkYWJsZSBzdHJlYW0gQVBJXG4vLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lJyk7XG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgcmVzdW1lKHRoaXMsIHN0YXRlKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7XG4gICAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBuZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfVxuXG4gIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICBzdGF0ZS5hd2FpdERyYWluID0gMDtcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xuICBmbG93KHN0cmVhbSk7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKSBzdHJlYW0ucmVhZCgwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnY2FsbCBwYXVzZSBmbG93aW5nPSVqJywgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKTtcbiAgaWYgKGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGF1c2UnKTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBmbG93KHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZyk7XG4gIHdoaWxlIChzdGF0ZS5mbG93aW5nICYmIHN0cmVhbS5yZWFkKCkgIT09IG51bGwpIHt9XG59XG5cbi8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSBzZWxmLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIHNlbGYucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZGF0YScpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuXG4gICAgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlXG4gICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpKSByZXR1cm47ZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSkgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IHNlbGYucHVzaChjaHVuayk7XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHRoaXNbaV0gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KGkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cbiAgdmFyIGV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcbiAgZm9yRWFjaChldmVudHMsIGZ1bmN0aW9uIChldikge1xuICAgIHN0cmVhbS5vbihldiwgc2VsZi5lbWl0LmJpbmQoc2VsZiwgZXYpKTtcbiAgfSk7XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgc2VsZi5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHNlbGY7XG59O1xuXG4vLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcblxuLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgLy8gbm90aGluZyBidWZmZXJlZFxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcblxuICB2YXIgcmV0O1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0ID0gc3RhdGUuYnVmZmVyLnNoaWZ0KCk7ZWxzZSBpZiAoIW4gfHwgbiA+PSBzdGF0ZS5sZW5ndGgpIHtcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGxpc3RcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgcmV0ID0gc3RhdGUuYnVmZmVyLmpvaW4oJycpO2Vsc2UgaWYgKHN0YXRlLmJ1ZmZlci5sZW5ndGggPT09IDEpIHJldCA9IHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGE7ZWxzZSByZXQgPSBzdGF0ZS5idWZmZXIuY29uY2F0KHN0YXRlLmxlbmd0aCk7XG4gICAgc3RhdGUuYnVmZmVyLmNsZWFyKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBwYXJ0IG9mIGxpc3RcbiAgICByZXQgPSBmcm9tTGlzdFBhcnRpYWwobiwgc3RhdGUuYnVmZmVyLCBzdGF0ZS5kZWNvZGVyKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbi8vIEV4dHJhY3RzIG9ubHkgZW5vdWdoIGJ1ZmZlcmVkIGRhdGEgdG8gc2F0aXNmeSB0aGUgYW1vdW50IHJlcXVlc3RlZC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3RQYXJ0aWFsKG4sIGxpc3QsIGhhc1N0cmluZ3MpIHtcbiAgdmFyIHJldDtcbiAgaWYgKG4gPCBsaXN0LmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBzbGljZSBpcyB0aGUgc2FtZSBmb3IgYnVmZmVycyBhbmQgc3RyaW5nc1xuICAgIHJldCA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKDAsIG4pO1xuICAgIGxpc3QuaGVhZC5kYXRhID0gbGlzdC5oZWFkLmRhdGEuc2xpY2Uobik7XG4gIH0gZWxzZSBpZiAobiA9PT0gbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gZmlyc3QgY2h1bmsgaXMgYSBwZXJmZWN0IG1hdGNoXG4gICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlc3VsdCBzcGFucyBtb3JlIHRoYW4gb25lIGJ1ZmZlclxuICAgIHJldCA9IGhhc1N0cmluZ3MgPyBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSA6IGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgY2hhcmFjdGVycyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGFcbi8vIGNodW5rcy5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkge1xuICB2YXIgcCA9IGxpc3QuaGVhZDtcbiAgdmFyIGMgPSAxO1xuICB2YXIgcmV0ID0gcC5kYXRhO1xuICBuIC09IHJldC5sZW5ndGg7XG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgdmFyIHN0ciA9IHAuZGF0YTtcbiAgICB2YXIgbmIgPSBuID4gc3RyLmxlbmd0aCA/IHN0ci5sZW5ndGggOiBuO1xuICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkgcmV0ICs9IHN0cjtlbHNlIHJldCArPSBzdHIuc2xpY2UoMCwgbik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IHN0ci5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgYnl0ZXMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhIGNodW5rcy5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gY29weUZyb21CdWZmZXIobiwgbGlzdCkge1xuICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4pO1xuICB2YXIgcCA9IGxpc3QuaGVhZDtcbiAgdmFyIGMgPSAxO1xuICBwLmRhdGEuY29weShyZXQpO1xuICBuIC09IHAuZGF0YS5sZW5ndGg7XG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgdmFyIGJ1ZiA9IHAuZGF0YTtcbiAgICB2YXIgbmIgPSBuID4gYnVmLmxlbmd0aCA/IGJ1Zi5sZW5ndGggOiBuO1xuICAgIGJ1Zi5jb3B5KHJldCwgcmV0Lmxlbmd0aCAtIG4sIDAsIG5iKTtcbiAgICBuIC09IG5iO1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICBpZiAobmIgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgKytjO1xuICAgICAgICBpZiAocC5uZXh0KSBsaXN0LmhlYWQgPSBwLm5leHQ7ZWxzZSBsaXN0LmhlYWQgPSBsaXN0LnRhaWwgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdC5oZWFkID0gcDtcbiAgICAgICAgcC5kYXRhID0gYnVmLnNsaWNlKG5iKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICArK2M7XG4gIH1cbiAgbGlzdC5sZW5ndGggLT0gYztcbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBJZiB3ZSBnZXQgaGVyZSBiZWZvcmUgY29uc3VtaW5nIGFsbCB0aGUgYnl0ZXMsIHRoZW4gdGhhdCBpcyBhXG4gIC8vIGJ1ZyBpbiBub2RlLiAgU2hvdWxkIG5ldmVyIGhhcHBlbi5cbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApIHRocm93IG5ldyBFcnJvcignXCJlbmRSZWFkYWJsZSgpXCIgY2FsbGVkIG9uIG5vbi1lbXB0eSBzdHJlYW0nKTtcblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gICAgbmV4dFRpY2soZW5kUmVhZGFibGVOVCwgc3RhdGUsIHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGVOVChzdGF0ZSwgc3RyZWFtKSB7XG4gIC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvckVhY2goeHMsIGYpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmKHhzW2ldLCBpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmRleE9mKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59XG4iLCAiLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuXG4vLyBJbXBsZW1lbnQgYW4gYXN5bmMgLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuXG5cbmltcG9ydCB7aW5oZXJpdHMsIGRlcHJlY2F0ZX0gZnJvbSAndXRpbCc7XG5pbXBvcnQge0J1ZmZlcn0gZnJvbSAnYnVmZmVyJztcbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xuaW1wb3J0IHtFdmVudEVtaXR0ZXJ9IGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQge0R1cGxleH0gZnJvbSAnLi9kdXBsZXgnO1xuaW1wb3J0IHtuZXh0VGlja30gZnJvbSAncHJvY2Vzcyc7XG5pbmhlcml0cyhXcml0YWJsZSwgRXZlbnRFbWl0dGVyKTtcblxuZnVuY3Rpb24gbm9wKCkge31cblxuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xuICB0aGlzLm5leHQgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2J1ZmZlcicsIHtcbiAgICBnZXQ6IGRlcHJlY2F0ZShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTtcbiAgICB9LCAnX3dyaXRhYmxlU3RhdGUuYnVmZmVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBfd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIgJyArICdpbnN0ZWFkLicpXG4gIH0pO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtIHx8IGh3bSA9PT0gMCA/IGh3bSA6IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+IH50aGlzLmhpZ2hXYXRlck1hcms7XG5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcbiAgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlO1xuXG4gIC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcbiAgdGhpcy5jb3JrZWQgPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24gKGVyKSB7XG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcbiAgfTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcblxuICAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXG4gIHRoaXMud3JpdGVsZW4gPSAwO1xuXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcblxuICAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xuICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWRcbiAgdGhpcy5wZW5kaW5nY2IgPSAwO1xuXG4gIC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcbiAgdGhpcy5wcmVmaW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXG4gIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG5cbiAgLy8gY291bnQgYnVmZmVyZWQgcmVxdWVzdHNcbiAgdGhpcy5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG5cbiAgLy8gYWxsb2NhdGUgdGhlIGZpcnN0IENvcmtlZFJlcXVlc3QsIHRoZXJlIGlzIGFsd2F5c1xuICAvLyBvbmUgYWxsb2NhdGVkIGFuZCBmcmVlIHRvIHVzZSwgYW5kIHdlIG1haW50YWluIGF0IG1vc3QgdHdvXG4gIHRoaXMuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3QodGhpcyk7XG59XG5cbldyaXRhYmxlU3RhdGUucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uIHdyaXRhYmxlU3RhdGVHZXRCdWZmZXIoKSB7XG4gIHZhciBjdXJyZW50ID0gdGhpcy5idWZmZXJlZFJlcXVlc3Q7XG4gIHZhciBvdXQgPSBbXTtcbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICBvdXQucHVzaChjdXJyZW50KTtcbiAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBXcml0YWJsZTtcbmV4cG9ydCBmdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG5cbiAgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0aG91Z2ggdGhleSdyZSBub3RcbiAgLy8gaW5zdGFuY2VvZiBXcml0YWJsZSwgdGhleSdyZSBpbnN0YW5jZW9mIFJlYWRhYmxlLlxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgV3JpdGFibGUpICYmICEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeS5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGUgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRlID0gb3B0aW9ucy53cml0ZTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZXYgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRldiA9IG9wdGlvbnMud3JpdGV2O1xuICB9XG5cbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG59XG5cbi8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdDYW5ub3QgcGlwZSwgbm90IHJlYWRhYmxlJykpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJyk7XG4gIC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgbmV4dFRpY2soY2IsIGVyKTtcbn1cblxuLy8gSWYgd2UgZ2V0IHNvbWV0aGluZyB0aGF0IGlzIG5vdCBhIGJ1ZmZlciwgc3RyaW5nLCBudWxsLCBvciB1bmRlZmluZWQsXG4vLyBhbmQgd2UncmUgbm90IGluIG9iamVjdE1vZGUsIHRoZW4gdGhhdCdzIGFuIGVycm9yLlxuLy8gT3RoZXJ3aXNlIHN0cmVhbSBjaHVua3MgYXJlIGFsbCBjb25zaWRlcmVkIHRvIGJlIG9mIGxlbmd0aD0xLCBhbmQgdGhlXG4vLyB3YXRlcm1hcmtzIGRldGVybWluZSBob3cgbWFueSBvYmplY3RzIHRvIGtlZXAgaW4gdGhlIGJ1ZmZlciwgcmF0aGVyIHRoYW5cbi8vIGhvdyBtYW55IGJ5dGVzIG9yIGNoYXJhY3RlcnMuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgdmFsaWQgPSB0cnVlO1xuICB2YXIgZXIgPSBmYWxzZTtcbiAgLy8gQWx3YXlzIHRocm93IGVycm9yIGlmIGEgbnVsbCBpcyB3cml0dGVuXG4gIC8vIGlmIHdlIGFyZSBub3QgaW4gb2JqZWN0IG1vZGUgdGhlbiB0aHJvd1xuICAvLyBpZiBpdCBpcyBub3QgYSBidWZmZXIsIHN0cmluZywgb3IgdW5kZWZpbmVkLlxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ01heSBub3Qgd3JpdGUgbnVsbCB2YWx1ZXMgdG8gc3RyZWFtJyk7XG4gIH0gZWxzZSBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIG5leHRUaWNrKGNiLCBlcik7XG4gICAgdmFsaWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsaWQ7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIHZhciByZXQgPSBmYWxzZTtcblxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkgZW5jb2RpbmcgPSAnYnVmZmVyJztlbHNlIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuXG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIGNiID0gbm9wO1xuXG4gIGlmIChzdGF0ZS5lbmRlZCkgd3JpdGVBZnRlckVuZCh0aGlzLCBjYik7ZWxzZSBpZiAodmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSkge1xuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIHN0YXRlLmNvcmtlZCsrO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG5cbiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XG4gIH1cbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2RpbmcgPSBmdW5jdGlvbiBzZXREZWZhdWx0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgLy8gbm9kZTo6UGFyc2VFbmNvZGluZygpIHJlcXVpcmVzIGxvd2VyIGNhc2UuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG4gIGlmICghKFsnaGV4JywgJ3V0ZjgnLCAndXRmLTgnLCAnYXNjaWknLCAnYmluYXJ5JywgJ2Jhc2U2NCcsICd1Y3MyJywgJ3Vjcy0yJywgJ3V0ZjE2bGUnLCAndXRmLTE2bGUnLCAncmF3J10uaW5kZXhPZigoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKSkgPiAtMSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVmYXVsdEVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuICByZXR1cm4gY2h1bms7XG59XG5cbi8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcblxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG5cbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuICBpZiAoIXJldCkgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpIHtcbiAgICB2YXIgbGFzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG5ldyBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgICBpZiAobGFzdCkge1xuICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgKz0gMTtcbiAgfSBlbHNlIHtcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIGlmICh3cml0ZXYpIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtlbHNlIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XG4gIC0tc3RhdGUucGVuZGluZ2NiO1xuICBpZiAoc3luYykgbmV4dFRpY2soY2IsIGVyKTtlbHNlIGNiKGVyKTtcblxuICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcblxuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuXG4gIGlmIChlcikgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7ZWxzZSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcblxuICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIHtcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChzeW5jKSB7XG4gICAgICAvKjxyZXBsYWNlbWVudD4qL1xuICAgICAgICBuZXh0VGljayhhZnRlcldyaXRlLCBzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgICAgLyo8L3JlcGxhY2VtZW50PiovXG4gICAgfSBlbHNlIHtcbiAgICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgc3RhdGUucGVuZGluZ2NiLS07XG4gIGNiKCk7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn1cblxuLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG4gIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdDtcblxuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgZW50cnkgJiYgZW50cnkubmV4dCkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgbCA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50O1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobCk7XG4gICAgdmFyIGhvbGRlciA9IHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZTtcbiAgICBob2xkZXIuZW50cnkgPSBlbnRyeTtcblxuICAgIHZhciBjb3VudCA9IDA7XG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICBidWZmZXJbY291bnRdID0gZW50cnk7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBjb3VudCArPSAxO1xuICAgIH1cblxuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBidWZmZXIsICcnLCBob2xkZXIuZmluaXNoKTtcblxuICAgIC8vIGRvV3JpdGUgaXMgYWxtb3N0IGFsd2F5cyBhc3luYywgZGVmZXIgdGhlc2UgdG8gc2F2ZSBhIGJpdCBvZiB0aW1lXG4gICAgLy8gYXMgdGhlIGhvdCBwYXRoIGVuZHMgd2l0aCBkb1dyaXRlXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gICAgaWYgKGhvbGRlci5uZXh0KSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDtcbiAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXQgZG9lcy5cbiAgICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVudHJ5ID09PSBudWxsKSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcblxuICAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG59O1xuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7XG59XG5cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQpIHtcbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5lZWQ7XG59XG5cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpIG5leHRUaWNrKGNiKTtlbHNlIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZTtcbn1cblxuLy8gSXQgc2VlbXMgYSBsaW5rZWQgbGlzdCBidXQgaXQgaXMgbm90XG4vLyB0aGVyZSB3aWxsIGJlIG9ubHkgMiBvZiB0aGVzZSBmb3IgZWFjaCBzdHJlYW1cbmZ1bmN0aW9uIENvcmtlZFJlcXVlc3Qoc3RhdGUpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB0aGlzLm5leHQgPSBudWxsO1xuICB0aGlzLmVudHJ5ID0gbnVsbDtcblxuICB0aGlzLmZpbmlzaCA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICB2YXIgZW50cnkgPSBfdGhpcy5lbnRyeTtcbiAgICBfdGhpcy5lbnRyeSA9IG51bGw7XG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgICAgY2IoZXJyKTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICB9XG4gICAgaWYgKHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSkge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlLm5leHQgPSBfdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gX3RoaXM7XG4gICAgfVxuICB9O1xufVxuIiwgIlxuaW1wb3J0IHtpbmhlcml0c30gZnJvbSAndXRpbCc7XG5pbXBvcnQge25leHRUaWNrfSBmcm9tICdwcm9jZXNzJztcbmltcG9ydCB7UmVhZGFibGV9IGZyb20gJy4vcmVhZGFibGUnO1xuaW1wb3J0IHtXcml0YWJsZX0gZnJvbSAnLi93cml0YWJsZSc7XG5cblxuaW5oZXJpdHMoRHVwbGV4LCBSZWFkYWJsZSk7XG5cbnZhciBrZXlzID0gT2JqZWN0LmtleXMoV3JpdGFibGUucHJvdG90eXBlKTtcbmZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICB2YXIgbWV0aG9kID0ga2V5c1t2XTtcbiAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xufVxuZXhwb3J0IGRlZmF1bHQgRHVwbGV4O1xuZXhwb3J0IGZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcblxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKSB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKSB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcblxuICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbn1cblxuLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxuZnVuY3Rpb24gb25lbmQoKSB7XG4gIC8vIGlmIHdlIGFsbG93IGhhbGYtb3BlbiBzdGF0ZSwgb3IgaWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsXG4gIC8vIHRoZW4gd2UncmUgb2suXG4gIGlmICh0aGlzLmFsbG93SGFsZk9wZW4gfHwgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgcmV0dXJuO1xuXG4gIC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cbiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suXG4gIG5leHRUaWNrKG9uRW5kTlQsIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBvbkVuZE5UKHNlbGYpIHtcbiAgc2VsZi5lbmQoKTtcbn1cbiIsICIvLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFwiZmlsdGVyXCIsXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxuLy9cbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXG4vL1xuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxuLy9cbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxuLy9cbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXG4vL1xuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXG4vL1xuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXG5cblxuaW1wb3J0IHtEdXBsZXh9IGZyb20gJy4vZHVwbGV4JztcblxuXG5pbXBvcnQge2luaGVyaXRzfSBmcm9tICd1dGlsJztcbmluaGVyaXRzKFRyYW5zZm9ybSwgRHVwbGV4KTtcblxuZnVuY3Rpb24gVHJhbnNmb3JtU3RhdGUoc3RyZWFtKSB7XG4gIHRoaXMuYWZ0ZXJUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoZXIsIGRhdGEpIHtcbiAgICByZXR1cm4gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSk7XG4gIH07XG5cbiAgdGhpcy5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHRoaXMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG4gIHRoaXMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRoaXMud3JpdGVlbmNvZGluZyA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG5cbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcblxuICBpZiAoIWNiKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdubyB3cml0ZWNiIGluIFRyYW5zZm9ybSBjbGFzcycpKTtcblxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG5cbiAgaWYgKGRhdGEgIT09IG51bGwgJiYgZGF0YSAhPT0gdW5kZWZpbmVkKSBzdHJlYW0ucHVzaChkYXRhKTtcblxuICBjYihlcik7XG5cbiAgdmFyIHJzID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBycy5yZWFkaW5nID0gZmFsc2U7XG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgIHN0cmVhbS5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufVxuZXhwb3J0IGRlZmF1bHQgVHJhbnNmb3JtO1xuZXhwb3J0IGZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKSByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcblxuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IG5ldyBUcmFuc2Zvcm1TdGF0ZSh0aGlzKTtcblxuICAvLyB3aGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuXG4gIHZhciBzdHJlYW0gPSB0aGlzO1xuXG4gIC8vIHN0YXJ0IG91dCBhc2tpbmcgZm9yIGEgcmVhZGFibGUgZXZlbnQgb25jZSBkYXRhIGlzIHRyYW5zZm9ybWVkLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gd2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgX3JlYWQgbWV0aG9kLCBhbmQgZG9uZSB0aGUgb3RoZXIgdGhpbmdzXG4gIC8vIHRoYXQgUmVhZGFibGUgd2FudHMgYmVmb3JlIHRoZSBmaXJzdCBfcmVhZCBjYWxsLCBzbyB1bnNldCB0aGVcbiAgLy8gc3luYyBndWFyZCBmbGFnLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHRoaXMuX3RyYW5zZm9ybSA9IG9wdGlvbnMudHJhbnNmb3JtO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaCA9IG9wdGlvbnMuZmx1c2g7XG4gIH1cblxuICB0aGlzLm9uY2UoJ3ByZWZpbmlzaCcsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuX2ZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaChmdW5jdGlvbiAoZXIpIHtcbiAgICAgIGRvbmUoc3RyZWFtLCBlcik7XG4gICAgfSk7ZWxzZSBkb25lKHN0cmVhbSk7XG4gIH0pO1xufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XG59O1xuXG4vLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcbi8vIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaW4gaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuXG4vL1xuLy8gQ2FsbCBgcHVzaChuZXdDaHVuaylgIHRvIHBhc3MgYWxvbmcgdHJhbnNmb3JtZWQgb3V0cHV0XG4vLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLlxuLy9cbi8vIENhbGwgYGNiKGVycilgIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBjaHVuay4gIElmIHlvdSBwYXNzXG4vLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91XG4vLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLndyaXRlY2IgPSBjYjtcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fCBycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTtcblxuLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh0cy53cml0ZWNodW5rICE9PSBudWxsICYmIHRzLndyaXRlY2IgJiYgIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlcikge1xuICBpZiAoZXIpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG5cbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcbiAgdmFyIHdzID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh3cy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHdzLmxlbmd0aCAhPSAwJyk7XG5cbiAgaWYgKHRzLnRyYW5zZm9ybWluZykgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gc3RpbGwgdHJhbnNmb3JtaW5nJyk7XG5cbiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xufVxuIiwgIlxuaW1wb3J0IHtUcmFuc2Zvcm19IGZyb20gJy4vdHJhbnNmb3JtJztcblxuaW1wb3J0IHtpbmhlcml0c30gZnJvbSAndXRpbCc7XG5pbmhlcml0cyhQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcbmV4cG9ydCBkZWZhdWx0IFBhc3NUaHJvdWdoO1xuZXhwb3J0IGZ1bmN0aW9uIFBhc3NUaHJvdWdoKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhc3NUaHJvdWdoKSkgcmV0dXJuIG5ldyBQYXNzVGhyb3VnaChvcHRpb25zKTtcblxuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cblxuUGFzc1Rocm91Z2gucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihudWxsLCBjaHVuayk7XG59O1xuIiwgImltcG9ydCBFRSBmcm9tICdldmVudHMnO1xuaW1wb3J0IHtpbmhlcml0c30gZnJvbSAndXRpbCc7XG5cbmltcG9ydCB7RHVwbGV4fSBmcm9tICcuL3JlYWRhYmxlLXN0cmVhbS9kdXBsZXguanMnO1xuaW1wb3J0IHtSZWFkYWJsZX0gZnJvbSAnLi9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanMnO1xuaW1wb3J0IHtXcml0YWJsZX0gZnJvbSAnLi9yZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanMnO1xuaW1wb3J0IHtUcmFuc2Zvcm19IGZyb20gJy4vcmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcyc7XG5pbXBvcnQge1Bhc3NUaHJvdWdofSBmcm9tICcuL3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcyc7XG5pbmhlcml0cyhTdHJlYW0sIEVFKTtcblN0cmVhbS5SZWFkYWJsZSA9IFJlYWRhYmxlO1xuU3RyZWFtLldyaXRhYmxlID0gV3JpdGFibGU7XG5TdHJlYW0uRHVwbGV4ID0gRHVwbGV4O1xuU3RyZWFtLlRyYW5zZm9ybSA9IFRyYW5zZm9ybTtcblN0cmVhbS5QYXNzVGhyb3VnaCA9IFBhc3NUaHJvdWdoO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjQueFxuU3RyZWFtLlN0cmVhbSA9IFN0cmVhbTtcblxuZXhwb3J0IGRlZmF1bHQgU3RyZWFtO1xuZXhwb3J0IHtSZWFkYWJsZSxXcml0YWJsZSxEdXBsZXgsVHJhbnNmb3JtLFBhc3NUaHJvdWdoLFN0cmVhbX1cblxuLy8gb2xkLXN0eWxlIHN0cmVhbXMuICBOb3RlIHRoYXQgdGhlIHBpcGUgbWV0aG9kICh0aGUgb25seSByZWxldmFudFxuLy8gcGFydCBvZiB0aGlzIGNsYXNzKSBpcyBvdmVycmlkZGVuIGluIHRoZSBSZWFkYWJsZSBjbGFzcy5cblxuZnVuY3Rpb24gU3RyZWFtKCkge1xuICBFRS5jYWxsKHRoaXMpO1xufVxuXG5TdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBvcHRpb25zKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGlmIChkZXN0LndyaXRhYmxlKSB7XG4gICAgICBpZiAoZmFsc2UgPT09IGRlc3Qud3JpdGUoY2h1bmspICYmIHNvdXJjZS5wYXVzZSkge1xuICAgICAgICBzb3VyY2UucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2RhdGEnLCBvbmRhdGEpO1xuXG4gIGZ1bmN0aW9uIG9uZHJhaW4oKSB7XG4gICAgaWYgKHNvdXJjZS5yZWFkYWJsZSAmJiBzb3VyY2UucmVzdW1lKSB7XG4gICAgICBzb3VyY2UucmVzdW1lKCk7XG4gICAgfVxuICB9XG5cbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICAvLyBJZiB0aGUgJ2VuZCcgb3B0aW9uIGlzIG5vdCBzdXBwbGllZCwgZGVzdC5lbmQoKSB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gIC8vIHNvdXJjZSBnZXRzIHRoZSAnZW5kJyBvciAnY2xvc2UnIGV2ZW50cy4gIE9ubHkgZGVzdC5lbmQoKSBvbmNlLlxuICBpZiAoIWRlc3QuX2lzU3RkaW8gJiYgKCFvcHRpb25zIHx8IG9wdGlvbnMuZW5kICE9PSBmYWxzZSkpIHtcbiAgICBzb3VyY2Uub24oJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2Uub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH1cblxuICB2YXIgZGlkT25FbmQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBpZiAodHlwZW9mIGRlc3QuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgZGVzdC5kZXN0cm95KCk7XG4gIH1cblxuICAvLyBkb24ndCBsZWF2ZSBkYW5nbGluZyBwaXBlcyB3aGVuIHRoZXJlIGFyZSBlcnJvcnMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBjbGVhbnVwKCk7XG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQodGhpcywgJ2Vycm9yJykgPT09IDApIHtcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgc3RyZWFtIGVycm9yIGluIHBpcGUuXG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIHJlbW92ZSBhbGwgdGhlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG4gIH1cblxuICBzb3VyY2Uub24oJ2VuZCcsIGNsZWFudXApO1xuICBzb3VyY2Uub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzb3VyY2UpO1xuXG4gIC8vIEFsbG93IGZvciB1bml4LWxpa2UgdXNhZ2U6IEEucGlwZShCKS5waXBlKEMpXG4gIHJldHVybiBkZXN0O1xufTtcbiIsICJcbmNvbnN0IHBvbHlmaWxsID0gcmVxdWlyZSgnc3RyZWFtJylcblxuaWYgKHBvbHlmaWxsICYmIHBvbHlmaWxsLmRlZmF1bHQpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHBvbHlmaWxsLmRlZmF1bHRcbiAgICBmb3IgKGxldCBrIGluIHBvbHlmaWxsKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzW2tdID0gcG9seWZpbGxba11cbiAgICB9XG59IGVsc2UgaWYgKHBvbHlmaWxsKSAge1xuICAgIG1vZHVsZS5leHBvcnRzID0gcG9seWZpbGxcbn1cblxuXG4iLCAiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNy4wLjJcbiAqIHJlYWN0LWRvbS1zZXJ2ZXIubm9kZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcbnZhciBzdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxuLy8gVE9ETzogdGhpcyBpcyBzcGVjaWFsIGJlY2F1c2UgaXQgZ2V0cyBpbXBvcnRlZCBkdXJpbmcgYnVpbGQuXG52YXIgUmVhY3RWZXJzaW9uID0gJzE3LjAuMic7XG5cbi8vIERvIG5vdCByZXF1aXJlIHRoaXMgbW9kdWxlIGRpcmVjdGx5ISBVc2Ugbm9ybWFsIGBpbnZhcmlhbnRgIGNhbGxzIHdpdGhcbi8vIHRlbXBsYXRlIGxpdGVyYWwgc3RyaW5ncy4gVGhlIG1lc3NhZ2VzIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBlcnJvciBjb2Rlc1xuLy8gZHVyaW5nIGJ1aWxkLlxuZnVuY3Rpb24gZm9ybWF0UHJvZEVycm9yTWVzc2FnZShjb2RlKSB7XG4gIHZhciB1cmwgPSAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL2Vycm9yLWRlY29kZXIuaHRtbD9pbnZhcmlhbnQ9JyArIGNvZGU7XG5cbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB1cmwgKz0gJyZhcmdzW109JyArIGVuY29kZVVSSUNvbXBvbmVudChhcmd1bWVudHNbaV0pO1xuICB9XG5cbiAgcmV0dXJuIFwiTWluaWZpZWQgUmVhY3QgZXJyb3IgI1wiICsgY29kZSArIFwiOyB2aXNpdCBcIiArIHVybCArIFwiIGZvciB0aGUgZnVsbCBtZXNzYWdlIG9yIFwiICsgJ3VzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCBmb3IgZnVsbCBlcnJvcnMgYW5kIGFkZGl0aW9uYWwgJyArICdoZWxwZnVsIHdhcm5pbmdzLic7XG59XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG4vLyBieSBjYWxscyB0byB0aGVzZSBtZXRob2RzIGJ5IGEgQmFiZWwgcGx1Z2luLlxuLy9cbi8vIEluIFBST0QgKG9yIGluIHBhY2thZ2VzIHdpdGhvdXQgYWNjZXNzIHRvIFJlYWN0IGludGVybmFscyksXG4vLyB0aGV5IGFyZSBsZWZ0IGFzIHRoZXkgYXJlIGluc3RlYWQuXG5cbmZ1bmN0aW9uIHdhcm4oZm9ybWF0KSB7XG4gIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBwcmludFdhcm5pbmcoJ3dhcm4nLCBmb3JtYXQsIGFyZ3MpO1xuICB9XG59XG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cbiAge1xuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuICAgIGlmIChzdGFjayAhPT0gJycpIHtcbiAgICAgIGZvcm1hdCArPSAnJXMnO1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgIH1cblxuICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gJycgKyBpdGVtO1xuICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuXG4gICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gIH1cbn1cblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IDB4ZWFjNztcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IDB4ZWFjYTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gMHhlYWNiO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSAweGVhY2M7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IDB4ZWFkMjtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IDB4ZWFjZTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gMHhlYWQwO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSAweGVhZDE7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gMHhlYWQ4O1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IDB4ZWFkMztcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSAweGVhZDQ7XG52YXIgUkVBQ1RfQkxPQ0tfVFlQRSA9IDB4ZWFkOTtcbnZhciBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSA9IDB4ZWFkYTtcbnZhciBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gMHhlYWQ1O1xudmFyIFJFQUNUX1NDT1BFX1RZUEUgPSAweGVhZDc7XG52YXIgUkVBQ1RfT1BBUVVFX0lEX1RZUEUgPSAweGVhZTA7XG52YXIgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSAweGVhZTE7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSAweGVhZTI7XG52YXIgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gMHhlYWUzO1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yKSB7XG4gIHZhciBzeW1ib2xGb3IgPSBTeW1ib2wuZm9yO1xuICBSRUFDVF9FTEVNRU5UX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbiAgUkVBQ1RfUE9SVEFMX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnBvcnRhbCcpO1xuICBSRUFDVF9GUkFHTUVOVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5mcmFnbWVudCcpO1xuICBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xuICBSRUFDVF9QUk9GSUxFUl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wcm9maWxlcicpO1xuICBSRUFDVF9QUk9WSURFUl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wcm92aWRlcicpO1xuICBSRUFDVF9DT05URVhUX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmNvbnRleHQnKTtcbiAgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbiAgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3VzcGVuc2UnKTtcbiAgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG4gIFJFQUNUX01FTU9fVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubWVtbycpO1xuICBSRUFDVF9MQVpZX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmxhenknKTtcbiAgUkVBQ1RfQkxPQ0tfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuYmxvY2snKTtcbiAgUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnNlcnZlci5ibG9jaycpO1xuICBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5mdW5kYW1lbnRhbCcpO1xuICBSRUFDVF9TQ09QRV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zY29wZScpO1xuICBSRUFDVF9PUEFRVUVfSURfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Qub3BhcXVlLmlkJyk7XG4gIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5kZWJ1Z190cmFjZV9tb2RlJyk7XG4gIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5vZmZzY3JlZW4nKTtcbiAgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5sZWdhY3lfaGlkZGVuJyk7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lIHx8IChmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWUpO1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn1cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWUoKS4gJyArICdUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcblxuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cbiAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcblxuICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKHR5cGUudHlwZSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfQkxPQ0tfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUodHlwZS5fcmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZShpbml0KHBheWxvYWQpKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gRmlsdGVyIGNlcnRhaW4gRE9NIGF0dHJpYnV0ZXMgKGUuZy4gc3JjLCBocmVmKSBpZiB0aGVpciB2YWx1ZXMgYXJlIGVtcHR5IHN0cmluZ3MuXG5cbnZhciBlbmFibGVTdXNwZW5zZVNlcnZlclJlbmRlcmVyID0gZmFsc2U7XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGxvZzogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZXYXJuXG4gICAgICAgIH0pLFxuICAgICAgICBlcnJvcjogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cEVuZDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRyb2w7XG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBzaG91bGQgYmUgc2V0dGluZyB0aGUgcHJvcHMgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lXG5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICBjb250cm9sID0geDtcbiAgICAgIH1cblxuICAgICAgZm4oKTtcbiAgICB9XG4gIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGUuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2wuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxuICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxuICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgYy0tO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG4gICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG4gICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBzLS07XG4gICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cblxuICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgICAgICAgIC8vIFY4IGFkZHMgYSBcIm5ld1wiIHByZWZpeCBmb3IgbmF0aXZlIGNsYXNzZXMuIExldCdzIHJlbW92ZSBpdCB0byBtYWtlIGl0IHByZXR0aWVyLlxuICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTtcblxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfQkxPQ0tfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLl9yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGluaXQocGF5bG9hZCksIHNvdXJjZSwgb3duZXJGbik7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50KSB7XG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lIFRoaXMgaXMgb2theSBidXQgRmxvdyBkb2Vzbid0IGtub3cgaXQuXG4gICAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcblxuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciQxID0gdm9pZCAwOyAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMnICsgJyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IkMSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvciQxLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yJDEubWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZTtcblxue1xuICBkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUgPSBuZXcgU2V0KCk7XG59XG5cbnZhciBlbXB0eU9iamVjdCA9IHt9O1xuXG57XG4gIE9iamVjdC5mcmVlemUoZW1wdHlPYmplY3QpO1xufVxuXG5mdW5jdGlvbiBtYXNrQ29udGV4dCh0eXBlLCBjb250ZXh0KSB7XG4gIHZhciBjb250ZXh0VHlwZXMgPSB0eXBlLmNvbnRleHRUeXBlcztcblxuICBpZiAoIWNvbnRleHRUeXBlcykge1xuICAgIHJldHVybiBlbXB0eU9iamVjdDtcbiAgfVxuXG4gIHZhciBtYXNrZWRDb250ZXh0ID0ge307XG5cbiAgZm9yICh2YXIgY29udGV4dE5hbWUgaW4gY29udGV4dFR5cGVzKSB7XG4gICAgbWFza2VkQ29udGV4dFtjb250ZXh0TmFtZV0gPSBjb250ZXh0W2NvbnRleHROYW1lXTtcbiAgfVxuXG4gIHJldHVybiBtYXNrZWRDb250ZXh0O1xufVxuXG5mdW5jdGlvbiBjaGVja0NvbnRleHRUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24pIHtcbiAge1xuICAgIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgJ0NvbXBvbmVudCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ29udGV4dEJvdW5kcyhjb250ZXh0LCB0aHJlYWRJRCkge1xuICAvLyBJZiB3ZSBkb24ndCBoYXZlIGVub3VnaCBzbG90cyBpbiB0aGlzIGNvbnRleHQgdG8gc3RvcmUgdGhpcyB0aHJlYWRJRCxcbiAgLy8gZmlsbCBpdCBpbiB3aXRob3V0IGxlYXZpbmcgYW55IGhvbGVzIHRvIGVuc3VyZSB0aGF0IHRoZSBWTSBvcHRpbWl6ZXNcbiAgLy8gdGhpcyBhcyBub24taG9sZXkgaW5kZXggcHJvcGVydGllcy5cbiAgLy8gKE5vdGU6IElmIGByZWFjdGAgcGFja2FnZSBpcyA8IDE2LjYsIF90aHJlYWRDb3VudCBpcyB1bmRlZmluZWQuKVxuICBmb3IgKHZhciBpID0gY29udGV4dC5fdGhyZWFkQ291bnQgfCAwOyBpIDw9IHRocmVhZElEOyBpKyspIHtcbiAgICAvLyBXZSBhc3N1bWUgdGhhdCB0aGlzIGlzIHRoZSBzYW1lIGFzIHRoZSBkZWZhdWx0VmFsdWUgd2hpY2ggbWlnaHQgbm90IGJlXG4gICAgLy8gdHJ1ZSBpZiB3ZSdyZSByZW5kZXJpbmcgaW5zaWRlIGEgc2Vjb25kYXJ5IHJlbmRlcmVyIGJ1dCB0aGV5IGFyZVxuICAgIC8vIHNlY29uZGFyeSBiZWNhdXNlIHRoZXNlIHVzZSBjYXNlcyBhcmUgdmVyeSByYXJlLlxuICAgIGNvbnRleHRbaV0gPSBjb250ZXh0Ll9jdXJyZW50VmFsdWUyO1xuICAgIGNvbnRleHQuX3RocmVhZENvdW50ID0gaSArIDE7XG4gIH1cbn1cbmZ1bmN0aW9uIHByb2Nlc3NDb250ZXh0KHR5cGUsIGNvbnRleHQsIHRocmVhZElELCBpc0NsYXNzKSB7XG4gIGlmIChpc0NsYXNzKSB7XG4gICAgdmFyIGNvbnRleHRUeXBlID0gdHlwZS5jb250ZXh0VHlwZTtcblxuICAgIHtcbiAgICAgIGlmICgnY29udGV4dFR5cGUnIGluIHR5cGUpIHtcbiAgICAgICAgdmFyIGlzVmFsaWQgPSAvLyBBbGxvdyBudWxsIGZvciBjb25kaXRpb25hbCBkZWNsYXJhdGlvblxuICAgICAgICBjb250ZXh0VHlwZSA9PT0gbnVsbCB8fCBjb250ZXh0VHlwZSAhPT0gdW5kZWZpbmVkICYmIGNvbnRleHRUeXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgJiYgY29udGV4dFR5cGUuX2NvbnRleHQgPT09IHVuZGVmaW5lZDsgLy8gTm90IGEgPENvbnRleHQuQ29uc3VtZXI+XG5cbiAgICAgICAgaWYgKCFpc1ZhbGlkICYmICFkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUuaGFzKHR5cGUpKSB7XG4gICAgICAgICAgZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlLmFkZCh0eXBlKTtcbiAgICAgICAgICB2YXIgYWRkZW5kdW0gPSAnJztcblxuICAgICAgICAgIGlmIChjb250ZXh0VHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhZGRlbmR1bSA9ICcgSG93ZXZlciwgaXQgaXMgc2V0IHRvIHVuZGVmaW5lZC4gJyArICdUaGlzIGNhbiBiZSBjYXVzZWQgYnkgYSB0eXBvIG9yIGJ5IG1peGluZyB1cCBuYW1lZCBhbmQgZGVmYXVsdCBpbXBvcnRzLiAnICsgJ1RoaXMgY2FuIGFsc28gaGFwcGVuIGR1ZSB0byBhIGNpcmN1bGFyIGRlcGVuZGVuY3ksIHNvICcgKyAndHJ5IG1vdmluZyB0aGUgY3JlYXRlQ29udGV4dCgpIGNhbGwgdG8gYSBzZXBhcmF0ZSBmaWxlLic7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY29udGV4dFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBhZGRlbmR1bSA9ICcgSG93ZXZlciwgaXQgaXMgc2V0IHRvIGEgJyArIHR5cGVvZiBjb250ZXh0VHlwZSArICcuJztcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHRUeXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFKSB7XG4gICAgICAgICAgICBhZGRlbmR1bSA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyB0aGUgQ29udGV4dC5Qcm92aWRlciBpbnN0ZWFkPyc7XG4gICAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0VHlwZS5fY29udGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyA8Q29udGV4dC5Db25zdW1lcj5cbiAgICAgICAgICAgIGFkZGVuZHVtID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIHRoZSBDb250ZXh0LkNvbnN1bWVyIGluc3RlYWQ/JztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWRkZW5kdW0gPSAnIEhvd2V2ZXIsIGl0IGlzIHNldCB0byBhbiBvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY29udGV4dFR5cGUpLmpvaW4oJywgJykgKyAnfS4nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yKCclcyBkZWZpbmVzIGFuIGludmFsaWQgY29udGV4dFR5cGUuICcgKyAnY29udGV4dFR5cGUgc2hvdWxkIHBvaW50IHRvIHRoZSBDb250ZXh0IG9iamVjdCByZXR1cm5lZCBieSBSZWFjdC5jcmVhdGVDb250ZXh0KCkuJXMnLCBnZXRDb21wb25lbnROYW1lKHR5cGUpIHx8ICdDb21wb25lbnQnLCBhZGRlbmR1bSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNvbnRleHRUeXBlID09PSAnb2JqZWN0JyAmJiBjb250ZXh0VHlwZSAhPT0gbnVsbCkge1xuICAgICAgdmFsaWRhdGVDb250ZXh0Qm91bmRzKGNvbnRleHRUeXBlLCB0aHJlYWRJRCk7XG4gICAgICByZXR1cm4gY29udGV4dFR5cGVbdGhyZWFkSURdO1xuICAgIH1cblxuICAgIHtcbiAgICAgIHZhciBtYXNrZWRDb250ZXh0ID0gbWFza0NvbnRleHQodHlwZSwgY29udGV4dCk7XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGUuY29udGV4dFR5cGVzKSB7XG4gICAgICAgICAgY2hlY2tDb250ZXh0VHlwZXModHlwZS5jb250ZXh0VHlwZXMsIG1hc2tlZENvbnRleHQsICdjb250ZXh0Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hc2tlZENvbnRleHQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHtcbiAgICAgIHZhciBfbWFza2VkQ29udGV4dCA9IG1hc2tDb250ZXh0KHR5cGUsIGNvbnRleHQpO1xuXG4gICAgICB7XG4gICAgICAgIGlmICh0eXBlLmNvbnRleHRUeXBlcykge1xuICAgICAgICAgIGNoZWNrQ29udGV4dFR5cGVzKHR5cGUuY29udGV4dFR5cGVzLCBfbWFza2VkQ29udGV4dCwgJ2NvbnRleHQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gX21hc2tlZENvbnRleHQ7XG4gICAgfVxuICB9XG59XG5cbnZhciBuZXh0QXZhaWxhYmxlVGhyZWFkSURzID0gbmV3IFVpbnQxNkFycmF5KDE2KTtcblxuZm9yICh2YXIgaSA9IDA7IGkgPCAxNTsgaSsrKSB7XG4gIG5leHRBdmFpbGFibGVUaHJlYWRJRHNbaV0gPSBpICsgMTtcbn1cblxubmV4dEF2YWlsYWJsZVRocmVhZElEc1sxNV0gPSAwO1xuXG5mdW5jdGlvbiBncm93VGhyZWFkQ291bnRBbmRSZXR1cm5OZXh0QXZhaWxhYmxlKCkge1xuICB2YXIgb2xkQXJyYXkgPSBuZXh0QXZhaWxhYmxlVGhyZWFkSURzO1xuICB2YXIgb2xkU2l6ZSA9IG9sZEFycmF5Lmxlbmd0aDtcbiAgdmFyIG5ld1NpemUgPSBvbGRTaXplICogMjtcblxuICBpZiAoIShuZXdTaXplIDw9IDB4MTAwMDApKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiTWF4aW11bSBudW1iZXIgb2YgY29uY3VycmVudCBSZWFjdCByZW5kZXJlcnMgZXhjZWVkZWQuIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgYXJlIG5vdCBwcm9wZXJseSBkZXN0cm95aW5nIHRoZSBSZWFkYWJsZSBwcm92aWRlZCBieSBSZWFjdC4gRW5zdXJlIHRoYXQgeW91IGNhbGwgLmRlc3Ryb3koKSBvbiBpdCBpZiB5b3Ugbm8gbG9uZ2VyIHdhbnQgdG8gcmVhZCBmcm9tIGl0LCBhbmQgZGlkIG5vdCByZWFkIHRvIHRoZSBlbmQuIElmIHlvdSB1c2UgLnBpcGUoKSB0aGlzIHNob3VsZCBiZSBhdXRvbWF0aWMuXCIgKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbmV3QXJyYXkgPSBuZXcgVWludDE2QXJyYXkobmV3U2l6ZSk7XG4gIG5ld0FycmF5LnNldChvbGRBcnJheSk7XG4gIG5leHRBdmFpbGFibGVUaHJlYWRJRHMgPSBuZXdBcnJheTtcbiAgbmV4dEF2YWlsYWJsZVRocmVhZElEc1swXSA9IG9sZFNpemUgKyAxO1xuXG4gIGZvciAodmFyIF9pID0gb2xkU2l6ZTsgX2kgPCBuZXdTaXplIC0gMTsgX2krKykge1xuICAgIG5leHRBdmFpbGFibGVUaHJlYWRJRHNbX2ldID0gX2kgKyAxO1xuICB9XG5cbiAgbmV4dEF2YWlsYWJsZVRocmVhZElEc1tuZXdTaXplIC0gMV0gPSAwO1xuICByZXR1cm4gb2xkU2l6ZTtcbn1cblxuZnVuY3Rpb24gYWxsb2NUaHJlYWRJRCgpIHtcbiAgdmFyIG5leHRJRCA9IG5leHRBdmFpbGFibGVUaHJlYWRJRHNbMF07XG5cbiAgaWYgKG5leHRJRCA9PT0gMCkge1xuICAgIHJldHVybiBncm93VGhyZWFkQ291bnRBbmRSZXR1cm5OZXh0QXZhaWxhYmxlKCk7XG4gIH1cblxuICBuZXh0QXZhaWxhYmxlVGhyZWFkSURzWzBdID0gbmV4dEF2YWlsYWJsZVRocmVhZElEc1tuZXh0SURdO1xuICByZXR1cm4gbmV4dElEO1xufVxuZnVuY3Rpb24gZnJlZVRocmVhZElEKGlkKSB7XG4gIG5leHRBdmFpbGFibGVUaHJlYWRJRHNbaWRdID0gbmV4dEF2YWlsYWJsZVRocmVhZElEc1swXTtcbiAgbmV4dEF2YWlsYWJsZVRocmVhZElEc1swXSA9IGlkO1xufVxuXG4vLyBBIHJlc2VydmVkIGF0dHJpYnV0ZS5cbi8vIEl0IGlzIGhhbmRsZWQgYnkgUmVhY3Qgc2VwYXJhdGVseSBhbmQgc2hvdWxkbid0IGJlIHdyaXR0ZW4gdG8gdGhlIERPTS5cbnZhciBSRVNFUlZFRCA9IDA7IC8vIEEgc2ltcGxlIHN0cmluZyBhdHRyaWJ1dGUuXG4vLyBBdHRyaWJ1dGVzIHRoYXQgYXJlbid0IGluIHRoZSBmaWx0ZXIgYXJlIHByZXN1bWVkIHRvIGhhdmUgdGhpcyB0eXBlLlxuXG52YXIgU1RSSU5HID0gMTsgLy8gQSBzdHJpbmcgYXR0cmlidXRlIHRoYXQgYWNjZXB0cyBib29sZWFucyBpbiBSZWFjdC4gSW4gSFRNTCwgdGhlc2UgYXJlIGNhbGxlZFxuLy8gXCJlbnVtZXJhdGVkXCIgYXR0cmlidXRlcyB3aXRoIFwidHJ1ZVwiIGFuZCBcImZhbHNlXCIgYXMgcG9zc2libGUgdmFsdWVzLlxuLy8gV2hlbiB0cnVlLCBpdCBzaG91bGQgYmUgc2V0IHRvIGEgXCJ0cnVlXCIgc3RyaW5nLlxuLy8gV2hlbiBmYWxzZSwgaXQgc2hvdWxkIGJlIHNldCB0byBhIFwiZmFsc2VcIiBzdHJpbmcuXG5cbnZhciBCT09MRUFOSVNIX1NUUklORyA9IDI7IC8vIEEgcmVhbCBib29sZWFuIGF0dHJpYnV0ZS5cbi8vIFdoZW4gdHJ1ZSwgaXQgc2hvdWxkIGJlIHByZXNlbnQgKHNldCBlaXRoZXIgdG8gYW4gZW1wdHkgc3RyaW5nIG9yIGl0cyBuYW1lKS5cbi8vIFdoZW4gZmFsc2UsIGl0IHNob3VsZCBiZSBvbWl0dGVkLlxuXG52YXIgQk9PTEVBTiA9IDM7IC8vIEFuIGF0dHJpYnV0ZSB0aGF0IGNhbiBiZSB1c2VkIGFzIGEgZmxhZyBhcyB3ZWxsIGFzIHdpdGggYSB2YWx1ZS5cbi8vIFdoZW4gdHJ1ZSwgaXQgc2hvdWxkIGJlIHByZXNlbnQgKHNldCBlaXRoZXIgdG8gYW4gZW1wdHkgc3RyaW5nIG9yIGl0cyBuYW1lKS5cbi8vIFdoZW4gZmFsc2UsIGl0IHNob3VsZCBiZSBvbWl0dGVkLlxuLy8gRm9yIGFueSBvdGhlciB2YWx1ZSwgc2hvdWxkIGJlIHByZXNlbnQgd2l0aCB0aGF0IHZhbHVlLlxuXG52YXIgT1ZFUkxPQURFRF9CT09MRUFOID0gNDsgLy8gQW4gYXR0cmlidXRlIHRoYXQgbXVzdCBiZSBudW1lcmljIG9yIHBhcnNlIGFzIGEgbnVtZXJpYy5cbi8vIFdoZW4gZmFsc3ksIGl0IHNob3VsZCBiZSByZW1vdmVkLlxuXG52YXIgTlVNRVJJQyA9IDU7IC8vIEFuIGF0dHJpYnV0ZSB0aGF0IG11c3QgYmUgcG9zaXRpdmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIHBvc2l0aXZlIG51bWVyaWMuXG4vLyBXaGVuIGZhbHN5LCBpdCBzaG91bGQgYmUgcmVtb3ZlZC5cblxudmFyIFBPU0lUSVZFX05VTUVSSUMgPSA2O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG52YXIgQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiA9IFwiOkEtWl9hLXpcXFxcdTAwQzAtXFxcXHUwMEQ2XFxcXHUwMEQ4LVxcXFx1MDBGNlxcXFx1MDBGOC1cXFxcdTAyRkZcXFxcdTAzNzAtXFxcXHUwMzdEXFxcXHUwMzdGLVxcXFx1MUZGRlxcXFx1MjAwQy1cXFxcdTIwMERcXFxcdTIwNzAtXFxcXHUyMThGXFxcXHUyQzAwLVxcXFx1MkZFRlxcXFx1MzAwMS1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZGRFwiO1xuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cbnZhciBBVFRSSUJVVEVfTkFNRV9DSEFSID0gQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiArIFwiXFxcXC0uMC05XFxcXHUwMEI3XFxcXHUwMzAwLVxcXFx1MDM2RlxcXFx1MjAzRi1cXFxcdTIwNDBcIjtcbnZhciBST09UX0FUVFJJQlVURV9OQU1FID0gJ2RhdGEtcmVhY3Ryb290JztcbnZhciBWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWCA9IG5ldyBSZWdFeHAoJ15bJyArIEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgKyAnXVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xudmFyIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xuZnVuY3Rpb24gaXNBdHRyaWJ1dGVOYW1lU2FmZShhdHRyaWJ1dGVOYW1lKSB7XG4gIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSwgYXR0cmlidXRlTmFtZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUsIGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYLnRlc3QoYXR0cmlidXRlTmFtZSkpIHtcbiAgICB2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXSA9IHRydWU7XG5cbiAge1xuICAgIGVycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lOiBgJXNgJywgYXR0cmlidXRlTmFtZSk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzaG91bGRJZ25vcmVBdHRyaWJ1dGUobmFtZSwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5SW5mby50eXBlID09PSBSRVNFUlZFRDtcbiAgfVxuXG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChuYW1lLmxlbmd0aCA+IDIgJiYgKG5hbWVbMF0gPT09ICdvJyB8fCBuYW1lWzBdID09PSAnTycpICYmIChuYW1lWzFdID09PSAnbicgfHwgbmFtZVsxXSA9PT0gJ04nKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc2hvdWxkUmVtb3ZlQXR0cmlidXRlV2l0aFdhcm5pbmcobmFtZSwgdmFsdWUsIHByb3BlcnR5SW5mbywgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgaWYgKHByb3BlcnR5SW5mbyAhPT0gbnVsbCAmJiBwcm9wZXJ0eUluZm8udHlwZSA9PT0gUkVTRVJWRUQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgIGNhc2UgJ2Z1bmN0aW9uJzogLy8gJEZsb3dJc3N1ZSBzeW1ib2wgaXMgcGVyZmVjdGx5IHZhbGlkIGhlcmVcblxuICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAge1xuICAgICAgICBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuICFwcm9wZXJ0eUluZm8uYWNjZXB0c0Jvb2xlYW5zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwcmVmaXggPSBuYW1lLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCwgNSk7XG4gICAgICAgICAgcmV0dXJuIHByZWZpeCAhPT0gJ2RhdGEtJyAmJiBwcmVmaXggIT09ICdhcmlhLSc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIHNob3VsZFJlbW92ZUF0dHJpYnV0ZShuYW1lLCB2YWx1ZSwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHNob3VsZFJlbW92ZUF0dHJpYnV0ZVdpdGhXYXJuaW5nKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHByb3BlcnR5SW5mbyAhPT0gbnVsbCkge1xuXG4gICAgc3dpdGNoIChwcm9wZXJ0eUluZm8udHlwZSkge1xuICAgICAgY2FzZSBCT09MRUFOOlxuICAgICAgICByZXR1cm4gIXZhbHVlO1xuXG4gICAgICBjYXNlIE9WRVJMT0FERURfQk9PTEVBTjpcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBmYWxzZTtcblxuICAgICAgY2FzZSBOVU1FUklDOlxuICAgICAgICByZXR1cm4gaXNOYU4odmFsdWUpO1xuXG4gICAgICBjYXNlIFBPU0lUSVZFX05VTUVSSUM6XG4gICAgICAgIHJldHVybiBpc05hTih2YWx1ZSkgfHwgdmFsdWUgPCAxO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldFByb3BlcnR5SW5mbyhuYW1lKSB7XG4gIHJldHVybiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpID8gcHJvcGVydGllc1tuYW1lXSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCB0eXBlLCBtdXN0VXNlUHJvcGVydHksIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZU5hbWVzcGFjZSwgc2FuaXRpemVVUkwsIHJlbW92ZUVtcHR5U3RyaW5nKSB7XG4gIHRoaXMuYWNjZXB0c0Jvb2xlYW5zID0gdHlwZSA9PT0gQk9PTEVBTklTSF9TVFJJTkcgfHwgdHlwZSA9PT0gQk9PTEVBTiB8fCB0eXBlID09PSBPVkVSTE9BREVEX0JPT0xFQU47XG4gIHRoaXMuYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZU5hbWU7XG4gIHRoaXMuYXR0cmlidXRlTmFtZXNwYWNlID0gYXR0cmlidXRlTmFtZXNwYWNlO1xuICB0aGlzLm11c3RVc2VQcm9wZXJ0eSA9IG11c3RVc2VQcm9wZXJ0eTtcbiAgdGhpcy5wcm9wZXJ0eU5hbWUgPSBuYW1lO1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnNhbml0aXplVVJMID0gc2FuaXRpemVVUkw7XG4gIHRoaXMucmVtb3ZlRW1wdHlTdHJpbmcgPSByZW1vdmVFbXB0eVN0cmluZztcbn0gLy8gV2hlbiBhZGRpbmcgYXR0cmlidXRlcyB0byB0aGlzIGxpc3QsIGJlIHN1cmUgdG8gYWxzbyBhZGQgdGhlbSB0b1xuLy8gdGhlIGBwb3NzaWJsZVN0YW5kYXJkTmFtZXNgIG1vZHVsZSB0byBlbnN1cmUgY2FzaW5nIGFuZCBpbmNvcnJlY3Rcbi8vIG5hbWUgd2FybmluZ3MuXG5cblxudmFyIHByb3BlcnRpZXMgPSB7fTsgLy8gVGhlc2UgcHJvcHMgYXJlIHJlc2VydmVkIGJ5IFJlYWN0LiBUaGV5IHNob3VsZG4ndCBiZSB3cml0dGVuIHRvIHRoZSBET00uXG5cbnZhciByZXNlcnZlZFByb3BzID0gWydjaGlsZHJlbicsICdkYW5nZXJvdXNseVNldElubmVySFRNTCcsIC8vIFRPRE86IFRoaXMgcHJldmVudHMgdGhlIGFzc2lnbm1lbnQgb2YgZGVmYXVsdFZhbHVlIHRvIHJlZ3VsYXJcbi8vIGVsZW1lbnRzIChub3QganVzdCBpbnB1dHMpLiBOb3cgdGhhdCBSZWFjdERPTUlucHV0IGFzc2lnbnMgdG8gdGhlXG4vLyBkZWZhdWx0VmFsdWUgcHJvcGVydHkgLS0gZG8gd2UgbmVlZCB0aGlzP1xuJ2RlZmF1bHRWYWx1ZScsICdkZWZhdWx0Q2hlY2tlZCcsICdpbm5lckhUTUwnLCAnc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJywgJ3N1cHByZXNzSHlkcmF0aW9uV2FybmluZycsICdzdHlsZSddO1xucmVzZXJ2ZWRQcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFJFU0VSVkVELCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gQSBmZXcgUmVhY3Qgc3RyaW5nIGF0dHJpYnV0ZXMgaGF2ZSBhIGRpZmZlcmVudCBuYW1lLlxuLy8gVGhpcyBpcyBhIG1hcHBpbmcgZnJvbSBSZWFjdCBwcm9wIG5hbWVzIHRvIHRoZSBhdHRyaWJ1dGUgbmFtZXMuXG5cbltbJ2FjY2VwdENoYXJzZXQnLCAnYWNjZXB0LWNoYXJzZXQnXSwgWydjbGFzc05hbWUnLCAnY2xhc3MnXSwgWydodG1sRm9yJywgJ2ZvciddLCBbJ2h0dHBFcXVpdicsICdodHRwLWVxdWl2J11dLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIG5hbWUgPSBfcmVmWzBdLFxuICAgICAgYXR0cmlidXRlTmFtZSA9IF9yZWZbMV07XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBhdHRyaWJ1dGVOYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGFyZSBcImVudW1lcmF0ZWRcIiBIVE1MIGF0dHJpYnV0ZXMgdGhhdCBhY2NlcHQgXCJ0cnVlXCIgYW5kIFwiZmFsc2VcIi5cbi8vIEluIFJlYWN0LCB3ZSBsZXQgdXNlcnMgcGFzcyBgdHJ1ZWAgYW5kIGBmYWxzZWAgZXZlbiB0aG91Z2ggdGVjaG5pY2FsbHlcbi8vIHRoZXNlIGFyZW4ndCBib29sZWFuIGF0dHJpYnV0ZXMgKHRoZXkgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncykuXG5cblsnY29udGVudEVkaXRhYmxlJywgJ2RyYWdnYWJsZScsICdzcGVsbENoZWNrJywgJ3ZhbHVlJ10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBCT09MRUFOSVNIX1NUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLnRvTG93ZXJDYXNlKCksIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIFwiZW51bWVyYXRlZFwiIFNWRyBhdHRyaWJ1dGVzIHRoYXQgYWNjZXB0IFwidHJ1ZVwiIGFuZCBcImZhbHNlXCIuXG4vLyBJbiBSZWFjdCwgd2UgbGV0IHVzZXJzIHBhc3MgYHRydWVgIGFuZCBgZmFsc2VgIGV2ZW4gdGhvdWdoIHRlY2huaWNhbGx5XG4vLyB0aGVzZSBhcmVuJ3QgYm9vbGVhbiBhdHRyaWJ1dGVzICh0aGV5IGFyZSBjb2VyY2VkIHRvIHN0cmluZ3MpLlxuLy8gU2luY2UgdGhlc2UgYXJlIFNWRyBhdHRyaWJ1dGVzLCB0aGVpciBhdHRyaWJ1dGUgbmFtZXMgYXJlIGNhc2Utc2Vuc2l0aXZlLlxuXG5bJ2F1dG9SZXZlcnNlJywgJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLCAnZm9jdXNhYmxlJywgJ3ByZXNlcnZlQWxwaGEnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIEJPT0xFQU5JU0hfU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIEhUTUwgYm9vbGVhbiBhdHRyaWJ1dGVzLlxuXG5bJ2FsbG93RnVsbFNjcmVlbicsICdhc3luYycsIC8vIE5vdGU6IHRoZXJlIGlzIGEgc3BlY2lhbCBjYXNlIHRoYXQgcHJldmVudHMgaXQgZnJvbSBiZWluZyB3cml0dGVuIHRvIHRoZSBET01cbi8vIG9uIHRoZSBjbGllbnQgc2lkZSBiZWNhdXNlIHRoZSBicm93c2VycyBhcmUgaW5jb25zaXN0ZW50LiBJbnN0ZWFkIHdlIGNhbGwgZm9jdXMoKS5cbidhdXRvRm9jdXMnLCAnYXV0b1BsYXknLCAnY29udHJvbHMnLCAnZGVmYXVsdCcsICdkZWZlcicsICdkaXNhYmxlZCcsICdkaXNhYmxlUGljdHVyZUluUGljdHVyZScsICdkaXNhYmxlUmVtb3RlUGxheWJhY2snLCAnZm9ybU5vVmFsaWRhdGUnLCAnaGlkZGVuJywgJ2xvb3AnLCAnbm9Nb2R1bGUnLCAnbm9WYWxpZGF0ZScsICdvcGVuJywgJ3BsYXlzSW5saW5lJywgJ3JlYWRPbmx5JywgJ3JlcXVpcmVkJywgJ3JldmVyc2VkJywgJ3Njb3BlZCcsICdzZWFtbGVzcycsIC8vIE1pY3JvZGF0YVxuJ2l0ZW1TY29wZSddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgQk9PTEVBTiwgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLnRvTG93ZXJDYXNlKCksIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIHRoZSBmZXcgUmVhY3QgcHJvcHMgdGhhdCB3ZSBzZXQgYXMgRE9NIHByb3BlcnRpZXNcbi8vIHJhdGhlciB0aGFuIGF0dHJpYnV0ZXMuIFRoZXNlIGFyZSBhbGwgYm9vbGVhbnMuXG5cblsnY2hlY2tlZCcsIC8vIE5vdGU6IGBvcHRpb24uc2VsZWN0ZWRgIGlzIG5vdCB1cGRhdGVkIGlmIGBzZWxlY3QubXVsdGlwbGVgIGlzXG4vLyBkaXNhYmxlZCB3aXRoIGByZW1vdmVBdHRyaWJ1dGVgLiBXZSBoYXZlIHNwZWNpYWwgbG9naWMgZm9yIGhhbmRsaW5nIHRoaXMuXG4nbXVsdGlwbGUnLCAnbXV0ZWQnLCAnc2VsZWN0ZWQnIC8vIE5PVEU6IGlmIHlvdSBhZGQgYSBjYW1lbENhc2VkIHByb3AgdG8gdGhpcyBsaXN0LFxuLy8geW91J2xsIG5lZWQgdG8gc2V0IGF0dHJpYnV0ZU5hbWUgdG8gbmFtZS50b0xvd2VyQ2FzZSgpXG4vLyBpbnN0ZWFkIGluIHRoZSBhc3NpZ25tZW50IGJlbG93LlxuXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIEJPT0xFQU4sIHRydWUsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGFyZSBIVE1MIGF0dHJpYnV0ZXMgdGhhdCBhcmUgXCJvdmVybG9hZGVkIGJvb2xlYW5zXCI6IHRoZXkgYmVoYXZlIGxpa2Vcbi8vIGJvb2xlYW5zLCBidXQgY2FuIGFsc28gYWNjZXB0IGEgc3RyaW5nIHZhbHVlLlxuXG5bJ2NhcHR1cmUnLCAnZG93bmxvYWQnIC8vIE5PVEU6IGlmIHlvdSBhZGQgYSBjYW1lbENhc2VkIHByb3AgdG8gdGhpcyBsaXN0LFxuLy8geW91J2xsIG5lZWQgdG8gc2V0IGF0dHJpYnV0ZU5hbWUgdG8gbmFtZS50b0xvd2VyQ2FzZSgpXG4vLyBpbnN0ZWFkIGluIHRoZSBhc3NpZ25tZW50IGJlbG93LlxuXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIE9WRVJMT0FERURfQk9PTEVBTiwgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGFyZSBIVE1MIGF0dHJpYnV0ZXMgdGhhdCBtdXN0IGJlIHBvc2l0aXZlIG51bWJlcnMuXG5cblsnY29scycsICdyb3dzJywgJ3NpemUnLCAnc3BhbicgLy8gTk9URTogaWYgeW91IGFkZCBhIGNhbWVsQ2FzZWQgcHJvcCB0byB0aGlzIGxpc3QsXG4vLyB5b3UnbGwgbmVlZCB0byBzZXQgYXR0cmlidXRlTmFtZSB0byBuYW1lLnRvTG93ZXJDYXNlKClcbi8vIGluc3RlYWQgaW4gdGhlIGFzc2lnbm1lbnQgYmVsb3cuXG5dLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgUE9TSVRJVkVfTlVNRVJJQywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGFyZSBIVE1MIGF0dHJpYnV0ZXMgdGhhdCBtdXN0IGJlIG51bWJlcnMuXG5cblsncm93U3BhbicsICdzdGFydCddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgTlVNRVJJQywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLnRvTG93ZXJDYXNlKCksIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTtcbnZhciBDQU1FTElaRSA9IC9bXFwtXFw6XShbYS16XSkvZztcblxudmFyIGNhcGl0YWxpemUgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuWzFdLnRvVXBwZXJDYXNlKCk7XG59OyAvLyBUaGlzIGlzIGEgbGlzdCBvZiBhbGwgU1ZHIGF0dHJpYnV0ZXMgdGhhdCBuZWVkIHNwZWNpYWwgY2FzaW5nLCBuYW1lc3BhY2luZyxcbi8vIG9yIGJvb2xlYW4gdmFsdWUgYXNzaWdubWVudC4gUmVndWxhciBhdHRyaWJ1dGVzIHRoYXQganVzdCBhY2NlcHQgc3RyaW5nc1xuLy8gYW5kIGhhdmUgdGhlIHNhbWUgbmFtZXMgYXJlIG9taXR0ZWQsIGp1c3QgbGlrZSBpbiB0aGUgSFRNTCBhdHRyaWJ1dGUgZmlsdGVyLlxuLy8gU29tZSBvZiB0aGVzZSBhdHRyaWJ1dGVzIGNhbiBiZSBoYXJkIHRvIGZpbmQuIFRoaXMgbGlzdCB3YXMgY3JlYXRlZCBieVxuLy8gc2NyYXBpbmcgdGhlIE1ETiBkb2N1bWVudGF0aW9uLlxuXG5cblsnYWNjZW50LWhlaWdodCcsICdhbGlnbm1lbnQtYmFzZWxpbmUnLCAnYXJhYmljLWZvcm0nLCAnYmFzZWxpbmUtc2hpZnQnLCAnY2FwLWhlaWdodCcsICdjbGlwLXBhdGgnLCAnY2xpcC1ydWxlJywgJ2NvbG9yLWludGVycG9sYXRpb24nLCAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJywgJ2NvbG9yLXByb2ZpbGUnLCAnY29sb3ItcmVuZGVyaW5nJywgJ2RvbWluYW50LWJhc2VsaW5lJywgJ2VuYWJsZS1iYWNrZ3JvdW5kJywgJ2ZpbGwtb3BhY2l0eScsICdmaWxsLXJ1bGUnLCAnZmxvb2QtY29sb3InLCAnZmxvb2Qtb3BhY2l0eScsICdmb250LWZhbWlseScsICdmb250LXNpemUnLCAnZm9udC1zaXplLWFkanVzdCcsICdmb250LXN0cmV0Y2gnLCAnZm9udC1zdHlsZScsICdmb250LXZhcmlhbnQnLCAnZm9udC13ZWlnaHQnLCAnZ2x5cGgtbmFtZScsICdnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsJywgJ2dseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsJywgJ2hvcml6LWFkdi14JywgJ2hvcml6LW9yaWdpbi14JywgJ2ltYWdlLXJlbmRlcmluZycsICdsZXR0ZXItc3BhY2luZycsICdsaWdodGluZy1jb2xvcicsICdtYXJrZXItZW5kJywgJ21hcmtlci1taWQnLCAnbWFya2VyLXN0YXJ0JywgJ292ZXJsaW5lLXBvc2l0aW9uJywgJ292ZXJsaW5lLXRoaWNrbmVzcycsICdwYWludC1vcmRlcicsICdwYW5vc2UtMScsICdwb2ludGVyLWV2ZW50cycsICdyZW5kZXJpbmctaW50ZW50JywgJ3NoYXBlLXJlbmRlcmluZycsICdzdG9wLWNvbG9yJywgJ3N0b3Atb3BhY2l0eScsICdzdHJpa2V0aHJvdWdoLXBvc2l0aW9uJywgJ3N0cmlrZXRocm91Z2gtdGhpY2tuZXNzJywgJ3N0cm9rZS1kYXNoYXJyYXknLCAnc3Ryb2tlLWRhc2hvZmZzZXQnLCAnc3Ryb2tlLWxpbmVjYXAnLCAnc3Ryb2tlLWxpbmVqb2luJywgJ3N0cm9rZS1taXRlcmxpbWl0JywgJ3N0cm9rZS1vcGFjaXR5JywgJ3N0cm9rZS13aWR0aCcsICd0ZXh0LWFuY2hvcicsICd0ZXh0LWRlY29yYXRpb24nLCAndGV4dC1yZW5kZXJpbmcnLCAndW5kZXJsaW5lLXBvc2l0aW9uJywgJ3VuZGVybGluZS10aGlja25lc3MnLCAndW5pY29kZS1iaWRpJywgJ3VuaWNvZGUtcmFuZ2UnLCAndW5pdHMtcGVyLWVtJywgJ3YtYWxwaGFiZXRpYycsICd2LWhhbmdpbmcnLCAndi1pZGVvZ3JhcGhpYycsICd2LW1hdGhlbWF0aWNhbCcsICd2ZWN0b3ItZWZmZWN0JywgJ3ZlcnQtYWR2LXknLCAndmVydC1vcmlnaW4teCcsICd2ZXJ0LW9yaWdpbi15JywgJ3dvcmQtc3BhY2luZycsICd3cml0aW5nLW1vZGUnLCAneG1sbnM6eGxpbmsnLCAneC1oZWlnaHQnIC8vIE5PVEU6IGlmIHlvdSBhZGQgYSBjYW1lbENhc2VkIHByb3AgdG8gdGhpcyBsaXN0LFxuLy8geW91J2xsIG5lZWQgdG8gc2V0IGF0dHJpYnV0ZU5hbWUgdG8gbmFtZS50b0xvd2VyQ2FzZSgpXG4vLyBpbnN0ZWFkIGluIHRoZSBhc3NpZ25tZW50IGJlbG93LlxuXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG4gIHZhciBuYW1lID0gYXR0cmlidXRlTmFtZS5yZXBsYWNlKENBTUVMSVpFLCBjYXBpdGFsaXplKTtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIGF0dHJpYnV0ZU5hbWUsIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFN0cmluZyBTVkcgYXR0cmlidXRlcyB3aXRoIHRoZSB4bGluayBuYW1lc3BhY2UuXG5cblsneGxpbms6YWN0dWF0ZScsICd4bGluazphcmNyb2xlJywgJ3hsaW5rOnJvbGUnLCAneGxpbms6c2hvdycsICd4bGluazp0aXRsZScsICd4bGluazp0eXBlJyAvLyBOT1RFOiBpZiB5b3UgYWRkIGEgY2FtZWxDYXNlZCBwcm9wIHRvIHRoaXMgbGlzdCxcbi8vIHlvdSdsbCBuZWVkIHRvIHNldCBhdHRyaWJ1dGVOYW1lIHRvIG5hbWUudG9Mb3dlckNhc2UoKVxuLy8gaW5zdGVhZCBpbiB0aGUgYXNzaWdubWVudCBiZWxvdy5cbl0uZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSkge1xuICB2YXIgbmFtZSA9IGF0dHJpYnV0ZU5hbWUucmVwbGFjZShDQU1FTElaRSwgY2FwaXRhbGl6ZSk7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBhdHRyaWJ1dGVOYW1lLCAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gU3RyaW5nIFNWRyBhdHRyaWJ1dGVzIHdpdGggdGhlIHhtbCBuYW1lc3BhY2UuXG5cblsneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJyAvLyBOT1RFOiBpZiB5b3UgYWRkIGEgY2FtZWxDYXNlZCBwcm9wIHRvIHRoaXMgbGlzdCxcbi8vIHlvdSdsbCBuZWVkIHRvIHNldCBhdHRyaWJ1dGVOYW1lIHRvIG5hbWUudG9Mb3dlckNhc2UoKVxuLy8gaW5zdGVhZCBpbiB0aGUgYXNzaWdubWVudCBiZWxvdy5cbl0uZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSkge1xuICB2YXIgbmFtZSA9IGF0dHJpYnV0ZU5hbWUucmVwbGFjZShDQU1FTElaRSwgY2FwaXRhbGl6ZSk7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBhdHRyaWJ1dGVOYW1lLCAnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJywgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhdHRyaWJ1dGUgZXhpc3RzIGJvdGggaW4gSFRNTCBhbmQgU1ZHLlxuLy8gVGhlIGF0dHJpYnV0ZSBuYW1lIGlzIGNhc2Utc2Vuc2l0aXZlIGluIFNWRyBzbyB3ZSBjYW4ndCBqdXN0IHVzZVxuLy8gdGhlIFJlYWN0IG5hbWUgbGlrZSB3ZSBkbyBmb3IgYXR0cmlidXRlcyB0aGF0IGV4aXN0IG9ubHkgaW4gSFRNTC5cblxuWyd0YWJJbmRleCcsICdjcm9zc09yaWdpbiddLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgcHJvcGVydGllc1thdHRyaWJ1dGVOYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQoYXR0cmlidXRlTmFtZSwgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIGF0dHJpYnV0ZU5hbWUudG9Mb3dlckNhc2UoKSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhdHRyaWJ1dGVzIGFjY2VwdCBVUkxzLiBUaGVzZSBtdXN0IG5vdCBhbGxvdyBqYXZhc2NyaXB0OiBVUkxTLlxuLy8gVGhlc2Ugd2lsbCBhbHNvIG5lZWQgdG8gYWNjZXB0IFRydXN0ZWQgVHlwZXMgb2JqZWN0IGluIHRoZSBmdXR1cmUuXG5cbnZhciB4bGlua0hyZWYgPSAneGxpbmtIcmVmJztcbnByb3BlcnRpZXNbeGxpbmtIcmVmXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQoJ3hsaW5rSHJlZicsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuJ3hsaW5rOmhyZWYnLCAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsIHRydWUsIC8vIHNhbml0aXplVVJMXG5mYWxzZSk7XG5bJ3NyYycsICdocmVmJywgJ2FjdGlvbicsICdmb3JtQWN0aW9uJ10uZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSkge1xuICBwcm9wZXJ0aWVzW2F0dHJpYnV0ZU5hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChhdHRyaWJ1dGVOYW1lLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgYXR0cmlidXRlTmFtZS50b0xvd2VyQ2FzZSgpLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICB0cnVlLCAvLyBzYW5pdGl6ZVVSTFxuICB0cnVlKTtcbn0pO1xuXG4vLyBhbmQgYW55IG5ld2xpbmUgb3IgdGFiIGFyZSBmaWx0ZXJlZCBvdXQgYXMgaWYgdGhleSdyZSBub3QgcGFydCBvZiB0aGUgVVJMLlxuLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmwtcGFyc2luZ1xuLy8gVGFiIG9yIG5ld2xpbmUgYXJlIGRlZmluZWQgYXMgXFxyXFxuXFx0OlxuLy8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI2FzY2lpLXRhYi1vci1uZXdsaW5lXG4vLyBBIEMwIGNvbnRyb2wgaXMgYSBjb2RlIHBvaW50IGluIHRoZSByYW5nZSBcXHUwMDAwIE5VTEwgdG8gXFx1MDAxRlxuLy8gSU5GT1JNQVRJT04gU0VQQVJBVE9SIE9ORSwgaW5jbHVzaXZlOlxuLy8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI2MwLWNvbnRyb2wtb3Itc3BhY2VcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG52YXIgaXNKYXZhU2NyaXB0UHJvdG9jb2wgPSAvXltcXHUwMDAwLVxcdTAwMUYgXSpqW1xcclxcblxcdF0qYVtcXHJcXG5cXHRdKnZbXFxyXFxuXFx0XSphW1xcclxcblxcdF0qc1tcXHJcXG5cXHRdKmNbXFxyXFxuXFx0XSpyW1xcclxcblxcdF0qaVtcXHJcXG5cXHRdKnBbXFxyXFxuXFx0XSp0W1xcclxcblxcdF0qXFw6L2k7XG52YXIgZGlkV2FybiA9IGZhbHNlO1xuXG5mdW5jdGlvbiBzYW5pdGl6ZVVSTCh1cmwpIHtcbiAge1xuICAgIGlmICghZGlkV2FybiAmJiBpc0phdmFTY3JpcHRQcm90b2NvbC50ZXN0KHVybCkpIHtcbiAgICAgIGRpZFdhcm4gPSB0cnVlO1xuXG4gICAgICBlcnJvcignQSBmdXR1cmUgdmVyc2lvbiBvZiBSZWFjdCB3aWxsIGJsb2NrIGphdmFzY3JpcHQ6IFVSTHMgYXMgYSBzZWN1cml0eSBwcmVjYXV0aW9uLiAnICsgJ1VzZSBldmVudCBoYW5kbGVycyBpbnN0ZWFkIGlmIHlvdSBjYW4uIElmIHlvdSBuZWVkIHRvIGdlbmVyYXRlIHVuc2FmZSBIVE1MIHRyeSAnICsgJ3VzaW5nIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIGluc3RlYWQuIFJlYWN0IHdhcyBwYXNzZWQgJXMuJywgSlNPTi5zdHJpbmdpZnkodXJsKSk7XG4gICAgfVxuICB9XG59XG5cbi8vIGNvZGUgY29waWVkIGFuZCBtb2RpZmllZCBmcm9tIGVzY2FwZS1odG1sXG5cbi8qKlxuICogTW9kdWxlIHZhcmlhYmxlcy5cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBtYXRjaEh0bWxSZWdFeHAgPSAvW1wiJyY8Pl0vO1xuLyoqXG4gKiBFc2NhcGVzIHNwZWNpYWwgY2hhcmFjdGVycyBhbmQgSFRNTCBlbnRpdGllcyBpbiBhIGdpdmVuIGh0bWwgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gc3RyaW5nIEhUTUwgc3RyaW5nIHRvIGVzY2FwZSBmb3IgbGF0ZXIgaW5zZXJ0aW9uXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlSHRtbChzdHJpbmcpIHtcbiAgdmFyIHN0ciA9ICcnICsgc3RyaW5nO1xuICB2YXIgbWF0Y2ggPSBtYXRjaEh0bWxSZWdFeHAuZXhlYyhzdHIpO1xuXG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgdmFyIGVzY2FwZTtcbiAgdmFyIGh0bWwgPSAnJztcbiAgdmFyIGluZGV4O1xuICB2YXIgbGFzdEluZGV4ID0gMDtcblxuICBmb3IgKGluZGV4ID0gbWF0Y2guaW5kZXg7IGluZGV4IDwgc3RyLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHN3aXRjaCAoc3RyLmNoYXJDb2RlQXQoaW5kZXgpKSB7XG4gICAgICBjYXNlIDM0OlxuICAgICAgICAvLyBcIlxuICAgICAgICBlc2NhcGUgPSAnJnF1b3Q7JztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMzg6XG4gICAgICAgIC8vICZcbiAgICAgICAgZXNjYXBlID0gJyZhbXA7JztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMzk6XG4gICAgICAgIC8vICdcbiAgICAgICAgZXNjYXBlID0gJyYjeDI3Oyc7IC8vIG1vZGlmaWVkIGZyb20gZXNjYXBlLWh0bWw7IHVzZWQgdG8gYmUgJyYjMzknXG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgNjA6XG4gICAgICAgIC8vIDxcbiAgICAgICAgZXNjYXBlID0gJyZsdDsnO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSA2MjpcbiAgICAgICAgLy8gPlxuICAgICAgICBlc2NhcGUgPSAnJmd0Oyc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobGFzdEluZGV4ICE9PSBpbmRleCkge1xuICAgICAgaHRtbCArPSBzdHIuc3Vic3RyaW5nKGxhc3RJbmRleCwgaW5kZXgpO1xuICAgIH1cblxuICAgIGxhc3RJbmRleCA9IGluZGV4ICsgMTtcbiAgICBodG1sICs9IGVzY2FwZTtcbiAgfVxuXG4gIHJldHVybiBsYXN0SW5kZXggIT09IGluZGV4ID8gaHRtbCArIHN0ci5zdWJzdHJpbmcobGFzdEluZGV4LCBpbmRleCkgOiBodG1sO1xufSAvLyBlbmQgY29kZSBjb3BpZWQgYW5kIG1vZGlmaWVkIGZyb20gZXNjYXBlLWh0bWxcblxuLyoqXG4gKiBFc2NhcGVzIHRleHQgdG8gcHJldmVudCBzY3JpcHRpbmcgYXR0YWNrcy5cbiAqXG4gKiBAcGFyYW0geyp9IHRleHQgVGV4dCB2YWx1ZSB0byBlc2NhcGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEFuIGVzY2FwZWQgc3RyaW5nLlxuICovXG5cblxuZnVuY3Rpb24gZXNjYXBlVGV4dEZvckJyb3dzZXIodGV4dCkge1xuICBpZiAodHlwZW9mIHRleHQgPT09ICdib29sZWFuJyB8fCB0eXBlb2YgdGV4dCA9PT0gJ251bWJlcicpIHtcbiAgICAvLyB0aGlzIHNob3J0Y2lyY3VpdCBoZWxwcyBwZXJmIGZvciB0eXBlcyB0aGF0IHdlIGtub3cgd2lsbCBuZXZlciBoYXZlXG4gICAgLy8gc3BlY2lhbCBjaGFyYWN0ZXJzLCBlc3BlY2lhbGx5IGdpdmVuIHRoYXQgdGhpcyBmdW5jdGlvbiBpcyB1c2VkIG9mdGVuXG4gICAgLy8gZm9yIG51bWVyaWMgZG9tIGlkcy5cbiAgICByZXR1cm4gJycgKyB0ZXh0O1xuICB9XG5cbiAgcmV0dXJuIGVzY2FwZUh0bWwodGV4dCk7XG59XG5cbi8qKlxuICogRXNjYXBlcyBhdHRyaWJ1dGUgdmFsdWUgdG8gcHJldmVudCBzY3JpcHRpbmcgYXR0YWNrcy5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIGVzY2FwZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gQW4gZXNjYXBlZCBzdHJpbmcuXG4gKi9cblxuZnVuY3Rpb24gcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIodmFsdWUpIHtcbiAgcmV0dXJuICdcIicgKyBlc2NhcGVUZXh0Rm9yQnJvd3Nlcih2YWx1ZSkgKyAnXCInO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVNYXJrdXBGb3JSb290KCkge1xuICByZXR1cm4gUk9PVF9BVFRSSUJVVEVfTkFNRSArICc9XCJcIic7XG59XG4vKipcbiAqIENyZWF0ZXMgbWFya3VwIGZvciBhIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBNYXJrdXAgc3RyaW5nLCBvciBudWxsIGlmIHRoZSBwcm9wZXJ0eSB3YXMgaW52YWxpZC5cbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVNYXJrdXBGb3JQcm9wZXJ0eShuYW1lLCB2YWx1ZSkge1xuICB2YXIgcHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKG5hbWUpO1xuXG4gIGlmIChuYW1lICE9PSAnc3R5bGUnICYmIHNob3VsZElnbm9yZUF0dHJpYnV0ZShuYW1lLCBwcm9wZXJ0eUluZm8sIGZhbHNlKSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmIChzaG91bGRSZW1vdmVBdHRyaWJ1dGUobmFtZSwgdmFsdWUsIHByb3BlcnR5SW5mbywgZmFsc2UpKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHByb3BlcnR5SW5mbyAhPT0gbnVsbCkge1xuICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWU7XG4gICAgdmFyIHR5cGUgPSBwcm9wZXJ0eUluZm8udHlwZTtcblxuICAgIGlmICh0eXBlID09PSBCT09MRUFOIHx8IHR5cGUgPT09IE9WRVJMT0FERURfQk9PTEVBTiAmJiB2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIGF0dHJpYnV0ZU5hbWUgKyAnPVwiXCInO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvcGVydHlJbmZvLnNhbml0aXplVVJMKSB7XG4gICAgICAgIHZhbHVlID0gJycgKyB2YWx1ZTtcbiAgICAgICAgc2FuaXRpemVVUkwodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXR0cmlidXRlTmFtZSArICc9JyArIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSkge1xuICAgIHJldHVybiBuYW1lICsgJz0nICsgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIodmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuLyoqXG4gKiBDcmVhdGVzIG1hcmt1cCBmb3IgYSBjdXN0b20gcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIHN0cmluZywgb3IgZW1wdHkgc3RyaW5nIGlmIHRoZSBwcm9wZXJ0eSB3YXMgaW52YWxpZC5cbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVNYXJrdXBGb3JDdXN0b21BdHRyaWJ1dGUobmFtZSwgdmFsdWUpIHtcbiAgaWYgKCFpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc9JyArIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAqL1xuZnVuY3Rpb24gaXMoeCwgeSkge1xuICByZXR1cm4geCA9PT0geSAmJiAoeCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHkpIHx8IHggIT09IHggJiYgeSAhPT0geSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxuICA7XG59XG5cbnZhciBvYmplY3RJcyA9IHR5cGVvZiBPYmplY3QuaXMgPT09ICdmdW5jdGlvbicgPyBPYmplY3QuaXMgOiBpcztcblxudmFyIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCA9IG51bGw7XG52YXIgZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xudmFyIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7IC8vIFdoZXRoZXIgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgaG9vayBpcyBhIHJlLXJlbmRlcmVkIGhvb2tcblxudmFyIGlzUmVSZW5kZXIgPSBmYWxzZTsgLy8gV2hldGhlciBhbiB1cGRhdGUgd2FzIHNjaGVkdWxlZCBkdXJpbmcgdGhlIGN1cnJlbnRseSBleGVjdXRpbmcgcmVuZGVyIHBhc3MuXG5cbnZhciBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7IC8vIExhemlseSBjcmVhdGVkIG1hcCBvZiByZW5kZXItcGhhc2UgdXBkYXRlc1xuXG52YXIgcmVuZGVyUGhhc2VVcGRhdGVzID0gbnVsbDsgLy8gQ291bnRlciB0byBwcmV2ZW50IGluZmluaXRlIGxvb3BzLlxuXG52YXIgbnVtYmVyT2ZSZVJlbmRlcnMgPSAwO1xudmFyIFJFX1JFTkRFUl9MSU1JVCA9IDI1O1xudmFyIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9IGZhbHNlOyAvLyBJbiBERVYsIHRoaXMgaXMgdGhlIG5hbWUgb2YgdGhlIGN1cnJlbnRseSBleGVjdXRpbmcgcHJpbWl0aXZlIGhvb2tcblxudmFyIGN1cnJlbnRIb29rTmFtZUluRGV2O1xuXG5mdW5jdGlvbiByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCkge1xuICBpZiAoIShjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgIT09IG51bGwpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiSW52YWxpZCBob29rIGNhbGwuIEhvb2tzIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgb2YgdGhlIGJvZHkgb2YgYSBmdW5jdGlvbiBjb21wb25lbnQuIFRoaXMgY291bGQgaGFwcGVuIGZvciBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbjEuIFlvdSBtaWdodCBoYXZlIG1pc21hdGNoaW5nIHZlcnNpb25zIG9mIFJlYWN0IGFuZCB0aGUgcmVuZGVyZXIgKHN1Y2ggYXMgUmVhY3QgRE9NKVxcbjIuIFlvdSBtaWdodCBiZSBicmVha2luZyB0aGUgUnVsZXMgb2YgSG9va3NcXG4zLiBZb3UgbWlnaHQgaGF2ZSBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QgaW4gdGhlIHNhbWUgYXBwXFxuU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9pbnZhbGlkLWhvb2stY2FsbCBmb3IgdGlwcyBhYm91dCBob3cgdG8gZGVidWcgYW5kIGZpeCB0aGlzIHByb2JsZW0uXCIgKTtcbiAgICB9XG4gIH1cblxuICB7XG4gICAgaWYgKGlzSW5Ib29rVXNlckNvZGVJbkRldikge1xuICAgICAgZXJyb3IoJ0RvIG5vdCBjYWxsIEhvb2tzIGluc2lkZSB1c2VFZmZlY3QoLi4uKSwgdXNlTWVtbyguLi4pLCBvciBvdGhlciBidWlsdC1pbiBIb29rcy4gJyArICdZb3UgY2FuIG9ubHkgY2FsbCBIb29rcyBhdCB0aGUgdG9wIGxldmVsIG9mIHlvdXIgUmVhY3QgZnVuY3Rpb24uICcgKyAnRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9ydWxlcy1vZi1ob29rcycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQ7XG59XG5cbmZ1bmN0aW9uIGFyZUhvb2tJbnB1dHNFcXVhbChuZXh0RGVwcywgcHJldkRlcHMpIHtcbiAgaWYgKHByZXZEZXBzID09PSBudWxsKSB7XG4gICAge1xuICAgICAgZXJyb3IoJyVzIHJlY2VpdmVkIGEgZmluYWwgYXJndW1lbnQgZHVyaW5nIHRoaXMgcmVuZGVyLCBidXQgbm90IGR1cmluZyAnICsgJ3RoZSBwcmV2aW91cyByZW5kZXIuIEV2ZW4gdGhvdWdoIHRoZSBmaW5hbCBhcmd1bWVudCBpcyBvcHRpb25hbCwgJyArICdpdHMgdHlwZSBjYW5ub3QgY2hhbmdlIGJldHdlZW4gcmVuZGVycy4nLCBjdXJyZW50SG9va05hbWVJbkRldik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAge1xuICAgIC8vIERvbid0IGJvdGhlciBjb21wYXJpbmcgbGVuZ3RocyBpbiBwcm9kIGJlY2F1c2UgdGhlc2UgYXJyYXlzIHNob3VsZCBiZVxuICAgIC8vIHBhc3NlZCBpbmxpbmUuXG4gICAgaWYgKG5leHREZXBzLmxlbmd0aCAhPT0gcHJldkRlcHMubGVuZ3RoKSB7XG4gICAgICBlcnJvcignVGhlIGZpbmFsIGFyZ3VtZW50IHBhc3NlZCB0byAlcyBjaGFuZ2VkIHNpemUgYmV0d2VlbiByZW5kZXJzLiBUaGUgJyArICdvcmRlciBhbmQgc2l6ZSBvZiB0aGlzIGFycmF5IG11c3QgcmVtYWluIGNvbnN0YW50LlxcblxcbicgKyAnUHJldmlvdXM6ICVzXFxuJyArICdJbmNvbWluZzogJXMnLCBjdXJyZW50SG9va05hbWVJbkRldiwgXCJbXCIgKyBuZXh0RGVwcy5qb2luKCcsICcpICsgXCJdXCIsIFwiW1wiICsgcHJldkRlcHMuam9pbignLCAnKSArIFwiXVwiKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHByZXZEZXBzLmxlbmd0aCAmJiBpIDwgbmV4dERlcHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAob2JqZWN0SXMobmV4dERlcHNbaV0sIHByZXZEZXBzW2ldKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUhvb2soKSB7XG4gIGlmIChudW1iZXJPZlJlUmVuZGVycyA+IDApIHtcbiAgICB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcIlJlbmRlcmVkIG1vcmUgaG9va3MgdGhhbiBkdXJpbmcgdGhlIHByZXZpb3VzIHJlbmRlclwiICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtZW1vaXplZFN0YXRlOiBudWxsLFxuICAgIHF1ZXVlOiBudWxsLFxuICAgIG5leHQ6IG51bGxcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkge1xuICBpZiAod29ya0luUHJvZ3Jlc3NIb29rID09PSBudWxsKSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgaG9vayBpbiB0aGUgbGlzdFxuICAgIGlmIChmaXJzdFdvcmtJblByb2dyZXNzSG9vayA9PT0gbnVsbCkge1xuICAgICAgaXNSZVJlbmRlciA9IGZhbHNlO1xuICAgICAgZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2sgPSB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBjcmVhdGVIb29rKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZXJlJ3MgYWxyZWFkeSBhIHdvcmstaW4tcHJvZ3Jlc3MuIFJldXNlIGl0LlxuICAgICAgaXNSZVJlbmRlciA9IHRydWU7XG4gICAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBmaXJzdFdvcmtJblByb2dyZXNzSG9vaztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHdvcmtJblByb2dyZXNzSG9vay5uZXh0ID09PSBudWxsKSB7XG4gICAgICBpc1JlUmVuZGVyID0gZmFsc2U7IC8vIEFwcGVuZCB0byB0aGUgZW5kIG9mIHRoZSBsaXN0XG5cbiAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0ID0gY3JlYXRlSG9vaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGVyZSdzIGFscmVhZHkgYSB3b3JrLWluLXByb2dyZXNzLiBSZXVzZSBpdC5cbiAgICAgIGlzUmVSZW5kZXIgPSB0cnVlO1xuICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rLm5leHQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzSG9vaztcbn1cblxuZnVuY3Rpb24gcHJlcGFyZVRvVXNlSG9va3MoY29tcG9uZW50SWRlbnRpdHkpIHtcbiAgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ID0gY29tcG9uZW50SWRlbnRpdHk7XG5cbiAge1xuICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9IGZhbHNlO1xuICB9IC8vIFRoZSBmb2xsb3dpbmcgc2hvdWxkIGhhdmUgYWxyZWFkeSBiZWVuIHJlc2V0XG4gIC8vIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSBmYWxzZTtcbiAgLy8gZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuICAvLyBudW1iZXJPZlJlUmVuZGVycyA9IDA7XG4gIC8vIHJlbmRlclBoYXNlVXBkYXRlcyA9IG51bGw7XG4gIC8vIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG5cbn1cbmZ1bmN0aW9uIGZpbmlzaEhvb2tzKENvbXBvbmVudCwgcHJvcHMsIGNoaWxkcmVuLCByZWZPckNvbnRleHQpIHtcbiAgLy8gVGhpcyBtdXN0IGJlIGNhbGxlZCBhZnRlciBldmVyeSBmdW5jdGlvbiBjb21wb25lbnQgdG8gcHJldmVudCBob29rcyBmcm9tXG4gIC8vIGJlaW5nIHVzZWQgaW4gY2xhc3Nlcy5cbiAgd2hpbGUgKGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUpIHtcbiAgICAvLyBVcGRhdGVzIHdlcmUgc2NoZWR1bGVkIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLiBUaGV5IGFyZSBzdG9yZWQgaW5cbiAgICAvLyB0aGUgYHJlbmRlclBoYXNlVXBkYXRlc2AgbWFwLiBDYWxsIHRoZSBjb21wb25lbnQgYWdhaW4sIHJldXNpbmcgdGhlXG4gICAgLy8gd29yay1pbi1wcm9ncmVzcyBob29rcyBhbmQgYXBwbHlpbmcgdGhlIGFkZGl0aW9uYWwgdXBkYXRlcyBvbiB0b3AuIEtlZXBcbiAgICAvLyByZXN0YXJ0aW5nIHVudGlsIG5vIG1vcmUgdXBkYXRlcyBhcmUgc2NoZWR1bGVkLlxuICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSBmYWxzZTtcbiAgICBudW1iZXJPZlJlUmVuZGVycyArPSAxOyAvLyBTdGFydCBvdmVyIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgbGlzdFxuXG4gICAgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcbiAgICBjaGlsZHJlbiA9IENvbXBvbmVudChwcm9wcywgcmVmT3JDb250ZXh0KTtcbiAgfVxuXG4gIHJlc2V0SG9va3NTdGF0ZSgpO1xuICByZXR1cm4gY2hpbGRyZW47XG59IC8vIFJlc2V0IHRoZSBpbnRlcm5hbCBob29rcyBzdGF0ZSBpZiBhbiBlcnJvciBvY2N1cnMgd2hpbGUgcmVuZGVyaW5nIGEgY29tcG9uZW50XG5cbmZ1bmN0aW9uIHJlc2V0SG9va3NTdGF0ZSgpIHtcbiAge1xuICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9IGZhbHNlO1xuICB9XG5cbiAgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ID0gbnVsbDtcbiAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IGZhbHNlO1xuICBmaXJzdFdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG4gIG51bWJlck9mUmVSZW5kZXJzID0gMDtcbiAgcmVuZGVyUGhhc2VVcGRhdGVzID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gcmVhZENvbnRleHQoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKSB7XG4gIHZhciB0aHJlYWRJRCA9IGN1cnJlbnRQYXJ0aWFsUmVuZGVyZXIudGhyZWFkSUQ7XG4gIHZhbGlkYXRlQ29udGV4dEJvdW5kcyhjb250ZXh0LCB0aHJlYWRJRCk7XG5cbiAge1xuICAgIGlmIChpc0luSG9va1VzZXJDb2RlSW5EZXYpIHtcbiAgICAgIGVycm9yKCdDb250ZXh0IGNhbiBvbmx5IGJlIHJlYWQgd2hpbGUgUmVhY3QgaXMgcmVuZGVyaW5nLiAnICsgJ0luIGNsYXNzZXMsIHlvdSBjYW4gcmVhZCBpdCBpbiB0aGUgcmVuZGVyIG1ldGhvZCBvciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuICcgKyAnSW4gZnVuY3Rpb24gY29tcG9uZW50cywgeW91IGNhbiByZWFkIGl0IGRpcmVjdGx5IGluIHRoZSBmdW5jdGlvbiBib2R5LCBidXQgbm90ICcgKyAnaW5zaWRlIEhvb2tzIGxpa2UgdXNlUmVkdWNlcigpIG9yIHVzZU1lbW8oKS4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29udGV4dFt0aHJlYWRJRF07XG59XG5cbmZ1bmN0aW9uIHVzZUNvbnRleHQoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKSB7XG4gIHtcbiAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDb250ZXh0JztcbiAgfVxuXG4gIHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKTtcbiAgdmFyIHRocmVhZElEID0gY3VycmVudFBhcnRpYWxSZW5kZXJlci50aHJlYWRJRDtcbiAgdmFsaWRhdGVDb250ZXh0Qm91bmRzKGNvbnRleHQsIHRocmVhZElEKTtcbiAgcmV0dXJuIGNvbnRleHRbdGhyZWFkSURdO1xufVxuXG5mdW5jdGlvbiBiYXNpY1N0YXRlUmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gIC8vICRGbG93Rml4TWU6IEZsb3cgZG9lc24ndCBsaWtlIG1peGVkIHR5cGVzXG4gIHJldHVybiB0eXBlb2YgYWN0aW9uID09PSAnZnVuY3Rpb24nID8gYWN0aW9uKHN0YXRlKSA6IGFjdGlvbjtcbn1cblxuZnVuY3Rpb24gdXNlU3RhdGUoaW5pdGlhbFN0YXRlKSB7XG4gIHtcbiAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTdGF0ZSc7XG4gIH1cblxuICByZXR1cm4gdXNlUmVkdWNlcihiYXNpY1N0YXRlUmVkdWNlciwgLy8gdXNlUmVkdWNlciBoYXMgYSBzcGVjaWFsIGNhc2UgdG8gc3VwcG9ydCBsYXp5IHVzZVN0YXRlIGluaXRpYWxpemVyc1xuICBpbml0aWFsU3RhdGUpO1xufVxuZnVuY3Rpb24gdXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gIHtcbiAgICBpZiAocmVkdWNlciAhPT0gYmFzaWNTdGF0ZVJlZHVjZXIpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZHVjZXInO1xuICAgIH1cbiAgfVxuXG4gIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCA9IHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKTtcbiAgd29ya0luUHJvZ3Jlc3NIb29rID0gY3JlYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG5cbiAgaWYgKGlzUmVSZW5kZXIpIHtcbiAgICAvLyBUaGlzIGlzIGEgcmUtcmVuZGVyLiBBcHBseSB0aGUgbmV3IHJlbmRlciBwaGFzZSB1cGRhdGVzIHRvIHRoZSBwcmV2aW91c1xuICAgIC8vIGN1cnJlbnQgaG9vay5cbiAgICB2YXIgcXVldWUgPSB3b3JrSW5Qcm9ncmVzc0hvb2sucXVldWU7XG4gICAgdmFyIGRpc3BhdGNoID0gcXVldWUuZGlzcGF0Y2g7XG5cbiAgICBpZiAocmVuZGVyUGhhc2VVcGRhdGVzICE9PSBudWxsKSB7XG4gICAgICAvLyBSZW5kZXIgcGhhc2UgdXBkYXRlcyBhcmUgc3RvcmVkIGluIGEgbWFwIG9mIHF1ZXVlIC0+IGxpbmtlZCBsaXN0XG4gICAgICB2YXIgZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSA9IHJlbmRlclBoYXNlVXBkYXRlcy5nZXQocXVldWUpO1xuXG4gICAgICBpZiAoZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlbmRlclBoYXNlVXBkYXRlcy5kZWxldGUocXVldWUpO1xuICAgICAgICB2YXIgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgdmFyIHVwZGF0ZSA9IGZpcnN0UmVuZGVyUGhhc2VVcGRhdGU7XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgIC8vIFByb2Nlc3MgdGhpcyByZW5kZXIgcGhhc2UgdXBkYXRlLiBXZSBkb24ndCBoYXZlIHRvIGNoZWNrIHRoZVxuICAgICAgICAgIC8vIHByaW9yaXR5IGJlY2F1c2UgaXQgd2lsbCBhbHdheXMgYmUgdGhlIHNhbWUgYXMgdGhlIGN1cnJlbnRcbiAgICAgICAgICAvLyByZW5kZXIncy5cbiAgICAgICAgICB2YXIgYWN0aW9uID0gdXBkYXRlLmFjdGlvbjtcblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV3U3RhdGUgPSByZWR1Y2VyKG5ld1N0YXRlLCBhY3Rpb24pO1xuXG4gICAgICAgICAge1xuICAgICAgICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7XG4gICAgICAgIH0gd2hpbGUgKHVwZGF0ZSAhPT0gbnVsbCk7XG5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgcmV0dXJuIFtuZXdTdGF0ZSwgZGlzcGF0Y2hdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUsIGRpc3BhdGNoXTtcbiAgfSBlbHNlIHtcbiAgICB7XG4gICAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBpbml0aWFsU3RhdGU7XG5cbiAgICBpZiAocmVkdWNlciA9PT0gYmFzaWNTdGF0ZVJlZHVjZXIpIHtcbiAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYHVzZVN0YXRlYC5cbiAgICAgIGluaXRpYWxTdGF0ZSA9IHR5cGVvZiBpbml0aWFsQXJnID09PSAnZnVuY3Rpb24nID8gaW5pdGlhbEFyZygpIDogaW5pdGlhbEFyZztcbiAgICB9IGVsc2Uge1xuICAgICAgaW5pdGlhbFN0YXRlID0gaW5pdCAhPT0gdW5kZWZpbmVkID8gaW5pdChpbml0aWFsQXJnKSA6IGluaXRpYWxBcmc7XG4gICAgfVxuXG4gICAge1xuICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUgPSBpbml0aWFsU3RhdGU7XG5cbiAgICB2YXIgX3F1ZXVlID0gd29ya0luUHJvZ3Jlc3NIb29rLnF1ZXVlID0ge1xuICAgICAgbGFzdDogbnVsbCxcbiAgICAgIGRpc3BhdGNoOiBudWxsXG4gICAgfTtcblxuICAgIHZhciBfZGlzcGF0Y2ggPSBfcXVldWUuZGlzcGF0Y2ggPSBkaXNwYXRjaEFjdGlvbi5iaW5kKG51bGwsIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCwgX3F1ZXVlKTtcblxuICAgIHJldHVybiBbd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUsIF9kaXNwYXRjaF07XG4gIH1cbn1cblxuZnVuY3Rpb24gdXNlTWVtbyhuZXh0Q3JlYXRlLCBkZXBzKSB7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCA9IHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKTtcbiAgd29ya0luUHJvZ3Jlc3NIb29rID0gY3JlYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBuZXh0RGVwcyA9IGRlcHMgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZXBzO1xuXG4gIGlmICh3b3JrSW5Qcm9ncmVzc0hvb2sgIT09IG51bGwpIHtcbiAgICB2YXIgcHJldlN0YXRlID0gd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGU7XG5cbiAgICBpZiAocHJldlN0YXRlICE9PSBudWxsKSB7XG4gICAgICBpZiAobmV4dERlcHMgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHByZXZEZXBzID0gcHJldlN0YXRlWzFdO1xuXG4gICAgICAgIGlmIChhcmVIb29rSW5wdXRzRXF1YWwobmV4dERlcHMsIHByZXZEZXBzKSkge1xuICAgICAgICAgIHJldHVybiBwcmV2U3RhdGVbMF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB7XG4gICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBuZXh0VmFsdWUgPSBuZXh0Q3JlYXRlKCk7XG5cbiAge1xuICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9IGZhbHNlO1xuICB9XG5cbiAgd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUgPSBbbmV4dFZhbHVlLCBuZXh0RGVwc107XG4gIHJldHVybiBuZXh0VmFsdWU7XG59XG5cbmZ1bmN0aW9uIHVzZVJlZihpbml0aWFsVmFsdWUpIHtcbiAgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ID0gcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIHByZXZpb3VzUmVmID0gd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGU7XG5cbiAgaWYgKHByZXZpb3VzUmVmID09PSBudWxsKSB7XG4gICAgdmFyIHJlZiA9IHtcbiAgICAgIGN1cnJlbnQ6IGluaXRpYWxWYWx1ZVxuICAgIH07XG5cbiAgICB7XG4gICAgICBPYmplY3Quc2VhbChyZWYpO1xuICAgIH1cblxuICAgIHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlID0gcmVmO1xuICAgIHJldHVybiByZWY7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHByZXZpb3VzUmVmO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVzZUxheW91dEVmZmVjdChjcmVhdGUsIGlucHV0cykge1xuICB7XG4gICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTGF5b3V0RWZmZWN0JztcblxuICAgIGVycm9yKCd1c2VMYXlvdXRFZmZlY3QgZG9lcyBub3RoaW5nIG9uIHRoZSBzZXJ2ZXIsIGJlY2F1c2UgaXRzIGVmZmVjdCBjYW5ub3QgJyArIFwiYmUgZW5jb2RlZCBpbnRvIHRoZSBzZXJ2ZXIgcmVuZGVyZXIncyBvdXRwdXQgZm9ybWF0LiBUaGlzIHdpbGwgbGVhZCBcIiArICd0byBhIG1pc21hdGNoIGJldHdlZW4gdGhlIGluaXRpYWwsIG5vbi1oeWRyYXRlZCBVSSBhbmQgdGhlIGludGVuZGVkICcgKyAnVUkuIFRvIGF2b2lkIHRoaXMsIHVzZUxheW91dEVmZmVjdCBzaG91bGQgb25seSBiZSB1c2VkIGluICcgKyAnY29tcG9uZW50cyB0aGF0IHJlbmRlciBleGNsdXNpdmVseSBvbiB0aGUgY2xpZW50LiAnICsgJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvdXNlbGF5b3V0ZWZmZWN0LXNzciBmb3IgY29tbW9uIGZpeGVzLicpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoQWN0aW9uKGNvbXBvbmVudElkZW50aXR5LCBxdWV1ZSwgYWN0aW9uKSB7XG4gIGlmICghKG51bWJlck9mUmVSZW5kZXJzIDwgUkVfUkVOREVSX0xJTUlUKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlRvbyBtYW55IHJlLXJlbmRlcnMuIFJlYWN0IGxpbWl0cyB0aGUgbnVtYmVyIG9mIHJlbmRlcnMgdG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wLlwiICk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNvbXBvbmVudElkZW50aXR5ID09PSBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQpIHtcbiAgICAvLyBUaGlzIGlzIGEgcmVuZGVyIHBoYXNlIHVwZGF0ZS4gU3Rhc2ggaXQgaW4gYSBsYXppbHktY3JlYXRlZCBtYXAgb2ZcbiAgICAvLyBxdWV1ZSAtPiBsaW5rZWQgbGlzdCBvZiB1cGRhdGVzLiBBZnRlciB0aGlzIHJlbmRlciBwYXNzLCB3ZSdsbCByZXN0YXJ0XG4gICAgLy8gYW5kIGFwcGx5IHRoZSBzdGFzaGVkIHVwZGF0ZXMgb24gdG9wIG9mIHRoZSB3b3JrLWluLXByb2dyZXNzIGhvb2suXG4gICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IHRydWU7XG4gICAgdmFyIHVwZGF0ZSA9IHtcbiAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG5cbiAgICBpZiAocmVuZGVyUGhhc2VVcGRhdGVzID09PSBudWxsKSB7XG4gICAgICByZW5kZXJQaGFzZVVwZGF0ZXMgPSBuZXcgTWFwKCk7XG4gICAgfVxuXG4gICAgdmFyIGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUgPSByZW5kZXJQaGFzZVVwZGF0ZXMuZ2V0KHF1ZXVlKTtcblxuICAgIGlmIChmaXJzdFJlbmRlclBoYXNlVXBkYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlbmRlclBoYXNlVXBkYXRlcy5zZXQocXVldWUsIHVwZGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEFwcGVuZCB0aGUgdXBkYXRlIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QuXG4gICAgICB2YXIgbGFzdFJlbmRlclBoYXNlVXBkYXRlID0gZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZTtcblxuICAgICAgd2hpbGUgKGxhc3RSZW5kZXJQaGFzZVVwZGF0ZS5uZXh0ICE9PSBudWxsKSB7XG4gICAgICAgIGxhc3RSZW5kZXJQaGFzZVVwZGF0ZSA9IGxhc3RSZW5kZXJQaGFzZVVwZGF0ZS5uZXh0O1xuICAgICAgfVxuXG4gICAgICBsYXN0UmVuZGVyUGhhc2VVcGRhdGUubmV4dCA9IHVwZGF0ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXNlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpIHtcbiAgcmV0dXJuIHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjYWxsYmFjaztcbiAgfSwgZGVwcyk7XG59IC8vIFRPRE8gRGVjaWRlIG9uIGhvdyB0byBpbXBsZW1lbnQgdGhpcyBob29rIGZvciBzZXJ2ZXIgcmVuZGVyaW5nLlxuLy8gSWYgYSBtdXRhdGlvbiBvY2N1cnMgZHVyaW5nIHJlbmRlciwgY29uc2lkZXIgdHJpZ2dlcmluZyBhIFN1c3BlbnNlIGJvdW5kYXJ5XG4vLyBhbmQgZmFsbGluZyBiYWNrIHRvIGNsaWVudCByZW5kZXJpbmcuXG5cbmZ1bmN0aW9uIHVzZU11dGFibGVTb3VyY2Uoc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKSB7XG4gIHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKTtcbiAgcmV0dXJuIGdldFNuYXBzaG90KHNvdXJjZS5fc291cmNlKTtcbn1cblxuZnVuY3Rpb24gdXNlRGVmZXJyZWRWYWx1ZSh2YWx1ZSkge1xuICByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gdXNlVHJhbnNpdGlvbigpIHtcbiAgcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuXG4gIHZhciBzdGFydFRyYW5zaXRpb24gPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9O1xuXG4gIHJldHVybiBbc3RhcnRUcmFuc2l0aW9uLCBmYWxzZV07XG59XG5cbmZ1bmN0aW9uIHVzZU9wYXF1ZUlkZW50aWZpZXIoKSB7XG4gIHJldHVybiAoY3VycmVudFBhcnRpYWxSZW5kZXJlci5pZGVudGlmaWVyUHJlZml4IHx8ICcnKSArICdSOicgKyAoY3VycmVudFBhcnRpYWxSZW5kZXJlci51bmlxdWVJRCsrKS50b1N0cmluZygzNik7XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG52YXIgY3VycmVudFBhcnRpYWxSZW5kZXJlciA9IG51bGw7XG5mdW5jdGlvbiBzZXRDdXJyZW50UGFydGlhbFJlbmRlcmVyKHJlbmRlcmVyKSB7XG4gIGN1cnJlbnRQYXJ0aWFsUmVuZGVyZXIgPSByZW5kZXJlcjtcbn1cbnZhciBEaXNwYXRjaGVyID0ge1xuICByZWFkQ29udGV4dDogcmVhZENvbnRleHQsXG4gIHVzZUNvbnRleHQ6IHVzZUNvbnRleHQsXG4gIHVzZU1lbW86IHVzZU1lbW8sXG4gIHVzZVJlZHVjZXI6IHVzZVJlZHVjZXIsXG4gIHVzZVJlZjogdXNlUmVmLFxuICB1c2VTdGF0ZTogdXNlU3RhdGUsXG4gIHVzZUxheW91dEVmZmVjdDogdXNlTGF5b3V0RWZmZWN0LFxuICB1c2VDYWxsYmFjazogdXNlQ2FsbGJhY2ssXG4gIC8vIHVzZUltcGVyYXRpdmVIYW5kbGUgaXMgbm90IHJ1biBpbiB0aGUgc2VydmVyIGVudmlyb25tZW50XG4gIHVzZUltcGVyYXRpdmVIYW5kbGU6IG5vb3AsXG4gIC8vIEVmZmVjdHMgYXJlIG5vdCBydW4gaW4gdGhlIHNlcnZlciBlbnZpcm9ubWVudC5cbiAgdXNlRWZmZWN0OiBub29wLFxuICAvLyBEZWJ1Z2dpbmcgZWZmZWN0XG4gIHVzZURlYnVnVmFsdWU6IG5vb3AsXG4gIHVzZURlZmVycmVkVmFsdWU6IHVzZURlZmVycmVkVmFsdWUsXG4gIHVzZVRyYW5zaXRpb246IHVzZVRyYW5zaXRpb24sXG4gIHVzZU9wYXF1ZUlkZW50aWZpZXI6IHVzZU9wYXF1ZUlkZW50aWZpZXIsXG4gIC8vIFN1YnNjcmlwdGlvbnMgYXJlIG5vdCBzZXR1cCBpbiBhIHNlcnZlciBlbnZpcm9ubWVudC5cbiAgdXNlTXV0YWJsZVNvdXJjZTogdXNlTXV0YWJsZVNvdXJjZVxufTtcblxudmFyIEhUTUxfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnO1xudmFyIE1BVEhfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnO1xudmFyIFNWR19OQU1FU1BBQ0UgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xudmFyIE5hbWVzcGFjZXMgPSB7XG4gIGh0bWw6IEhUTUxfTkFNRVNQQUNFLFxuICBtYXRobWw6IE1BVEhfTkFNRVNQQUNFLFxuICBzdmc6IFNWR19OQU1FU1BBQ0Vcbn07IC8vIEFzc3VtZXMgdGhlcmUgaXMgbm8gcGFyZW50IG5hbWVzcGFjZS5cblxuZnVuY3Rpb24gZ2V0SW50cmluc2ljTmFtZXNwYWNlKHR5cGUpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnc3ZnJzpcbiAgICAgIHJldHVybiBTVkdfTkFNRVNQQUNFO1xuXG4gICAgY2FzZSAnbWF0aCc6XG4gICAgICByZXR1cm4gTUFUSF9OQU1FU1BBQ0U7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIEhUTUxfTkFNRVNQQUNFO1xuICB9XG59XG5mdW5jdGlvbiBnZXRDaGlsZE5hbWVzcGFjZShwYXJlbnROYW1lc3BhY2UsIHR5cGUpIHtcbiAgaWYgKHBhcmVudE5hbWVzcGFjZSA9PSBudWxsIHx8IHBhcmVudE5hbWVzcGFjZSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAvLyBObyAob3IgZGVmYXVsdCkgcGFyZW50IG5hbWVzcGFjZTogcG90ZW50aWFsIGVudHJ5IHBvaW50LlxuICAgIHJldHVybiBnZXRJbnRyaW5zaWNOYW1lc3BhY2UodHlwZSk7XG4gIH1cblxuICBpZiAocGFyZW50TmFtZXNwYWNlID09PSBTVkdfTkFNRVNQQUNFICYmIHR5cGUgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgIC8vIFdlJ3JlIGxlYXZpbmcgU1ZHLlxuICAgIHJldHVybiBIVE1MX05BTUVTUEFDRTtcbiAgfSAvLyBCeSBkZWZhdWx0LCBwYXNzIG5hbWVzcGFjZSBiZWxvdy5cblxuXG4gIHJldHVybiBwYXJlbnROYW1lc3BhY2U7XG59XG5cbnZhciBoYXNSZWFkT25seVZhbHVlID0ge1xuICBidXR0b246IHRydWUsXG4gIGNoZWNrYm94OiB0cnVlLFxuICBpbWFnZTogdHJ1ZSxcbiAgaGlkZGVuOiB0cnVlLFxuICByYWRpbzogdHJ1ZSxcbiAgcmVzZXQ6IHRydWUsXG4gIHN1Ym1pdDogdHJ1ZVxufTtcbmZ1bmN0aW9uIGNoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHModGFnTmFtZSwgcHJvcHMpIHtcbiAge1xuICAgIGlmICghKGhhc1JlYWRPbmx5VmFsdWVbcHJvcHMudHlwZV0gfHwgcHJvcHMub25DaGFuZ2UgfHwgcHJvcHMub25JbnB1dCB8fCBwcm9wcy5yZWFkT25seSB8fCBwcm9wcy5kaXNhYmxlZCB8fCBwcm9wcy52YWx1ZSA9PSBudWxsKSkge1xuICAgICAgZXJyb3IoJ1lvdSBwcm92aWRlZCBhIGB2YWx1ZWAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnICsgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArICd0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0VmFsdWVgLiBPdGhlcndpc2UsICcgKyAnc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuJyk7XG4gICAgfVxuXG4gICAgaWYgKCEocHJvcHMub25DaGFuZ2UgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQgfHwgcHJvcHMuY2hlY2tlZCA9PSBudWxsKSkge1xuICAgICAgZXJyb3IoJ1lvdSBwcm92aWRlZCBhIGBjaGVja2VkYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuICcgKyAnYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiAnICsgJ3RoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRDaGVja2VkYC4gT3RoZXJ3aXNlLCAnICsgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBGb3IgSFRNTCwgY2VydGFpbiB0YWdzIHNob3VsZCBvbWl0IHRoZWlyIGNsb3NlIHRhZy4gV2Uga2VlcCBhIGxpc3QgZm9yXG4vLyB0aG9zZSBzcGVjaWFsLWNhc2UgdGFncy5cbnZhciBvbWl0dGVkQ2xvc2VUYWdzID0ge1xuICBhcmVhOiB0cnVlLFxuICBiYXNlOiB0cnVlLFxuICBicjogdHJ1ZSxcbiAgY29sOiB0cnVlLFxuICBlbWJlZDogdHJ1ZSxcbiAgaHI6IHRydWUsXG4gIGltZzogdHJ1ZSxcbiAgaW5wdXQ6IHRydWUsXG4gIGtleWdlbjogdHJ1ZSxcbiAgbGluazogdHJ1ZSxcbiAgbWV0YTogdHJ1ZSxcbiAgcGFyYW06IHRydWUsXG4gIHNvdXJjZTogdHJ1ZSxcbiAgdHJhY2s6IHRydWUsXG4gIHdicjogdHJ1ZSAvLyBOT1RFOiBtZW51aXRlbSdzIGNsb3NlIHRhZyBzaG91bGQgYmUgb21pdHRlZCwgYnV0IHRoYXQgY2F1c2VzIHByb2JsZW1zLlxuXG59O1xuXG4vLyBgb21pdHRlZENsb3NlVGFnc2AgZXhjZXB0IHRoYXQgYG1lbnVpdGVtYCBzaG91bGQgc3RpbGwgaGF2ZSBpdHMgY2xvc2luZyB0YWcuXG5cbnZhciB2b2lkRWxlbWVudFRhZ3MgPSBfYXNzaWduKHtcbiAgbWVudWl0ZW06IHRydWVcbn0sIG9taXR0ZWRDbG9zZVRhZ3MpO1xuXG52YXIgSFRNTCA9ICdfX2h0bWwnO1xuXG5mdW5jdGlvbiBhc3NlcnRWYWxpZFByb3BzKHRhZywgcHJvcHMpIHtcbiAgaWYgKCFwcm9wcykge1xuICAgIHJldHVybjtcbiAgfSAvLyBOb3RlIHRoZSB1c2Ugb2YgYD09YCB3aGljaCBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkLlxuXG5cbiAgaWYgKHZvaWRFbGVtZW50VGFnc1t0YWddKSB7XG4gICAgaWYgKCEocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCAmJiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PSBudWxsKSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvciggdGFnICsgXCIgaXMgYSB2b2lkIGVsZW1lbnQgdGFnIGFuZCBtdXN0IG5laXRoZXIgaGF2ZSBgY2hpbGRyZW5gIG5vciB1c2UgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC5cIiApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAhPSBudWxsKSB7XG4gICAgaWYgKCEocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCkpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIFwiQ2FuIG9ubHkgc2V0IG9uZSBvZiBgY2hpbGRyZW5gIG9yIGBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAuXCIgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoISh0eXBlb2YgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT09ICdvYmplY3QnICYmIEhUTUwgaW4gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwpKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcImBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAgbXVzdCBiZSBpbiB0aGUgZm9ybSBge19faHRtbDogLi4ufWAuIFBsZWFzZSB2aXNpdCBodHRwczovL3JlYWN0anMub3JnL2xpbmsvZGFuZ2Vyb3VzbHktc2V0LWlubmVyLWh0bWwgZm9yIG1vcmUgaW5mb3JtYXRpb24uXCIgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB7XG4gICAgaWYgKCFwcm9wcy5zdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcgJiYgcHJvcHMuY29udGVudEVkaXRhYmxlICYmIHByb3BzLmNoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgIGVycm9yKCdBIGNvbXBvbmVudCBpcyBgY29udGVudEVkaXRhYmxlYCBhbmQgY29udGFpbnMgYGNoaWxkcmVuYCBtYW5hZ2VkIGJ5ICcgKyAnUmVhY3QuIEl0IGlzIG5vdyB5b3VyIHJlc3BvbnNpYmlsaXR5IHRvIGd1YXJhbnRlZSB0aGF0IG5vbmUgb2YgJyArICd0aG9zZSBub2RlcyBhcmUgdW5leHBlY3RlZGx5IG1vZGlmaWVkIG9yIGR1cGxpY2F0ZWQuIFRoaXMgaXMgJyArICdwcm9iYWJseSBub3QgaW50ZW50aW9uYWwuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCEocHJvcHMuc3R5bGUgPT0gbnVsbCB8fCB0eXBlb2YgcHJvcHMuc3R5bGUgPT09ICdvYmplY3QnKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlRoZSBgc3R5bGVgIHByb3AgZXhwZWN0cyBhIG1hcHBpbmcgZnJvbSBzdHlsZSBwcm9wZXJ0aWVzIHRvIHZhbHVlcywgbm90IGEgc3RyaW5nLiBGb3IgZXhhbXBsZSwgc3R5bGU9e3ttYXJnaW5SaWdodDogc3BhY2luZyArICdlbSd9fSB3aGVuIHVzaW5nIEpTWC5cIiApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENTUyBwcm9wZXJ0aWVzIHdoaWNoIGFjY2VwdCBudW1iZXJzIGJ1dCBhcmUgbm90IGluIHVuaXRzIG9mIFwicHhcIi5cbiAqL1xudmFyIGlzVW5pdGxlc3NOdW1iZXIgPSB7XG4gIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiB0cnVlLFxuICBib3JkZXJJbWFnZU91dHNldDogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VTbGljZTogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VXaWR0aDogdHJ1ZSxcbiAgYm94RmxleDogdHJ1ZSxcbiAgYm94RmxleEdyb3VwOiB0cnVlLFxuICBib3hPcmRpbmFsR3JvdXA6IHRydWUsXG4gIGNvbHVtbkNvdW50OiB0cnVlLFxuICBjb2x1bW5zOiB0cnVlLFxuICBmbGV4OiB0cnVlLFxuICBmbGV4R3JvdzogdHJ1ZSxcbiAgZmxleFBvc2l0aXZlOiB0cnVlLFxuICBmbGV4U2hyaW5rOiB0cnVlLFxuICBmbGV4TmVnYXRpdmU6IHRydWUsXG4gIGZsZXhPcmRlcjogdHJ1ZSxcbiAgZ3JpZEFyZWE6IHRydWUsXG4gIGdyaWRSb3c6IHRydWUsXG4gIGdyaWRSb3dFbmQ6IHRydWUsXG4gIGdyaWRSb3dTcGFuOiB0cnVlLFxuICBncmlkUm93U3RhcnQ6IHRydWUsXG4gIGdyaWRDb2x1bW46IHRydWUsXG4gIGdyaWRDb2x1bW5FbmQ6IHRydWUsXG4gIGdyaWRDb2x1bW5TcGFuOiB0cnVlLFxuICBncmlkQ29sdW1uU3RhcnQ6IHRydWUsXG4gIGZvbnRXZWlnaHQ6IHRydWUsXG4gIGxpbmVDbGFtcDogdHJ1ZSxcbiAgbGluZUhlaWdodDogdHJ1ZSxcbiAgb3BhY2l0eTogdHJ1ZSxcbiAgb3JkZXI6IHRydWUsXG4gIG9ycGhhbnM6IHRydWUsXG4gIHRhYlNpemU6IHRydWUsXG4gIHdpZG93czogdHJ1ZSxcbiAgekluZGV4OiB0cnVlLFxuICB6b29tOiB0cnVlLFxuICAvLyBTVkctcmVsYXRlZCBwcm9wZXJ0aWVzXG4gIGZpbGxPcGFjaXR5OiB0cnVlLFxuICBmbG9vZE9wYWNpdHk6IHRydWUsXG4gIHN0b3BPcGFjaXR5OiB0cnVlLFxuICBzdHJva2VEYXNoYXJyYXk6IHRydWUsXG4gIHN0cm9rZURhc2hvZmZzZXQ6IHRydWUsXG4gIHN0cm9rZU1pdGVybGltaXQ6IHRydWUsXG4gIHN0cm9rZU9wYWNpdHk6IHRydWUsXG4gIHN0cm9rZVdpZHRoOiB0cnVlXG59O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IHZlbmRvci1zcGVjaWZpYyBwcmVmaXgsIGVnOiBXZWJraXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgc3R5bGUgbmFtZSwgZWc6IHRyYW5zaXRpb25EdXJhdGlvblxuICogQHJldHVybiB7c3RyaW5nfSBzdHlsZSBuYW1lIHByZWZpeGVkIHdpdGggYHByZWZpeGAsIHByb3Blcmx5IGNhbWVsQ2FzZWQsIGVnOlxuICogV2Via2l0VHJhbnNpdGlvbkR1cmF0aW9uXG4gKi9cblxuZnVuY3Rpb24gcHJlZml4S2V5KHByZWZpeCwga2V5KSB7XG4gIHJldHVybiBwcmVmaXggKyBrZXkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrZXkuc3Vic3RyaW5nKDEpO1xufVxuLyoqXG4gKiBTdXBwb3J0IHN0eWxlIG5hbWVzIHRoYXQgbWF5IGNvbWUgcGFzc2VkIGluIHByZWZpeGVkIGJ5IGFkZGluZyBwZXJtdXRhdGlvbnNcbiAqIG9mIHZlbmRvciBwcmVmaXhlcy5cbiAqL1xuXG5cbnZhciBwcmVmaXhlcyA9IFsnV2Via2l0JywgJ21zJywgJ01veicsICdPJ107IC8vIFVzaW5nIE9iamVjdC5rZXlzIGhlcmUsIG9yIGVsc2UgdGhlIHZhbmlsbGEgZm9yLWluIGxvb3AgbWFrZXMgSUU4IGdvIGludG8gYW5cbi8vIGluZmluaXRlIGxvb3AsIGJlY2F1c2UgaXQgaXRlcmF0ZXMgb3ZlciB0aGUgbmV3bHkgYWRkZWQgcHJvcHMgdG9vLlxuXG5PYmplY3Qua2V5cyhpc1VuaXRsZXNzTnVtYmVyKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gIHByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24gKHByZWZpeCkge1xuICAgIGlzVW5pdGxlc3NOdW1iZXJbcHJlZml4S2V5KHByZWZpeCwgcHJvcCldID0gaXNVbml0bGVzc051bWJlcltwcm9wXTtcbiAgfSk7XG59KTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgaW50byB0aGUgcHJvcGVyIGNzcyB3cml0YWJsZSB2YWx1ZS4gVGhlIHN0eWxlIG5hbWUgYG5hbWVgXG4gKiBzaG91bGQgYmUgbG9naWNhbCAobm8gaHlwaGVucyksIGFzIHNwZWNpZmllZFxuICogaW4gYENTU1Byb3BlcnR5LmlzVW5pdGxlc3NOdW1iZXJgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIENTUyBwcm9wZXJ0eSBuYW1lIHN1Y2ggYXMgYHRvcE1hcmdpbmAuXG4gKiBAcGFyYW0geyp9IHZhbHVlIENTUyBwcm9wZXJ0eSB2YWx1ZSBzdWNoIGFzIGAxMHB4YC5cbiAqIEByZXR1cm4ge3N0cmluZ30gTm9ybWFsaXplZCBzdHlsZSB2YWx1ZSB3aXRoIGRpbWVuc2lvbnMgYXBwbGllZC5cbiAqL1xuXG5mdW5jdGlvbiBkYW5nZXJvdXNTdHlsZVZhbHVlKG5hbWUsIHZhbHVlLCBpc0N1c3RvbVByb3BlcnR5KSB7XG4gIC8vIE5vdGUgdGhhdCB3ZSd2ZSByZW1vdmVkIGVzY2FwZVRleHRGb3JCcm93c2VyKCkgY2FsbHMgaGVyZSBzaW5jZSB0aGVcbiAgLy8gd2hvbGUgc3RyaW5nIHdpbGwgYmUgZXNjYXBlZCB3aGVuIHRoZSBhdHRyaWJ1dGUgaXMgaW5qZWN0ZWQgaW50b1xuICAvLyB0aGUgbWFya3VwLiBJZiB5b3UgcHJvdmlkZSB1bnNhZmUgdXNlciBkYXRhIGhlcmUgdGhleSBjYW4gaW5qZWN0XG4gIC8vIGFyYml0cmFyeSBDU1Mgd2hpY2ggbWF5IGJlIHByb2JsZW1hdGljIChJIGNvdWxkbid0IHJlcHJvIHRoaXMpOlxuICAvLyBodHRwczovL3d3dy5vd2FzcC5vcmcvaW5kZXgucGhwL1hTU19GaWx0ZXJfRXZhc2lvbl9DaGVhdF9TaGVldFxuICAvLyBodHRwOi8vd3d3LnRoZXNwYW5uZXIuY28udWsvMjAwNy8xMS8yNi91bHRpbWF0ZS14c3MtY3NzLWluamVjdGlvbi9cbiAgLy8gVGhpcyBpcyBub3QgYW4gWFNTIGhvbGUgYnV0IGluc3RlYWQgYSBwb3RlbnRpYWwgQ1NTIGluamVjdGlvbiBpc3N1ZVxuICAvLyB3aGljaCBoYXMgbGVhZCB0byBhIGdyZWF0ZXIgZGlzY3Vzc2lvbiBhYm91dCBob3cgd2UncmUgZ29pbmcgdG9cbiAgLy8gdHJ1c3QgVVJMcyBtb3ZpbmcgZm9yd2FyZC4gU2VlICMyMTE1OTAxXG4gIHZhciBpc0VtcHR5ID0gdmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyB8fCB2YWx1ZSA9PT0gJyc7XG5cbiAgaWYgKGlzRW1wdHkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAoIWlzQ3VzdG9tUHJvcGVydHkgJiYgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiB2YWx1ZSAhPT0gMCAmJiAhKGlzVW5pdGxlc3NOdW1iZXIuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgaXNVbml0bGVzc051bWJlcltuYW1lXSkpIHtcbiAgICByZXR1cm4gdmFsdWUgKyAncHgnOyAvLyBQcmVzdW1lcyBpbXBsaWNpdCAncHgnIHN1ZmZpeCBmb3IgdW5pdGxlc3MgbnVtYmVyc1xuICB9XG5cbiAgcmV0dXJuICgnJyArIHZhbHVlKS50cmltKCk7XG59XG5cbnZhciB1cHBlcmNhc2VQYXR0ZXJuID0gLyhbQS1aXSkvZztcbnZhciBtc1BhdHRlcm4gPSAvXm1zLS87XG4vKipcbiAqIEh5cGhlbmF0ZXMgYSBjYW1lbGNhc2VkIENTUyBwcm9wZXJ0eSBuYW1lLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdiYWNrZ3JvdW5kQ29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZC1jb2xvclwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdNb3pUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tb3otdHJhbnNpdGlvblwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdtc1RyYW5zaXRpb24nKVxuICogICA8IFwiLW1zLXRyYW5zaXRpb25cIlxuICpcbiAqIEFzIE1vZGVybml6ciBzdWdnZXN0cyAoaHR0cDovL21vZGVybml6ci5jb20vZG9jcy8jcHJlZml4ZWQpLCBhbiBgbXNgIHByZWZpeFxuICogaXMgY29udmVydGVkIHRvIGAtbXMtYC5cbiAqL1xuXG5mdW5jdGlvbiBoeXBoZW5hdGVTdHlsZU5hbWUobmFtZSkge1xuICByZXR1cm4gbmFtZS5yZXBsYWNlKHVwcGVyY2FzZVBhdHRlcm4sICctJDEnKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UobXNQYXR0ZXJuLCAnLW1zLScpO1xufVxuXG5mdW5jdGlvbiBpc0N1c3RvbUNvbXBvbmVudCh0YWdOYW1lLCBwcm9wcykge1xuICBpZiAodGFnTmFtZS5pbmRleE9mKCctJykgPT09IC0xKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBwcm9wcy5pcyA9PT0gJ3N0cmluZyc7XG4gIH1cblxuICBzd2l0Y2ggKHRhZ05hbWUpIHtcbiAgICAvLyBUaGVzZSBhcmUgcmVzZXJ2ZWQgU1ZHIGFuZCBNYXRoTUwgZWxlbWVudHMuXG4gICAgLy8gV2UgZG9uJ3QgbWluZCB0aGlzIGxpc3QgdG9vIG11Y2ggYmVjYXVzZSB3ZSBleHBlY3QgaXQgdG8gbmV2ZXIgZ3Jvdy5cbiAgICAvLyBUaGUgYWx0ZXJuYXRpdmUgaXMgdG8gdHJhY2sgdGhlIG5hbWVzcGFjZSBpbiBhIGZldyBwbGFjZXMgd2hpY2ggaXMgY29udm9sdXRlZC5cbiAgICAvLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViY29tcG9uZW50cy9zcGVjL2N1c3RvbS8jY3VzdG9tLWVsZW1lbnRzLWNvcmUtY29uY2VwdHNcbiAgICBjYXNlICdhbm5vdGF0aW9uLXhtbCc6XG4gICAgY2FzZSAnY29sb3ItcHJvZmlsZSc6XG4gICAgY2FzZSAnZm9udC1mYWNlJzpcbiAgICBjYXNlICdmb250LWZhY2Utc3JjJzpcbiAgICBjYXNlICdmb250LWZhY2UtdXJpJzpcbiAgICBjYXNlICdmb250LWZhY2UtZm9ybWF0JzpcbiAgICBjYXNlICdmb250LWZhY2UtbmFtZSc6XG4gICAgY2FzZSAnbWlzc2luZy1nbHlwaCc6XG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxudmFyIHdhcm5WYWxpZFN0eWxlID0gZnVuY3Rpb24gKCkge307XG5cbntcbiAgLy8gJ21zVHJhbnNmb3JtJyBpcyBjb3JyZWN0LCBidXQgdGhlIG90aGVyIHByZWZpeGVzIHNob3VsZCBiZSBjYXBpdGFsaXplZFxuICB2YXIgYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuID0gL14oPzp3ZWJraXR8bW96fG8pW0EtWl0vO1xuICB2YXIgbXNQYXR0ZXJuJDEgPSAvXi1tcy0vO1xuICB2YXIgaHlwaGVuUGF0dGVybiA9IC8tKC4pL2c7IC8vIHN0eWxlIHZhbHVlcyBzaG91bGRuJ3QgY29udGFpbiBhIHNlbWljb2xvblxuXG4gIHZhciBiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4gPSAvO1xccyokLztcbiAgdmFyIHdhcm5lZFN0eWxlTmFtZXMgPSB7fTtcbiAgdmFyIHdhcm5lZFN0eWxlVmFsdWVzID0ge307XG4gIHZhciB3YXJuZWRGb3JOYU5WYWx1ZSA9IGZhbHNlO1xuICB2YXIgd2FybmVkRm9ySW5maW5pdHlWYWx1ZSA9IGZhbHNlO1xuXG4gIHZhciBjYW1lbGl6ZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoaHlwaGVuUGF0dGVybiwgZnVuY3Rpb24gKF8sIGNoYXJhY3Rlcikge1xuICAgICAgcmV0dXJuIGNoYXJhY3Rlci50b1VwcGVyQ2FzZSgpO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciB3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0gPSB0cnVlO1xuXG4gICAgZXJyb3IoJ1Vuc3VwcG9ydGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JywgbmFtZSwgLy8gQXMgQW5kaSBTbWl0aCBzdWdnZXN0c1xuICAgIC8vIChodHRwOi8vd3d3LmFuZGlzbWl0aC5jb20vYmxvZy8yMDEyLzAyL21vZGVybml6ci1wcmVmaXhlZC8pLCBhbiBgLW1zYCBwcmVmaXhcbiAgICAvLyBpcyBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlIGBtc2AuXG4gICAgY2FtZWxpemUobmFtZS5yZXBsYWNlKG1zUGF0dGVybiQxLCAnbXMtJykpKTtcbiAgfTtcblxuICB2YXIgd2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG5cbiAgICBlcnJvcignVW5zdXBwb3J0ZWQgdmVuZG9yLXByZWZpeGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JywgbmFtZSwgbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSkpO1xuICB9O1xuXG4gIHZhciB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAod2FybmVkU3R5bGVWYWx1ZXMuaGFzT3duUHJvcGVydHkodmFsdWUpICYmIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSA9IHRydWU7XG5cbiAgICBlcnJvcihcIlN0eWxlIHByb3BlcnR5IHZhbHVlcyBzaG91bGRuJ3QgY29udGFpbiBhIHNlbWljb2xvbi4gXCIgKyAnVHJ5IFwiJXM6ICVzXCIgaW5zdGVhZC4nLCBuYW1lLCB2YWx1ZS5yZXBsYWNlKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiwgJycpKTtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVJc05hTiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh3YXJuZWRGb3JOYU5WYWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZEZvck5hTlZhbHVlID0gdHJ1ZTtcblxuICAgIGVycm9yKCdgTmFOYCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuJywgbmFtZSk7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlSXNJbmZpbml0eSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh3YXJuZWRGb3JJbmZpbml0eVZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkRm9ySW5maW5pdHlWYWx1ZSA9IHRydWU7XG5cbiAgICBlcnJvcignYEluZmluaXR5YCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuJywgbmFtZSk7XG4gIH07XG5cbiAgd2FyblZhbGlkU3R5bGUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAobmFtZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUobmFtZSk7XG4gICAgfSBlbHNlIGlmIChiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4udGVzdChuYW1lKSkge1xuICAgICAgd2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lKG5hbWUpO1xuICAgIH0gZWxzZSBpZiAoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLnRlc3QodmFsdWUpKSB7XG4gICAgICB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24obmFtZSwgdmFsdWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgIHdhcm5TdHlsZVZhbHVlSXNOYU4obmFtZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICghaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICAgIHdhcm5TdHlsZVZhbHVlSXNJbmZpbml0eShuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG52YXIgd2FyblZhbGlkU3R5bGUkMSA9IHdhcm5WYWxpZFN0eWxlO1xuXG52YXIgYXJpYVByb3BlcnRpZXMgPSB7XG4gICdhcmlhLWN1cnJlbnQnOiAwLFxuICAvLyBzdGF0ZVxuICAnYXJpYS1kZXRhaWxzJzogMCxcbiAgJ2FyaWEtZGlzYWJsZWQnOiAwLFxuICAvLyBzdGF0ZVxuICAnYXJpYS1oaWRkZW4nOiAwLFxuICAvLyBzdGF0ZVxuICAnYXJpYS1pbnZhbGlkJzogMCxcbiAgLy8gc3RhdGVcbiAgJ2FyaWEta2V5c2hvcnRjdXRzJzogMCxcbiAgJ2FyaWEtbGFiZWwnOiAwLFxuICAnYXJpYS1yb2xlZGVzY3JpcHRpb24nOiAwLFxuICAvLyBXaWRnZXQgQXR0cmlidXRlc1xuICAnYXJpYS1hdXRvY29tcGxldGUnOiAwLFxuICAnYXJpYS1jaGVja2VkJzogMCxcbiAgJ2FyaWEtZXhwYW5kZWQnOiAwLFxuICAnYXJpYS1oYXNwb3B1cCc6IDAsXG4gICdhcmlhLWxldmVsJzogMCxcbiAgJ2FyaWEtbW9kYWwnOiAwLFxuICAnYXJpYS1tdWx0aWxpbmUnOiAwLFxuICAnYXJpYS1tdWx0aXNlbGVjdGFibGUnOiAwLFxuICAnYXJpYS1vcmllbnRhdGlvbic6IDAsXG4gICdhcmlhLXBsYWNlaG9sZGVyJzogMCxcbiAgJ2FyaWEtcHJlc3NlZCc6IDAsXG4gICdhcmlhLXJlYWRvbmx5JzogMCxcbiAgJ2FyaWEtcmVxdWlyZWQnOiAwLFxuICAnYXJpYS1zZWxlY3RlZCc6IDAsXG4gICdhcmlhLXNvcnQnOiAwLFxuICAnYXJpYS12YWx1ZW1heCc6IDAsXG4gICdhcmlhLXZhbHVlbWluJzogMCxcbiAgJ2FyaWEtdmFsdWVub3cnOiAwLFxuICAnYXJpYS12YWx1ZXRleHQnOiAwLFxuICAvLyBMaXZlIFJlZ2lvbiBBdHRyaWJ1dGVzXG4gICdhcmlhLWF0b21pYyc6IDAsXG4gICdhcmlhLWJ1c3knOiAwLFxuICAnYXJpYS1saXZlJzogMCxcbiAgJ2FyaWEtcmVsZXZhbnQnOiAwLFxuICAvLyBEcmFnLWFuZC1Ecm9wIEF0dHJpYnV0ZXNcbiAgJ2FyaWEtZHJvcGVmZmVjdCc6IDAsXG4gICdhcmlhLWdyYWJiZWQnOiAwLFxuICAvLyBSZWxhdGlvbnNoaXAgQXR0cmlidXRlc1xuICAnYXJpYS1hY3RpdmVkZXNjZW5kYW50JzogMCxcbiAgJ2FyaWEtY29sY291bnQnOiAwLFxuICAnYXJpYS1jb2xpbmRleCc6IDAsXG4gICdhcmlhLWNvbHNwYW4nOiAwLFxuICAnYXJpYS1jb250cm9scyc6IDAsXG4gICdhcmlhLWRlc2NyaWJlZGJ5JzogMCxcbiAgJ2FyaWEtZXJyb3JtZXNzYWdlJzogMCxcbiAgJ2FyaWEtZmxvd3RvJzogMCxcbiAgJ2FyaWEtbGFiZWxsZWRieSc6IDAsXG4gICdhcmlhLW93bnMnOiAwLFxuICAnYXJpYS1wb3NpbnNldCc6IDAsXG4gICdhcmlhLXJvd2NvdW50JzogMCxcbiAgJ2FyaWEtcm93aW5kZXgnOiAwLFxuICAnYXJpYS1yb3dzcGFuJzogMCxcbiAgJ2FyaWEtc2V0c2l6ZSc6IDBcbn07XG5cbnZhciB3YXJuZWRQcm9wZXJ0aWVzID0ge307XG52YXIgckFSSUEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpLVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbnZhciByQVJJQUNhbWVsID0gbmV3IFJlZ0V4cCgnXihhcmlhKVtBLVpdWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xudmFyIGhhc093blByb3BlcnR5JDEgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnR5KHRhZ05hbWUsIG5hbWUpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSQxLmNhbGwod2FybmVkUHJvcGVydGllcywgbmFtZSkgJiYgd2FybmVkUHJvcGVydGllc1tuYW1lXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHJBUklBQ2FtZWwudGVzdChuYW1lKSkge1xuICAgICAgdmFyIGFyaWFOYW1lID0gJ2FyaWEtJyArIG5hbWUuc2xpY2UoNCkudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBjb3JyZWN0TmFtZSA9IGFyaWFQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGFyaWFOYW1lKSA/IGFyaWFOYW1lIDogbnVsbDsgLy8gSWYgdGhpcyBpcyBhbiBhcmlhLSogYXR0cmlidXRlLCBidXQgaXMgbm90IGxpc3RlZCBpbiB0aGUga25vd24gRE9NXG4gICAgICAvLyBET00gcHJvcGVydGllcywgdGhlbiBpdCBpcyBhbiBpbnZhbGlkIGFyaWEtKiBhdHRyaWJ1dGUuXG5cbiAgICAgIGlmIChjb3JyZWN0TmFtZSA9PSBudWxsKSB7XG4gICAgICAgIGVycm9yKCdJbnZhbGlkIEFSSUEgYXR0cmlidXRlIGAlc2AuIEFSSUEgYXR0cmlidXRlcyBmb2xsb3cgdGhlIHBhdHRlcm4gYXJpYS0qIGFuZCBtdXN0IGJlIGxvd2VyY2FzZS4nLCBuYW1lKTtcblxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IC8vIGFyaWEtKiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsb3dlcmNhc2U7IHN1Z2dlc3QgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uLlxuXG5cbiAgICAgIGlmIChuYW1lICE9PSBjb3JyZWN0TmFtZSkge1xuICAgICAgICBlcnJvcignSW52YWxpZCBBUklBIGF0dHJpYnV0ZSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8nLCBuYW1lLCBjb3JyZWN0TmFtZSk7XG5cbiAgICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyQVJJQS50ZXN0KG5hbWUpKSB7XG4gICAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgc3RhbmRhcmROYW1lID0gYXJpYVByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpID8gbG93ZXJDYXNlZE5hbWUgOiBudWxsOyAvLyBJZiB0aGlzIGlzIGFuIGFyaWEtKiBhdHRyaWJ1dGUsIGJ1dCBpcyBub3QgbGlzdGVkIGluIHRoZSBrbm93biBET01cbiAgICAgIC8vIERPTSBwcm9wZXJ0aWVzLCB0aGVuIGl0IGlzIGFuIGludmFsaWQgYXJpYS0qIGF0dHJpYnV0ZS5cblxuICAgICAgaWYgKHN0YW5kYXJkTmFtZSA9PSBudWxsKSB7XG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IC8vIGFyaWEtKiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsb3dlcmNhc2U7IHN1Z2dlc3QgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uLlxuXG5cbiAgICAgIGlmIChuYW1lICE9PSBzdGFuZGFyZE5hbWUpIHtcbiAgICAgICAgZXJyb3IoJ1Vua25vd24gQVJJQSBhdHRyaWJ1dGUgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JywgbmFtZSwgc3RhbmRhcmROYW1lKTtcblxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHdhcm5JbnZhbGlkQVJJQVByb3BzKHR5cGUsIHByb3BzKSB7XG4gIHtcbiAgICB2YXIgaW52YWxpZFByb3BzID0gW107XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIHZhciBpc1ZhbGlkID0gdmFsaWRhdGVQcm9wZXJ0eSh0eXBlLCBrZXkpO1xuXG4gICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgaW52YWxpZFByb3BzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdW5rbm93blByb3BTdHJpbmcgPSBpbnZhbGlkUHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICByZXR1cm4gJ2AnICsgcHJvcCArICdgJztcbiAgICB9KS5qb2luKCcsICcpO1xuXG4gICAgaWYgKGludmFsaWRQcm9wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGVycm9yKCdJbnZhbGlkIGFyaWEgcHJvcCAlcyBvbiA8JXM+IHRhZy4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9pbnZhbGlkLWFyaWEtcHJvcHMnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSk7XG4gICAgfSBlbHNlIGlmIChpbnZhbGlkUHJvcHMubGVuZ3RoID4gMSkge1xuICAgICAgZXJyb3IoJ0ludmFsaWQgYXJpYSBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9pbnZhbGlkLWFyaWEtcHJvcHMnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyh0eXBlLCBwcm9wcykge1xuICBpZiAoaXNDdXN0b21Db21wb25lbnQodHlwZSwgcHJvcHMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgd2FybkludmFsaWRBUklBUHJvcHModHlwZSwgcHJvcHMpO1xufVxuXG52YXIgZGlkV2FyblZhbHVlTnVsbCA9IGZhbHNlO1xuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzJDEodHlwZSwgcHJvcHMpIHtcbiAge1xuICAgIGlmICh0eXBlICE9PSAnaW5wdXQnICYmIHR5cGUgIT09ICd0ZXh0YXJlYScgJiYgdHlwZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcHMgIT0gbnVsbCAmJiBwcm9wcy52YWx1ZSA9PT0gbnVsbCAmJiAhZGlkV2FyblZhbHVlTnVsbCkge1xuICAgICAgZGlkV2FyblZhbHVlTnVsbCA9IHRydWU7XG5cbiAgICAgIGlmICh0eXBlID09PSAnc2VsZWN0JyAmJiBwcm9wcy5tdWx0aXBsZSkge1xuICAgICAgICBlcnJvcignYHZhbHVlYCBwcm9wIG9uIGAlc2Agc2hvdWxkIG5vdCBiZSBudWxsLiAnICsgJ0NvbnNpZGVyIHVzaW5nIGFuIGVtcHR5IGFycmF5IHdoZW4gYG11bHRpcGxlYCBpcyBzZXQgdG8gYHRydWVgICcgKyAndG8gY2xlYXIgdGhlIGNvbXBvbmVudCBvciBgdW5kZWZpbmVkYCBmb3IgdW5jb250cm9sbGVkIGNvbXBvbmVudHMuJywgdHlwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcignYHZhbHVlYCBwcm9wIG9uIGAlc2Agc2hvdWxkIG5vdCBiZSBudWxsLiAnICsgJ0NvbnNpZGVyIHVzaW5nIGFuIGVtcHR5IHN0cmluZyB0byBjbGVhciB0aGUgY29tcG9uZW50IG9yIGB1bmRlZmluZWRgICcgKyAnZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLicsIHR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBXaGVuIGFkZGluZyBhdHRyaWJ1dGVzIHRvIHRoZSBIVE1MIG9yIFNWRyBhbGxvd2VkIGF0dHJpYnV0ZSBsaXN0LCBiZSBzdXJlIHRvXG4vLyBhbHNvIGFkZCB0aGVtIHRvIHRoaXMgbW9kdWxlIHRvIGVuc3VyZSBjYXNpbmcgYW5kIGluY29ycmVjdCBuYW1lXG4vLyB3YXJuaW5ncy5cbnZhciBwb3NzaWJsZVN0YW5kYXJkTmFtZXMgPSB7XG4gIC8vIEhUTUxcbiAgYWNjZXB0OiAnYWNjZXB0JyxcbiAgYWNjZXB0Y2hhcnNldDogJ2FjY2VwdENoYXJzZXQnLFxuICAnYWNjZXB0LWNoYXJzZXQnOiAnYWNjZXB0Q2hhcnNldCcsXG4gIGFjY2Vzc2tleTogJ2FjY2Vzc0tleScsXG4gIGFjdGlvbjogJ2FjdGlvbicsXG4gIGFsbG93ZnVsbHNjcmVlbjogJ2FsbG93RnVsbFNjcmVlbicsXG4gIGFsdDogJ2FsdCcsXG4gIGFzOiAnYXMnLFxuICBhc3luYzogJ2FzeW5jJyxcbiAgYXV0b2NhcGl0YWxpemU6ICdhdXRvQ2FwaXRhbGl6ZScsXG4gIGF1dG9jb21wbGV0ZTogJ2F1dG9Db21wbGV0ZScsXG4gIGF1dG9jb3JyZWN0OiAnYXV0b0NvcnJlY3QnLFxuICBhdXRvZm9jdXM6ICdhdXRvRm9jdXMnLFxuICBhdXRvcGxheTogJ2F1dG9QbGF5JyxcbiAgYXV0b3NhdmU6ICdhdXRvU2F2ZScsXG4gIGNhcHR1cmU6ICdjYXB0dXJlJyxcbiAgY2VsbHBhZGRpbmc6ICdjZWxsUGFkZGluZycsXG4gIGNlbGxzcGFjaW5nOiAnY2VsbFNwYWNpbmcnLFxuICBjaGFsbGVuZ2U6ICdjaGFsbGVuZ2UnLFxuICBjaGFyc2V0OiAnY2hhclNldCcsXG4gIGNoZWNrZWQ6ICdjaGVja2VkJyxcbiAgY2hpbGRyZW46ICdjaGlsZHJlbicsXG4gIGNpdGU6ICdjaXRlJyxcbiAgY2xhc3M6ICdjbGFzc05hbWUnLFxuICBjbGFzc2lkOiAnY2xhc3NJRCcsXG4gIGNsYXNzbmFtZTogJ2NsYXNzTmFtZScsXG4gIGNvbHM6ICdjb2xzJyxcbiAgY29sc3BhbjogJ2NvbFNwYW4nLFxuICBjb250ZW50OiAnY29udGVudCcsXG4gIGNvbnRlbnRlZGl0YWJsZTogJ2NvbnRlbnRFZGl0YWJsZScsXG4gIGNvbnRleHRtZW51OiAnY29udGV4dE1lbnUnLFxuICBjb250cm9sczogJ2NvbnRyb2xzJyxcbiAgY29udHJvbHNsaXN0OiAnY29udHJvbHNMaXN0JyxcbiAgY29vcmRzOiAnY29vcmRzJyxcbiAgY3Jvc3NvcmlnaW46ICdjcm9zc09yaWdpbicsXG4gIGRhbmdlcm91c2x5c2V0aW5uZXJodG1sOiAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnLFxuICBkYXRhOiAnZGF0YScsXG4gIGRhdGV0aW1lOiAnZGF0ZVRpbWUnLFxuICBkZWZhdWx0OiAnZGVmYXVsdCcsXG4gIGRlZmF1bHRjaGVja2VkOiAnZGVmYXVsdENoZWNrZWQnLFxuICBkZWZhdWx0dmFsdWU6ICdkZWZhdWx0VmFsdWUnLFxuICBkZWZlcjogJ2RlZmVyJyxcbiAgZGlyOiAnZGlyJyxcbiAgZGlzYWJsZWQ6ICdkaXNhYmxlZCcsXG4gIGRpc2FibGVwaWN0dXJlaW5waWN0dXJlOiAnZGlzYWJsZVBpY3R1cmVJblBpY3R1cmUnLFxuICBkaXNhYmxlcmVtb3RlcGxheWJhY2s6ICdkaXNhYmxlUmVtb3RlUGxheWJhY2snLFxuICBkb3dubG9hZDogJ2Rvd25sb2FkJyxcbiAgZHJhZ2dhYmxlOiAnZHJhZ2dhYmxlJyxcbiAgZW5jdHlwZTogJ2VuY1R5cGUnLFxuICBlbnRlcmtleWhpbnQ6ICdlbnRlcktleUhpbnQnLFxuICBmb3I6ICdodG1sRm9yJyxcbiAgZm9ybTogJ2Zvcm0nLFxuICBmb3JtbWV0aG9kOiAnZm9ybU1ldGhvZCcsXG4gIGZvcm1hY3Rpb246ICdmb3JtQWN0aW9uJyxcbiAgZm9ybWVuY3R5cGU6ICdmb3JtRW5jVHlwZScsXG4gIGZvcm1ub3ZhbGlkYXRlOiAnZm9ybU5vVmFsaWRhdGUnLFxuICBmb3JtdGFyZ2V0OiAnZm9ybVRhcmdldCcsXG4gIGZyYW1lYm9yZGVyOiAnZnJhbWVCb3JkZXInLFxuICBoZWFkZXJzOiAnaGVhZGVycycsXG4gIGhlaWdodDogJ2hlaWdodCcsXG4gIGhpZGRlbjogJ2hpZGRlbicsXG4gIGhpZ2g6ICdoaWdoJyxcbiAgaHJlZjogJ2hyZWYnLFxuICBocmVmbGFuZzogJ2hyZWZMYW5nJyxcbiAgaHRtbGZvcjogJ2h0bWxGb3InLFxuICBodHRwZXF1aXY6ICdodHRwRXF1aXYnLFxuICAnaHR0cC1lcXVpdic6ICdodHRwRXF1aXYnLFxuICBpY29uOiAnaWNvbicsXG4gIGlkOiAnaWQnLFxuICBpbm5lcmh0bWw6ICdpbm5lckhUTUwnLFxuICBpbnB1dG1vZGU6ICdpbnB1dE1vZGUnLFxuICBpbnRlZ3JpdHk6ICdpbnRlZ3JpdHknLFxuICBpczogJ2lzJyxcbiAgaXRlbWlkOiAnaXRlbUlEJyxcbiAgaXRlbXByb3A6ICdpdGVtUHJvcCcsXG4gIGl0ZW1yZWY6ICdpdGVtUmVmJyxcbiAgaXRlbXNjb3BlOiAnaXRlbVNjb3BlJyxcbiAgaXRlbXR5cGU6ICdpdGVtVHlwZScsXG4gIGtleXBhcmFtczogJ2tleVBhcmFtcycsXG4gIGtleXR5cGU6ICdrZXlUeXBlJyxcbiAga2luZDogJ2tpbmQnLFxuICBsYWJlbDogJ2xhYmVsJyxcbiAgbGFuZzogJ2xhbmcnLFxuICBsaXN0OiAnbGlzdCcsXG4gIGxvb3A6ICdsb29wJyxcbiAgbG93OiAnbG93JyxcbiAgbWFuaWZlc3Q6ICdtYW5pZmVzdCcsXG4gIG1hcmdpbndpZHRoOiAnbWFyZ2luV2lkdGgnLFxuICBtYXJnaW5oZWlnaHQ6ICdtYXJnaW5IZWlnaHQnLFxuICBtYXg6ICdtYXgnLFxuICBtYXhsZW5ndGg6ICdtYXhMZW5ndGgnLFxuICBtZWRpYTogJ21lZGlhJyxcbiAgbWVkaWFncm91cDogJ21lZGlhR3JvdXAnLFxuICBtZXRob2Q6ICdtZXRob2QnLFxuICBtaW46ICdtaW4nLFxuICBtaW5sZW5ndGg6ICdtaW5MZW5ndGgnLFxuICBtdWx0aXBsZTogJ211bHRpcGxlJyxcbiAgbXV0ZWQ6ICdtdXRlZCcsXG4gIG5hbWU6ICduYW1lJyxcbiAgbm9tb2R1bGU6ICdub01vZHVsZScsXG4gIG5vbmNlOiAnbm9uY2UnLFxuICBub3ZhbGlkYXRlOiAnbm9WYWxpZGF0ZScsXG4gIG9wZW46ICdvcGVuJyxcbiAgb3B0aW11bTogJ29wdGltdW0nLFxuICBwYXR0ZXJuOiAncGF0dGVybicsXG4gIHBsYWNlaG9sZGVyOiAncGxhY2Vob2xkZXInLFxuICBwbGF5c2lubGluZTogJ3BsYXlzSW5saW5lJyxcbiAgcG9zdGVyOiAncG9zdGVyJyxcbiAgcHJlbG9hZDogJ3ByZWxvYWQnLFxuICBwcm9maWxlOiAncHJvZmlsZScsXG4gIHJhZGlvZ3JvdXA6ICdyYWRpb0dyb3VwJyxcbiAgcmVhZG9ubHk6ICdyZWFkT25seScsXG4gIHJlZmVycmVycG9saWN5OiAncmVmZXJyZXJQb2xpY3knLFxuICByZWw6ICdyZWwnLFxuICByZXF1aXJlZDogJ3JlcXVpcmVkJyxcbiAgcmV2ZXJzZWQ6ICdyZXZlcnNlZCcsXG4gIHJvbGU6ICdyb2xlJyxcbiAgcm93czogJ3Jvd3MnLFxuICByb3dzcGFuOiAncm93U3BhbicsXG4gIHNhbmRib3g6ICdzYW5kYm94JyxcbiAgc2NvcGU6ICdzY29wZScsXG4gIHNjb3BlZDogJ3Njb3BlZCcsXG4gIHNjcm9sbGluZzogJ3Njcm9sbGluZycsXG4gIHNlYW1sZXNzOiAnc2VhbWxlc3MnLFxuICBzZWxlY3RlZDogJ3NlbGVjdGVkJyxcbiAgc2hhcGU6ICdzaGFwZScsXG4gIHNpemU6ICdzaXplJyxcbiAgc2l6ZXM6ICdzaXplcycsXG4gIHNwYW46ICdzcGFuJyxcbiAgc3BlbGxjaGVjazogJ3NwZWxsQ2hlY2snLFxuICBzcmM6ICdzcmMnLFxuICBzcmNkb2M6ICdzcmNEb2MnLFxuICBzcmNsYW5nOiAnc3JjTGFuZycsXG4gIHNyY3NldDogJ3NyY1NldCcsXG4gIHN0YXJ0OiAnc3RhcnQnLFxuICBzdGVwOiAnc3RlcCcsXG4gIHN0eWxlOiAnc3R5bGUnLFxuICBzdW1tYXJ5OiAnc3VtbWFyeScsXG4gIHRhYmluZGV4OiAndGFiSW5kZXgnLFxuICB0YXJnZXQ6ICd0YXJnZXQnLFxuICB0aXRsZTogJ3RpdGxlJyxcbiAgdHlwZTogJ3R5cGUnLFxuICB1c2VtYXA6ICd1c2VNYXAnLFxuICB2YWx1ZTogJ3ZhbHVlJyxcbiAgd2lkdGg6ICd3aWR0aCcsXG4gIHdtb2RlOiAnd21vZGUnLFxuICB3cmFwOiAnd3JhcCcsXG4gIC8vIFNWR1xuICBhYm91dDogJ2Fib3V0JyxcbiAgYWNjZW50aGVpZ2h0OiAnYWNjZW50SGVpZ2h0JyxcbiAgJ2FjY2VudC1oZWlnaHQnOiAnYWNjZW50SGVpZ2h0JyxcbiAgYWNjdW11bGF0ZTogJ2FjY3VtdWxhdGUnLFxuICBhZGRpdGl2ZTogJ2FkZGl0aXZlJyxcbiAgYWxpZ25tZW50YmFzZWxpbmU6ICdhbGlnbm1lbnRCYXNlbGluZScsXG4gICdhbGlnbm1lbnQtYmFzZWxpbmUnOiAnYWxpZ25tZW50QmFzZWxpbmUnLFxuICBhbGxvd3Jlb3JkZXI6ICdhbGxvd1Jlb3JkZXInLFxuICBhbHBoYWJldGljOiAnYWxwaGFiZXRpYycsXG4gIGFtcGxpdHVkZTogJ2FtcGxpdHVkZScsXG4gIGFyYWJpY2Zvcm06ICdhcmFiaWNGb3JtJyxcbiAgJ2FyYWJpYy1mb3JtJzogJ2FyYWJpY0Zvcm0nLFxuICBhc2NlbnQ6ICdhc2NlbnQnLFxuICBhdHRyaWJ1dGVuYW1lOiAnYXR0cmlidXRlTmFtZScsXG4gIGF0dHJpYnV0ZXR5cGU6ICdhdHRyaWJ1dGVUeXBlJyxcbiAgYXV0b3JldmVyc2U6ICdhdXRvUmV2ZXJzZScsXG4gIGF6aW11dGg6ICdhemltdXRoJyxcbiAgYmFzZWZyZXF1ZW5jeTogJ2Jhc2VGcmVxdWVuY3knLFxuICBiYXNlbGluZXNoaWZ0OiAnYmFzZWxpbmVTaGlmdCcsXG4gICdiYXNlbGluZS1zaGlmdCc6ICdiYXNlbGluZVNoaWZ0JyxcbiAgYmFzZXByb2ZpbGU6ICdiYXNlUHJvZmlsZScsXG4gIGJib3g6ICdiYm94JyxcbiAgYmVnaW46ICdiZWdpbicsXG4gIGJpYXM6ICdiaWFzJyxcbiAgYnk6ICdieScsXG4gIGNhbGNtb2RlOiAnY2FsY01vZGUnLFxuICBjYXBoZWlnaHQ6ICdjYXBIZWlnaHQnLFxuICAnY2FwLWhlaWdodCc6ICdjYXBIZWlnaHQnLFxuICBjbGlwOiAnY2xpcCcsXG4gIGNsaXBwYXRoOiAnY2xpcFBhdGgnLFxuICAnY2xpcC1wYXRoJzogJ2NsaXBQYXRoJyxcbiAgY2xpcHBhdGh1bml0czogJ2NsaXBQYXRoVW5pdHMnLFxuICBjbGlwcnVsZTogJ2NsaXBSdWxlJyxcbiAgJ2NsaXAtcnVsZSc6ICdjbGlwUnVsZScsXG4gIGNvbG9yOiAnY29sb3InLFxuICBjb2xvcmludGVycG9sYXRpb246ICdjb2xvckludGVycG9sYXRpb24nLFxuICAnY29sb3ItaW50ZXJwb2xhdGlvbic6ICdjb2xvckludGVycG9sYXRpb24nLFxuICBjb2xvcmludGVycG9sYXRpb25maWx0ZXJzOiAnY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVycycsXG4gICdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnOiAnY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVycycsXG4gIGNvbG9ycHJvZmlsZTogJ2NvbG9yUHJvZmlsZScsXG4gICdjb2xvci1wcm9maWxlJzogJ2NvbG9yUHJvZmlsZScsXG4gIGNvbG9ycmVuZGVyaW5nOiAnY29sb3JSZW5kZXJpbmcnLFxuICAnY29sb3ItcmVuZGVyaW5nJzogJ2NvbG9yUmVuZGVyaW5nJyxcbiAgY29udGVudHNjcmlwdHR5cGU6ICdjb250ZW50U2NyaXB0VHlwZScsXG4gIGNvbnRlbnRzdHlsZXR5cGU6ICdjb250ZW50U3R5bGVUeXBlJyxcbiAgY3Vyc29yOiAnY3Vyc29yJyxcbiAgY3g6ICdjeCcsXG4gIGN5OiAnY3knLFxuICBkOiAnZCcsXG4gIGRhdGF0eXBlOiAnZGF0YXR5cGUnLFxuICBkZWNlbGVyYXRlOiAnZGVjZWxlcmF0ZScsXG4gIGRlc2NlbnQ6ICdkZXNjZW50JyxcbiAgZGlmZnVzZWNvbnN0YW50OiAnZGlmZnVzZUNvbnN0YW50JyxcbiAgZGlyZWN0aW9uOiAnZGlyZWN0aW9uJyxcbiAgZGlzcGxheTogJ2Rpc3BsYXknLFxuICBkaXZpc29yOiAnZGl2aXNvcicsXG4gIGRvbWluYW50YmFzZWxpbmU6ICdkb21pbmFudEJhc2VsaW5lJyxcbiAgJ2RvbWluYW50LWJhc2VsaW5lJzogJ2RvbWluYW50QmFzZWxpbmUnLFxuICBkdXI6ICdkdXInLFxuICBkeDogJ2R4JyxcbiAgZHk6ICdkeScsXG4gIGVkZ2Vtb2RlOiAnZWRnZU1vZGUnLFxuICBlbGV2YXRpb246ICdlbGV2YXRpb24nLFxuICBlbmFibGViYWNrZ3JvdW5kOiAnZW5hYmxlQmFja2dyb3VuZCcsXG4gICdlbmFibGUtYmFja2dyb3VuZCc6ICdlbmFibGVCYWNrZ3JvdW5kJyxcbiAgZW5kOiAnZW5kJyxcbiAgZXhwb25lbnQ6ICdleHBvbmVudCcsXG4gIGV4dGVybmFscmVzb3VyY2VzcmVxdWlyZWQ6ICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJyxcbiAgZmlsbDogJ2ZpbGwnLFxuICBmaWxsb3BhY2l0eTogJ2ZpbGxPcGFjaXR5JyxcbiAgJ2ZpbGwtb3BhY2l0eSc6ICdmaWxsT3BhY2l0eScsXG4gIGZpbGxydWxlOiAnZmlsbFJ1bGUnLFxuICAnZmlsbC1ydWxlJzogJ2ZpbGxSdWxlJyxcbiAgZmlsdGVyOiAnZmlsdGVyJyxcbiAgZmlsdGVycmVzOiAnZmlsdGVyUmVzJyxcbiAgZmlsdGVydW5pdHM6ICdmaWx0ZXJVbml0cycsXG4gIGZsb29kb3BhY2l0eTogJ2Zsb29kT3BhY2l0eScsXG4gICdmbG9vZC1vcGFjaXR5JzogJ2Zsb29kT3BhY2l0eScsXG4gIGZsb29kY29sb3I6ICdmbG9vZENvbG9yJyxcbiAgJ2Zsb29kLWNvbG9yJzogJ2Zsb29kQ29sb3InLFxuICBmb2N1c2FibGU6ICdmb2N1c2FibGUnLFxuICBmb250ZmFtaWx5OiAnZm9udEZhbWlseScsXG4gICdmb250LWZhbWlseSc6ICdmb250RmFtaWx5JyxcbiAgZm9udHNpemU6ICdmb250U2l6ZScsXG4gICdmb250LXNpemUnOiAnZm9udFNpemUnLFxuICBmb250c2l6ZWFkanVzdDogJ2ZvbnRTaXplQWRqdXN0JyxcbiAgJ2ZvbnQtc2l6ZS1hZGp1c3QnOiAnZm9udFNpemVBZGp1c3QnLFxuICBmb250c3RyZXRjaDogJ2ZvbnRTdHJldGNoJyxcbiAgJ2ZvbnQtc3RyZXRjaCc6ICdmb250U3RyZXRjaCcsXG4gIGZvbnRzdHlsZTogJ2ZvbnRTdHlsZScsXG4gICdmb250LXN0eWxlJzogJ2ZvbnRTdHlsZScsXG4gIGZvbnR2YXJpYW50OiAnZm9udFZhcmlhbnQnLFxuICAnZm9udC12YXJpYW50JzogJ2ZvbnRWYXJpYW50JyxcbiAgZm9udHdlaWdodDogJ2ZvbnRXZWlnaHQnLFxuICAnZm9udC13ZWlnaHQnOiAnZm9udFdlaWdodCcsXG4gIGZvcm1hdDogJ2Zvcm1hdCcsXG4gIGZyb206ICdmcm9tJyxcbiAgZng6ICdmeCcsXG4gIGZ5OiAnZnknLFxuICBnMTogJ2cxJyxcbiAgZzI6ICdnMicsXG4gIGdseXBobmFtZTogJ2dseXBoTmFtZScsXG4gICdnbHlwaC1uYW1lJzogJ2dseXBoTmFtZScsXG4gIGdseXBob3JpZW50YXRpb25ob3Jpem9udGFsOiAnZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWwnLFxuICAnZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCc6ICdnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbCcsXG4gIGdseXBob3JpZW50YXRpb252ZXJ0aWNhbDogJ2dseXBoT3JpZW50YXRpb25WZXJ0aWNhbCcsXG4gICdnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCc6ICdnbHlwaE9yaWVudGF0aW9uVmVydGljYWwnLFxuICBnbHlwaHJlZjogJ2dseXBoUmVmJyxcbiAgZ3JhZGllbnR0cmFuc2Zvcm06ICdncmFkaWVudFRyYW5zZm9ybScsXG4gIGdyYWRpZW50dW5pdHM6ICdncmFkaWVudFVuaXRzJyxcbiAgaGFuZ2luZzogJ2hhbmdpbmcnLFxuICBob3JpemFkdng6ICdob3JpekFkdlgnLFxuICAnaG9yaXotYWR2LXgnOiAnaG9yaXpBZHZYJyxcbiAgaG9yaXpvcmlnaW54OiAnaG9yaXpPcmlnaW5YJyxcbiAgJ2hvcml6LW9yaWdpbi14JzogJ2hvcml6T3JpZ2luWCcsXG4gIGlkZW9ncmFwaGljOiAnaWRlb2dyYXBoaWMnLFxuICBpbWFnZXJlbmRlcmluZzogJ2ltYWdlUmVuZGVyaW5nJyxcbiAgJ2ltYWdlLXJlbmRlcmluZyc6ICdpbWFnZVJlbmRlcmluZycsXG4gIGluMjogJ2luMicsXG4gIGluOiAnaW4nLFxuICBpbmxpc3Q6ICdpbmxpc3QnLFxuICBpbnRlcmNlcHQ6ICdpbnRlcmNlcHQnLFxuICBrMTogJ2sxJyxcbiAgazI6ICdrMicsXG4gIGszOiAnazMnLFxuICBrNDogJ2s0JyxcbiAgazogJ2snLFxuICBrZXJuZWxtYXRyaXg6ICdrZXJuZWxNYXRyaXgnLFxuICBrZXJuZWx1bml0bGVuZ3RoOiAna2VybmVsVW5pdExlbmd0aCcsXG4gIGtlcm5pbmc6ICdrZXJuaW5nJyxcbiAga2V5cG9pbnRzOiAna2V5UG9pbnRzJyxcbiAga2V5c3BsaW5lczogJ2tleVNwbGluZXMnLFxuICBrZXl0aW1lczogJ2tleVRpbWVzJyxcbiAgbGVuZ3RoYWRqdXN0OiAnbGVuZ3RoQWRqdXN0JyxcbiAgbGV0dGVyc3BhY2luZzogJ2xldHRlclNwYWNpbmcnLFxuICAnbGV0dGVyLXNwYWNpbmcnOiAnbGV0dGVyU3BhY2luZycsXG4gIGxpZ2h0aW5nY29sb3I6ICdsaWdodGluZ0NvbG9yJyxcbiAgJ2xpZ2h0aW5nLWNvbG9yJzogJ2xpZ2h0aW5nQ29sb3InLFxuICBsaW1pdGluZ2NvbmVhbmdsZTogJ2xpbWl0aW5nQ29uZUFuZ2xlJyxcbiAgbG9jYWw6ICdsb2NhbCcsXG4gIG1hcmtlcmVuZDogJ21hcmtlckVuZCcsXG4gICdtYXJrZXItZW5kJzogJ21hcmtlckVuZCcsXG4gIG1hcmtlcmhlaWdodDogJ21hcmtlckhlaWdodCcsXG4gIG1hcmtlcm1pZDogJ21hcmtlck1pZCcsXG4gICdtYXJrZXItbWlkJzogJ21hcmtlck1pZCcsXG4gIG1hcmtlcnN0YXJ0OiAnbWFya2VyU3RhcnQnLFxuICAnbWFya2VyLXN0YXJ0JzogJ21hcmtlclN0YXJ0JyxcbiAgbWFya2VydW5pdHM6ICdtYXJrZXJVbml0cycsXG4gIG1hcmtlcndpZHRoOiAnbWFya2VyV2lkdGgnLFxuICBtYXNrOiAnbWFzaycsXG4gIG1hc2tjb250ZW50dW5pdHM6ICdtYXNrQ29udGVudFVuaXRzJyxcbiAgbWFza3VuaXRzOiAnbWFza1VuaXRzJyxcbiAgbWF0aGVtYXRpY2FsOiAnbWF0aGVtYXRpY2FsJyxcbiAgbW9kZTogJ21vZGUnLFxuICBudW1vY3RhdmVzOiAnbnVtT2N0YXZlcycsXG4gIG9mZnNldDogJ29mZnNldCcsXG4gIG9wYWNpdHk6ICdvcGFjaXR5JyxcbiAgb3BlcmF0b3I6ICdvcGVyYXRvcicsXG4gIG9yZGVyOiAnb3JkZXInLFxuICBvcmllbnQ6ICdvcmllbnQnLFxuICBvcmllbnRhdGlvbjogJ29yaWVudGF0aW9uJyxcbiAgb3JpZ2luOiAnb3JpZ2luJyxcbiAgb3ZlcmZsb3c6ICdvdmVyZmxvdycsXG4gIG92ZXJsaW5lcG9zaXRpb246ICdvdmVybGluZVBvc2l0aW9uJyxcbiAgJ292ZXJsaW5lLXBvc2l0aW9uJzogJ292ZXJsaW5lUG9zaXRpb24nLFxuICBvdmVybGluZXRoaWNrbmVzczogJ292ZXJsaW5lVGhpY2tuZXNzJyxcbiAgJ292ZXJsaW5lLXRoaWNrbmVzcyc6ICdvdmVybGluZVRoaWNrbmVzcycsXG4gIHBhaW50b3JkZXI6ICdwYWludE9yZGVyJyxcbiAgJ3BhaW50LW9yZGVyJzogJ3BhaW50T3JkZXInLFxuICBwYW5vc2UxOiAncGFub3NlMScsXG4gICdwYW5vc2UtMSc6ICdwYW5vc2UxJyxcbiAgcGF0aGxlbmd0aDogJ3BhdGhMZW5ndGgnLFxuICBwYXR0ZXJuY29udGVudHVuaXRzOiAncGF0dGVybkNvbnRlbnRVbml0cycsXG4gIHBhdHRlcm50cmFuc2Zvcm06ICdwYXR0ZXJuVHJhbnNmb3JtJyxcbiAgcGF0dGVybnVuaXRzOiAncGF0dGVyblVuaXRzJyxcbiAgcG9pbnRlcmV2ZW50czogJ3BvaW50ZXJFdmVudHMnLFxuICAncG9pbnRlci1ldmVudHMnOiAncG9pbnRlckV2ZW50cycsXG4gIHBvaW50czogJ3BvaW50cycsXG4gIHBvaW50c2F0eDogJ3BvaW50c0F0WCcsXG4gIHBvaW50c2F0eTogJ3BvaW50c0F0WScsXG4gIHBvaW50c2F0ejogJ3BvaW50c0F0WicsXG4gIHByZWZpeDogJ3ByZWZpeCcsXG4gIHByZXNlcnZlYWxwaGE6ICdwcmVzZXJ2ZUFscGhhJyxcbiAgcHJlc2VydmVhc3BlY3RyYXRpbzogJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLFxuICBwcmltaXRpdmV1bml0czogJ3ByaW1pdGl2ZVVuaXRzJyxcbiAgcHJvcGVydHk6ICdwcm9wZXJ0eScsXG4gIHI6ICdyJyxcbiAgcmFkaXVzOiAncmFkaXVzJyxcbiAgcmVmeDogJ3JlZlgnLFxuICByZWZ5OiAncmVmWScsXG4gIHJlbmRlcmluZ2ludGVudDogJ3JlbmRlcmluZ0ludGVudCcsXG4gICdyZW5kZXJpbmctaW50ZW50JzogJ3JlbmRlcmluZ0ludGVudCcsXG4gIHJlcGVhdGNvdW50OiAncmVwZWF0Q291bnQnLFxuICByZXBlYXRkdXI6ICdyZXBlYXREdXInLFxuICByZXF1aXJlZGV4dGVuc2lvbnM6ICdyZXF1aXJlZEV4dGVuc2lvbnMnLFxuICByZXF1aXJlZGZlYXR1cmVzOiAncmVxdWlyZWRGZWF0dXJlcycsXG4gIHJlc291cmNlOiAncmVzb3VyY2UnLFxuICByZXN0YXJ0OiAncmVzdGFydCcsXG4gIHJlc3VsdDogJ3Jlc3VsdCcsXG4gIHJlc3VsdHM6ICdyZXN1bHRzJyxcbiAgcm90YXRlOiAncm90YXRlJyxcbiAgcng6ICdyeCcsXG4gIHJ5OiAncnknLFxuICBzY2FsZTogJ3NjYWxlJyxcbiAgc2VjdXJpdHk6ICdzZWN1cml0eScsXG4gIHNlZWQ6ICdzZWVkJyxcbiAgc2hhcGVyZW5kZXJpbmc6ICdzaGFwZVJlbmRlcmluZycsXG4gICdzaGFwZS1yZW5kZXJpbmcnOiAnc2hhcGVSZW5kZXJpbmcnLFxuICBzbG9wZTogJ3Nsb3BlJyxcbiAgc3BhY2luZzogJ3NwYWNpbmcnLFxuICBzcGVjdWxhcmNvbnN0YW50OiAnc3BlY3VsYXJDb25zdGFudCcsXG4gIHNwZWN1bGFyZXhwb25lbnQ6ICdzcGVjdWxhckV4cG9uZW50JyxcbiAgc3BlZWQ6ICdzcGVlZCcsXG4gIHNwcmVhZG1ldGhvZDogJ3NwcmVhZE1ldGhvZCcsXG4gIHN0YXJ0b2Zmc2V0OiAnc3RhcnRPZmZzZXQnLFxuICBzdGRkZXZpYXRpb246ICdzdGREZXZpYXRpb24nLFxuICBzdGVtaDogJ3N0ZW1oJyxcbiAgc3RlbXY6ICdzdGVtdicsXG4gIHN0aXRjaHRpbGVzOiAnc3RpdGNoVGlsZXMnLFxuICBzdG9wY29sb3I6ICdzdG9wQ29sb3InLFxuICAnc3RvcC1jb2xvcic6ICdzdG9wQ29sb3InLFxuICBzdG9wb3BhY2l0eTogJ3N0b3BPcGFjaXR5JyxcbiAgJ3N0b3Atb3BhY2l0eSc6ICdzdG9wT3BhY2l0eScsXG4gIHN0cmlrZXRocm91Z2hwb3NpdGlvbjogJ3N0cmlrZXRocm91Z2hQb3NpdGlvbicsXG4gICdzdHJpa2V0aHJvdWdoLXBvc2l0aW9uJzogJ3N0cmlrZXRocm91Z2hQb3NpdGlvbicsXG4gIHN0cmlrZXRocm91Z2h0aGlja25lc3M6ICdzdHJpa2V0aHJvdWdoVGhpY2tuZXNzJyxcbiAgJ3N0cmlrZXRocm91Z2gtdGhpY2tuZXNzJzogJ3N0cmlrZXRocm91Z2hUaGlja25lc3MnLFxuICBzdHJpbmc6ICdzdHJpbmcnLFxuICBzdHJva2U6ICdzdHJva2UnLFxuICBzdHJva2VkYXNoYXJyYXk6ICdzdHJva2VEYXNoYXJyYXknLFxuICAnc3Ryb2tlLWRhc2hhcnJheSc6ICdzdHJva2VEYXNoYXJyYXknLFxuICBzdHJva2VkYXNob2Zmc2V0OiAnc3Ryb2tlRGFzaG9mZnNldCcsXG4gICdzdHJva2UtZGFzaG9mZnNldCc6ICdzdHJva2VEYXNob2Zmc2V0JyxcbiAgc3Ryb2tlbGluZWNhcDogJ3N0cm9rZUxpbmVjYXAnLFxuICAnc3Ryb2tlLWxpbmVjYXAnOiAnc3Ryb2tlTGluZWNhcCcsXG4gIHN0cm9rZWxpbmVqb2luOiAnc3Ryb2tlTGluZWpvaW4nLFxuICAnc3Ryb2tlLWxpbmVqb2luJzogJ3N0cm9rZUxpbmVqb2luJyxcbiAgc3Ryb2tlbWl0ZXJsaW1pdDogJ3N0cm9rZU1pdGVybGltaXQnLFxuICAnc3Ryb2tlLW1pdGVybGltaXQnOiAnc3Ryb2tlTWl0ZXJsaW1pdCcsXG4gIHN0cm9rZXdpZHRoOiAnc3Ryb2tlV2lkdGgnLFxuICAnc3Ryb2tlLXdpZHRoJzogJ3N0cm9rZVdpZHRoJyxcbiAgc3Ryb2tlb3BhY2l0eTogJ3N0cm9rZU9wYWNpdHknLFxuICAnc3Ryb2tlLW9wYWNpdHknOiAnc3Ryb2tlT3BhY2l0eScsXG4gIHN1cHByZXNzY29udGVudGVkaXRhYmxld2FybmluZzogJ3N1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZycsXG4gIHN1cHByZXNzaHlkcmF0aW9ud2FybmluZzogJ3N1cHByZXNzSHlkcmF0aW9uV2FybmluZycsXG4gIHN1cmZhY2VzY2FsZTogJ3N1cmZhY2VTY2FsZScsXG4gIHN5c3RlbWxhbmd1YWdlOiAnc3lzdGVtTGFuZ3VhZ2UnLFxuICB0YWJsZXZhbHVlczogJ3RhYmxlVmFsdWVzJyxcbiAgdGFyZ2V0eDogJ3RhcmdldFgnLFxuICB0YXJnZXR5OiAndGFyZ2V0WScsXG4gIHRleHRhbmNob3I6ICd0ZXh0QW5jaG9yJyxcbiAgJ3RleHQtYW5jaG9yJzogJ3RleHRBbmNob3InLFxuICB0ZXh0ZGVjb3JhdGlvbjogJ3RleHREZWNvcmF0aW9uJyxcbiAgJ3RleHQtZGVjb3JhdGlvbic6ICd0ZXh0RGVjb3JhdGlvbicsXG4gIHRleHRsZW5ndGg6ICd0ZXh0TGVuZ3RoJyxcbiAgdGV4dHJlbmRlcmluZzogJ3RleHRSZW5kZXJpbmcnLFxuICAndGV4dC1yZW5kZXJpbmcnOiAndGV4dFJlbmRlcmluZycsXG4gIHRvOiAndG8nLFxuICB0cmFuc2Zvcm06ICd0cmFuc2Zvcm0nLFxuICB0eXBlb2Y6ICd0eXBlb2YnLFxuICB1MTogJ3UxJyxcbiAgdTI6ICd1MicsXG4gIHVuZGVybGluZXBvc2l0aW9uOiAndW5kZXJsaW5lUG9zaXRpb24nLFxuICAndW5kZXJsaW5lLXBvc2l0aW9uJzogJ3VuZGVybGluZVBvc2l0aW9uJyxcbiAgdW5kZXJsaW5ldGhpY2tuZXNzOiAndW5kZXJsaW5lVGhpY2tuZXNzJyxcbiAgJ3VuZGVybGluZS10aGlja25lc3MnOiAndW5kZXJsaW5lVGhpY2tuZXNzJyxcbiAgdW5pY29kZTogJ3VuaWNvZGUnLFxuICB1bmljb2RlYmlkaTogJ3VuaWNvZGVCaWRpJyxcbiAgJ3VuaWNvZGUtYmlkaSc6ICd1bmljb2RlQmlkaScsXG4gIHVuaWNvZGVyYW5nZTogJ3VuaWNvZGVSYW5nZScsXG4gICd1bmljb2RlLXJhbmdlJzogJ3VuaWNvZGVSYW5nZScsXG4gIHVuaXRzcGVyZW06ICd1bml0c1BlckVtJyxcbiAgJ3VuaXRzLXBlci1lbSc6ICd1bml0c1BlckVtJyxcbiAgdW5zZWxlY3RhYmxlOiAndW5zZWxlY3RhYmxlJyxcbiAgdmFscGhhYmV0aWM6ICd2QWxwaGFiZXRpYycsXG4gICd2LWFscGhhYmV0aWMnOiAndkFscGhhYmV0aWMnLFxuICB2YWx1ZXM6ICd2YWx1ZXMnLFxuICB2ZWN0b3JlZmZlY3Q6ICd2ZWN0b3JFZmZlY3QnLFxuICAndmVjdG9yLWVmZmVjdCc6ICd2ZWN0b3JFZmZlY3QnLFxuICB2ZXJzaW9uOiAndmVyc2lvbicsXG4gIHZlcnRhZHZ5OiAndmVydEFkdlknLFxuICAndmVydC1hZHYteSc6ICd2ZXJ0QWR2WScsXG4gIHZlcnRvcmlnaW54OiAndmVydE9yaWdpblgnLFxuICAndmVydC1vcmlnaW4teCc6ICd2ZXJ0T3JpZ2luWCcsXG4gIHZlcnRvcmlnaW55OiAndmVydE9yaWdpblknLFxuICAndmVydC1vcmlnaW4teSc6ICd2ZXJ0T3JpZ2luWScsXG4gIHZoYW5naW5nOiAndkhhbmdpbmcnLFxuICAndi1oYW5naW5nJzogJ3ZIYW5naW5nJyxcbiAgdmlkZW9ncmFwaGljOiAndklkZW9ncmFwaGljJyxcbiAgJ3YtaWRlb2dyYXBoaWMnOiAndklkZW9ncmFwaGljJyxcbiAgdmlld2JveDogJ3ZpZXdCb3gnLFxuICB2aWV3dGFyZ2V0OiAndmlld1RhcmdldCcsXG4gIHZpc2liaWxpdHk6ICd2aXNpYmlsaXR5JyxcbiAgdm1hdGhlbWF0aWNhbDogJ3ZNYXRoZW1hdGljYWwnLFxuICAndi1tYXRoZW1hdGljYWwnOiAndk1hdGhlbWF0aWNhbCcsXG4gIHZvY2FiOiAndm9jYWInLFxuICB3aWR0aHM6ICd3aWR0aHMnLFxuICB3b3Jkc3BhY2luZzogJ3dvcmRTcGFjaW5nJyxcbiAgJ3dvcmQtc3BhY2luZyc6ICd3b3JkU3BhY2luZycsXG4gIHdyaXRpbmdtb2RlOiAnd3JpdGluZ01vZGUnLFxuICAnd3JpdGluZy1tb2RlJzogJ3dyaXRpbmdNb2RlJyxcbiAgeDE6ICd4MScsXG4gIHgyOiAneDInLFxuICB4OiAneCcsXG4gIHhjaGFubmVsc2VsZWN0b3I6ICd4Q2hhbm5lbFNlbGVjdG9yJyxcbiAgeGhlaWdodDogJ3hIZWlnaHQnLFxuICAneC1oZWlnaHQnOiAneEhlaWdodCcsXG4gIHhsaW5rYWN0dWF0ZTogJ3hsaW5rQWN0dWF0ZScsXG4gICd4bGluazphY3R1YXRlJzogJ3hsaW5rQWN0dWF0ZScsXG4gIHhsaW5rYXJjcm9sZTogJ3hsaW5rQXJjcm9sZScsXG4gICd4bGluazphcmNyb2xlJzogJ3hsaW5rQXJjcm9sZScsXG4gIHhsaW5raHJlZjogJ3hsaW5rSHJlZicsXG4gICd4bGluazpocmVmJzogJ3hsaW5rSHJlZicsXG4gIHhsaW5rcm9sZTogJ3hsaW5rUm9sZScsXG4gICd4bGluazpyb2xlJzogJ3hsaW5rUm9sZScsXG4gIHhsaW5rc2hvdzogJ3hsaW5rU2hvdycsXG4gICd4bGluazpzaG93JzogJ3hsaW5rU2hvdycsXG4gIHhsaW5rdGl0bGU6ICd4bGlua1RpdGxlJyxcbiAgJ3hsaW5rOnRpdGxlJzogJ3hsaW5rVGl0bGUnLFxuICB4bGlua3R5cGU6ICd4bGlua1R5cGUnLFxuICAneGxpbms6dHlwZSc6ICd4bGlua1R5cGUnLFxuICB4bWxiYXNlOiAneG1sQmFzZScsXG4gICd4bWw6YmFzZSc6ICd4bWxCYXNlJyxcbiAgeG1sbGFuZzogJ3htbExhbmcnLFxuICAneG1sOmxhbmcnOiAneG1sTGFuZycsXG4gIHhtbG5zOiAneG1sbnMnLFxuICAneG1sOnNwYWNlJzogJ3htbFNwYWNlJyxcbiAgeG1sbnN4bGluazogJ3htbG5zWGxpbmsnLFxuICAneG1sbnM6eGxpbmsnOiAneG1sbnNYbGluaycsXG4gIHhtbHNwYWNlOiAneG1sU3BhY2UnLFxuICB5MTogJ3kxJyxcbiAgeTI6ICd5MicsXG4gIHk6ICd5JyxcbiAgeWNoYW5uZWxzZWxlY3RvcjogJ3lDaGFubmVsU2VsZWN0b3InLFxuICB6OiAneicsXG4gIHpvb21hbmRwYW46ICd6b29tQW5kUGFuJ1xufTtcblxudmFyIHZhbGlkYXRlUHJvcGVydHkkMSA9IGZ1bmN0aW9uICgpIHt9O1xuXG57XG4gIHZhciB3YXJuZWRQcm9wZXJ0aWVzJDEgPSB7fTtcbiAgdmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gIHZhciBFVkVOVF9OQU1FX1JFR0VYID0gL15vbi4vO1xuICB2YXIgSU5WQUxJRF9FVkVOVF9OQU1FX1JFR0VYID0gL15vblteQS1aXS87XG4gIHZhciByQVJJQSQxID0gbmV3IFJlZ0V4cCgnXihhcmlhKS1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG4gIHZhciByQVJJQUNhbWVsJDEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpW0EtWl1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG5cbiAgdmFsaWRhdGVQcm9wZXJ0eSQxID0gZnVuY3Rpb24gKHRhZ05hbWUsIG5hbWUsIHZhbHVlLCBldmVudFJlZ2lzdHJ5KSB7XG4gICAgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKHdhcm5lZFByb3BlcnRpZXMkMSwgbmFtZSkgJiYgd2FybmVkUHJvcGVydGllcyQxW25hbWVdKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdvbmZvY3VzaW4nIHx8IGxvd2VyQ2FzZWROYW1lID09PSAnb25mb2N1c291dCcpIHtcbiAgICAgIGVycm9yKCdSZWFjdCB1c2VzIG9uRm9jdXMgYW5kIG9uQmx1ciBpbnN0ZWFkIG9mIG9uRm9jdXNJbiBhbmQgb25Gb2N1c091dC4gJyArICdBbGwgUmVhY3QgZXZlbnRzIGFyZSBub3JtYWxpemVkIHRvIGJ1YmJsZSwgc28gb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0ICcgKyAnYXJlIG5vdCBuZWVkZWQvc3VwcG9ydGVkIGJ5IFJlYWN0LicpO1xuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBXZSBjYW4ndCByZWx5IG9uIHRoZSBldmVudCBzeXN0ZW0gYmVpbmcgaW5qZWN0ZWQgb24gdGhlIHNlcnZlci5cblxuXG4gICAgaWYgKGV2ZW50UmVnaXN0cnkgIT0gbnVsbCkge1xuICAgICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMgPSBldmVudFJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMsXG4gICAgICAgICAgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyA9IGV2ZW50UmVnaXN0cnkucG9zc2libGVSZWdpc3RyYXRpb25OYW1lcztcblxuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWdpc3RyYXRpb25OYW1lID0gcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkgPyBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzW2xvd2VyQ2FzZWROYW1lXSA6IG51bGw7XG5cbiAgICAgIGlmIChyZWdpc3RyYXRpb25OYW1lICE9IG51bGwpIHtcbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8nLCBuYW1lLCByZWdpc3RyYXRpb25OYW1lKTtcblxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKEVWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSkge1xuICAgICAgICBlcnJvcignVW5rbm93biBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuIEl0IHdpbGwgYmUgaWdub3JlZC4nLCBuYW1lKTtcblxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKEVWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSkge1xuICAgICAgLy8gSWYgbm8gZXZlbnQgcGx1Z2lucyBoYXZlIGJlZW4gaW5qZWN0ZWQsIHdlIGFyZSBpbiBhIHNlcnZlciBlbnZpcm9ubWVudC5cbiAgICAgIC8vIFNvIHdlIGNhbid0IHRlbGwgaWYgdGhlIGV2ZW50IG5hbWUgaXMgY29ycmVjdCBmb3Igc3VyZSwgYnV0IHdlIGNhbiBmaWx0ZXJcbiAgICAgIC8vIG91dCBrbm93biBiYWQgb25lcyBsaWtlIGBvbmNsaWNrYC4gV2UgY2FuJ3Qgc3VnZ2VzdCBhIHNwZWNpZmljIHJlcGxhY2VtZW50IHRob3VnaC5cbiAgICAgIGlmIChJTlZBTElEX0VWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSkge1xuICAgICAgICBlcnJvcignSW52YWxpZCBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuICcgKyAnUmVhY3QgZXZlbnRzIHVzZSB0aGUgY2FtZWxDYXNlIG5hbWluZyBjb252ZW50aW9uLCBmb3IgZXhhbXBsZSBgb25DbGlja2AuJywgbmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIExldCB0aGUgQVJJQSBhdHRyaWJ1dGUgaG9vayB2YWxpZGF0ZSBBUklBIGF0dHJpYnV0ZXNcblxuXG4gICAgaWYgKHJBUklBJDEudGVzdChuYW1lKSB8fCByQVJJQUNhbWVsJDEudGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnaW5uZXJodG1sJykge1xuICAgICAgZXJyb3IoJ0RpcmVjdGx5IHNldHRpbmcgcHJvcGVydHkgYGlubmVySFRNTGAgaXMgbm90IHBlcm1pdHRlZC4gJyArICdGb3IgbW9yZSBpbmZvcm1hdGlvbiwgbG9va3VwIGRvY3VtZW50YXRpb24gb24gYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKTtcblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ2FyaWEnKSB7XG4gICAgICBlcnJvcignVGhlIGBhcmlhYCBhdHRyaWJ1dGUgaXMgcmVzZXJ2ZWQgZm9yIGZ1dHVyZSB1c2UgaW4gUmVhY3QuICcgKyAnUGFzcyBpbmRpdmlkdWFsIGBhcmlhLWAgYXR0cmlidXRlcyBpbnN0ZWFkLicpO1xuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnaXMnICYmIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGEgYCVzYCBmb3IgYSBzdHJpbmcgYXR0cmlidXRlIGBpc2AuIElmIHRoaXMgaXMgZXhwZWN0ZWQsIGNhc3QgJyArICd0aGUgdmFsdWUgdG8gYSBzdHJpbmcuJywgdHlwZW9mIHZhbHVlKTtcblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIE5hTiBmb3IgdGhlIGAlc2AgYXR0cmlidXRlLiBJZiB0aGlzIGlzIGV4cGVjdGVkLCBjYXN0ICcgKyAndGhlIHZhbHVlIHRvIGEgc3RyaW5nLicsIG5hbWUpO1xuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHByb3BlcnR5SW5mbyA9IGdldFByb3BlcnR5SW5mbyhuYW1lKTtcbiAgICB2YXIgaXNSZXNlcnZlZCA9IHByb3BlcnR5SW5mbyAhPT0gbnVsbCAmJiBwcm9wZXJ0eUluZm8udHlwZSA9PT0gUkVTRVJWRUQ7IC8vIEtub3duIGF0dHJpYnV0ZXMgc2hvdWxkIG1hdGNoIHRoZSBjYXNpbmcgc3BlY2lmaWVkIGluIHRoZSBwcm9wZXJ0eSBjb25maWcuXG5cbiAgICBpZiAocG9zc2libGVTdGFuZGFyZE5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSkge1xuICAgICAgdmFyIHN0YW5kYXJkTmFtZSA9IHBvc3NpYmxlU3RhbmRhcmROYW1lc1tsb3dlckNhc2VkTmFtZV07XG5cbiAgICAgIGlmIChzdGFuZGFyZE5hbWUgIT09IG5hbWUpIHtcbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgRE9NIHByb3BlcnR5IGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPycsIG5hbWUsIHN0YW5kYXJkTmFtZSk7XG5cbiAgICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghaXNSZXNlcnZlZCAmJiBuYW1lICE9PSBsb3dlckNhc2VkTmFtZSkge1xuICAgICAgLy8gVW5rbm93biBhdHRyaWJ1dGVzIHNob3VsZCBoYXZlIGxvd2VyY2FzZSBjYXNpbmcgc2luY2UgdGhhdCdzIGhvdyB0aGV5XG4gICAgICAvLyB3aWxsIGJlIGNhc2VkIGFueXdheSB3aXRoIHNlcnZlciByZW5kZXJpbmcuXG4gICAgICBlcnJvcignUmVhY3QgZG9lcyBub3QgcmVjb2duaXplIHRoZSBgJXNgIHByb3Agb24gYSBET00gZWxlbWVudC4gSWYgeW91ICcgKyAnaW50ZW50aW9uYWxseSB3YW50IGl0IHRvIGFwcGVhciBpbiB0aGUgRE9NIGFzIGEgY3VzdG9tICcgKyAnYXR0cmlidXRlLCBzcGVsbCBpdCBhcyBsb3dlcmNhc2UgYCVzYCBpbnN0ZWFkLiAnICsgJ0lmIHlvdSBhY2NpZGVudGFsbHkgcGFzc2VkIGl0IGZyb20gYSBwYXJlbnQgY29tcG9uZW50LCByZW1vdmUgJyArICdpdCBmcm9tIHRoZSBET00gZWxlbWVudC4nLCBuYW1lLCBsb3dlckNhc2VkTmFtZSk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgJiYgc2hvdWxkUmVtb3ZlQXR0cmlidXRlV2l0aFdhcm5pbmcobmFtZSwgdmFsdWUsIHByb3BlcnR5SW5mbywgZmFsc2UpKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZXJyb3IoJ1JlY2VpdmVkIGAlc2AgZm9yIGEgbm9uLWJvb2xlYW4gYXR0cmlidXRlIGAlc2AuXFxuXFxuJyArICdJZiB5b3Ugd2FudCB0byB3cml0ZSBpdCB0byB0aGUgRE9NLCBwYXNzIGEgc3RyaW5nIGluc3RlYWQ6ICcgKyAnJXM9XCIlc1wiIG9yICVzPXt2YWx1ZS50b1N0cmluZygpfS4nLCB2YWx1ZSwgbmFtZSwgbmFtZSwgdmFsdWUsIG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3IoJ1JlY2VpdmVkIGAlc2AgZm9yIGEgbm9uLWJvb2xlYW4gYXR0cmlidXRlIGAlc2AuXFxuXFxuJyArICdJZiB5b3Ugd2FudCB0byB3cml0ZSBpdCB0byB0aGUgRE9NLCBwYXNzIGEgc3RyaW5nIGluc3RlYWQ6ICcgKyAnJXM9XCIlc1wiIG9yICVzPXt2YWx1ZS50b1N0cmluZygpfS5cXG5cXG4nICsgJ0lmIHlvdSB1c2VkIHRvIGNvbmRpdGlvbmFsbHkgb21pdCBpdCB3aXRoICVzPXtjb25kaXRpb24gJiYgdmFsdWV9LCAnICsgJ3Bhc3MgJXM9e2NvbmRpdGlvbiA/IHZhbHVlIDogdW5kZWZpbmVkfSBpbnN0ZWFkLicsIHZhbHVlLCBuYW1lLCBuYW1lLCB2YWx1ZSwgbmFtZSwgbmFtZSwgbmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIE5vdyB0aGF0IHdlJ3ZlIHZhbGlkYXRlZCBjYXNpbmcsIGRvIG5vdCB2YWxpZGF0ZVxuICAgIC8vIGRhdGEgdHlwZXMgZm9yIHJlc2VydmVkIHByb3BzXG5cblxuICAgIGlmIChpc1Jlc2VydmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIFdhcm4gd2hlbiBhIGtub3duIGF0dHJpYnV0ZSBpcyBhIGJhZCB0eXBlXG5cblxuICAgIGlmIChzaG91bGRSZW1vdmVBdHRyaWJ1dGVXaXRoV2FybmluZyhuYW1lLCB2YWx1ZSwgcHJvcGVydHlJbmZvLCBmYWxzZSkpIHtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBXYXJuIHdoZW4gcGFzc2luZyB0aGUgc3RyaW5ncyAnZmFsc2UnIG9yICd0cnVlJyBpbnRvIGEgYm9vbGVhbiBwcm9wXG5cblxuICAgIGlmICgodmFsdWUgPT09ICdmYWxzZScgfHwgdmFsdWUgPT09ICd0cnVlJykgJiYgcHJvcGVydHlJbmZvICE9PSBudWxsICYmIHByb3BlcnR5SW5mby50eXBlID09PSBCT09MRUFOKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgdGhlIHN0cmluZyBgJXNgIGZvciB0aGUgYm9vbGVhbiBhdHRyaWJ1dGUgYCVzYC4gJyArICclcyAnICsgJ0RpZCB5b3UgbWVhbiAlcz17JXN9PycsIHZhbHVlLCBuYW1lLCB2YWx1ZSA9PT0gJ2ZhbHNlJyA/ICdUaGUgYnJvd3NlciB3aWxsIGludGVycHJldCBpdCBhcyBhIHRydXRoeSB2YWx1ZS4nIDogJ0FsdGhvdWdoIHRoaXMgd29ya3MsIGl0IHdpbGwgbm90IHdvcmsgYXMgZXhwZWN0ZWQgaWYgeW91IHBhc3MgdGhlIHN0cmluZyBcImZhbHNlXCIuJywgbmFtZSwgdmFsdWUpO1xuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG59XG5cbnZhciB3YXJuVW5rbm93blByb3BlcnRpZXMgPSBmdW5jdGlvbiAodHlwZSwgcHJvcHMsIGV2ZW50UmVnaXN0cnkpIHtcbiAge1xuICAgIHZhciB1bmtub3duUHJvcHMgPSBbXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgdmFyIGlzVmFsaWQgPSB2YWxpZGF0ZVByb3BlcnR5JDEodHlwZSwga2V5LCBwcm9wc1trZXldLCBldmVudFJlZ2lzdHJ5KTtcblxuICAgICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICAgIHVua25vd25Qcm9wcy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHVua25vd25Qcm9wU3RyaW5nID0gdW5rbm93blByb3BzLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgcmV0dXJuICdgJyArIHByb3AgKyAnYCc7XG4gICAgfSkuam9pbignLCAnKTtcblxuICAgIGlmICh1bmtub3duUHJvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBlcnJvcignSW52YWxpZCB2YWx1ZSBmb3IgcHJvcCAlcyBvbiA8JXM+IHRhZy4gRWl0aGVyIHJlbW92ZSBpdCBmcm9tIHRoZSBlbGVtZW50LCAnICsgJ29yIHBhc3MgYSBzdHJpbmcgb3IgbnVtYmVyIHZhbHVlIHRvIGtlZXAgaXQgaW4gdGhlIERPTS4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9hdHRyaWJ1dGUtYmVoYXZpb3IgJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUpO1xuICAgIH0gZWxzZSBpZiAodW5rbm93blByb3BzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGVycm9yKCdJbnZhbGlkIHZhbHVlcyBmb3IgcHJvcHMgJXMgb24gPCVzPiB0YWcuIEVpdGhlciByZW1vdmUgdGhlbSBmcm9tIHRoZSBlbGVtZW50LCAnICsgJ29yIHBhc3MgYSBzdHJpbmcgb3IgbnVtYmVyIHZhbHVlIHRvIGtlZXAgdGhlbSBpbiB0aGUgRE9NLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2F0dHJpYnV0ZS1iZWhhdmlvciAnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXMkMih0eXBlLCBwcm9wcywgZXZlbnRSZWdpc3RyeSkge1xuICBpZiAoaXNDdXN0b21Db21wb25lbnQodHlwZSwgcHJvcHMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgd2FyblVua25vd25Qcm9wZXJ0aWVzKHR5cGUsIHByb3BzLCBldmVudFJlZ2lzdHJ5KTtcbn1cblxudmFyIHRvQXJyYXkgPSBSZWFjdC5DaGlsZHJlbi50b0FycmF5OyAvLyBUaGlzIGlzIG9ubHkgdXNlZCBpbiBERVYuXG4vLyBFYWNoIGVudHJ5IGlzIGB0aGlzLnN0YWNrYCBmcm9tIGEgY3VycmVudGx5IGV4ZWN1dGluZyByZW5kZXJlciBpbnN0YW5jZS5cbi8vIChUaGVyZSBtYXkgYmUgbW9yZSB0aGFuIG9uZSBiZWNhdXNlIFJlYWN0RE9NU2VydmVyIGlzIHJlZW50cmFudCkuXG4vLyBFYWNoIHN0YWNrIGlzIGFuIGFycmF5IG9mIGZyYW1lcyB3aGljaCBtYXkgY29udGFpbiBuZXN0ZWQgc3RhY2tzIG9mIGVsZW1lbnRzLlxuXG52YXIgY3VycmVudERlYnVnU3RhY2tzID0gW107XG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDE7XG52YXIgcHJldkdldEN1cnJlbnRTdGFja0ltcGwgPSBudWxsO1xuXG52YXIgZ2V0Q3VycmVudFNlcnZlclN0YWNrSW1wbCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICcnO1xufTtcblxudmFyIGRlc2NyaWJlU3RhY2tGcmFtZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIHJldHVybiAnJztcbn07XG5cbnZhciB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50ID0gZnVuY3Rpb24gKHR5cGUsIHByb3BzKSB7fTtcblxudmFyIHB1c2hDdXJyZW50RGVidWdTdGFjayA9IGZ1bmN0aW9uIChzdGFjaykge307XG5cbnZhciBwdXNoRWxlbWVudFRvRGVidWdTdGFjayA9IGZ1bmN0aW9uIChlbGVtZW50KSB7fTtcblxudmFyIHBvcEN1cnJlbnREZWJ1Z1N0YWNrID0gZnVuY3Rpb24gKCkge307XG5cbnZhciBoYXNXYXJuZWRBYm91dFVzaW5nQ29udGV4dEFzQ29uc3VtZXIgPSBmYWxzZTtcblxue1xuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG4gIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQgPSBmdW5jdGlvbiAodHlwZSwgcHJvcHMpIHtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXModHlwZSwgcHJvcHMpO1xuICAgIHZhbGlkYXRlUHJvcGVydGllcyQxKHR5cGUsIHByb3BzKTtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXMkMih0eXBlLCBwcm9wcywgbnVsbCk7XG4gIH07XG5cbiAgZGVzY3JpYmVTdGFja0ZyYW1lID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBudWxsKTtcbiAgfTtcblxuICBwdXNoQ3VycmVudERlYnVnU3RhY2sgPSBmdW5jdGlvbiAoc3RhY2spIHtcbiAgICBjdXJyZW50RGVidWdTdGFja3MucHVzaChzdGFjayk7XG5cbiAgICBpZiAoY3VycmVudERlYnVnU3RhY2tzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgLy8gV2UgYXJlIGVudGVyaW5nIGEgc2VydmVyIHJlbmRlcmVyLlxuICAgICAgLy8gUmVtZW1iZXIgdGhlIHByZXZpb3VzIChlLmcuIGNsaWVudCkgZ2xvYmFsIHN0YWNrIGltcGxlbWVudGF0aW9uLlxuICAgICAgcHJldkdldEN1cnJlbnRTdGFja0ltcGwgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuZ2V0Q3VycmVudFN0YWNrO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLmdldEN1cnJlbnRTdGFjayA9IGdldEN1cnJlbnRTZXJ2ZXJTdGFja0ltcGw7XG4gICAgfVxuICB9O1xuXG4gIHB1c2hFbGVtZW50VG9EZWJ1Z1N0YWNrID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAvLyBGb3IgdGhlIGlubmVybW9zdCBleGVjdXRpbmcgUmVhY3RET01TZXJ2ZXIgY2FsbCxcbiAgICB2YXIgc3RhY2sgPSBjdXJyZW50RGVidWdTdGFja3NbY3VycmVudERlYnVnU3RhY2tzLmxlbmd0aCAtIDFdOyAvLyBUYWtlIHRoZSBpbm5lcm1vc3QgZXhlY3V0aW5nIGZyYW1lIChlLmcuIDxGb28+KSxcblxuICAgIHZhciBmcmFtZSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdOyAvLyBhbmQgcmVjb3JkIHRoYXQgaXQgaGFzIG9uZSBtb3JlIGVsZW1lbnQgYXNzb2NpYXRlZCB3aXRoIGl0LlxuXG4gICAgZnJhbWUuZGVidWdFbGVtZW50U3RhY2sucHVzaChlbGVtZW50KTsgLy8gV2Ugb25seSBuZWVkIHRoaXMgYmVjYXVzZSB3ZSB0YWlsLW9wdGltaXplIHNpbmdsZS1lbGVtZW50XG4gICAgLy8gY2hpbGRyZW4gYW5kIGRpcmVjdGx5IGhhbmRsZSB0aGVtIGluIGFuIGlubmVyIGxvb3AgaW5zdGVhZCBvZlxuICAgIC8vIGNyZWF0aW5nIHNlcGFyYXRlIGZyYW1lcyBmb3IgdGhlbS5cbiAgfTtcblxuICBwb3BDdXJyZW50RGVidWdTdGFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICBjdXJyZW50RGVidWdTdGFja3MucG9wKCk7XG5cbiAgICBpZiAoY3VycmVudERlYnVnU3RhY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gV2UgYXJlIGV4aXRpbmcgdGhlIHNlcnZlciByZW5kZXJlci5cbiAgICAgIC8vIFJlc3RvcmUgdGhlIHByZXZpb3VzIChlLmcuIGNsaWVudCkgZ2xvYmFsIHN0YWNrIGltcGxlbWVudGF0aW9uLlxuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLmdldEN1cnJlbnRTdGFjayA9IHByZXZHZXRDdXJyZW50U3RhY2tJbXBsO1xuICAgICAgcHJldkdldEN1cnJlbnRTdGFja0ltcGwgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICBnZXRDdXJyZW50U2VydmVyU3RhY2tJbXBsID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjdXJyZW50RGVidWdTdGFja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBOb3RoaW5nIGlzIGN1cnJlbnRseSByZW5kZXJpbmcuXG4gICAgICByZXR1cm4gJyc7XG4gICAgfSAvLyBSZWFjdERPTVNlcnZlciBpcyByZWVudHJhbnQgc28gdGhlcmUgbWF5IGJlIG11bHRpcGxlIGNhbGxzIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgLy8gVGFrZSB0aGUgZnJhbWVzIGZyb20gdGhlIGlubmVybW9zdCBjYWxsIHdoaWNoIGlzIHRoZSBsYXN0IGluIHRoZSBhcnJheS5cblxuXG4gICAgdmFyIGZyYW1lcyA9IGN1cnJlbnREZWJ1Z1N0YWNrc1tjdXJyZW50RGVidWdTdGFja3MubGVuZ3RoIC0gMV07XG4gICAgdmFyIHN0YWNrID0gJyc7IC8vIEdvIHRocm91Z2ggZXZlcnkgZnJhbWUgaW4gdGhlIHN0YWNrIGZyb20gdGhlIGlubmVybW9zdCBvbmUuXG5cbiAgICBmb3IgKHZhciBpID0gZnJhbWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZnJhbWUgPSBmcmFtZXNbaV07IC8vIEV2ZXJ5IGZyYW1lIG1pZ2h0IGhhdmUgbW9yZSB0aGFuIG9uZSBkZWJ1ZyBlbGVtZW50IHN0YWNrIGVudHJ5IGFzc29jaWF0ZWQgd2l0aCBpdC5cbiAgICAgIC8vIFRoaXMgaXMgYmVjYXVzZSBzaW5nbGUtY2hpbGQgbmVzdGluZyBkb2Vzbid0IGNyZWF0ZSBtYXRlcmlhbGl6ZWQgZnJhbWVzLlxuICAgICAgLy8gSW5zdGVhZCBpdCB3b3VsZCBwdXNoIHRoZW0gdGhyb3VnaCBgcHVzaEVsZW1lbnRUb0RlYnVnU3RhY2soKWAuXG5cbiAgICAgIHZhciBkZWJ1Z0VsZW1lbnRTdGFjayA9IGZyYW1lLmRlYnVnRWxlbWVudFN0YWNrO1xuXG4gICAgICBmb3IgKHZhciBpaSA9IGRlYnVnRWxlbWVudFN0YWNrLmxlbmd0aCAtIDE7IGlpID49IDA7IGlpLS0pIHtcbiAgICAgICAgc3RhY2sgKz0gZGVzY3JpYmVTdGFja0ZyYW1lKGRlYnVnRWxlbWVudFN0YWNrW2lpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YWNrO1xuICB9O1xufVxuXG52YXIgZGlkV2FybkRlZmF1bHRJbnB1dFZhbHVlID0gZmFsc2U7XG52YXIgZGlkV2FybkRlZmF1bHRDaGVja2VkID0gZmFsc2U7XG52YXIgZGlkV2FybkRlZmF1bHRTZWxlY3RWYWx1ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5EZWZhdWx0VGV4dGFyZWFWYWx1ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5JbnZhbGlkT3B0aW9uQ2hpbGRyZW4gPSBmYWxzZTtcbnZhciBkaWRXYXJuQWJvdXROb29wVXBkYXRlRm9yQ29tcG9uZW50ID0ge307XG52YXIgZGlkV2FybkFib3V0QmFkQ2xhc3MgPSB7fTtcbnZhciBkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50ID0ge307XG52YXIgZGlkV2FybkFib3V0RGVwcmVjYXRlZFdpbGxNb3VudCA9IHt9O1xudmFyIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZSA9IHt9O1xudmFyIGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZSA9IHt9O1xudmFyIHZhbHVlUHJvcE5hbWVzID0gWyd2YWx1ZScsICdkZWZhdWx0VmFsdWUnXTtcbnZhciBuZXdsaW5lRWF0aW5nVGFncyA9IHtcbiAgbGlzdGluZzogdHJ1ZSxcbiAgcHJlOiB0cnVlLFxuICB0ZXh0YXJlYTogdHJ1ZVxufTsgLy8gV2UgYWNjZXB0IGFueSB0YWcgdG8gYmUgcmVuZGVyZWQgYnV0IHNpbmNlIHRoaXMgZ2V0cyBpbmplY3RlZCBpbnRvIGFyYml0cmFyeVxuLy8gSFRNTCwgd2Ugd2FudCB0byBtYWtlIHN1cmUgdGhhdCBpdCdzIGEgc2FmZSB0YWcuXG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi9SRUMteG1sLyNOVC1OYW1lXG5cbnZhciBWQUxJRF9UQUdfUkVHRVggPSAvXlthLXpBLVpdW2EtekEtWjpfXFwuXFwtXFxkXSokLzsgLy8gU2ltcGxpZmllZCBzdWJzZXRcblxudmFyIHZhbGlkYXRlZFRhZ0NhY2hlID0ge307XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRGFuZ2Vyb3VzVGFnKHRhZykge1xuICBpZiAoIXZhbGlkYXRlZFRhZ0NhY2hlLmhhc093blByb3BlcnR5KHRhZykpIHtcbiAgICBpZiAoIVZBTElEX1RBR19SRUdFWC50ZXN0KHRhZykpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIFwiSW52YWxpZCB0YWc6IFwiICsgdGFnICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFsaWRhdGVkVGFnQ2FjaGVbdGFnXSA9IHRydWU7XG4gIH1cbn1cblxudmFyIHN0eWxlTmFtZUNhY2hlID0ge307XG5cbnZhciBwcm9jZXNzU3R5bGVOYW1lID0gZnVuY3Rpb24gKHN0eWxlTmFtZSkge1xuICBpZiAoc3R5bGVOYW1lQ2FjaGUuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgIHJldHVybiBzdHlsZU5hbWVDYWNoZVtzdHlsZU5hbWVdO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IGh5cGhlbmF0ZVN0eWxlTmFtZShzdHlsZU5hbWUpO1xuICBzdHlsZU5hbWVDYWNoZVtzdHlsZU5hbWVdID0gcmVzdWx0O1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZnVuY3Rpb24gY3JlYXRlTWFya3VwRm9yU3R5bGVzKHN0eWxlcykge1xuICB2YXIgc2VyaWFsaXplZCA9ICcnO1xuICB2YXIgZGVsaW1pdGVyID0gJyc7XG5cbiAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBpc0N1c3RvbVByb3BlcnR5ID0gc3R5bGVOYW1lLmluZGV4T2YoJy0tJykgPT09IDA7XG4gICAgdmFyIHN0eWxlVmFsdWUgPSBzdHlsZXNbc3R5bGVOYW1lXTtcblxuICAgIHtcbiAgICAgIGlmICghaXNDdXN0b21Qcm9wZXJ0eSkge1xuICAgICAgICB3YXJuVmFsaWRTdHlsZSQxKHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0eWxlVmFsdWUgIT0gbnVsbCkge1xuICAgICAgc2VyaWFsaXplZCArPSBkZWxpbWl0ZXIgKyAoaXNDdXN0b21Qcm9wZXJ0eSA/IHN0eWxlTmFtZSA6IHByb2Nlc3NTdHlsZU5hbWUoc3R5bGVOYW1lKSkgKyAnOic7XG4gICAgICBzZXJpYWxpemVkICs9IGRhbmdlcm91c1N0eWxlVmFsdWUoc3R5bGVOYW1lLCBzdHlsZVZhbHVlLCBpc0N1c3RvbVByb3BlcnR5KTtcbiAgICAgIGRlbGltaXRlciA9ICc7JztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2VyaWFsaXplZCB8fCBudWxsO1xufVxuXG5mdW5jdGlvbiB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgY2FsbGVyTmFtZSkge1xuICB7XG4gICAgdmFyIF9jb25zdHJ1Y3RvciA9IHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgIHZhciBjb21wb25lbnROYW1lID0gX2NvbnN0cnVjdG9yICYmIGdldENvbXBvbmVudE5hbWUoX2NvbnN0cnVjdG9yKSB8fCAnUmVhY3RDbGFzcyc7XG4gICAgdmFyIHdhcm5pbmdLZXkgPSBjb21wb25lbnROYW1lICsgJy4nICsgY2FsbGVyTmFtZTtcblxuICAgIGlmIChkaWRXYXJuQWJvdXROb29wVXBkYXRlRm9yQ29tcG9uZW50W3dhcm5pbmdLZXldKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXJyb3IoJyVzKC4uLik6IENhbiBvbmx5IHVwZGF0ZSBhIG1vdW50aW5nIGNvbXBvbmVudC4gJyArICdUaGlzIHVzdWFsbHkgbWVhbnMgeW91IGNhbGxlZCAlcygpIG91dHNpZGUgY29tcG9uZW50V2lsbE1vdW50KCkgb24gdGhlIHNlcnZlci4gJyArICdUaGlzIGlzIGEgbm8tb3AuXFxuXFxuUGxlYXNlIGNoZWNrIHRoZSBjb2RlIGZvciB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNhbGxlck5hbWUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgZGlkV2FybkFib3V0Tm9vcFVwZGF0ZUZvckNvbXBvbmVudFt3YXJuaW5nS2V5XSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0JDEoQ29tcG9uZW50KSB7XG4gIHJldHVybiBDb21wb25lbnQucHJvdG90eXBlICYmIENvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudDtcbn1cblxuZnVuY3Rpb24gZ2V0Tm9uQ2hpbGRyZW5Jbm5lck1hcmt1cChwcm9wcykge1xuICB2YXIgaW5uZXJIVE1MID0gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw7XG5cbiAgaWYgKGlubmVySFRNTCAhPSBudWxsKSB7XG4gICAgaWYgKGlubmVySFRNTC5fX2h0bWwgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGlubmVySFRNTC5fX2h0bWw7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjb250ZW50ID0gcHJvcHMuY2hpbGRyZW47XG5cbiAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjb250ZW50ID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIGVzY2FwZVRleHRGb3JCcm93c2VyKGNvbnRlbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBmbGF0dGVuVG9wTGV2ZWxDaGlsZHJlbihjaGlsZHJlbikge1xuICBpZiAoIVJlYWN0LmlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSkge1xuICAgIHJldHVybiB0b0FycmF5KGNoaWxkcmVuKTtcbiAgfVxuXG4gIHZhciBlbGVtZW50ID0gY2hpbGRyZW47XG5cbiAgaWYgKGVsZW1lbnQudHlwZSAhPT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgIHJldHVybiBbZWxlbWVudF07XG4gIH1cblxuICB2YXIgZnJhZ21lbnRDaGlsZHJlbiA9IGVsZW1lbnQucHJvcHMuY2hpbGRyZW47XG5cbiAgaWYgKCFSZWFjdC5pc1ZhbGlkRWxlbWVudChmcmFnbWVudENoaWxkcmVuKSkge1xuICAgIHJldHVybiB0b0FycmF5KGZyYWdtZW50Q2hpbGRyZW4pO1xuICB9XG5cbiAgdmFyIGZyYWdtZW50Q2hpbGRFbGVtZW50ID0gZnJhZ21lbnRDaGlsZHJlbjtcbiAgcmV0dXJuIFtmcmFnbWVudENoaWxkRWxlbWVudF07XG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW5PcHRpb25DaGlsZHJlbihjaGlsZHJlbikge1xuICBpZiAoY2hpbGRyZW4gPT09IHVuZGVmaW5lZCB8fCBjaGlsZHJlbiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuXG4gIHZhciBjb250ZW50ID0gJyc7IC8vIEZsYXR0ZW4gY2hpbGRyZW4gYW5kIHdhcm4gaWYgdGhleSBhcmVuJ3Qgc3RyaW5ncyBvciBudW1iZXJzO1xuICAvLyBpbnZhbGlkIHR5cGVzIGFyZSBpZ25vcmVkLlxuXG4gIFJlYWN0LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmIChjaGlsZCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29udGVudCArPSBjaGlsZDtcblxuICAgIHtcbiAgICAgIGlmICghZGlkV2FybkludmFsaWRPcHRpb25DaGlsZHJlbiAmJiB0eXBlb2YgY2hpbGQgIT09ICdzdHJpbmcnICYmIHR5cGVvZiBjaGlsZCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgZGlkV2FybkludmFsaWRPcHRpb25DaGlsZHJlbiA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJ09ubHkgc3RyaW5ncyBhbmQgbnVtYmVycyBhcmUgc3VwcG9ydGVkIGFzIDxvcHRpb24+IGNoaWxkcmVuLicpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBjb250ZW50O1xufVxuXG52YXIgaGFzT3duUHJvcGVydHkkMiA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgU1RZTEUgPSAnc3R5bGUnO1xudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBjaGlsZHJlbjogbnVsbCxcbiAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IG51bGwsXG4gIHN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZzogbnVsbCxcbiAgc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nOiBudWxsXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVPcGVuVGFnTWFya3VwKHRhZ1ZlcmJhdGltLCB0YWdMb3dlcmNhc2UsIHByb3BzLCBuYW1lc3BhY2UsIG1ha2VTdGF0aWNNYXJrdXAsIGlzUm9vdEVsZW1lbnQpIHtcbiAgdmFyIHJldCA9ICc8JyArIHRhZ1ZlcmJhdGltO1xuICB2YXIgaXNDdXN0b21Db21wb25lbnQkMSA9IGlzQ3VzdG9tQ29tcG9uZW50KHRhZ0xvd2VyY2FzZSwgcHJvcHMpO1xuXG4gIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoIWhhc093blByb3BlcnR5JDIuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcblxuICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICBwcm9wVmFsdWUgPSBjcmVhdGVNYXJrdXBGb3JTdHlsZXMocHJvcFZhbHVlKTtcbiAgICB9XG5cbiAgICB2YXIgbWFya3VwID0gbnVsbDtcblxuICAgIGlmIChpc0N1c3RvbUNvbXBvbmVudCQxKSB7XG4gICAgICBpZiAoIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgIG1hcmt1cCA9IGNyZWF0ZU1hcmt1cEZvckN1c3RvbUF0dHJpYnV0ZShwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtYXJrdXAgPSBjcmVhdGVNYXJrdXBGb3JQcm9wZXJ0eShwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgIH1cblxuICAgIGlmIChtYXJrdXApIHtcbiAgICAgIHJldCArPSAnICcgKyBtYXJrdXA7XG4gICAgfVxuICB9IC8vIEZvciBzdGF0aWMgcGFnZXMsIG5vIG5lZWQgdG8gcHV0IFJlYWN0IElEIGFuZCBjaGVja3N1bS4gU2F2ZXMgbG90cyBvZlxuICAvLyBieXRlcy5cblxuXG4gIGlmIChtYWtlU3RhdGljTWFya3VwKSB7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIGlmIChpc1Jvb3RFbGVtZW50KSB7XG4gICAgcmV0ICs9ICcgJyArIGNyZWF0ZU1hcmt1cEZvclJvb3QoKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUmVuZGVyUmVzdWx0KGNoaWxkLCB0eXBlKSB7XG4gIGlmIChjaGlsZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvciggKGdldENvbXBvbmVudE5hbWUodHlwZSkgfHwgJ0NvbXBvbmVudCcpICsgXCIoLi4uKTogTm90aGluZyB3YXMgcmV0dXJuZWQgZnJvbSByZW5kZXIuIFRoaXMgdXN1YWxseSBtZWFucyBhIHJldHVybiBzdGF0ZW1lbnQgaXMgbWlzc2luZy4gT3IsIHRvIHJlbmRlciBub3RoaW5nLCByZXR1cm4gbnVsbC5cIiApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlKGNoaWxkLCBjb250ZXh0LCB0aHJlYWRJRCkge1xuICB3aGlsZSAoUmVhY3QuaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgLy8gU2FmZSBiZWNhdXNlIHdlIGp1c3QgY2hlY2tlZCBpdCdzIGFuIGVsZW1lbnQuXG4gICAgdmFyIGVsZW1lbnQgPSBjaGlsZDtcbiAgICB2YXIgQ29tcG9uZW50ID0gZWxlbWVudC50eXBlO1xuXG4gICAge1xuICAgICAgcHVzaEVsZW1lbnRUb0RlYnVnU3RhY2soZWxlbWVudCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBDb21wb25lbnQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHByb2Nlc3NDaGlsZChlbGVtZW50LCBDb21wb25lbnQpO1xuICB9IC8vIEV4dHJhIGNsb3N1cmUgc28gcXVldWUgYW5kIHJlcGxhY2UgY2FuIGJlIGNhcHR1cmVkIHByb3Blcmx5XG5cblxuICBmdW5jdGlvbiBwcm9jZXNzQ2hpbGQoZWxlbWVudCwgQ29tcG9uZW50KSB7XG4gICAgdmFyIGlzQ2xhc3MgPSBzaG91bGRDb25zdHJ1Y3QkMShDb21wb25lbnQpO1xuICAgIHZhciBwdWJsaWNDb250ZXh0ID0gcHJvY2Vzc0NvbnRleHQoQ29tcG9uZW50LCBjb250ZXh0LCB0aHJlYWRJRCwgaXNDbGFzcyk7XG4gICAgdmFyIHF1ZXVlID0gW107XG4gICAgdmFyIHJlcGxhY2UgPSBmYWxzZTtcbiAgICB2YXIgdXBkYXRlciA9IHtcbiAgICAgIGlzTW91bnRlZDogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgICAgICBpZiAocXVldWUgPT09IG51bGwpIHtcbiAgICAgICAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ2ZvcmNlVXBkYXRlJyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUpIHtcbiAgICAgICAgcmVwbGFjZSA9IHRydWU7XG4gICAgICAgIHF1ZXVlID0gW2NvbXBsZXRlU3RhdGVdO1xuICAgICAgfSxcbiAgICAgIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjdXJyZW50UGFydGlhbFN0YXRlKSB7XG4gICAgICAgIGlmIChxdWV1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHF1ZXVlLnB1c2goY3VycmVudFBhcnRpYWxTdGF0ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgaW5zdDtcblxuICAgIGlmIChpc0NsYXNzKSB7XG4gICAgICBpbnN0ID0gbmV3IENvbXBvbmVudChlbGVtZW50LnByb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVyKTtcblxuICAgICAgaWYgKHR5cGVvZiBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoaW5zdC5zdGF0ZSA9PT0gbnVsbCB8fCBpbnN0LnN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGVbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgICAgICAgZXJyb3IoJ2Alc2AgdXNlcyBgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzYCBidXQgaXRzIGluaXRpYWwgc3RhdGUgaXMgJyArICclcy4gVGhpcyBpcyBub3QgcmVjb21tZW5kZWQuIEluc3RlYWQsIGRlZmluZSB0aGUgaW5pdGlhbCBzdGF0ZSBieSAnICsgJ2Fzc2lnbmluZyBhbiBvYmplY3QgdG8gYHRoaXMuc3RhdGVgIGluIHRoZSBjb25zdHJ1Y3RvciBvZiBgJXNgLiAnICsgJ1RoaXMgZW5zdXJlcyB0aGF0IGBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNgIGFyZ3VtZW50cyBoYXZlIGEgY29uc2lzdGVudCBzaGFwZS4nLCBjb21wb25lbnROYW1lLCBpbnN0LnN0YXRlID09PSBudWxsID8gJ251bGwnIDogJ3VuZGVmaW5lZCcsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgICAgICAgIGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZVtjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhcnRpYWxTdGF0ZSA9IENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuY2FsbChudWxsLCBlbGVtZW50LnByb3BzLCBpbnN0LnN0YXRlKTtcblxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHBhcnRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgX2NvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCkgfHwgJ1Vua25vd24nO1xuXG4gICAgICAgICAgICBpZiAoIWRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZVtfY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgICAgICAgZXJyb3IoJyVzLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpOiBBIHZhbGlkIHN0YXRlIG9iamVjdCAob3IgbnVsbCkgbXVzdCBiZSByZXR1cm5lZC4gJyArICdZb3UgaGF2ZSByZXR1cm5lZCB1bmRlZmluZWQuJywgX2NvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgICAgICAgIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZVtfY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJ0aWFsU3RhdGUgIT0gbnVsbCkge1xuICAgICAgICAgIGluc3Quc3RhdGUgPSBfYXNzaWduKHt9LCBpbnN0LnN0YXRlLCBwYXJ0aWFsU3RhdGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKENvbXBvbmVudC5wcm90b3R5cGUgJiYgdHlwZW9mIENvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFyIF9jb21wb25lbnROYW1lMiA9IGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgICAgICBpZiAoIWRpZFdhcm5BYm91dEJhZENsYXNzW19jb21wb25lbnROYW1lMl0pIHtcbiAgICAgICAgICAgIGVycm9yKFwiVGhlIDwlcyAvPiBjb21wb25lbnQgYXBwZWFycyB0byBoYXZlIGEgcmVuZGVyIG1ldGhvZCwgYnV0IGRvZXNuJ3QgZXh0ZW5kIFJlYWN0LkNvbXBvbmVudC4gXCIgKyAnVGhpcyBpcyBsaWtlbHkgdG8gY2F1c2UgZXJyb3JzLiBDaGFuZ2UgJXMgdG8gZXh0ZW5kIFJlYWN0LkNvbXBvbmVudCBpbnN0ZWFkLicsIF9jb21wb25lbnROYW1lMiwgX2NvbXBvbmVudE5hbWUyKTtcblxuICAgICAgICAgICAgZGlkV2FybkFib3V0QmFkQ2xhc3NbX2NvbXBvbmVudE5hbWUyXSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBjb21wb25lbnRJZGVudGl0eSA9IHt9O1xuICAgICAgcHJlcGFyZVRvVXNlSG9va3MoY29tcG9uZW50SWRlbnRpdHkpO1xuICAgICAgaW5zdCA9IENvbXBvbmVudChlbGVtZW50LnByb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVyKTtcbiAgICAgIGluc3QgPSBmaW5pc2hIb29rcyhDb21wb25lbnQsIGVsZW1lbnQucHJvcHMsIGluc3QsIHB1YmxpY0NvbnRleHQpO1xuXG4gICAgICB7XG4gICAgICAgIC8vIFN1cHBvcnQgZm9yIG1vZHVsZSBjb21wb25lbnRzIGlzIGRlcHJlY2F0ZWQgYW5kIGlzIHJlbW92ZWQgYmVoaW5kIGEgZmxhZy5cbiAgICAgICAgLy8gV2hldGhlciBvciBub3QgaXQgd291bGQgY3Jhc2ggbGF0ZXIsIHdlIHdhbnQgdG8gc2hvdyBhIGdvb2QgbWVzc2FnZSBpbiBERVYgZmlyc3QuXG4gICAgICAgIGlmIChpbnN0ICE9IG51bGwgJiYgaW5zdC5yZW5kZXIgIT0gbnVsbCkge1xuICAgICAgICAgIHZhciBfY29tcG9uZW50TmFtZTMgPSBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCkgfHwgJ1Vua25vd24nO1xuXG4gICAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50W19jb21wb25lbnROYW1lM10pIHtcbiAgICAgICAgICAgIGVycm9yKCdUaGUgPCVzIC8+IGNvbXBvbmVudCBhcHBlYXJzIHRvIGJlIGEgZnVuY3Rpb24gY29tcG9uZW50IHRoYXQgcmV0dXJucyBhIGNsYXNzIGluc3RhbmNlLiAnICsgJ0NoYW5nZSAlcyB0byBhIGNsYXNzIHRoYXQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQgaW5zdGVhZC4gJyArIFwiSWYgeW91IGNhbid0IHVzZSBhIGNsYXNzIHRyeSBhc3NpZ25pbmcgdGhlIHByb3RvdHlwZSBvbiB0aGUgZnVuY3Rpb24gYXMgYSB3b3JrYXJvdW5kLiBcIiArIFwiYCVzLnByb3RvdHlwZSA9IFJlYWN0LkNvbXBvbmVudC5wcm90b3R5cGVgLiBEb24ndCB1c2UgYW4gYXJyb3cgZnVuY3Rpb24gc2luY2UgaXQgXCIgKyAnY2Fubm90IGJlIGNhbGxlZCB3aXRoIGBuZXdgIGJ5IFJlYWN0LicsIF9jb21wb25lbnROYW1lMywgX2NvbXBvbmVudE5hbWUzLCBfY29tcG9uZW50TmFtZTMpO1xuXG4gICAgICAgICAgICBkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50W19jb21wb25lbnROYW1lM10gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBJZiB0aGUgZmxhZyBpcyBvbiwgZXZlcnl0aGluZyBpcyBhc3N1bWVkIHRvIGJlIGEgZnVuY3Rpb24gY29tcG9uZW50LlxuICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSBhbHNvIGRvIHRoZSB1bmZvcnR1bmF0ZSBkeW5hbWljIGNoZWNrcy5cblxuXG4gICAgICBpZiAoIGluc3QgPT0gbnVsbCB8fCBpbnN0LnJlbmRlciA9PSBudWxsKSB7XG4gICAgICAgIGNoaWxkID0gaW5zdDtcbiAgICAgICAgdmFsaWRhdGVSZW5kZXJSZXN1bHQoY2hpbGQsIENvbXBvbmVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbnN0LnByb3BzID0gZWxlbWVudC5wcm9wcztcbiAgICBpbnN0LmNvbnRleHQgPSBwdWJsaWNDb250ZXh0O1xuICAgIGluc3QudXBkYXRlciA9IHVwZGF0ZXI7XG4gICAgdmFyIGluaXRpYWxTdGF0ZSA9IGluc3Quc3RhdGU7XG5cbiAgICBpZiAoaW5pdGlhbFN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGluc3Quc3RhdGUgPSBpbml0aWFsU3RhdGUgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdC5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0LmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKHR5cGVvZiBpbnN0LmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKCBpbnN0LmNvbXBvbmVudFdpbGxNb3VudC5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgX2NvbXBvbmVudE5hbWU0ID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXREZXByZWNhdGVkV2lsbE1vdW50W19jb21wb25lbnROYW1lNF0pIHtcbiAgICAgICAgICAgICAgd2FybiggLy8ga2VlcCB0aGlzIHdhcm5pbmcgaW4gc3luYyB3aXRoIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmcuanNcbiAgICAgICAgICAgICAgJ2NvbXBvbmVudFdpbGxNb3VudCBoYXMgYmVlbiByZW5hbWVkLCBhbmQgaXMgbm90IHJlY29tbWVuZGVkIGZvciB1c2UuICcgKyAnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuJyArICcqIE1vdmUgY29kZSBmcm9tIGNvbXBvbmVudFdpbGxNb3VudCB0byBjb21wb25lbnREaWRNb3VudCAocHJlZmVycmVkIGluIG1vc3QgY2FzZXMpICcgKyAnb3IgdGhlIGNvbnN0cnVjdG9yLlxcbicgKyAnXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJywgX2NvbXBvbmVudE5hbWU0KTtcblxuICAgICAgICAgICAgICBkaWRXYXJuQWJvdXREZXByZWNhdGVkV2lsbE1vdW50W19jb21wb25lbnROYW1lNF0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgICAgICAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBhbnkgY29tcG9uZW50IHdpdGggdGhlIG5ldyBnRFNGUC5cblxuXG4gICAgICAgIGlmICh0eXBlb2YgQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGluc3QuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpbnN0LlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG4gICAgICAgIC8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgYW55IGNvbXBvbmVudCB3aXRoIHRoZSBuZXcgZ0RTRlAuXG4gICAgICAgIGluc3QuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHZhciBvbGRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICB2YXIgb2xkUmVwbGFjZSA9IHJlcGxhY2U7XG4gICAgICAgIHF1ZXVlID0gbnVsbDtcbiAgICAgICAgcmVwbGFjZSA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChvbGRSZXBsYWNlICYmIG9sZFF1ZXVlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGluc3Quc3RhdGUgPSBvbGRRdWV1ZVswXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbmV4dFN0YXRlID0gb2xkUmVwbGFjZSA/IG9sZFF1ZXVlWzBdIDogaW5zdC5zdGF0ZTtcbiAgICAgICAgICB2YXIgZG9udE11dGF0ZSA9IHRydWU7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gb2xkUmVwbGFjZSA/IDEgOiAwOyBpIDwgb2xkUXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwYXJ0aWFsID0gb2xkUXVldWVbaV07XG5cbiAgICAgICAgICAgIHZhciBfcGFydGlhbFN0YXRlID0gdHlwZW9mIHBhcnRpYWwgPT09ICdmdW5jdGlvbicgPyBwYXJ0aWFsLmNhbGwoaW5zdCwgbmV4dFN0YXRlLCBlbGVtZW50LnByb3BzLCBwdWJsaWNDb250ZXh0KSA6IHBhcnRpYWw7XG5cbiAgICAgICAgICAgIGlmIChfcGFydGlhbFN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgaWYgKGRvbnRNdXRhdGUpIHtcbiAgICAgICAgICAgICAgICBkb250TXV0YXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbmV4dFN0YXRlID0gX2Fzc2lnbih7fSwgbmV4dFN0YXRlLCBfcGFydGlhbFN0YXRlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfYXNzaWduKG5leHRTdGF0ZSwgX3BhcnRpYWxTdGF0ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpbnN0LnN0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2hpbGQgPSBpbnN0LnJlbmRlcigpO1xuXG4gICAge1xuICAgICAgaWYgKGNoaWxkID09PSB1bmRlZmluZWQgJiYgaW5zdC5yZW5kZXIuX2lzTW9ja0Z1bmN0aW9uKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgcHJvYmFibHkgYmFkIHByYWN0aWNlLiBDb25zaWRlciB3YXJuaW5nIGhlcmUgYW5kXG4gICAgICAgIC8vIGRlcHJlY2F0aW5nIHRoaXMgY29udmVuaWVuY2UuXG4gICAgICAgIGNoaWxkID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YWxpZGF0ZVJlbmRlclJlc3VsdChjaGlsZCwgQ29tcG9uZW50KTtcbiAgICB2YXIgY2hpbGRDb250ZXh0O1xuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBpbnN0LmdldENoaWxkQ29udGV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgX2NoaWxkQ29udGV4dFR5cGVzID0gQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzO1xuXG4gICAgICAgIGlmICh0eXBlb2YgX2NoaWxkQ29udGV4dFR5cGVzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGNoaWxkQ29udGV4dCA9IGluc3QuZ2V0Q2hpbGRDb250ZXh0KCk7XG5cbiAgICAgICAgICBmb3IgKHZhciBjb250ZXh0S2V5IGluIGNoaWxkQ29udGV4dCkge1xuICAgICAgICAgICAgaWYgKCEoY29udGV4dEtleSBpbiBfY2hpbGRDb250ZXh0VHlwZXMpKSB7XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvciggKGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KSB8fCAnVW5rbm93bicpICsgXCIuZ2V0Q2hpbGRDb250ZXh0KCk6IGtleSBcXFwiXCIgKyBjb250ZXh0S2V5ICsgXCJcXFwiIGlzIG5vdCBkZWZpbmVkIGluIGNoaWxkQ29udGV4dFR5cGVzLlwiICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgZXJyb3IoJyVzLmdldENoaWxkQ29udGV4dCgpOiBjaGlsZENvbnRleHRUeXBlcyBtdXN0IGJlIGRlZmluZWQgaW4gb3JkZXIgdG8gJyArICd1c2UgZ2V0Q2hpbGRDb250ZXh0KCkuJywgZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpIHx8ICdVbmtub3duJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGlsZENvbnRleHQpIHtcbiAgICAgICAgY29udGV4dCA9IF9hc3NpZ24oe30sIGNvbnRleHQsIGNoaWxkQ29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjaGlsZDogY2hpbGQsXG4gICAgY29udGV4dDogY29udGV4dFxuICB9O1xufVxuXG52YXIgUmVhY3RET01TZXJ2ZXJSZW5kZXJlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8vIFRPRE86IHR5cGUgdGhpcyBtb3JlIHN0cmljdGx5OlxuICAvLyBERVYtb25seVxuICBmdW5jdGlvbiBSZWFjdERPTVNlcnZlclJlbmRlcmVyKGNoaWxkcmVuLCBtYWtlU3RhdGljTWFya3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIGZsYXRDaGlsZHJlbiA9IGZsYXR0ZW5Ub3BMZXZlbENoaWxkcmVuKGNoaWxkcmVuKTtcbiAgICB2YXIgdG9wRnJhbWUgPSB7XG4gICAgICB0eXBlOiBudWxsLFxuICAgICAgLy8gQXNzdW1lIGFsbCB0cmVlcyBzdGFydCBpbiB0aGUgSFRNTCBuYW1lc3BhY2UgKG5vdCB0b3RhbGx5IHRydWUsIGJ1dFxuICAgICAgLy8gdGhpcyBpcyB3aGF0IHdlIGRpZCBoaXN0b3JpY2FsbHkpXG4gICAgICBkb21OYW1lc3BhY2U6IE5hbWVzcGFjZXMuaHRtbCxcbiAgICAgIGNoaWxkcmVuOiBmbGF0Q2hpbGRyZW4sXG4gICAgICBjaGlsZEluZGV4OiAwLFxuICAgICAgY29udGV4dDogZW1wdHlPYmplY3QsXG4gICAgICBmb290ZXI6ICcnXG4gICAgfTtcblxuICAgIHtcbiAgICAgIHRvcEZyYW1lLmRlYnVnRWxlbWVudFN0YWNrID0gW107XG4gICAgfVxuXG4gICAgdGhpcy50aHJlYWRJRCA9IGFsbG9jVGhyZWFkSUQoKTtcbiAgICB0aGlzLnN0YWNrID0gW3RvcEZyYW1lXTtcbiAgICB0aGlzLmV4aGF1c3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuY3VycmVudFNlbGVjdFZhbHVlID0gbnVsbDtcbiAgICB0aGlzLnByZXZpb3VzV2FzVGV4dE5vZGUgPSBmYWxzZTtcbiAgICB0aGlzLm1ha2VTdGF0aWNNYXJrdXAgPSBtYWtlU3RhdGljTWFya3VwO1xuICAgIHRoaXMuc3VzcGVuc2VEZXB0aCA9IDA7IC8vIENvbnRleHQgKG5ldyBBUEkpXG5cbiAgICB0aGlzLmNvbnRleHRJbmRleCA9IC0xO1xuICAgIHRoaXMuY29udGV4dFN0YWNrID0gW107XG4gICAgdGhpcy5jb250ZXh0VmFsdWVTdGFjayA9IFtdOyAvLyB1c2VPcGFxdWVJZGVudGlmaWVyIElEXG5cbiAgICB0aGlzLnVuaXF1ZUlEID0gMDtcbiAgICB0aGlzLmlkZW50aWZpZXJQcmVmaXggPSBvcHRpb25zICYmIG9wdGlvbnMuaWRlbnRpZmllclByZWZpeCB8fCAnJztcblxuICAgIHtcbiAgICAgIHRoaXMuY29udGV4dFByb3ZpZGVyU3RhY2sgPSBbXTtcbiAgICB9XG4gIH1cblxuICB2YXIgX3Byb3RvID0gUmVhY3RET01TZXJ2ZXJSZW5kZXJlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIGlmICghdGhpcy5leGhhdXN0ZWQpIHtcbiAgICAgIHRoaXMuZXhoYXVzdGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuY2xlYXJQcm92aWRlcnMoKTtcbiAgICAgIGZyZWVUaHJlYWRJRCh0aGlzLnRocmVhZElEKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIE5vdGU6IFdlIHVzZSBqdXN0IHR3byBzdGFja3MgcmVnYXJkbGVzcyBvZiBob3cgbWFueSBjb250ZXh0IHByb3ZpZGVycyB5b3UgaGF2ZS5cbiAgICogUHJvdmlkZXJzIGFyZSBhbHdheXMgcG9wcGVkIGluIHRoZSByZXZlcnNlIG9yZGVyIHRvIGhvdyB0aGV5IHdlcmUgcHVzaGVkXG4gICAqIHNvIHdlIGFsd2F5cyBrbm93IG9uIHRoZSB3YXkgZG93biB3aGljaCBwcm92aWRlciB5b3UnbGwgZW5jb3VudGVyIG5leHQgb24gdGhlIHdheSB1cC5cbiAgICogT24gdGhlIHdheSBkb3duLCB3ZSBwdXNoIHRoZSBjdXJyZW50IHByb3ZpZGVyLCBhbmQgaXRzIGNvbnRleHQgdmFsdWUgKmJlZm9yZSpcbiAgICogd2UgbXV0YXRlZCBpdCwgb250byB0aGUgc3RhY2tzLiBUaGVyZWZvcmUsIG9uIHRoZSB3YXkgdXAsIHdlIGFsd2F5cyBrbm93IHdoaWNoXG4gICAqIHByb3ZpZGVyIG5lZWRzIHRvIGJlIFwicmVzdG9yZWRcIiB0byB3aGljaCB2YWx1ZS5cbiAgICogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMTI5ODUjaXNzdWVjb21tZW50LTM5NjMwMTI0OFxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wdXNoUHJvdmlkZXIgPSBmdW5jdGlvbiBwdXNoUHJvdmlkZXIocHJvdmlkZXIpIHtcbiAgICB2YXIgaW5kZXggPSArK3RoaXMuY29udGV4dEluZGV4O1xuICAgIHZhciBjb250ZXh0ID0gcHJvdmlkZXIudHlwZS5fY29udGV4dDtcbiAgICB2YXIgdGhyZWFkSUQgPSB0aGlzLnRocmVhZElEO1xuICAgIHZhbGlkYXRlQ29udGV4dEJvdW5kcyhjb250ZXh0LCB0aHJlYWRJRCk7XG4gICAgdmFyIHByZXZpb3VzVmFsdWUgPSBjb250ZXh0W3RocmVhZElEXTsgLy8gUmVtZW1iZXIgd2hpY2ggdmFsdWUgdG8gcmVzdG9yZSB0aGlzIGNvbnRleHQgdG8gb24gb3VyIHdheSB1cC5cblxuICAgIHRoaXMuY29udGV4dFN0YWNrW2luZGV4XSA9IGNvbnRleHQ7XG4gICAgdGhpcy5jb250ZXh0VmFsdWVTdGFja1tpbmRleF0gPSBwcmV2aW91c1ZhbHVlO1xuXG4gICAge1xuICAgICAgLy8gT25seSB1c2VkIGZvciBwdXNoL3BvcCBtaXNtYXRjaCB3YXJuaW5ncy5cbiAgICAgIHRoaXMuY29udGV4dFByb3ZpZGVyU3RhY2tbaW5kZXhdID0gcHJvdmlkZXI7XG4gICAgfSAvLyBNdXRhdGUgdGhlIGN1cnJlbnQgdmFsdWUuXG5cblxuICAgIGNvbnRleHRbdGhyZWFkSURdID0gcHJvdmlkZXIucHJvcHMudmFsdWU7XG4gIH07XG5cbiAgX3Byb3RvLnBvcFByb3ZpZGVyID0gZnVuY3Rpb24gcG9wUHJvdmlkZXIocHJvdmlkZXIpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmNvbnRleHRJbmRleDtcblxuICAgIHtcbiAgICAgIGlmIChpbmRleCA8IDAgfHwgcHJvdmlkZXIgIT09IHRoaXMuY29udGV4dFByb3ZpZGVyU3RhY2tbaW5kZXhdKSB7XG4gICAgICAgIGVycm9yKCdVbmV4cGVjdGVkIHBvcC4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dFN0YWNrW2luZGV4XTtcbiAgICB2YXIgcHJldmlvdXNWYWx1ZSA9IHRoaXMuY29udGV4dFZhbHVlU3RhY2tbaW5kZXhdOyAvLyBcIkhpZGVcIiB0aGVzZSBudWxsIGFzc2lnbm1lbnRzIGZyb20gRmxvdyBieSB1c2luZyBgYW55YFxuICAgIC8vIGJlY2F1c2UgY29uY2VwdHVhbGx5IHRoZXkgYXJlIGRlbGV0aW9ucy0tYXMgbG9uZyBhcyB3ZVxuICAgIC8vIHByb21pc2UgdG8gbmV2ZXIgYWNjZXNzIHZhbHVlcyBiZXlvbmQgYHRoaXMuY29udGV4dEluZGV4YC5cblxuICAgIHRoaXMuY29udGV4dFN0YWNrW2luZGV4XSA9IG51bGw7XG4gICAgdGhpcy5jb250ZXh0VmFsdWVTdGFja1tpbmRleF0gPSBudWxsO1xuXG4gICAge1xuICAgICAgdGhpcy5jb250ZXh0UHJvdmlkZXJTdGFja1tpbmRleF0gPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuY29udGV4dEluZGV4LS07IC8vIFJlc3RvcmUgdG8gdGhlIHByZXZpb3VzIHZhbHVlIHdlIHN0b3JlZCBhcyB3ZSB3ZXJlIHdhbGtpbmcgZG93bi5cbiAgICAvLyBXZSd2ZSBhbHJlYWR5IHZlcmlmaWVkIHRoYXQgdGhpcyBjb250ZXh0IGhhcyBiZWVuIGV4cGFuZGVkIHRvIGFjY29tbW9kYXRlXG4gICAgLy8gdGhpcyB0aHJlYWQgaWQsIHNvIHdlIGRvbid0IG5lZWQgdG8gZG8gaXQgYWdhaW4uXG5cbiAgICBjb250ZXh0W3RoaXMudGhyZWFkSURdID0gcHJldmlvdXNWYWx1ZTtcbiAgfTtcblxuICBfcHJvdG8uY2xlYXJQcm92aWRlcnMgPSBmdW5jdGlvbiBjbGVhclByb3ZpZGVycygpIHtcbiAgICAvLyBSZXN0b3JlIGFueSByZW1haW5pbmcgcHJvdmlkZXJzIG9uIHRoZSBzdGFjayB0byBwcmV2aW91cyB2YWx1ZXNcbiAgICBmb3IgKHZhciBpbmRleCA9IHRoaXMuY29udGV4dEluZGV4OyBpbmRleCA+PSAwOyBpbmRleC0tKSB7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dFN0YWNrW2luZGV4XTtcbiAgICAgIHZhciBwcmV2aW91c1ZhbHVlID0gdGhpcy5jb250ZXh0VmFsdWVTdGFja1tpbmRleF07XG4gICAgICBjb250ZXh0W3RoaXMudGhyZWFkSURdID0gcHJldmlvdXNWYWx1ZTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJlYWQgPSBmdW5jdGlvbiByZWFkKGJ5dGVzKSB7XG4gICAgaWYgKHRoaXMuZXhoYXVzdGVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgcHJldlBhcnRpYWxSZW5kZXJlciA9IGN1cnJlbnRQYXJ0aWFsUmVuZGVyZXI7XG4gICAgc2V0Q3VycmVudFBhcnRpYWxSZW5kZXJlcih0aGlzKTtcbiAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IERpc3BhdGNoZXI7XG5cbiAgICB0cnkge1xuICAgICAgLy8gTWFya3VwIGdlbmVyYXRlZCB3aXRoaW4gPFN1c3BlbnNlPiBlbmRzIHVwIGJ1ZmZlcmVkIHVudGlsIHdlIGtub3dcbiAgICAgIC8vIG5vdGhpbmcgaW4gdGhhdCBib3VuZGFyeSBzdXNwZW5kZWRcbiAgICAgIHZhciBvdXQgPSBbJyddO1xuICAgICAgdmFyIHN1c3BlbmRlZCA9IGZhbHNlO1xuXG4gICAgICB3aGlsZSAob3V0WzBdLmxlbmd0aCA8IGJ5dGVzKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuZXhoYXVzdGVkID0gdHJ1ZTtcbiAgICAgICAgICBmcmVlVGhyZWFkSUQodGhpcy50aHJlYWRJRCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZnJhbWUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XG5cbiAgICAgICAgaWYgKHN1c3BlbmRlZCB8fCBmcmFtZS5jaGlsZEluZGV4ID49IGZyYW1lLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBmb290ZXIgPSBmcmFtZS5mb290ZXI7XG5cbiAgICAgICAgICBpZiAoZm9vdGVyICE9PSAnJykge1xuICAgICAgICAgICAgdGhpcy5wcmV2aW91c1dhc1RleHROb2RlID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcblxuICAgICAgICAgIGlmIChmcmFtZS50eXBlID09PSAnc2VsZWN0Jykge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2VsZWN0VmFsdWUgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZnJhbWUudHlwZSAhPSBudWxsICYmIGZyYW1lLnR5cGUudHlwZSAhPSBudWxsICYmIGZyYW1lLnR5cGUudHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSkge1xuICAgICAgICAgICAgdmFyIHByb3ZpZGVyID0gZnJhbWUudHlwZTtcbiAgICAgICAgICAgIHRoaXMucG9wUHJvdmlkZXIocHJvdmlkZXIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZnJhbWUudHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSkge1xuICAgICAgICAgICAgdGhpcy5zdXNwZW5zZURlcHRoLS07XG4gICAgICAgICAgICB2YXIgYnVmZmVyZWQgPSBvdXQucG9wKCk7XG5cbiAgICAgICAgICAgIGlmIChzdXNwZW5kZWQpIHtcbiAgICAgICAgICAgICAgc3VzcGVuZGVkID0gZmFsc2U7IC8vIElmIHJlbmRlcmluZyB3YXMgc3VzcGVuZGVkIGF0IHRoaXMgYm91bmRhcnksIHJlbmRlciB0aGUgZmFsbGJhY2tGcmFtZVxuXG4gICAgICAgICAgICAgIHZhciBmYWxsYmFja0ZyYW1lID0gZnJhbWUuZmFsbGJhY2tGcmFtZTtcblxuICAgICAgICAgICAgICBpZiAoIWZhbGxiYWNrRnJhbWUpIHtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcih0cnVlID8gXCJSZWFjdERPTVNlcnZlciBkaWQgbm90IGZpbmQgYW4gaW50ZXJuYWwgZmFsbGJhY2sgZnJhbWUgZm9yIFN1c3BlbnNlLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiA6IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMzAzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKGZhbGxiYWNrRnJhbWUpO1xuICAgICAgICAgICAgICBvdXRbdGhpcy5zdXNwZW5zZURlcHRoXSArPSAnPCEtLSQhLS0+JzsgLy8gU2tpcCBmbHVzaGluZyBvdXRwdXQgc2luY2Ugd2UncmUgc3dpdGNoaW5nIHRvIHRoZSBmYWxsYmFja1xuXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3V0W3RoaXMuc3VzcGVuc2VEZXB0aF0gKz0gYnVmZmVyZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBGbHVzaCBvdXRwdXRcblxuXG4gICAgICAgICAgb3V0W3RoaXMuc3VzcGVuc2VEZXB0aF0gKz0gZm9vdGVyO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNoaWxkID0gZnJhbWUuY2hpbGRyZW5bZnJhbWUuY2hpbGRJbmRleCsrXTtcbiAgICAgICAgdmFyIG91dEJ1ZmZlciA9ICcnO1xuXG4gICAgICAgIGlmICh0cnVlKSB7XG4gICAgICAgICAgcHVzaEN1cnJlbnREZWJ1Z1N0YWNrKHRoaXMuc3RhY2spOyAvLyBXZSdyZSBzdGFydGluZyB3b3JrIG9uIHRoaXMgZnJhbWUsIHNvIHJlc2V0IGl0cyBpbm5lciBzdGFjay5cblxuICAgICAgICAgIGZyYW1lLmRlYnVnRWxlbWVudFN0YWNrLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIG91dEJ1ZmZlciArPSB0aGlzLnJlbmRlcihjaGlsZCwgZnJhbWUuY29udGV4dCwgZnJhbWUuZG9tTmFtZXNwYWNlKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgaWYgKGVyciAhPSBudWxsICYmIHR5cGVvZiBlcnIudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaWYgKGVuYWJsZVN1c3BlbnNlU2VydmVyUmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgaWYgKCEodGhpcy5zdXNwZW5zZURlcHRoID4gMCkpIHtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcih0cnVlID8gXCJBIFJlYWN0IGNvbXBvbmVudCBzdXNwZW5kZWQgd2hpbGUgcmVuZGVyaW5nLCBidXQgbm8gZmFsbGJhY2sgVUkgd2FzIHNwZWNpZmllZC5cXG5cXG5BZGQgYSA8U3VzcGVuc2UgZmFsbGJhY2s9Li4uPiBjb21wb25lbnQgaGlnaGVyIGluIHRoZSB0cmVlIHRvIHByb3ZpZGUgYSBsb2FkaW5nIGluZGljYXRvciBvciBwbGFjZWhvbGRlciB0byBkaXNwbGF5LlwiIDogZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzNDIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzdXNwZW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKCFmYWxzZSkge1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKHRydWUgPyBcIlJlYWN0RE9NU2VydmVyIGRvZXMgbm90IHlldCBzdXBwb3J0IFN1c3BlbnNlLlwiIDogZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyOTQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAodHJ1ZSkge1xuICAgICAgICAgICAgcG9wQ3VycmVudERlYnVnU3RhY2soKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3V0Lmxlbmd0aCA8PSB0aGlzLnN1c3BlbnNlRGVwdGgpIHtcbiAgICAgICAgICBvdXQucHVzaCgnJyk7XG4gICAgICAgIH1cblxuICAgICAgICBvdXRbdGhpcy5zdXNwZW5zZURlcHRoXSArPSBvdXRCdWZmZXI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXRbMF07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICBzZXRDdXJyZW50UGFydGlhbFJlbmRlcmVyKHByZXZQYXJ0aWFsUmVuZGVyZXIpO1xuICAgICAgcmVzZXRIb29rc1N0YXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoY2hpbGQsIGNvbnRleHQsIHBhcmVudE5hbWVzcGFjZSkge1xuICAgIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHZhciB0ZXh0ID0gJycgKyBjaGlsZDtcblxuICAgICAgaWYgKHRleHQgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubWFrZVN0YXRpY01hcmt1cCkge1xuICAgICAgICByZXR1cm4gZXNjYXBlVGV4dEZvckJyb3dzZXIodGV4dCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnByZXZpb3VzV2FzVGV4dE5vZGUpIHtcbiAgICAgICAgcmV0dXJuICc8IS0tIC0tPicgKyBlc2NhcGVUZXh0Rm9yQnJvd3Nlcih0ZXh0KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wcmV2aW91c1dhc1RleHROb2RlID0gdHJ1ZTtcbiAgICAgIHJldHVybiBlc2NhcGVUZXh0Rm9yQnJvd3Nlcih0ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG5leHRDaGlsZDtcblxuICAgICAgdmFyIF9yZXNvbHZlID0gcmVzb2x2ZShjaGlsZCwgY29udGV4dCwgdGhpcy50aHJlYWRJRCk7XG5cbiAgICAgIG5leHRDaGlsZCA9IF9yZXNvbHZlLmNoaWxkO1xuICAgICAgY29udGV4dCA9IF9yZXNvbHZlLmNvbnRleHQ7XG5cbiAgICAgIGlmIChuZXh0Q2hpbGQgPT09IG51bGwgfHwgbmV4dENoaWxkID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9IGVsc2UgaWYgKCFSZWFjdC5pc1ZhbGlkRWxlbWVudChuZXh0Q2hpbGQpKSB7XG4gICAgICAgIGlmIChuZXh0Q2hpbGQgIT0gbnVsbCAmJiBuZXh0Q2hpbGQuJCR0eXBlb2YgIT0gbnVsbCkge1xuICAgICAgICAgIC8vIENhdGNoIHVuZXhwZWN0ZWQgc3BlY2lhbCB0eXBlcyBlYXJseS5cbiAgICAgICAgICB2YXIgJCR0eXBlb2YgPSBuZXh0Q2hpbGQuJCR0eXBlb2Y7XG5cbiAgICAgICAgICBpZiAoISgkJHR5cGVvZiAhPT0gUkVBQ1RfUE9SVEFMX1RZUEUpKSB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCBcIlBvcnRhbHMgYXJlIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkIGJ5IHRoZSBzZXJ2ZXIgcmVuZGVyZXIuIFJlbmRlciB0aGVtIGNvbmRpdGlvbmFsbHkgc28gdGhhdCB0aGV5IG9ubHkgYXBwZWFyIG9uIHRoZSBjbGllbnQgcmVuZGVyLlwiICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBDYXRjaC1hbGwgdG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wIGlmIFJlYWN0LkNoaWxkcmVuLnRvQXJyYXkoKSBzdXBwb3J0cyBzb21lIG5ldyB0eXBlLlxuXG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCBcIlVua25vd24gZWxlbWVudC1saWtlIG9iamVjdCB0eXBlOiBcIiArICQkdHlwZW9mLnRvU3RyaW5nKCkgKyBcIi4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5leHRDaGlsZHJlbiA9IHRvQXJyYXkobmV4dENoaWxkKTtcbiAgICAgICAgdmFyIGZyYW1lID0ge1xuICAgICAgICAgIHR5cGU6IG51bGwsXG4gICAgICAgICAgZG9tTmFtZXNwYWNlOiBwYXJlbnROYW1lc3BhY2UsXG4gICAgICAgICAgY2hpbGRyZW46IG5leHRDaGlsZHJlbixcbiAgICAgICAgICBjaGlsZEluZGV4OiAwLFxuICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgZm9vdGVyOiAnJ1xuICAgICAgICB9O1xuXG4gICAgICAgIHtcbiAgICAgICAgICBmcmFtZS5kZWJ1Z0VsZW1lbnRTdGFjayA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdGFjay5wdXNoKGZyYW1lKTtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfSAvLyBTYWZlIGJlY2F1c2Ugd2UganVzdCBjaGVja2VkIGl0J3MgYW4gZWxlbWVudC5cblxuXG4gICAgICB2YXIgbmV4dEVsZW1lbnQgPSBuZXh0Q2hpbGQ7XG4gICAgICB2YXIgZWxlbWVudFR5cGUgPSBuZXh0RWxlbWVudC50eXBlO1xuXG4gICAgICBpZiAodHlwZW9mIGVsZW1lbnRUeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJET00obmV4dEVsZW1lbnQsIGNvbnRleHQsIHBhcmVudE5hbWVzcGFjZSk7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoZWxlbWVudFR5cGUpIHtcbiAgICAgICAgLy8gVE9ETzogTGVnYWN5SGlkZGVuIGFjdHMgdGhlIHNhbWUgYXMgYSBmcmFnbWVudC4gVGhpcyBvbmx5IHdvcmtzXG4gICAgICAgIC8vIGJlY2F1c2Ugd2UgY3VycmVudGx5IGFzc3VtZSB0aGF0IGV2ZXJ5IGluc3RhbmNlIG9mIExlZ2FjeUhpZGRlbiBpc1xuICAgICAgICAvLyBhY2NvbXBhbmllZCBieSBhIGhvc3QgY29tcG9uZW50IHdyYXBwZXIuIEluIHRoZSBoaWRkZW4gbW9kZSwgdGhlIGhvc3RcbiAgICAgICAgLy8gY29tcG9uZW50IGlzIGdpdmVuIGEgYGhpZGRlbmAgYXR0cmlidXRlLCB3aGljaCBlbnN1cmVzIHRoYXQgdGhlXG4gICAgICAgIC8vIGluaXRpYWwgSFRNTCBpcyBub3QgdmlzaWJsZS4gVG8gc3VwcG9ydCB0aGUgdXNlIG9mIExlZ2FjeUhpZGRlbiBhcyBhXG4gICAgICAgIC8vIHRydWUgZnJhZ21lbnQsIHdpdGhvdXQgYW4gZXh0cmEgRE9NIG5vZGUsIHdlIHdvdWxkIGhhdmUgdG8gaGlkZSB0aGVcbiAgICAgICAgLy8gaW5pdGlhbCBIVE1MIGluIHNvbWUgb3RoZXIgd2F5LlxuICAgICAgICBjYXNlIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRTpcbiAgICAgICAgY2FzZSBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRTpcbiAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9uZXh0Q2hpbGRyZW4gPSB0b0FycmF5KG5leHRDaGlsZC5wcm9wcy5jaGlsZHJlbik7XG5cbiAgICAgICAgICAgIHZhciBfZnJhbWUgPSB7XG4gICAgICAgICAgICAgIHR5cGU6IG51bGwsXG4gICAgICAgICAgICAgIGRvbU5hbWVzcGFjZTogcGFyZW50TmFtZXNwYWNlLFxuICAgICAgICAgICAgICBjaGlsZHJlbjogX25leHRDaGlsZHJlbixcbiAgICAgICAgICAgICAgY2hpbGRJbmRleDogMCxcbiAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgICAgZm9vdGVyOiAnJ1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBfZnJhbWUuZGVidWdFbGVtZW50U3RhY2sgPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKF9mcmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvciggXCJSZWFjdERPTVNlcnZlciBkb2VzIG5vdCB5ZXQgc3VwcG9ydCBTdXNwZW5zZS5cIiApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lLW5vLWZhbGx0aHJvdWdoXG5cbiAgICAgICAgY2FzZSBSRUFDVF9TQ09QRV9UWVBFOlxuICAgICAgICAgIHtcblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiUmVhY3RET01TZXJ2ZXIgZG9lcyBub3QgeWV0IHN1cHBvcnQgc2NvcGUgY29tcG9uZW50cy5cIiApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGVsZW1lbnRUeXBlID09PSAnb2JqZWN0JyAmJiBlbGVtZW50VHlwZSAhPT0gbnVsbCkge1xuICAgICAgICBzd2l0Y2ggKGVsZW1lbnRUeXBlLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IG5leHRDaGlsZDtcblxuICAgICAgICAgICAgICB2YXIgX25leHRDaGlsZHJlbjU7XG5cbiAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudElkZW50aXR5ID0ge307XG4gICAgICAgICAgICAgIHByZXBhcmVUb1VzZUhvb2tzKGNvbXBvbmVudElkZW50aXR5KTtcbiAgICAgICAgICAgICAgX25leHRDaGlsZHJlbjUgPSBlbGVtZW50VHlwZS5yZW5kZXIoZWxlbWVudC5wcm9wcywgZWxlbWVudC5yZWYpO1xuICAgICAgICAgICAgICBfbmV4dENoaWxkcmVuNSA9IGZpbmlzaEhvb2tzKGVsZW1lbnRUeXBlLnJlbmRlciwgZWxlbWVudC5wcm9wcywgX25leHRDaGlsZHJlbjUsIGVsZW1lbnQucmVmKTtcbiAgICAgICAgICAgICAgX25leHRDaGlsZHJlbjUgPSB0b0FycmF5KF9uZXh0Q2hpbGRyZW41KTtcbiAgICAgICAgICAgICAgdmFyIF9mcmFtZTUgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogbnVsbCxcbiAgICAgICAgICAgICAgICBkb21OYW1lc3BhY2U6IHBhcmVudE5hbWVzcGFjZSxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogX25leHRDaGlsZHJlbjUsXG4gICAgICAgICAgICAgICAgY2hpbGRJbmRleDogMCxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgICAgIGZvb3RlcjogJydcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgX2ZyYW1lNS5kZWJ1Z0VsZW1lbnRTdGFjayA9IFtdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKF9mcmFtZTUpO1xuICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIF9lbGVtZW50ID0gbmV4dENoaWxkO1xuICAgICAgICAgICAgICB2YXIgX25leHRDaGlsZHJlbjYgPSBbUmVhY3QuY3JlYXRlRWxlbWVudChlbGVtZW50VHlwZS50eXBlLCBfYXNzaWduKHtcbiAgICAgICAgICAgICAgICByZWY6IF9lbGVtZW50LnJlZlxuICAgICAgICAgICAgICB9LCBfZWxlbWVudC5wcm9wcykpXTtcbiAgICAgICAgICAgICAgdmFyIF9mcmFtZTYgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogbnVsbCxcbiAgICAgICAgICAgICAgICBkb21OYW1lc3BhY2U6IHBhcmVudE5hbWVzcGFjZSxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogX25leHRDaGlsZHJlbjYsXG4gICAgICAgICAgICAgICAgY2hpbGRJbmRleDogMCxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgICAgIGZvb3RlcjogJydcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgX2ZyYW1lNi5kZWJ1Z0VsZW1lbnRTdGFjayA9IFtdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKF9mcmFtZTYpO1xuICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBwcm92aWRlciA9IG5leHRDaGlsZDtcbiAgICAgICAgICAgICAgdmFyIG5leHRQcm9wcyA9IHByb3ZpZGVyLnByb3BzO1xuXG4gICAgICAgICAgICAgIHZhciBfbmV4dENoaWxkcmVuNyA9IHRvQXJyYXkobmV4dFByb3BzLmNoaWxkcmVuKTtcblxuICAgICAgICAgICAgICB2YXIgX2ZyYW1lNyA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBwcm92aWRlcixcbiAgICAgICAgICAgICAgICBkb21OYW1lc3BhY2U6IHBhcmVudE5hbWVzcGFjZSxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogX25leHRDaGlsZHJlbjcsXG4gICAgICAgICAgICAgICAgY2hpbGRJbmRleDogMCxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgICAgIGZvb3RlcjogJydcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgX2ZyYW1lNy5kZWJ1Z0VsZW1lbnRTdGFjayA9IFtdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy5wdXNoUHJvdmlkZXIocHJvdmlkZXIpO1xuICAgICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goX2ZyYW1lNyk7XG4gICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgcmVhY3RDb250ZXh0ID0gbmV4dENoaWxkLnR5cGU7IC8vIFRoZSBsb2dpYyBiZWxvdyBmb3IgQ29udGV4dCBkaWZmZXJzIGRlcGVuZGluZyBvbiBQUk9EIG9yIERFViBtb2RlLiBJblxuICAgICAgICAgICAgICAvLyBERVYgbW9kZSwgd2UgY3JlYXRlIGEgc2VwYXJhdGUgb2JqZWN0IGZvciBDb250ZXh0LkNvbnN1bWVyIHRoYXQgYWN0c1xuICAgICAgICAgICAgICAvLyBsaWtlIGEgcHJveHkgdG8gQ29udGV4dC4gVGhpcyBwcm94eSBvYmplY3QgYWRkcyB1bm5lY2Vzc2FyeSBjb2RlIGluIFBST0RcbiAgICAgICAgICAgICAgLy8gc28gd2UgdXNlIHRoZSBvbGQgYmVoYXZpb3VyIChDb250ZXh0LkNvbnN1bWVyIHJlZmVyZW5jZXMgQ29udGV4dCkgdG9cbiAgICAgICAgICAgICAgLy8gcmVkdWNlIHNpemUgYW5kIG92ZXJoZWFkLiBUaGUgc2VwYXJhdGUgb2JqZWN0IHJlZmVyZW5jZXMgY29udGV4dCB2aWFcbiAgICAgICAgICAgICAgLy8gYSBwcm9wZXJ0eSBjYWxsZWQgXCJfY29udGV4dFwiLCB3aGljaCBhbHNvIGdpdmVzIHVzIHRoZSBhYmlsaXR5IHRvIGNoZWNrXG4gICAgICAgICAgICAgIC8vIGluIERFViBtb2RlIGlmIHRoaXMgcHJvcGVydHkgZXhpc3RzIG9yIG5vdCBhbmQgd2FybiBpZiBpdCBkb2VzIG5vdC5cblxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKHJlYWN0Q29udGV4dC5fY29udGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAvLyBUaGlzIG1heSBiZSBiZWNhdXNlIGl0J3MgYSBDb250ZXh0IChyYXRoZXIgdGhhbiBhIENvbnN1bWVyKS5cbiAgICAgICAgICAgICAgICAgIC8vIE9yIGl0IG1heSBiZSBiZWNhdXNlIGl0J3Mgb2xkZXIgUmVhY3Qgd2hlcmUgdGhleSdyZSB0aGUgc2FtZSB0aGluZy5cbiAgICAgICAgICAgICAgICAgIC8vIFdlIG9ubHkgd2FudCB0byB3YXJuIGlmIHdlJ3JlIHN1cmUgaXQncyBhIG5ldyBSZWFjdC5cbiAgICAgICAgICAgICAgICAgIGlmIChyZWFjdENvbnRleHQgIT09IHJlYWN0Q29udGV4dC5Db25zdW1lcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0VXNpbmdDb250ZXh0QXNDb25zdW1lcikge1xuICAgICAgICAgICAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdDb250ZXh0QXNDb25zdW1lciA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICBlcnJvcignUmVuZGVyaW5nIDxDb250ZXh0PiBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gJyArICdhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gcmVuZGVyIDxDb250ZXh0LkNvbnN1bWVyPiBpbnN0ZWFkPycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJlYWN0Q29udGV4dCA9IHJlYWN0Q29udGV4dC5fY29udGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgX25leHRQcm9wcyA9IG5leHRDaGlsZC5wcm9wcztcbiAgICAgICAgICAgICAgdmFyIHRocmVhZElEID0gdGhpcy50aHJlYWRJRDtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDb250ZXh0Qm91bmRzKHJlYWN0Q29udGV4dCwgdGhyZWFkSUQpO1xuICAgICAgICAgICAgICB2YXIgbmV4dFZhbHVlID0gcmVhY3RDb250ZXh0W3RocmVhZElEXTtcblxuICAgICAgICAgICAgICB2YXIgX25leHRDaGlsZHJlbjggPSB0b0FycmF5KF9uZXh0UHJvcHMuY2hpbGRyZW4obmV4dFZhbHVlKSk7XG5cbiAgICAgICAgICAgICAgdmFyIF9mcmFtZTggPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogbmV4dENoaWxkLFxuICAgICAgICAgICAgICAgIGRvbU5hbWVzcGFjZTogcGFyZW50TmFtZXNwYWNlLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBfbmV4dENoaWxkcmVuOCxcbiAgICAgICAgICAgICAgICBjaGlsZEluZGV4OiAwLFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgICAgICAgZm9vdGVyOiAnJ1xuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBfZnJhbWU4LmRlYnVnRWxlbWVudFN0YWNrID0gW107XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goX2ZyYW1lOCk7XG4gICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUtbm8tZmFsbHRocm91Z2hcblxuICAgICAgICAgIGNhc2UgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRTpcbiAgICAgICAgICAgIHtcblxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiUmVhY3RET01TZXJ2ZXIgZG9lcyBub3QgeWV0IHN1cHBvcnQgdGhlIGZ1bmRhbWVudGFsIEFQSS5cIiApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZS1uby1mYWxsdGhyb3VnaFxuXG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBfZWxlbWVudDIgPSBuZXh0Q2hpbGQ7XG4gICAgICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gbmV4dENoaWxkLnR5cGU7IC8vIEF0dGVtcHQgdG8gaW5pdGlhbGl6ZSBsYXp5IGNvbXBvbmVudCByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhlXG4gICAgICAgICAgICAgIC8vIHN1c3BlbnNlIHNlcnZlci1zaWRlIHJlbmRlcmVyIGlzIGVuYWJsZWQgc28gc3luY2hyb25vdXNseVxuICAgICAgICAgICAgICAvLyByZXNvbHZlZCBjb25zdHJ1Y3RvcnMgYXJlIHN1cHBvcnRlZC5cblxuICAgICAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGluaXQocGF5bG9hZCk7XG4gICAgICAgICAgICAgIHZhciBfbmV4dENoaWxkcmVuMTAgPSBbUmVhY3QuY3JlYXRlRWxlbWVudChyZXN1bHQsIF9hc3NpZ24oe1xuICAgICAgICAgICAgICAgIHJlZjogX2VsZW1lbnQyLnJlZlxuICAgICAgICAgICAgICB9LCBfZWxlbWVudDIucHJvcHMpKV07XG4gICAgICAgICAgICAgIHZhciBfZnJhbWUxMCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBudWxsLFxuICAgICAgICAgICAgICAgIGRvbU5hbWVzcGFjZTogcGFyZW50TmFtZXNwYWNlLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBfbmV4dENoaWxkcmVuMTAsXG4gICAgICAgICAgICAgICAgY2hpbGRJbmRleDogMCxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgICAgIGZvb3RlcjogJydcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgX2ZyYW1lMTAuZGVidWdFbGVtZW50U3RhY2sgPSBbXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChfZnJhbWUxMCk7XG4gICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaW5mbyA9ICcnO1xuXG4gICAgICB7XG4gICAgICAgIHZhciBvd25lciA9IG5leHRFbGVtZW50Ll9vd25lcjtcblxuICAgICAgICBpZiAoZWxlbWVudFR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgZWxlbWVudFR5cGUgPT09ICdvYmplY3QnICYmIGVsZW1lbnRUeXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKGVsZW1lbnRUeXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBcIiArICduYW1lZCBpbXBvcnRzLic7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3duZXJOYW1lID0gb3duZXIgPyBnZXRDb21wb25lbnROYW1lKG93bmVyKSA6IG51bGw7XG5cbiAgICAgICAgaWYgKG93bmVyTmFtZSkge1xuICAgICAgICAgIGluZm8gKz0gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgb3duZXJOYW1lICsgJ2AuJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvciggXCJFbGVtZW50IHR5cGUgaXMgaW52YWxpZDogZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciBidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlIGNvbXBvbmVudHMpIGJ1dCBnb3Q6IFwiICsgKGVsZW1lbnRUeXBlID09IG51bGwgPyBlbGVtZW50VHlwZSA6IHR5cGVvZiBlbGVtZW50VHlwZSkgKyBcIi5cIiArIGluZm8gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyRE9NID0gZnVuY3Rpb24gcmVuZGVyRE9NKGVsZW1lbnQsIGNvbnRleHQsIHBhcmVudE5hbWVzcGFjZSkge1xuICAgIHZhciB0YWcgPSBlbGVtZW50LnR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgbmFtZXNwYWNlID0gcGFyZW50TmFtZXNwYWNlO1xuXG4gICAgaWYgKHBhcmVudE5hbWVzcGFjZSA9PT0gTmFtZXNwYWNlcy5odG1sKSB7XG4gICAgICBuYW1lc3BhY2UgPSBnZXRJbnRyaW5zaWNOYW1lc3BhY2UodGFnKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAobmFtZXNwYWNlID09PSBOYW1lc3BhY2VzLmh0bWwpIHtcbiAgICAgICAgLy8gU2hvdWxkIHRoaXMgY2hlY2sgYmUgZ2F0ZWQgYnkgcGFyZW50IG5hbWVzcGFjZT8gTm90IHN1cmUgd2Ugd2FudCB0b1xuICAgICAgICAvLyBhbGxvdyA8U1ZHPiBvciA8bUFUSD4uXG4gICAgICAgIGlmICh0YWcgIT09IGVsZW1lbnQudHlwZSkge1xuICAgICAgICAgIGVycm9yKCc8JXMgLz4gaXMgdXNpbmcgaW5jb3JyZWN0IGNhc2luZy4gJyArICdVc2UgUGFzY2FsQ2FzZSBmb3IgUmVhY3QgY29tcG9uZW50cywgJyArICdvciBsb3dlcmNhc2UgZm9yIEhUTUwgZWxlbWVudHMuJywgZWxlbWVudC50eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhbGlkYXRlRGFuZ2Vyb3VzVGFnKHRhZyk7XG4gICAgdmFyIHByb3BzID0gZWxlbWVudC5wcm9wcztcblxuICAgIGlmICh0YWcgPT09ICdpbnB1dCcpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcygnaW5wdXQnLCBwcm9wcyk7XG5cbiAgICAgICAgaWYgKHByb3BzLmNoZWNrZWQgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0Q2hlY2tlZCAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuRGVmYXVsdENoZWNrZWQpIHtcbiAgICAgICAgICBlcnJvcignJXMgY29udGFpbnMgYW4gaW5wdXQgb2YgdHlwZSAlcyB3aXRoIGJvdGggY2hlY2tlZCBhbmQgZGVmYXVsdENoZWNrZWQgcHJvcHMuICcgKyAnSW5wdXQgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIGNoZWNrZWQgcHJvcCwgb3IgdGhlIGRlZmF1bHRDaGVja2VkIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzJywgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSk7XG5cbiAgICAgICAgICBkaWRXYXJuRGVmYXVsdENoZWNrZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5EZWZhdWx0SW5wdXRWYWx1ZSkge1xuICAgICAgICAgIGVycm9yKCclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCB2YWx1ZSBhbmQgZGVmYXVsdFZhbHVlIHByb3BzLiAnICsgJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzJywgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSk7XG5cbiAgICAgICAgICBkaWRXYXJuRGVmYXVsdElucHV0VmFsdWUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHByb3BzID0gX2Fzc2lnbih7XG4gICAgICAgIHR5cGU6IHVuZGVmaW5lZFxuICAgICAgfSwgcHJvcHMsIHtcbiAgICAgICAgZGVmYXVsdENoZWNrZWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIHZhbHVlOiBwcm9wcy52YWx1ZSAhPSBudWxsID8gcHJvcHMudmFsdWUgOiBwcm9wcy5kZWZhdWx0VmFsdWUsXG4gICAgICAgIGNoZWNrZWQ6IHByb3BzLmNoZWNrZWQgIT0gbnVsbCA/IHByb3BzLmNoZWNrZWQgOiBwcm9wcy5kZWZhdWx0Q2hlY2tlZFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0YWcgPT09ICd0ZXh0YXJlYScpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcygndGV4dGFyZWEnLCBwcm9wcyk7XG5cbiAgICAgICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5EZWZhdWx0VGV4dGFyZWFWYWx1ZSkge1xuICAgICAgICAgIGVycm9yKCdUZXh0YXJlYSBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgdGV4dGFyZWEgJyArICdhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHMnKTtcblxuICAgICAgICAgIGRpZFdhcm5EZWZhdWx0VGV4dGFyZWFWYWx1ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGluaXRpYWxWYWx1ZSA9IHByb3BzLnZhbHVlO1xuXG4gICAgICBpZiAoaW5pdGlhbFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRWYWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZTsgLy8gVE9ETyAoeXVuZ3N0ZXJzKTogUmVtb3ZlIHN1cHBvcnQgZm9yIGNoaWxkcmVuIGNvbnRlbnQgaW4gPHRleHRhcmVhPi5cblxuICAgICAgICB2YXIgdGV4dGFyZWFDaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuXG4gICAgICAgIGlmICh0ZXh0YXJlYUNoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBlcnJvcignVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIGluc3RlYWQgb2Ygc2V0dGluZyAnICsgJ2NoaWxkcmVuIG9uIDx0ZXh0YXJlYT4uJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCEoZGVmYXVsdFZhbHVlID09IG51bGwpKSB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCBcIklmIHlvdSBzdXBwbHkgYGRlZmF1bHRWYWx1ZWAgb24gYSA8dGV4dGFyZWE+LCBkbyBub3QgcGFzcyBjaGlsZHJlbi5cIiApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRleHRhcmVhQ2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBpZiAoISh0ZXh0YXJlYUNoaWxkcmVuLmxlbmd0aCA8PSAxKSkge1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiPHRleHRhcmVhPiBjYW4gb25seSBoYXZlIGF0IG1vc3Qgb25lIGNoaWxkLlwiICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGV4dGFyZWFDaGlsZHJlbiA9IHRleHRhcmVhQ2hpbGRyZW5bMF07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGVmYXVsdFZhbHVlID0gJycgKyB0ZXh0YXJlYUNoaWxkcmVuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgZGVmYXVsdFZhbHVlID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBpbml0aWFsVmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHByb3BzID0gX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgY2hpbGRyZW46ICcnICsgaW5pdGlhbFZhbHVlXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcygnc2VsZWN0JywgcHJvcHMpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVQcm9wTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcHJvcE5hbWUgPSB2YWx1ZVByb3BOYW1lc1tpXTtcblxuICAgICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHByb3BzW3Byb3BOYW1lXSk7XG5cbiAgICAgICAgICBpZiAocHJvcHMubXVsdGlwbGUgJiYgIWlzQXJyYXkpIHtcbiAgICAgICAgICAgIGVycm9yKCdUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYW4gYXJyYXkgaWYgJyArICdgbXVsdGlwbGVgIGlzIHRydWUuJywgcHJvcE5hbWUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXByb3BzLm11bHRpcGxlICYmIGlzQXJyYXkpIHtcbiAgICAgICAgICAgIGVycm9yKCdUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYSBzY2FsYXIgJyArICd2YWx1ZSBpZiBgbXVsdGlwbGVgIGlzIGZhbHNlLicsIHByb3BOYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FybkRlZmF1bHRTZWxlY3RWYWx1ZSkge1xuICAgICAgICAgIGVycm9yKCdTZWxlY3QgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHNlbGVjdCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzJyk7XG5cbiAgICAgICAgICBkaWRXYXJuRGVmYXVsdFNlbGVjdFZhbHVlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmN1cnJlbnRTZWxlY3RWYWx1ZSA9IHByb3BzLnZhbHVlICE9IG51bGwgPyBwcm9wcy52YWx1ZSA6IHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICAgIHByb3BzID0gX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0YWcgPT09ICdvcHRpb24nKSB7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBudWxsO1xuICAgICAgdmFyIHNlbGVjdFZhbHVlID0gdGhpcy5jdXJyZW50U2VsZWN0VmFsdWU7XG4gICAgICB2YXIgb3B0aW9uQ2hpbGRyZW4gPSBmbGF0dGVuT3B0aW9uQ2hpbGRyZW4ocHJvcHMuY2hpbGRyZW4pO1xuXG4gICAgICBpZiAoc2VsZWN0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgICB2YXIgdmFsdWU7XG5cbiAgICAgICAgaWYgKHByb3BzLnZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICB2YWx1ZSA9IHByb3BzLnZhbHVlICsgJyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBvcHRpb25DaGlsZHJlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGVjdGVkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2VsZWN0VmFsdWUpKSB7XG4gICAgICAgICAgLy8gbXVsdGlwbGVcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlbGVjdFZhbHVlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAoJycgKyBzZWxlY3RWYWx1ZVtqXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZWN0ZWQgPSAnJyArIHNlbGVjdFZhbHVlID09PSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb3BzID0gX2Fzc2lnbih7XG4gICAgICAgICAgc2VsZWN0ZWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICBjaGlsZHJlbjogdW5kZWZpbmVkXG4gICAgICAgIH0sIHByb3BzLCB7XG4gICAgICAgICAgc2VsZWN0ZWQ6IHNlbGVjdGVkLFxuICAgICAgICAgIGNoaWxkcmVuOiBvcHRpb25DaGlsZHJlblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB7XG4gICAgICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50KHRhZywgcHJvcHMpO1xuICAgIH1cblxuICAgIGFzc2VydFZhbGlkUHJvcHModGFnLCBwcm9wcyk7XG4gICAgdmFyIG91dCA9IGNyZWF0ZU9wZW5UYWdNYXJrdXAoZWxlbWVudC50eXBlLCB0YWcsIHByb3BzLCBuYW1lc3BhY2UsIHRoaXMubWFrZVN0YXRpY01hcmt1cCwgdGhpcy5zdGFjay5sZW5ndGggPT09IDEpO1xuICAgIHZhciBmb290ZXIgPSAnJztcblxuICAgIGlmIChvbWl0dGVkQ2xvc2VUYWdzLmhhc093blByb3BlcnR5KHRhZykpIHtcbiAgICAgIG91dCArPSAnLz4nO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gJz4nO1xuICAgICAgZm9vdGVyID0gJzwvJyArIGVsZW1lbnQudHlwZSArICc+JztcbiAgICB9XG5cbiAgICB2YXIgY2hpbGRyZW47XG4gICAgdmFyIGlubmVyTWFya3VwID0gZ2V0Tm9uQ2hpbGRyZW5Jbm5lck1hcmt1cChwcm9wcyk7XG5cbiAgICBpZiAoaW5uZXJNYXJrdXAgIT0gbnVsbCkge1xuICAgICAgY2hpbGRyZW4gPSBbXTtcblxuICAgICAgaWYgKG5ld2xpbmVFYXRpbmdUYWdzLmhhc093blByb3BlcnR5KHRhZykgJiYgaW5uZXJNYXJrdXAuY2hhckF0KDApID09PSAnXFxuJykge1xuICAgICAgICAvLyB0ZXh0L2h0bWwgaWdub3JlcyB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIHRoZXNlIHRhZ3MgaWYgaXQncyBhIG5ld2xpbmVcbiAgICAgICAgLy8gUHJlZmVyIHRvIGJyZWFrIGFwcGxpY2F0aW9uL3htbCBvdmVyIHRleHQvaHRtbCAoZm9yIG5vdykgYnkgYWRkaW5nXG4gICAgICAgIC8vIGEgbmV3bGluZSBzcGVjaWZpY2FsbHkgdG8gZ2V0IGVhdGVuIGJ5IHRoZSBwYXJzZXIuIChBbHRlcm5hdGVseSBmb3JcbiAgICAgICAgLy8gdGV4dGFyZWFzLCByZXBsYWNpbmcgXCJeXFxuXCIgd2l0aCBcIlxcclxcblwiIGRvZXNuJ3QgZ2V0IGVhdGVuLCBhbmQgdGhlIGZpcnN0XG4gICAgICAgIC8vIFxcciBpcyBub3JtYWxpemVkIG91dCBieSBIVE1MVGV4dEFyZWFFbGVtZW50I3ZhbHVlLilcbiAgICAgICAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbC1wb2x5Z2xvdC8jbmV3bGluZXMtaW4tdGV4dGFyZWEtYW5kLXByZT5cbiAgICAgICAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjZWxlbWVudC1yZXN0cmljdGlvbnM+XG4gICAgICAgIC8vIFNlZTogPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI25ld2xpbmVzPlxuICAgICAgICAvLyBTZWU6IFBhcnNpbmcgb2YgXCJ0ZXh0YXJlYVwiIFwibGlzdGluZ1wiIGFuZCBcInByZVwiIGVsZW1lbnRzXG4gICAgICAgIC8vICBmcm9tIDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5PlxuICAgICAgICBvdXQgKz0gJ1xcbic7XG4gICAgICB9XG5cbiAgICAgIG91dCArPSBpbm5lck1hcmt1cDtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hpbGRyZW4gPSB0b0FycmF5KHByb3BzLmNoaWxkcmVuKTtcbiAgICB9XG5cbiAgICB2YXIgZnJhbWUgPSB7XG4gICAgICBkb21OYW1lc3BhY2U6IGdldENoaWxkTmFtZXNwYWNlKHBhcmVudE5hbWVzcGFjZSwgZWxlbWVudC50eXBlKSxcbiAgICAgIHR5cGU6IHRhZyxcbiAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICAgIGNoaWxkSW5kZXg6IDAsXG4gICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgZm9vdGVyOiBmb290ZXJcbiAgICB9O1xuXG4gICAge1xuICAgICAgZnJhbWUuZGVidWdFbGVtZW50U3RhY2sgPSBbXTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YWNrLnB1c2goZnJhbWUpO1xuICAgIHRoaXMucHJldmlvdXNXYXNUZXh0Tm9kZSA9IGZhbHNlO1xuICAgIHJldHVybiBvdXQ7XG4gIH07XG5cbiAgcmV0dXJuIFJlYWN0RE9NU2VydmVyUmVuZGVyZXI7XG59KCk7XG5cbi8qKlxuICogUmVuZGVyIGEgUmVhY3RFbGVtZW50IHRvIGl0cyBpbml0aWFsIEhUTUwuIFRoaXMgc2hvdWxkIG9ubHkgYmUgdXNlZCBvbiB0aGVcbiAqIHNlcnZlci5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtZG9tLXNlcnZlci5odG1sI3JlbmRlcnRvc3RyaW5nXG4gKi9cblxuZnVuY3Rpb24gcmVuZGVyVG9TdHJpbmcoZWxlbWVudCwgb3B0aW9ucykge1xuICB2YXIgcmVuZGVyZXIgPSBuZXcgUmVhY3RET01TZXJ2ZXJSZW5kZXJlcihlbGVtZW50LCBmYWxzZSwgb3B0aW9ucyk7XG5cbiAgdHJ5IHtcbiAgICB2YXIgbWFya3VwID0gcmVuZGVyZXIucmVhZChJbmZpbml0eSk7XG4gICAgcmV0dXJuIG1hcmt1cDtcbiAgfSBmaW5hbGx5IHtcbiAgICByZW5kZXJlci5kZXN0cm95KCk7XG4gIH1cbn1cbi8qKlxuICogU2ltaWxhciB0byByZW5kZXJUb1N0cmluZywgZXhjZXB0IHRoaXMgZG9lc24ndCBjcmVhdGUgZXh0cmEgRE9NIGF0dHJpYnV0ZXNcbiAqIHN1Y2ggYXMgZGF0YS1yZWFjdC1pZCB0aGF0IFJlYWN0IHVzZXMgaW50ZXJuYWxseS5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtZG9tLXNlcnZlci5odG1sI3JlbmRlcnRvc3RhdGljbWFya3VwXG4gKi9cblxuZnVuY3Rpb24gcmVuZGVyVG9TdGF0aWNNYXJrdXAoZWxlbWVudCwgb3B0aW9ucykge1xuICB2YXIgcmVuZGVyZXIgPSBuZXcgUmVhY3RET01TZXJ2ZXJSZW5kZXJlcihlbGVtZW50LCB0cnVlLCBvcHRpb25zKTtcblxuICB0cnkge1xuICAgIHZhciBtYXJrdXAgPSByZW5kZXJlci5yZWFkKEluZmluaXR5KTtcbiAgICByZXR1cm4gbWFya3VwO1xuICB9IGZpbmFsbHkge1xuICAgIHJlbmRlcmVyLmRlc3Ryb3koKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gIHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59XG5cbnZhciBSZWFjdE1hcmt1cFJlYWRhYmxlU3RyZWFtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhZGFibGUpIHtcbiAgX2luaGVyaXRzTG9vc2UoUmVhY3RNYXJrdXBSZWFkYWJsZVN0cmVhbSwgX1JlYWRhYmxlKTtcblxuICBmdW5jdGlvbiBSZWFjdE1hcmt1cFJlYWRhYmxlU3RyZWFtKGVsZW1lbnQsIG1ha2VTdGF0aWNNYXJrdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICAvLyBDYWxscyB0aGUgc3RyZWFtLlJlYWRhYmxlKG9wdGlvbnMpIGNvbnN0cnVjdG9yLiBDb25zaWRlciBleHBvc2luZyBidWlsdC1pblxuICAgIC8vIGZlYXR1cmVzIGxpa2UgaGlnaFdhdGVyTWFyayBpbiB0aGUgZnV0dXJlLlxuICAgIF90aGlzID0gX1JlYWRhYmxlLmNhbGwodGhpcywge30pIHx8IHRoaXM7XG4gICAgX3RoaXMucGFydGlhbFJlbmRlcmVyID0gbmV3IFJlYWN0RE9NU2VydmVyUmVuZGVyZXIoZWxlbWVudCwgbWFrZVN0YXRpY01hcmt1cCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFJlYWN0TWFya3VwUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlO1xuXG4gIF9wcm90by5fZGVzdHJveSA9IGZ1bmN0aW9uIF9kZXN0cm95KGVyciwgY2FsbGJhY2spIHtcbiAgICB0aGlzLnBhcnRpYWxSZW5kZXJlci5kZXN0cm95KCk7XG4gICAgY2FsbGJhY2soZXJyKTtcbiAgfTtcblxuICBfcHJvdG8uX3JlYWQgPSBmdW5jdGlvbiBfcmVhZChzaXplKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMucHVzaCh0aGlzLnBhcnRpYWxSZW5kZXJlci5yZWFkKHNpemUpKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuZGVzdHJveShlcnIpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gUmVhY3RNYXJrdXBSZWFkYWJsZVN0cmVhbTtcbn0oc3RyZWFtLlJlYWRhYmxlKTtcbi8qKlxuICogUmVuZGVyIGEgUmVhY3RFbGVtZW50IHRvIGl0cyBpbml0aWFsIEhUTUwuIFRoaXMgc2hvdWxkIG9ubHkgYmUgdXNlZCBvbiB0aGVcbiAqIHNlcnZlci5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtZG9tLXNlcnZlci5odG1sI3JlbmRlcnRvbm9kZXN0cmVhbVxuICovXG5cblxuZnVuY3Rpb24gcmVuZGVyVG9Ob2RlU3RyZWFtKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBSZWFjdE1hcmt1cFJlYWRhYmxlU3RyZWFtKGVsZW1lbnQsIGZhbHNlLCBvcHRpb25zKTtcbn1cbi8qKlxuICogU2ltaWxhciB0byByZW5kZXJUb05vZGVTdHJlYW0sIGV4Y2VwdCB0aGlzIGRvZXNuJ3QgY3JlYXRlIGV4dHJhIERPTSBhdHRyaWJ1dGVzXG4gKiBzdWNoIGFzIGRhdGEtcmVhY3QtaWQgdGhhdCBSZWFjdCB1c2VzIGludGVybmFsbHkuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWRvbS1zZXJ2ZXIuaHRtbCNyZW5kZXJ0b3N0YXRpY25vZGVzdHJlYW1cbiAqL1xuXG5mdW5jdGlvbiByZW5kZXJUb1N0YXRpY05vZGVTdHJlYW0oZWxlbWVudCwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IFJlYWN0TWFya3VwUmVhZGFibGVTdHJlYW0oZWxlbWVudCwgdHJ1ZSwgb3B0aW9ucyk7XG59XG5cbmV4cG9ydHMucmVuZGVyVG9Ob2RlU3RyZWFtID0gcmVuZGVyVG9Ob2RlU3RyZWFtO1xuZXhwb3J0cy5yZW5kZXJUb1N0YXRpY01hcmt1cCA9IHJlbmRlclRvU3RhdGljTWFya3VwO1xuZXhwb3J0cy5yZW5kZXJUb1N0YXRpY05vZGVTdHJlYW0gPSByZW5kZXJUb1N0YXRpY05vZGVTdHJlYW07XG5leHBvcnRzLnJlbmRlclRvU3RyaW5nID0gcmVuZGVyVG9TdHJpbmc7XG5leHBvcnRzLnZlcnNpb24gPSBSZWFjdFZlcnNpb247XG4gIH0pKCk7XG59XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS1zZXJ2ZXIubm9kZS5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20tc2VydmVyLm5vZGUuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiIsICIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zZXJ2ZXIubm9kZScpO1xuIiwgImltcG9ydCB7IGNyZWF0ZVBhZ2VzRnVuY3Rpb25IYW5kbGVyIH0gZnJvbSBcIkByZW1peC1ydW4vY2xvdWRmbGFyZS1wYWdlc1wiO1xuaW1wb3J0ICogYXMgYnVpbGQgZnJvbSBcIkByZW1peC1ydW4vZGV2L3NlcnZlci1idWlsZFwiO1xuXG5jb25zdCBoYW5kbGVSZXF1ZXN0ID0gY3JlYXRlUGFnZXNGdW5jdGlvbkhhbmRsZXIoe1xuICBidWlsZCxcbiAgbW9kZTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYsXG4gIGdldExvYWRDb250ZXh0OiBjb250ZXh0ID0+IGNvbnRleHQuZW52XG59KTtcblxuZXhwb3J0IGZ1bmN0aW9uIG9uUmVxdWVzdChjb250ZXh0KSB7XG4gIHJldHVybiBoYW5kbGVSZXF1ZXN0KGNvbnRleHQpO1xufVxuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9jbG91ZGZsYXJlLXBhZ2VzIHYxLjIuMlxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5pbXBvcnQgeyBpbnN0YWxsR2xvYmFscyB9IGZyb20gJy4vZ2xvYmFscy5qcyc7XG5leHBvcnQgeyBjcmVhdGVDbG91ZGZsYXJlS1ZTZXNzaW9uU3RvcmFnZSB9IGZyb20gJy4vc2Vzc2lvbnMvY2xvdWRmbGFyZUtWU2Vzc2lvblN0b3JhZ2UuanMnO1xuZXhwb3J0IHsgY3JlYXRlUGFnZXNGdW5jdGlvbkhhbmRsZXIsIGNyZWF0ZVJlcXVlc3RIYW5kbGVyIH0gZnJvbSAnLi93b3JrZXIuanMnO1xuXG5pbnN0YWxsR2xvYmFscygpO1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9jbG91ZGZsYXJlLXBhZ2VzIHYxLjIuMlxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5pbXBvcnQgeyBzaWduLCB1bnNpZ24gfSBmcm9tICcuL2Nvb2tpZVNpZ25pbmcuanMnO1xuXG5mdW5jdGlvbiBpbnN0YWxsR2xvYmFscygpIHtcbiAgc2VsZi5zaWduID0gc2lnbjtcbiAgc2VsZi51bnNpZ24gPSB1bnNpZ247XG59XG5cbmV4cG9ydCB7IGluc3RhbGxHbG9iYWxzIH07XG4iLCAiLyoqXG4gKiBAcmVtaXgtcnVuL2Nsb3VkZmxhcmUtcGFnZXMgdjEuMi4yXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbmFzeW5jIGZ1bmN0aW9uIHNpZ24odmFsdWUsIHNlY3JldCkge1xuICBsZXQga2V5ID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoXCJyYXdcIiwgZW5jb2Rlci5lbmNvZGUoc2VjcmV0KSwge1xuICAgIG5hbWU6IFwiSE1BQ1wiLFxuICAgIGhhc2g6IFwiU0hBLTI1NlwiXG4gIH0sIGZhbHNlLCBbXCJzaWduXCJdKTtcbiAgbGV0IGRhdGEgPSBlbmNvZGVyLmVuY29kZSh2YWx1ZSk7XG4gIGxldCBzaWduYXR1cmUgPSBhd2FpdCBjcnlwdG8uc3VidGxlLnNpZ24oXCJITUFDXCIsIGtleSwgZGF0YSk7XG4gIGxldCBoYXNoID0gYnRvYShTdHJpbmcuZnJvbUNoYXJDb2RlKC4uLm5ldyBVaW50OEFycmF5KHNpZ25hdHVyZSkpKS5yZXBsYWNlKC89KyQvLCBcIlwiKTtcbiAgcmV0dXJuIHZhbHVlICsgXCIuXCIgKyBoYXNoO1xufVxuYXN5bmMgZnVuY3Rpb24gdW5zaWduKGNvb2tpZSwgc2VjcmV0KSB7XG4gIGxldCBrZXkgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmltcG9ydEtleShcInJhd1wiLCBlbmNvZGVyLmVuY29kZShzZWNyZXQpLCB7XG4gICAgbmFtZTogXCJITUFDXCIsXG4gICAgaGFzaDogXCJTSEEtMjU2XCJcbiAgfSwgZmFsc2UsIFtcInZlcmlmeVwiXSk7XG4gIGxldCB2YWx1ZSA9IGNvb2tpZS5zbGljZSgwLCBjb29raWUubGFzdEluZGV4T2YoXCIuXCIpKTtcbiAgbGV0IGhhc2ggPSBjb29raWUuc2xpY2UoY29va2llLmxhc3RJbmRleE9mKFwiLlwiKSArIDEpO1xuICBsZXQgZGF0YSA9IGVuY29kZXIuZW5jb2RlKHZhbHVlKTtcbiAgbGV0IHNpZ25hdHVyZSA9IGJ5dGVTdHJpbmdUb1VpbnQ4QXJyYXkoYXRvYihoYXNoKSk7XG4gIGxldCB2YWxpZCA9IGF3YWl0IGNyeXB0by5zdWJ0bGUudmVyaWZ5KFwiSE1BQ1wiLCBrZXksIHNpZ25hdHVyZSwgZGF0YSk7XG4gIHJldHVybiB2YWxpZCA/IHZhbHVlIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGJ5dGVTdHJpbmdUb1VpbnQ4QXJyYXkoYnl0ZVN0cmluZykge1xuICBsZXQgYXJyYXkgPSBuZXcgVWludDhBcnJheShieXRlU3RyaW5nLmxlbmd0aCk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlU3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgYXJyYXlbaV0gPSBieXRlU3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gIH1cblxuICByZXR1cm4gYXJyYXk7XG59XG5cbmV4cG9ydCB7IHNpZ24sIHVuc2lnbiB9O1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9jbG91ZGZsYXJlLXBhZ2VzIHYxLjIuMlxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5pbXBvcnQgeyBjcmVhdGVTZXNzaW9uU3RvcmFnZSB9IGZyb20gJ0ByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBTZXNzaW9uU3RvcmFnZSB0aGF0IHN0b3JlcyBzZXNzaW9uIGRhdGEgaW4gdGhlIENsb3VsZGZsYXJlIEtWIFN0b3JlLlxuICpcbiAqIFRoZSBhZHZhbnRhZ2Ugb2YgdXNpbmcgdGhpcyBpbnN0ZWFkIG9mIGNvb2tpZSBzZXNzaW9uIHN0b3JhZ2UgaXMgdGhhdFxuICogS1YgU3RvcmUgbWF5IGNvbnRhaW4gbXVjaCBtb3JlIGRhdGEgdGhhbiBjb29raWVzLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZW1peC5ydW4vYXBpL3JlbWl4I2NyZWF0ZWNsb3VkZmxhcmVrdnNlc3Npb25zdG9yYWdlLWNsb3VkZmxhcmUtd29ya2Vyc1xuICovXG5mdW5jdGlvbiBjcmVhdGVDbG91ZGZsYXJlS1ZTZXNzaW9uU3RvcmFnZSh7XG4gIGNvb2tpZSxcbiAga3Zcbn0pIHtcbiAgcmV0dXJuIGNyZWF0ZVNlc3Npb25TdG9yYWdlKHtcbiAgICBjb29raWUsXG5cbiAgICBhc3luYyBjcmVhdGVEYXRhKGRhdGEsIGV4cGlyZXMpIHtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGxldCByYW5kb21CeXRlcyA9IG5ldyBVaW50OEFycmF5KDgpO1xuICAgICAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHJhbmRvbUJ5dGVzKTsgLy8gVGhpcyBzdG9yYWdlIG1hbmFnZXMgYW4gaWQgc3BhY2Ugb2YgMl42NCBpZHMsIHdoaWNoIGlzIGZhciBncmVhdGVyXG4gICAgICAgIC8vIHRoYW4gdGhlIG1heGltdW0gbnVtYmVyIG9mIGZpbGVzIGFsbG93ZWQgb24gYW4gTlRGUyBvciBleHQ0IHZvbHVtZVxuICAgICAgICAvLyAoMl4zMikuIEhvd2V2ZXIsIHRoZSBsYXJnZXIgaWQgc3BhY2Ugc2hvdWxkIGhlbHAgdG8gYXZvaWQgY29sbGlzaW9uc1xuICAgICAgICAvLyB3aXRoIGV4aXN0aW5nIGlkcyB3aGVuIGNyZWF0aW5nIG5ldyBzZXNzaW9ucywgd2hpY2ggc3BlZWRzIHRoaW5ncyB1cC5cblxuICAgICAgICBsZXQgaWQgPSBbLi4ucmFuZG9tQnl0ZXNdLm1hcCh4ID0+IHgudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKSkuam9pbihcIlwiKTtcblxuICAgICAgICBpZiAoYXdhaXQga3YuZ2V0KGlkLCBcImpzb25cIikpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF3YWl0IGt2LnB1dChpZCwgSlNPTi5zdHJpbmdpZnkoZGF0YSksIHtcbiAgICAgICAgICBleHBpcmF0aW9uOiBleHBpcmVzID8gTWF0aC5yb3VuZChleHBpcmVzLmdldFRpbWUoKSAvIDEwMDApIDogdW5kZWZpbmVkXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFzeW5jIHJlYWREYXRhKGlkKSB7XG4gICAgICBsZXQgc2Vzc2lvbiA9IGF3YWl0IGt2LmdldChpZCk7XG5cbiAgICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIEpTT04ucGFyc2Uoc2Vzc2lvbik7XG4gICAgfSxcblxuICAgIGFzeW5jIHVwZGF0ZURhdGEoaWQsIGRhdGEsIGV4cGlyZXMpIHtcbiAgICAgIGF3YWl0IGt2LnB1dChpZCwgSlNPTi5zdHJpbmdpZnkoZGF0YSksIHtcbiAgICAgICAgZXhwaXJhdGlvbjogZXhwaXJlcyA/IE1hdGgucm91bmQoZXhwaXJlcy5nZXRUaW1lKCkgLyAxMDAwKSA6IHVuZGVmaW5lZFxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGFzeW5jIGRlbGV0ZURhdGEoaWQpIHtcbiAgICAgIGF3YWl0IGt2LmRlbGV0ZShpZCk7XG4gICAgfVxuXG4gIH0pO1xufVxuXG5leHBvcnQgeyBjcmVhdGVDbG91ZGZsYXJlS1ZTZXNzaW9uU3RvcmFnZSB9O1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZSB2MS4yLjJcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuZXhwb3J0IHsgY3JlYXRlQ29va2llLCBpc0Nvb2tpZSB9IGZyb20gJy4vY29va2llcy5qcyc7XG5leHBvcnQgeyBqc29uLCByZWRpcmVjdCB9IGZyb20gJy4vcmVzcG9uc2VzLmpzJztcbmV4cG9ydCB7IGNyZWF0ZVJlcXVlc3RIYW5kbGVyIH0gZnJvbSAnLi9zZXJ2ZXIuanMnO1xuZXhwb3J0IHsgY3JlYXRlU2Vzc2lvbiwgY3JlYXRlU2Vzc2lvblN0b3JhZ2UsIGlzU2Vzc2lvbiB9IGZyb20gJy4vc2Vzc2lvbnMuanMnO1xuZXhwb3J0IHsgY3JlYXRlQ29va2llU2Vzc2lvblN0b3JhZ2UgfSBmcm9tICcuL3Nlc3Npb25zL2Nvb2tpZVN0b3JhZ2UuanMnO1xuZXhwb3J0IHsgY3JlYXRlTWVtb3J5U2Vzc2lvblN0b3JhZ2UgfSBmcm9tICcuL3Nlc3Npb25zL21lbW9yeVN0b3JhZ2UuanMnO1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZSB2MS4yLjJcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuLyoqXG4gKiBUaGlzIGlzIGEgc2hvcnRjdXQgZm9yIGNyZWF0aW5nIGBhcHBsaWNhdGlvbi9qc29uYCByZXNwb25zZXMuIENvbnZlcnRzIGBkYXRhYFxuICogdG8gSlNPTiBhbmQgc2V0cyB0aGUgYENvbnRlbnQtVHlwZWAgaGVhZGVyLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZW1peC5ydW4vYXBpL3JlbWl4I2pzb25cbiAqL1xuZnVuY3Rpb24ganNvbihkYXRhLCBpbml0ID0ge30pIHtcbiAgbGV0IHJlc3BvbnNlSW5pdCA9IGluaXQ7XG5cbiAgaWYgKHR5cGVvZiBpbml0ID09PSBcIm51bWJlclwiKSB7XG4gICAgcmVzcG9uc2VJbml0ID0ge1xuICAgICAgc3RhdHVzOiBpbml0XG4gICAgfTtcbiAgfVxuXG4gIGxldCBoZWFkZXJzID0gbmV3IEhlYWRlcnMocmVzcG9uc2VJbml0LmhlYWRlcnMpO1xuXG4gIGlmICghaGVhZGVycy5oYXMoXCJDb250ZW50LVR5cGVcIikpIHtcbiAgICBoZWFkZXJzLnNldChcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIik7XG4gIH1cblxuICByZXR1cm4gbmV3IFJlc3BvbnNlKEpTT04uc3RyaW5naWZ5KGRhdGEpLCB7IC4uLnJlc3BvbnNlSW5pdCxcbiAgICBoZWFkZXJzXG4gIH0pO1xufVxuLyoqXG4gKiBBIHJlZGlyZWN0IHJlc3BvbnNlLiBTZXRzIHRoZSBzdGF0dXMgY29kZSBhbmQgdGhlIGBMb2NhdGlvbmAgaGVhZGVyLlxuICogRGVmYXVsdHMgdG8gXCIzMDIgRm91bmRcIi5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVtaXgucnVuL2FwaS9yZW1peCNyZWRpcmVjdFxuICovXG5cbmZ1bmN0aW9uIHJlZGlyZWN0KHVybCwgaW5pdCA9IDMwMikge1xuICBsZXQgcmVzcG9uc2VJbml0ID0gaW5pdDtcblxuICBpZiAodHlwZW9mIHJlc3BvbnNlSW5pdCA9PT0gXCJudW1iZXJcIikge1xuICAgIHJlc3BvbnNlSW5pdCA9IHtcbiAgICAgIHN0YXR1czogcmVzcG9uc2VJbml0XG4gICAgfTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcmVzcG9uc2VJbml0LnN0YXR1cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJlc3BvbnNlSW5pdC5zdGF0dXMgPSAzMDI7XG4gIH1cblxuICBsZXQgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHJlc3BvbnNlSW5pdC5oZWFkZXJzKTtcbiAgaGVhZGVycy5zZXQoXCJMb2NhdGlvblwiLCB1cmwpO1xuICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHsgLi4ucmVzcG9uc2VJbml0LFxuICAgIGhlYWRlcnNcbiAgfSk7XG59XG5mdW5jdGlvbiBpc1Jlc3BvbnNlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZS5zdGF0dXMgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIHZhbHVlLnN0YXR1c1RleHQgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHZhbHVlLmhlYWRlcnMgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlLmJvZHkgIT09IFwidW5kZWZpbmVkXCI7XG59XG5jb25zdCByZWRpcmVjdFN0YXR1c0NvZGVzID0gbmV3IFNldChbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdKTtcbmZ1bmN0aW9uIGlzUmVkaXJlY3RSZXNwb25zZShyZXNwb25zZSkge1xuICByZXR1cm4gcmVkaXJlY3RTdGF0dXNDb2Rlcy5oYXMocmVzcG9uc2Uuc3RhdHVzKTtcbn1cbmZ1bmN0aW9uIGlzQ2F0Y2hSZXNwb25zZShyZXNwb25zZSkge1xuICByZXR1cm4gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJYLVJlbWl4LUNhdGNoXCIpICE9IG51bGw7XG59XG5cbmV4cG9ydCB7IGlzQ2F0Y2hSZXNwb25zZSwgaXNSZWRpcmVjdFJlc3BvbnNlLCBpc1Jlc3BvbnNlLCBqc29uLCByZWRpcmVjdCB9O1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZSB2MS4yLjJcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuaW1wb3J0IHsgY2FsbFJvdXRlQWN0aW9uLCBjYWxsUm91dGVMb2FkZXIsIGV4dHJhY3REYXRhIH0gZnJvbSAnLi9kYXRhLmpzJztcbmltcG9ydCB7IGNyZWF0ZUVudHJ5Um91dGVNb2R1bGVzLCBjcmVhdGVFbnRyeU1hdGNoZXMgfSBmcm9tICcuL2VudHJ5LmpzJztcbmltcG9ydCB7IHNlcmlhbGl6ZUVycm9yIH0gZnJvbSAnLi9lcnJvcnMuanMnO1xuaW1wb3J0IHsgZ2V0RG9jdW1lbnRIZWFkZXJzIH0gZnJvbSAnLi9oZWFkZXJzLmpzJztcbmltcG9ydCB7IG1hdGNoU2VydmVyUm91dGVzIH0gZnJvbSAnLi9yb3V0ZU1hdGNoaW5nLmpzJztcbmltcG9ydCB7IGlzU2VydmVyTW9kZSwgU2VydmVyTW9kZSB9IGZyb20gJy4vbW9kZS5qcyc7XG5pbXBvcnQgeyBjcmVhdGVSb3V0ZXMgfSBmcm9tICcuL3JvdXRlcy5qcyc7XG5pbXBvcnQgeyBpc1JlZGlyZWN0UmVzcG9uc2UsIGlzQ2F0Y2hSZXNwb25zZSwganNvbiB9IGZyb20gJy4vcmVzcG9uc2VzLmpzJztcbmltcG9ydCB7IGNyZWF0ZVNlcnZlckhhbmRvZmZTdHJpbmcgfSBmcm9tICcuL3NlcnZlckhhbmRvZmYuanMnO1xuXG4vKipcbiAqIFRoZSBtYWluIHJlcXVlc3QgaGFuZGxlciBmb3IgYSBSZW1peCBzZXJ2ZXIuIFRoaXMgaGFuZGxlciBydW5zIGluIHRoZSBjb250ZXh0XG4gKiBvZiBhIGNsb3VkIHByb3ZpZGVyJ3Mgc2VydmVyIChlLmcuIEV4cHJlc3Mgb24gRmlyZWJhc2UpIG9yIGxvY2FsbHkgdmlhIHRoZWlyXG4gKiBkZXYgdG9vbHMuXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBzZXJ2ZXMgSFRUUCByZXF1ZXN0cy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUmVxdWVzdEhhbmRsZXIoYnVpbGQsIHBsYXRmb3JtLCBtb2RlKSB7XG4gIGxldCByb3V0ZXMgPSBjcmVhdGVSb3V0ZXMoYnVpbGQucm91dGVzKTtcbiAgbGV0IHNlcnZlck1vZGUgPSBpc1NlcnZlck1vZGUobW9kZSkgPyBtb2RlIDogU2VydmVyTW9kZS5Qcm9kdWN0aW9uO1xuICByZXR1cm4gYXN5bmMgZnVuY3Rpb24gcmVxdWVzdEhhbmRsZXIocmVxdWVzdCwgbG9hZENvbnRleHQpIHtcbiAgICBsZXQgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgbGV0IG1hdGNoZXMgPSBtYXRjaFNlcnZlclJvdXRlcyhyb3V0ZXMsIHVybC5wYXRobmFtZSk7XG4gICAgbGV0IHJlcXVlc3RUeXBlID0gZ2V0UmVxdWVzdFR5cGUodXJsLCBtYXRjaGVzKTtcbiAgICBsZXQgcmVzcG9uc2U7XG5cbiAgICBzd2l0Y2ggKHJlcXVlc3RUeXBlKSB7XG4gICAgICBjYXNlIFwiZGF0YVwiOlxuICAgICAgICByZXNwb25zZSA9IGF3YWl0IGhhbmRsZURhdGFSZXF1ZXN0KHtcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIGxvYWRDb250ZXh0LFxuICAgICAgICAgIG1hdGNoZXM6IG1hdGNoZXMsXG4gICAgICAgICAgaGFuZGxlRGF0YVJlcXVlc3Q6IGJ1aWxkLmVudHJ5Lm1vZHVsZS5oYW5kbGVEYXRhUmVxdWVzdCxcbiAgICAgICAgICBzZXJ2ZXJNb2RlXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcImRvY3VtZW50XCI6XG4gICAgICAgIHJlc3BvbnNlID0gYXdhaXQgcmVuZGVyRG9jdW1lbnRSZXF1ZXN0KHtcbiAgICAgICAgICBidWlsZCxcbiAgICAgICAgICBsb2FkQ29udGV4dCxcbiAgICAgICAgICBtYXRjaGVzLFxuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgcm91dGVzLFxuICAgICAgICAgIHNlcnZlck1vZGVcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwicmVzb3VyY2VcIjpcbiAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBoYW5kbGVSZXNvdXJjZVJlcXVlc3Qoe1xuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgbG9hZENvbnRleHQsXG4gICAgICAgICAgbWF0Y2hlczogbWF0Y2hlcyxcbiAgICAgICAgICBzZXJ2ZXJNb2RlXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAocmVxdWVzdC5tZXRob2QudG9Mb3dlckNhc2UoKSA9PT0gXCJoZWFkXCIpIHtcbiAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge1xuICAgICAgICBoZWFkZXJzOiByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9O1xufVxuXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVEYXRhUmVxdWVzdCh7XG4gIGhhbmRsZURhdGFSZXF1ZXN0LFxuICBsb2FkQ29udGV4dCxcbiAgbWF0Y2hlcyxcbiAgcmVxdWVzdCxcbiAgc2VydmVyTW9kZVxufSkge1xuICBpZiAoIWlzVmFsaWRSZXF1ZXN0TWV0aG9kKHJlcXVlc3QpKSB7XG4gICAgcmV0dXJuIGVycm9yQm91bmRhcnlFcnJvcihuZXcgRXJyb3IoYEludmFsaWQgcmVxdWVzdCBtZXRob2QgXCIke3JlcXVlc3QubWV0aG9kfVwiYCksIDQwNSk7XG4gIH1cblxuICBsZXQgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG5cbiAgaWYgKCFtYXRjaGVzKSB7XG4gICAgcmV0dXJuIGVycm9yQm91bmRhcnlFcnJvcihuZXcgRXJyb3IoYE5vIHJvdXRlIG1hdGNoZXMgVVJMIFwiJHt1cmwucGF0aG5hbWV9XCJgKSwgNDA0KTtcbiAgfVxuXG4gIGxldCByZXNwb25zZTtcbiAgbGV0IG1hdGNoO1xuXG4gIHRyeSB7XG4gICAgaWYgKGlzQWN0aW9uUmVxdWVzdChyZXF1ZXN0KSkge1xuICAgICAgbWF0Y2ggPSBnZXRBY3Rpb25SZXF1ZXN0TWF0Y2godXJsLCBtYXRjaGVzKTtcbiAgICAgIHJlc3BvbnNlID0gYXdhaXQgY2FsbFJvdXRlQWN0aW9uKHtcbiAgICAgICAgbG9hZENvbnRleHQsXG4gICAgICAgIG1hdGNoLFxuICAgICAgICByZXF1ZXN0OiByZXF1ZXN0XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHJvdXRlSWQgPSB1cmwuc2VhcmNoUGFyYW1zLmdldChcIl9kYXRhXCIpO1xuXG4gICAgICBpZiAoIXJvdXRlSWQpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yQm91bmRhcnlFcnJvcihuZXcgRXJyb3IoYE1pc3Npbmcgcm91dGUgaWQgaW4gP19kYXRhYCksIDQwMyk7XG4gICAgICB9XG5cbiAgICAgIGxldCB0ZW1wTWF0Y2ggPSBtYXRjaGVzLmZpbmQobWF0Y2ggPT4gbWF0Y2gucm91dGUuaWQgPT09IHJvdXRlSWQpO1xuXG4gICAgICBpZiAoIXRlbXBNYXRjaCkge1xuICAgICAgICByZXR1cm4gZXJyb3JCb3VuZGFyeUVycm9yKG5ldyBFcnJvcihgUm91dGUgXCIke3JvdXRlSWR9XCIgZG9lcyBub3QgbWF0Y2ggVVJMIFwiJHt1cmwucGF0aG5hbWV9XCJgKSwgNDAzKTtcbiAgICAgIH1cblxuICAgICAgbWF0Y2ggPSB0ZW1wTWF0Y2g7XG4gICAgICByZXNwb25zZSA9IGF3YWl0IGNhbGxSb3V0ZUxvYWRlcih7XG4gICAgICAgIGxvYWRDb250ZXh0LFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgcmVxdWVzdFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGlzUmVkaXJlY3RSZXNwb25zZShyZXNwb25zZSkpIHtcbiAgICAgIC8vIFdlIGRvbid0IGhhdmUgYW55IHdheSB0byBwcmV2ZW50IGEgZmV0Y2ggcmVxdWVzdCBmcm9tIGZvbGxvd2luZ1xuICAgICAgLy8gcmVkaXJlY3RzLiBTbyB3ZSB1c2UgdGhlIGBYLVJlbWl4LVJlZGlyZWN0YCBoZWFkZXIgdG8gaW5kaWNhdGUgdGhlXG4gICAgICAvLyBuZXh0IFVSTCwgYW5kIHRoZW4gXCJmb2xsb3dcIiB0aGUgcmVkaXJlY3QgbWFudWFsbHkgb24gdGhlIGNsaWVudC5cbiAgICAgIGxldCBoZWFkZXJzID0gbmV3IEhlYWRlcnMocmVzcG9uc2UuaGVhZGVycyk7XG4gICAgICBoZWFkZXJzLnNldChcIlgtUmVtaXgtUmVkaXJlY3RcIiwgaGVhZGVycy5nZXQoXCJMb2NhdGlvblwiKSk7XG4gICAgICBoZWFkZXJzLmRlbGV0ZShcIkxvY2F0aW9uXCIpO1xuICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7XG4gICAgICAgIHN0YXR1czogMjA0LFxuICAgICAgICBoZWFkZXJzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoaGFuZGxlRGF0YVJlcXVlc3QpIHtcbiAgICAgIHJlc3BvbnNlID0gYXdhaXQgaGFuZGxlRGF0YVJlcXVlc3QocmVzcG9uc2UuY2xvbmUoKSwge1xuICAgICAgICBjb250ZXh0OiBsb2FkQ29udGV4dCxcbiAgICAgICAgcGFyYW1zOiBtYXRjaC5wYXJhbXMsXG4gICAgICAgIHJlcXVlc3Q6IHJlcXVlc3QuY2xvbmUoKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChzZXJ2ZXJNb2RlICE9PSBTZXJ2ZXJNb2RlLlRlc3QpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIH1cblxuICAgIGlmIChzZXJ2ZXJNb2RlID09PSBTZXJ2ZXJNb2RlLkRldmVsb3BtZW50KSB7XG4gICAgICByZXR1cm4gZXJyb3JCb3VuZGFyeUVycm9yKGVycm9yLCA1MDApO1xuICAgIH1cblxuICAgIHJldHVybiBlcnJvckJvdW5kYXJ5RXJyb3IobmV3IEVycm9yKFwiVW5leHBlY3RlZCBTZXJ2ZXIgRXJyb3JcIiksIDUwMCk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVuZGVyRG9jdW1lbnRSZXF1ZXN0KHtcbiAgYnVpbGQsXG4gIGxvYWRDb250ZXh0LFxuICBtYXRjaGVzLFxuICByZXF1ZXN0LFxuICByb3V0ZXMsXG4gIHNlcnZlck1vZGVcbn0pIHtcbiAgbGV0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICBsZXQgYXBwU3RhdGUgPSB7XG4gICAgdHJhY2tCb3VuZGFyaWVzOiB0cnVlLFxuICAgIHRyYWNrQ2F0Y2hCb3VuZGFyaWVzOiB0cnVlLFxuICAgIGNhdGNoQm91bmRhcnlSb3V0ZUlkOiBudWxsLFxuICAgIHJlbmRlckJvdW5kYXJ5Um91dGVJZDogbnVsbCxcbiAgICBsb2FkZXJCb3VuZGFyeVJvdXRlSWQ6IG51bGwsXG4gICAgZXJyb3I6IHVuZGVmaW5lZCxcbiAgICBjYXRjaDogdW5kZWZpbmVkXG4gIH07XG5cbiAgaWYgKCFpc1ZhbGlkUmVxdWVzdE1ldGhvZChyZXF1ZXN0KSkge1xuICAgIG1hdGNoZXMgPSBudWxsO1xuICAgIGFwcFN0YXRlLnRyYWNrQ2F0Y2hCb3VuZGFyaWVzID0gZmFsc2U7XG4gICAgYXBwU3RhdGUuY2F0Y2ggPSB7XG4gICAgICBkYXRhOiBudWxsLFxuICAgICAgc3RhdHVzOiA0MDUsXG4gICAgICBzdGF0dXNUZXh0OiBcIk1ldGhvZCBOb3QgQWxsb3dlZFwiXG4gICAgfTtcbiAgfSBlbHNlIGlmICghbWF0Y2hlcykge1xuICAgIGFwcFN0YXRlLnRyYWNrQ2F0Y2hCb3VuZGFyaWVzID0gZmFsc2U7XG4gICAgYXBwU3RhdGUuY2F0Y2ggPSB7XG4gICAgICBkYXRhOiBudWxsLFxuICAgICAgc3RhdHVzOiA0MDQsXG4gICAgICBzdGF0dXNUZXh0OiBcIk5vdCBGb3VuZFwiXG4gICAgfTtcbiAgfVxuXG4gIGxldCBhY3Rpb25TdGF0dXM7XG4gIGxldCBhY3Rpb25EYXRhO1xuICBsZXQgYWN0aW9uTWF0Y2g7XG4gIGxldCBhY3Rpb25SZXNwb25zZTtcblxuICBpZiAobWF0Y2hlcyAmJiBpc0FjdGlvblJlcXVlc3QocmVxdWVzdCkpIHtcbiAgICBhY3Rpb25NYXRjaCA9IGdldEFjdGlvblJlcXVlc3RNYXRjaCh1cmwsIG1hdGNoZXMpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGFjdGlvblJlc3BvbnNlID0gYXdhaXQgY2FsbFJvdXRlQWN0aW9uKHtcbiAgICAgICAgbG9hZENvbnRleHQsXG4gICAgICAgIG1hdGNoOiBhY3Rpb25NYXRjaCxcbiAgICAgICAgcmVxdWVzdDogcmVxdWVzdFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChpc1JlZGlyZWN0UmVzcG9uc2UoYWN0aW9uUmVzcG9uc2UpKSB7XG4gICAgICAgIHJldHVybiBhY3Rpb25SZXNwb25zZTtcbiAgICAgIH1cblxuICAgICAgYWN0aW9uU3RhdHVzID0ge1xuICAgICAgICBzdGF0dXM6IGFjdGlvblJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogYWN0aW9uUmVzcG9uc2Uuc3RhdHVzVGV4dFxuICAgICAgfTtcblxuICAgICAgaWYgKGlzQ2F0Y2hSZXNwb25zZShhY3Rpb25SZXNwb25zZSkpIHtcbiAgICAgICAgYXBwU3RhdGUuY2F0Y2hCb3VuZGFyeVJvdXRlSWQgPSBnZXREZWVwZXN0Um91dGVJZFdpdGhCb3VuZGFyeShtYXRjaGVzLCBcIkNhdGNoQm91bmRhcnlcIik7XG4gICAgICAgIGFwcFN0YXRlLnRyYWNrQ2F0Y2hCb3VuZGFyaWVzID0gZmFsc2U7XG4gICAgICAgIGFwcFN0YXRlLmNhdGNoID0geyAuLi5hY3Rpb25TdGF0dXMsXG4gICAgICAgICAgZGF0YTogYXdhaXQgZXh0cmFjdERhdGEoYWN0aW9uUmVzcG9uc2UpXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3Rpb25EYXRhID0ge1xuICAgICAgICAgIFthY3Rpb25NYXRjaC5yb3V0ZS5pZF06IGF3YWl0IGV4dHJhY3REYXRhKGFjdGlvblJlc3BvbnNlKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBhcHBTdGF0ZS5sb2FkZXJCb3VuZGFyeVJvdXRlSWQgPSBnZXREZWVwZXN0Um91dGVJZFdpdGhCb3VuZGFyeShtYXRjaGVzLCBcIkVycm9yQm91bmRhcnlcIik7XG4gICAgICBhcHBTdGF0ZS50cmFja0JvdW5kYXJpZXMgPSBmYWxzZTtcbiAgICAgIGFwcFN0YXRlLmVycm9yID0gYXdhaXQgc2VyaWFsaXplRXJyb3IoZXJyb3IpO1xuXG4gICAgICBpZiAoc2VydmVyTW9kZSAhPT0gU2VydmVyTW9kZS5UZXN0KSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFRoZXJlIHdhcyBhbiBlcnJvciBydW5uaW5nIHRoZSBhY3Rpb24gZm9yIHJvdXRlICR7YWN0aW9uTWF0Y2gucm91dGUuaWR9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbGV0IHJvdXRlTW9kdWxlcyA9IGNyZWF0ZUVudHJ5Um91dGVNb2R1bGVzKGJ1aWxkLnJvdXRlcyk7XG4gIGxldCBtYXRjaGVzVG9Mb2FkID0gbWF0Y2hlcyB8fCBbXTtcblxuICBpZiAoYXBwU3RhdGUuY2F0Y2gpIHtcbiAgICBtYXRjaGVzVG9Mb2FkID0gZ2V0TWF0Y2hlc1VwVG9EZWVwZXN0Qm91bmRhcnkoIC8vIGdldCByaWQgb2YgdGhlIGFjdGlvbiwgd2UgZG9uJ3Qgd2FudCB0byBjYWxsIGl0J3MgbG9hZGVyIGVpdGhlclxuICAgIC8vIGJlY2F1c2Ugd2UnbGwgYmUgcmVuZGVyaW5nIHRoZSBjYXRjaCBib3VuZGFyeSwgaWYgeW91IGNhbiBnZXQgYWNjZXNzXG4gICAgLy8gdG8gdGhlIGxvYWRlciBkYXRhIGluIHRoZSBjYXRjaCBib3VuZGFyeSB0aGVuIGhvdyB0aGUgaGVjayBpcyBpdFxuICAgIC8vIHN1cHBvc2VkIHRvIGRlYWwgd2l0aCB0aHJvd24gcmVzcG9uc2VzP1xuICAgIG1hdGNoZXNUb0xvYWQuc2xpY2UoMCwgLTEpLCBcIkNhdGNoQm91bmRhcnlcIik7XG4gIH0gZWxzZSBpZiAoYXBwU3RhdGUuZXJyb3IpIHtcbiAgICBtYXRjaGVzVG9Mb2FkID0gZ2V0TWF0Y2hlc1VwVG9EZWVwZXN0Qm91bmRhcnkoIC8vIGdldCByaWQgb2YgdGhlIGFjdGlvbiwgd2UgZG9uJ3Qgd2FudCB0byBjYWxsIGl0J3MgbG9hZGVyIGVpdGhlclxuICAgIC8vIGJlY2F1c2Ugd2UnbGwgYmUgcmVuZGVyaW5nIHRoZSBlcnJvciBib3VuZGFyeSwgaWYgeW91IGNhbiBnZXQgYWNjZXNzXG4gICAgLy8gdG8gdGhlIGxvYWRlciBkYXRhIGluIHRoZSBlcnJvciBib3VuZGFyeSB0aGVuIGhvdyB0aGUgaGVjayBpcyBpdFxuICAgIC8vIHN1cHBvc2VkIHRvIGRlYWwgd2l0aCBlcnJvcnMgaW4gdGhlIGxvYWRlciwgdG9vP1xuICAgIG1hdGNoZXNUb0xvYWQuc2xpY2UoMCwgLTEpLCBcIkVycm9yQm91bmRhcnlcIik7XG4gIH1cblxuICBsZXQgcm91dGVMb2FkZXJSZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKG1hdGNoZXNUb0xvYWQubWFwKG1hdGNoID0+IG1hdGNoLnJvdXRlLm1vZHVsZS5sb2FkZXIgPyBjYWxsUm91dGVMb2FkZXIoe1xuICAgIGxvYWRDb250ZXh0LFxuICAgIG1hdGNoLFxuICAgIHJlcXVlc3RcbiAgfSkgOiBQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKSkpOyAvLyBTdG9yZSB0aGUgc3RhdGUgb2YgdGhlIGFjdGlvbi4gV2Ugd2lsbCB1c2UgdGhpcyB0byBkZXRlcm1pbmUgbGF0ZXJcbiAgLy8gd2hhdCBjYXRjaCBvciBlcnJvciBib3VuZGFyeSBzaG91bGQgYmUgcmVuZGVyZWQgdW5kZXIgY2FzZXMgd2hlcmVcbiAgLy8gYWN0aW9ucyBkb24ndCB0aHJvdyBidXQgbG9hZGVycyBkbywgYWN0aW9ucyB0aHJvdyBhbmQgcGFyZW50IGxvYWRlcnNcbiAgLy8gYWxzbyB0aHJvdywgZXRjLlxuXG4gIGxldCBhY3Rpb25DYXRjaCA9IGFwcFN0YXRlLmNhdGNoO1xuICBsZXQgYWN0aW9uRXJyb3IgPSBhcHBTdGF0ZS5lcnJvcjtcbiAgbGV0IGFjdGlvbkNhdGNoQm91bmRhcnlSb3V0ZUlkID0gYXBwU3RhdGUuY2F0Y2hCb3VuZGFyeVJvdXRlSWQ7XG4gIGxldCBhY3Rpb25Mb2FkZXJCb3VuZGFyeVJvdXRlSWQgPSBhcHBTdGF0ZS5sb2FkZXJCb3VuZGFyeVJvdXRlSWQ7IC8vIFJlc2V0IHRoZSBhcHAgZXJyb3IgYW5kIGNhdGNoIHN0YXRlIHRvIHByb3BvZ2F0ZSB0aGUgbG9hZGVyIHN0YXRlc1xuICAvLyBmcm9tIHRoZSByZXN1bHRzIGludG8gdGhlIGFwcCBzdGF0ZS5cblxuICBhcHBTdGF0ZS5jYXRjaCA9IHVuZGVmaW5lZDtcbiAgYXBwU3RhdGUuZXJyb3IgPSB1bmRlZmluZWQ7XG4gIGxldCByb3V0ZUxvYWRlclJlc3BvbnNlcyA9IHt9O1xuICBsZXQgbG9hZGVyU3RhdHVzQ29kZXMgPSBbXTtcbiAgbGV0IHJvdXRlRGF0YSA9IHt9O1xuXG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBtYXRjaGVzVG9Mb2FkLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGxldCBtYXRjaCA9IG1hdGNoZXNUb0xvYWRbaW5kZXhdO1xuICAgIGxldCByZXN1bHQgPSByb3V0ZUxvYWRlclJlc3VsdHNbaW5kZXhdO1xuICAgIGxldCBlcnJvciA9IHJlc3VsdC5zdGF0dXMgPT09IFwicmVqZWN0ZWRcIiA/IHJlc3VsdC5yZWFzb24gOiB1bmRlZmluZWQ7XG4gICAgbGV0IHJlc3BvbnNlID0gcmVzdWx0LnN0YXR1cyA9PT0gXCJmdWxmaWxsZWRcIiA/IHJlc3VsdC52YWx1ZSA6IHVuZGVmaW5lZDtcbiAgICBsZXQgaXNSZWRpcmVjdCA9IHJlc3BvbnNlID8gaXNSZWRpcmVjdFJlc3BvbnNlKHJlc3BvbnNlKSA6IGZhbHNlO1xuICAgIGxldCBpc0NhdGNoID0gcmVzcG9uc2UgPyBpc0NhdGNoUmVzcG9uc2UocmVzcG9uc2UpIDogZmFsc2U7IC8vIElmIGEgcGFyZW50IGxvYWRlciBoYXMgYWxyZWFkeSBjYXVnaHQgb3IgZXJyb3InZCwgYmFpbCBiZWNhdXNlXG4gICAgLy8gd2UgZG9uJ3QgbmVlZCBhbnkgbW9yZSBjaGlsZCBkYXRhLlxuXG4gICAgaWYgKGFwcFN0YXRlLmNhdGNoIHx8IGFwcFN0YXRlLmVycm9yKSB7XG4gICAgICBicmVhaztcbiAgICB9IC8vIElmIHRoZXJlIGlzIGEgcmVzcG9uc2UgYW5kIGl0J3MgYSByZWRpcmVjdCwgZG8gaXQgdW5sZXNzIHRoZXJlXG4gICAgLy8gaXMgYW4gYWN0aW9uIGVycm9yIG9yIGNhdGNoIHN0YXRlLCB0aG9zZSBhY3Rpb24gYm91bmRhcnkgc3RhdGVzXG4gICAgLy8gdGFrZSBwcmVjZWRlbmNlIG92ZXIgbG9hZGVyIHNhdGVzLCB0aGlzIG1lYW5zIGlmIGEgbG9hZGVyIHJlZGlyZWN0c1xuICAgIC8vIGFmdGVyIGFuIGFjdGlvbiBjYXRjaGVzIG9yIGVycm9ycyB3ZSB3b24ndCBmb2xsb3cgaXQsIGFuZCBpbnN0ZWFkXG4gICAgLy8gcmVuZGVyIHRoZSBib3VuZGFyeSBjYXVzZWQgYnkgdGhlIGFjdGlvbi5cblxuXG4gICAgaWYgKCFhY3Rpb25DYXRjaCAmJiAhYWN0aW9uRXJyb3IgJiYgcmVzcG9uc2UgJiYgaXNSZWRpcmVjdCkge1xuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0gLy8gVHJhY2sgdGhlIGJvdW5kYXJ5IElEJ3MgZm9yIHRoZSBsb2FkZXJzXG5cblxuICAgIGlmIChtYXRjaC5yb3V0ZS5tb2R1bGUuQ2F0Y2hCb3VuZGFyeSkge1xuICAgICAgYXBwU3RhdGUuY2F0Y2hCb3VuZGFyeVJvdXRlSWQgPSBtYXRjaC5yb3V0ZS5pZDtcbiAgICB9XG5cbiAgICBpZiAobWF0Y2gucm91dGUubW9kdWxlLkVycm9yQm91bmRhcnkpIHtcbiAgICAgIGFwcFN0YXRlLmxvYWRlckJvdW5kYXJ5Um91dGVJZCA9IG1hdGNoLnJvdXRlLmlkO1xuICAgIH1cblxuICAgIGlmIChlcnJvcikge1xuICAgICAgbG9hZGVyU3RhdHVzQ29kZXMucHVzaCg1MDApO1xuICAgICAgYXBwU3RhdGUudHJhY2tCb3VuZGFyaWVzID0gZmFsc2U7XG4gICAgICBhcHBTdGF0ZS5lcnJvciA9IGF3YWl0IHNlcmlhbGl6ZUVycm9yKGVycm9yKTtcblxuICAgICAgaWYgKHNlcnZlck1vZGUgIT09IFNlcnZlck1vZGUuVGVzdCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBUaGVyZSB3YXMgYW4gZXJyb3IgcnVubmluZyB0aGUgZGF0YSBsb2FkZXIgZm9yIHJvdXRlICR7bWF0Y2gucm91dGUuaWR9YCk7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSBpZiAocmVzcG9uc2UpIHtcbiAgICAgIHJvdXRlTG9hZGVyUmVzcG9uc2VzW21hdGNoLnJvdXRlLmlkXSA9IHJlc3BvbnNlO1xuICAgICAgbG9hZGVyU3RhdHVzQ29kZXMucHVzaChyZXNwb25zZS5zdGF0dXMpO1xuXG4gICAgICBpZiAoaXNDYXRjaCkge1xuICAgICAgICAvLyBJZiBpdCdzIGEgY2F0Y2ggcmVzcG9uc2UsIHN0b3JlIGl0IGluIGFwcCBzdGF0ZSwgYW5kIGJhaWxcbiAgICAgICAgYXBwU3RhdGUudHJhY2tDYXRjaEJvdW5kYXJpZXMgPSBmYWxzZTtcbiAgICAgICAgYXBwU3RhdGUuY2F0Y2ggPSB7XG4gICAgICAgICAgZGF0YTogYXdhaXQgZXh0cmFjdERhdGEocmVzcG9uc2UpLFxuICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlLnN0YXR1c1RleHRcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBFeHRyYWN0IGFuZCBzdG9yZSB0aGUgbG9hZGVyIGRhdGFcbiAgICAgICAgcm91dGVEYXRhW21hdGNoLnJvdXRlLmlkXSA9IGF3YWl0IGV4dHJhY3REYXRhKHJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gSWYgdGhlcmUgd2FzIG5vdCBhIGxvYWRlciBjYXRjaCBvciBlcnJvciBzdGF0ZSB0cmlnZ2VyZWQgcmVzZXQgdGhlXG4gIC8vIGJvdW5kYXJpZXMgYXMgdGhleSBhcmUgcHJvYmFibHkgZGVlcGVyIGluIHRoZSB0cmVlIGlmIHRoZSBhY3Rpb25cbiAgLy8gaW5pdGlhbGx5IHRyaWdnZXJlZCBhIGJvdW5kYXJ5IGFzIHRoYXQgbWF0Y2ggd291bGQgbm90IGV4aXN0IGluIHRoZVxuICAvLyBtYXRjaGVzIHRvIGxvYWQuXG5cblxuICBpZiAoIWFwcFN0YXRlLmNhdGNoKSB7XG4gICAgYXBwU3RhdGUuY2F0Y2hCb3VuZGFyeVJvdXRlSWQgPSBhY3Rpb25DYXRjaEJvdW5kYXJ5Um91dGVJZDtcbiAgfVxuXG4gIGlmICghYXBwU3RhdGUuZXJyb3IpIHtcbiAgICBhcHBTdGF0ZS5sb2FkZXJCb3VuZGFyeVJvdXRlSWQgPSBhY3Rpb25Mb2FkZXJCb3VuZGFyeVJvdXRlSWQ7XG4gIH0gLy8gSWYgdGhlcmUgd2FzIGFuIGFjdGlvbiBlcnJvciBvciBjYXRjaCwgd2Ugd2lsbCByZXNldCB0aGUgc3RhdGUgdG8gdGhlXG4gIC8vIGluaXRpYWwgdmFsdWVzLCBvdGhlcndpc2Ugd2Ugd2lsbCB1c2Ugd2hhdGV2ZXIgY2FtZSBvdXQgb2YgdGhlIGxvYWRlcnMuXG5cblxuICBhcHBTdGF0ZS5jYXRjaCA9IGFjdGlvbkNhdGNoIHx8IGFwcFN0YXRlLmNhdGNoO1xuICBhcHBTdGF0ZS5lcnJvciA9IGFjdGlvbkVycm9yIHx8IGFwcFN0YXRlLmVycm9yO1xuICBsZXQgcmVuZGVyYWJsZU1hdGNoZXMgPSBnZXRSZW5kZXJhYmxlTWF0Y2hlcyhtYXRjaGVzLCBhcHBTdGF0ZSk7XG5cbiAgaWYgKCFyZW5kZXJhYmxlTWF0Y2hlcykge1xuICAgIHJlbmRlcmFibGVNYXRjaGVzID0gW107XG4gICAgbGV0IHJvb3QgPSByb3V0ZXNbMF07XG5cbiAgICBpZiAocm9vdCAhPT0gbnVsbCAmJiByb290ICE9PSB2b2lkIDAgJiYgcm9vdC5tb2R1bGUuQ2F0Y2hCb3VuZGFyeSkge1xuICAgICAgYXBwU3RhdGUuY2F0Y2hCb3VuZGFyeVJvdXRlSWQgPSBcInJvb3RcIjtcbiAgICAgIHJlbmRlcmFibGVNYXRjaGVzLnB1c2goe1xuICAgICAgICBwYXJhbXM6IHt9LFxuICAgICAgICBwYXRobmFtZTogXCJcIixcbiAgICAgICAgcm91dGU6IHJvdXRlc1swXVxuICAgICAgfSk7XG4gICAgfVxuICB9IC8vIEhhbmRsZSByZXNwb25zZXMgd2l0aCBhIG5vbi0yMDAgc3RhdHVzIGNvZGUuIFRoZSBmaXJzdCBsb2FkZXIgd2l0aCBhXG4gIC8vIG5vbi0yMDAgc3RhdHVzIGNvZGUgZGV0ZXJtaW5lcyB0aGUgc3RhdHVzIGNvZGUgZm9yIHRoZSB3aG9sZSByZXNwb25zZS5cblxuXG4gIGxldCBub3RPa1Jlc3BvbnNlID0gYWN0aW9uU3RhdHVzICYmIGFjdGlvblN0YXR1cy5zdGF0dXMgIT09IDIwMCA/IGFjdGlvblN0YXR1cy5zdGF0dXMgOiBsb2FkZXJTdGF0dXNDb2Rlcy5maW5kKHN0YXR1cyA9PiBzdGF0dXMgIT09IDIwMCk7XG4gIGxldCByZXNwb25zZVN0YXR1c0NvZGUgPSBhcHBTdGF0ZS5lcnJvciA/IDUwMCA6IHR5cGVvZiBub3RPa1Jlc3BvbnNlID09PSBcIm51bWJlclwiID8gbm90T2tSZXNwb25zZSA6IGFwcFN0YXRlLmNhdGNoID8gYXBwU3RhdGUuY2F0Y2guc3RhdHVzIDogMjAwO1xuICBsZXQgcmVzcG9uc2VIZWFkZXJzID0gZ2V0RG9jdW1lbnRIZWFkZXJzKGJ1aWxkLCByZW5kZXJhYmxlTWF0Y2hlcywgcm91dGVMb2FkZXJSZXNwb25zZXMsIGFjdGlvblJlc3BvbnNlKTtcbiAgbGV0IGVudHJ5TWF0Y2hlcyA9IGNyZWF0ZUVudHJ5TWF0Y2hlcyhyZW5kZXJhYmxlTWF0Y2hlcywgYnVpbGQuYXNzZXRzLnJvdXRlcyk7XG4gIGxldCBzZXJ2ZXJIYW5kb2ZmID0ge1xuICAgIGFjdGlvbkRhdGEsXG4gICAgYXBwU3RhdGU6IGFwcFN0YXRlLFxuICAgIG1hdGNoZXM6IGVudHJ5TWF0Y2hlcyxcbiAgICByb3V0ZURhdGFcbiAgfTtcbiAgbGV0IGVudHJ5Q29udGV4dCA9IHsgLi4uc2VydmVySGFuZG9mZixcbiAgICBtYW5pZmVzdDogYnVpbGQuYXNzZXRzLFxuICAgIHJvdXRlTW9kdWxlcyxcbiAgICBzZXJ2ZXJIYW5kb2ZmU3RyaW5nOiBjcmVhdGVTZXJ2ZXJIYW5kb2ZmU3RyaW5nKHNlcnZlckhhbmRvZmYpXG4gIH07XG4gIGxldCBoYW5kbGVEb2N1bWVudFJlcXVlc3QgPSBidWlsZC5lbnRyeS5tb2R1bGUuZGVmYXVsdDtcblxuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCBoYW5kbGVEb2N1bWVudFJlcXVlc3QocmVxdWVzdC5jbG9uZSgpLCByZXNwb25zZVN0YXR1c0NvZGUsIHJlc3BvbnNlSGVhZGVycywgZW50cnlDb250ZXh0KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXNwb25zZVN0YXR1c0NvZGUgPSA1MDA7IC8vIEdvIGFnYWluLCB0aGlzIHRpbWUgd2l0aCB0aGUgY29tcG9uZW50RGlkQ2F0Y2ggZW11bGF0aW9uLiBBcyBpdCByZW5kZXJlZFxuICAgIC8vIGxhc3QgdGltZSB3ZSBtdXRhdGVkIGBjb21wb25lbnREaWRDYXRjaC5yb3V0ZUlkYCBmb3IgdGhlIGxhc3QgcmVuZGVyZWRcbiAgICAvLyByb3V0ZSwgbm93IHdlIGtub3cgd2hlcmUgdG8gcmVuZGVyIHRoZSBlcnJvciBib3VuZGFyeSAoZmVlbHMgYSBsaXR0bGVcbiAgICAvLyBoYWNreSBidXQgdGhhdCdzIGhvdyBob29rcyB3b3JrKS4gVGhpcyB0ZWxscyB0aGUgZW11bGF0b3IgdG8gc3RvcFxuICAgIC8vIHRyYWNraW5nIHRoZSBgcm91dGVJZGAgYXMgd2UgcmVuZGVyIGJlY2F1c2Ugd2UgYWxyZWFkeSBoYXZlIGFuIGVycm9yIHRvXG4gICAgLy8gcmVuZGVyLlxuXG4gICAgYXBwU3RhdGUudHJhY2tCb3VuZGFyaWVzID0gZmFsc2U7XG4gICAgYXBwU3RhdGUuZXJyb3IgPSBhd2FpdCBzZXJpYWxpemVFcnJvcihlcnJvcik7XG4gICAgZW50cnlDb250ZXh0LnNlcnZlckhhbmRvZmZTdHJpbmcgPSBjcmVhdGVTZXJ2ZXJIYW5kb2ZmU3RyaW5nKHNlcnZlckhhbmRvZmYpO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBoYW5kbGVEb2N1bWVudFJlcXVlc3QocmVxdWVzdC5jbG9uZSgpLCByZXNwb25zZVN0YXR1c0NvZGUsIHJlc3BvbnNlSGVhZGVycywgZW50cnlDb250ZXh0KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKHNlcnZlck1vZGUgIT09IFNlcnZlck1vZGUuVGVzdCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgIH1cblxuICAgICAgbGV0IG1lc3NhZ2UgPSBcIlVuZXhwZWN0ZWQgU2VydmVyIEVycm9yXCI7XG5cbiAgICAgIGlmIChzZXJ2ZXJNb2RlID09PSBTZXJ2ZXJNb2RlLkRldmVsb3BtZW50KSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gYFxcblxcbiR7U3RyaW5nKGVycm9yKX1gO1xuICAgICAgfSAvLyBHb29kIGdyaWVmIGZvbGtzLCBnZXQgeW91ciBhY3QgdG9nZXRoZXIgXHVEODNEXHVERTAyIVxuXG5cbiAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UobWVzc2FnZSwge1xuICAgICAgICBzdGF0dXM6IDUwMCxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwidGV4dC9wbGFpblwiXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVSZXNvdXJjZVJlcXVlc3Qoe1xuICBsb2FkQ29udGV4dCxcbiAgbWF0Y2hlcyxcbiAgcmVxdWVzdCxcbiAgc2VydmVyTW9kZVxufSkge1xuICBsZXQgbWF0Y2ggPSBtYXRjaGVzLnNsaWNlKC0xKVswXTtcblxuICB0cnkge1xuICAgIGlmIChpc0FjdGlvblJlcXVlc3QocmVxdWVzdCkpIHtcbiAgICAgIHJldHVybiBhd2FpdCBjYWxsUm91dGVBY3Rpb24oe1xuICAgICAgICBtYXRjaCxcbiAgICAgICAgbG9hZENvbnRleHQsXG4gICAgICAgIHJlcXVlc3RcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYXdhaXQgY2FsbFJvdXRlTG9hZGVyKHtcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIGxvYWRDb250ZXh0LFxuICAgICAgICByZXF1ZXN0XG4gICAgICB9KTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKHNlcnZlck1vZGUgIT09IFNlcnZlck1vZGUuVGVzdCkge1xuICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgfVxuXG4gICAgbGV0IG1lc3NhZ2UgPSBcIlVuZXhwZWN0ZWQgU2VydmVyIEVycm9yXCI7XG5cbiAgICBpZiAoc2VydmVyTW9kZSA9PT0gU2VydmVyTW9kZS5EZXZlbG9wbWVudCkge1xuICAgICAgbWVzc2FnZSArPSBgXFxuXFxuJHtTdHJpbmcoZXJyb3IpfWA7XG4gICAgfSAvLyBHb29kIGdyaWVmIGZvbGtzLCBnZXQgeW91ciBhY3QgdG9nZXRoZXIgXHVEODNEXHVERTAyIVxuXG5cbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKG1lc3NhZ2UsIHtcbiAgICAgIHN0YXR1czogNTAwLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcInRleHQvcGxhaW5cIlxuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFJlcXVlc3RUeXBlKHVybCwgbWF0Y2hlcykge1xuICBpZiAodXJsLnNlYXJjaFBhcmFtcy5oYXMoXCJfZGF0YVwiKSkge1xuICAgIHJldHVybiBcImRhdGFcIjtcbiAgfVxuXG4gIGlmICghbWF0Y2hlcykge1xuICAgIHJldHVybiBcImRvY3VtZW50XCI7XG4gIH1cblxuICBsZXQgbWF0Y2ggPSBtYXRjaGVzLnNsaWNlKC0xKVswXTtcblxuICBpZiAoIW1hdGNoLnJvdXRlLm1vZHVsZS5kZWZhdWx0KSB7XG4gICAgcmV0dXJuIFwicmVzb3VyY2VcIjtcbiAgfVxuXG4gIHJldHVybiBcImRvY3VtZW50XCI7XG59XG5cbmZ1bmN0aW9uIGlzQWN0aW9uUmVxdWVzdChyZXF1ZXN0KSB7XG4gIGxldCBtZXRob2QgPSByZXF1ZXN0Lm1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gbWV0aG9kID09PSBcInBvc3RcIiB8fCBtZXRob2QgPT09IFwicHV0XCIgfHwgbWV0aG9kID09PSBcInBhdGNoXCIgfHwgbWV0aG9kID09PSBcImRlbGV0ZVwiO1xufVxuXG5mdW5jdGlvbiBpc0hlYWRSZXF1ZXN0KHJlcXVlc3QpIHtcbiAgcmV0dXJuIHJlcXVlc3QubWV0aG9kLnRvTG93ZXJDYXNlKCkgPT09IFwiaGVhZFwiO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkUmVxdWVzdE1ldGhvZChyZXF1ZXN0KSB7XG4gIHJldHVybiByZXF1ZXN0Lm1ldGhvZC50b0xvd2VyQ2FzZSgpID09PSBcImdldFwiIHx8IGlzSGVhZFJlcXVlc3QocmVxdWVzdCkgfHwgaXNBY3Rpb25SZXF1ZXN0KHJlcXVlc3QpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBlcnJvckJvdW5kYXJ5RXJyb3IoZXJyb3IsIHN0YXR1cykge1xuICByZXR1cm4ganNvbihhd2FpdCBzZXJpYWxpemVFcnJvcihlcnJvciksIHtcbiAgICBzdGF0dXMsXG4gICAgaGVhZGVyczoge1xuICAgICAgXCJYLVJlbWl4LUVycm9yXCI6IFwieWVzXCJcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpc0luZGV4UmVxdWVzdFVybCh1cmwpIHtcbiAgbGV0IGluZGV4UmVxdWVzdCA9IGZhbHNlO1xuXG4gIGZvciAobGV0IHBhcmFtIG9mIHVybC5zZWFyY2hQYXJhbXMuZ2V0QWxsKFwiaW5kZXhcIikpIHtcbiAgICBpZiAoIXBhcmFtKSB7XG4gICAgICBpbmRleFJlcXVlc3QgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbmRleFJlcXVlc3Q7XG59XG5cbmZ1bmN0aW9uIGdldEFjdGlvblJlcXVlc3RNYXRjaCh1cmwsIG1hdGNoZXMpIHtcbiAgbGV0IG1hdGNoID0gbWF0Y2hlcy5zbGljZSgtMSlbMF07XG5cbiAgaWYgKCFpc0luZGV4UmVxdWVzdFVybCh1cmwpICYmIG1hdGNoLnJvdXRlLmlkLmVuZHNXaXRoKFwiL2luZGV4XCIpKSB7XG4gICAgcmV0dXJuIG1hdGNoZXMuc2xpY2UoLTIpWzBdO1xuICB9XG5cbiAgcmV0dXJuIG1hdGNoO1xufVxuXG5mdW5jdGlvbiBnZXREZWVwZXN0Um91dGVJZFdpdGhCb3VuZGFyeShtYXRjaGVzLCBrZXkpIHtcbiAgbGV0IG1hdGNoZWQgPSBnZXRNYXRjaGVzVXBUb0RlZXBlc3RCb3VuZGFyeShtYXRjaGVzLCBrZXkpLnNsaWNlKC0xKVswXTtcbiAgcmV0dXJuIG1hdGNoZWQgPyBtYXRjaGVkLnJvdXRlLmlkIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0TWF0Y2hlc1VwVG9EZWVwZXN0Qm91bmRhcnkobWF0Y2hlcywga2V5KSB7XG4gIGxldCBkZWVwZXN0Qm91bmRhcnlJbmRleCA9IC0xO1xuICBtYXRjaGVzLmZvckVhY2goKG1hdGNoLCBpbmRleCkgPT4ge1xuICAgIGlmIChtYXRjaC5yb3V0ZS5tb2R1bGVba2V5XSkge1xuICAgICAgZGVlcGVzdEJvdW5kYXJ5SW5kZXggPSBpbmRleDtcbiAgICB9XG4gIH0pO1xuXG4gIGlmIChkZWVwZXN0Qm91bmRhcnlJbmRleCA9PT0gLTEpIHtcbiAgICAvLyBubyByb3V0ZSBlcnJvciBib3VuZGFyaWVzLCBkb24ndCBuZWVkIHRvIGNhbGwgYW55IGxvYWRlcnNcbiAgICByZXR1cm4gW107XG4gIH1cblxuICByZXR1cm4gbWF0Y2hlcy5zbGljZSgwLCBkZWVwZXN0Qm91bmRhcnlJbmRleCArIDEpO1xufSAvLyBUaGlzIHByZXZlbnRzIGA8T3V0bGV0Lz5gIGZyb20gcmVuZGVyaW5nIGFueXRoaW5nIGJlbG93IHdoZXJlIHRoZSBlcnJvciB0aHJld1xuLy8gVE9ETzogbWF5YmUgZG8gdGhpcyBpbiA8UmVtaXhFcnJvckJvdW5kYXJ5ICsgY29udGV4dD5cblxuXG5mdW5jdGlvbiBnZXRSZW5kZXJhYmxlTWF0Y2hlcyhtYXRjaGVzLCBhcHBTdGF0ZSkge1xuICBpZiAoIW1hdGNoZXMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBubyBlcnJvciwgbm8gd29ycmllc1xuXG5cbiAgaWYgKCFhcHBTdGF0ZS5jYXRjaCAmJiAhYXBwU3RhdGUuZXJyb3IpIHtcbiAgICByZXR1cm4gbWF0Y2hlcztcbiAgfVxuXG4gIGxldCBsYXN0UmVuZGVyYWJsZUluZGV4ID0gLTE7XG4gIG1hdGNoZXMuZm9yRWFjaCgobWF0Y2gsIGluZGV4KSA9PiB7XG4gICAgbGV0IGlkID0gbWF0Y2gucm91dGUuaWQ7XG5cbiAgICBpZiAoYXBwU3RhdGUucmVuZGVyQm91bmRhcnlSb3V0ZUlkID09PSBpZCB8fCBhcHBTdGF0ZS5sb2FkZXJCb3VuZGFyeVJvdXRlSWQgPT09IGlkIHx8IGFwcFN0YXRlLmNhdGNoQm91bmRhcnlSb3V0ZUlkID09PSBpZCkge1xuICAgICAgbGFzdFJlbmRlcmFibGVJbmRleCA9IGluZGV4O1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBtYXRjaGVzLnNsaWNlKDAsIGxhc3RSZW5kZXJhYmxlSW5kZXggKyAxKTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlUmVxdWVzdEhhbmRsZXIgfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUgdjEuMi4yXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmltcG9ydCB7IGlzUmVzcG9uc2UsIGlzUmVkaXJlY3RSZXNwb25zZSwganNvbiB9IGZyb20gJy4vcmVzcG9uc2VzLmpzJztcblxuLyoqXG4gKiBBbiBvYmplY3Qgb2YgYXJiaXRyYXJ5IGZvciByb3V0ZSBsb2FkZXJzIGFuZCBhY3Rpb25zIHByb3ZpZGVkIGJ5IHRoZVxuICogc2VydmVyJ3MgYGdldExvYWRDb250ZXh0KClgIGZ1bmN0aW9uLlxuICovXG5cbmFzeW5jIGZ1bmN0aW9uIGNhbGxSb3V0ZUFjdGlvbih7XG4gIGxvYWRDb250ZXh0LFxuICBtYXRjaCxcbiAgcmVxdWVzdFxufSkge1xuICBsZXQgYWN0aW9uID0gbWF0Y2gucm91dGUubW9kdWxlLmFjdGlvbjtcblxuICBpZiAoIWFjdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihgWW91IG1hZGUgYSAke3JlcXVlc3QubWV0aG9kfSByZXF1ZXN0IHRvICR7cmVxdWVzdC51cmx9IGJ1dCBkaWQgbm90IHByb3ZpZGUgYCArIGBhbiBcXGBhY3Rpb25cXGAgZm9yIHJvdXRlIFwiJHttYXRjaC5yb3V0ZS5pZH1cIiwgc28gdGhlcmUgaXMgbm8gd2F5IHRvIGhhbmRsZSB0aGUgYCArIGByZXF1ZXN0LmApO1xuICB9XG5cbiAgbGV0IHJlc3VsdDtcblxuICB0cnkge1xuICAgIHJlc3VsdCA9IGF3YWl0IGFjdGlvbih7XG4gICAgICByZXF1ZXN0OiBzdHJpcERhdGFQYXJhbShzdHJpcEluZGV4UGFyYW0ocmVxdWVzdCkpLFxuICAgICAgY29udGV4dDogbG9hZENvbnRleHQsXG4gICAgICBwYXJhbXM6IG1hdGNoLnBhcmFtc1xuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmICghaXNSZXNwb25zZShlcnJvcikpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIGlmICghaXNSZWRpcmVjdFJlc3BvbnNlKGVycm9yKSkge1xuICAgICAgZXJyb3IuaGVhZGVycy5zZXQoXCJYLVJlbWl4LUNhdGNoXCIsIFwieWVzXCIpO1xuICAgIH1cblxuICAgIHJlc3VsdCA9IGVycm9yO1xuICB9XG5cbiAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgZGVmaW5lZCBhbiBhY3Rpb24gZm9yIHJvdXRlIFwiJHttYXRjaC5yb3V0ZS5pZH1cIiBidXQgZGlkbid0IHJldHVybiBgICsgYGFueXRoaW5nIGZyb20geW91ciBcXGBhY3Rpb25cXGAgZnVuY3Rpb24uIFBsZWFzZSByZXR1cm4gYSB2YWx1ZSBvciBcXGBudWxsXFxgLmApO1xuICB9XG5cbiAgcmV0dXJuIGlzUmVzcG9uc2UocmVzdWx0KSA/IHJlc3VsdCA6IGpzb24ocmVzdWx0KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGNhbGxSb3V0ZUxvYWRlcih7XG4gIGxvYWRDb250ZXh0LFxuICBtYXRjaCxcbiAgcmVxdWVzdFxufSkge1xuICBsZXQgbG9hZGVyID0gbWF0Y2gucm91dGUubW9kdWxlLmxvYWRlcjtcblxuICBpZiAoIWxvYWRlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihgWW91IG1hZGUgYSAke3JlcXVlc3QubWV0aG9kfSByZXF1ZXN0IHRvICR7cmVxdWVzdC51cmx9IGJ1dCBkaWQgbm90IHByb3ZpZGUgYCArIGBhIFxcYGxvYWRlclxcYCBmb3Igcm91dGUgXCIke21hdGNoLnJvdXRlLmlkfVwiLCBzbyB0aGVyZSBpcyBubyB3YXkgdG8gaGFuZGxlIHRoZSBgICsgYHJlcXVlc3QuYCk7XG4gIH1cblxuICBsZXQgcmVzdWx0O1xuXG4gIHRyeSB7XG4gICAgcmVzdWx0ID0gYXdhaXQgbG9hZGVyKHtcbiAgICAgIHJlcXVlc3Q6IHN0cmlwRGF0YVBhcmFtKHN0cmlwSW5kZXhQYXJhbShyZXF1ZXN0LmNsb25lKCkpKSxcbiAgICAgIGNvbnRleHQ6IGxvYWRDb250ZXh0LFxuICAgICAgcGFyYW1zOiBtYXRjaC5wYXJhbXNcbiAgICB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoIWlzUmVzcG9uc2UoZXJyb3IpKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICBpZiAoIWlzUmVkaXJlY3RSZXNwb25zZShlcnJvcikpIHtcbiAgICAgIGVycm9yLmhlYWRlcnMuc2V0KFwiWC1SZW1peC1DYXRjaFwiLCBcInllc1wiKTtcbiAgICB9XG5cbiAgICByZXN1bHQgPSBlcnJvcjtcbiAgfVxuXG4gIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgWW91IGRlZmluZWQgYSBsb2FkZXIgZm9yIHJvdXRlIFwiJHttYXRjaC5yb3V0ZS5pZH1cIiBidXQgZGlkbid0IHJldHVybiBgICsgYGFueXRoaW5nIGZyb20geW91ciBcXGBsb2FkZXJcXGAgZnVuY3Rpb24uIFBsZWFzZSByZXR1cm4gYSB2YWx1ZSBvciBcXGBudWxsXFxgLmApO1xuICB9XG5cbiAgcmV0dXJuIGlzUmVzcG9uc2UocmVzdWx0KSA/IHJlc3VsdCA6IGpzb24ocmVzdWx0KTtcbn1cblxuZnVuY3Rpb24gc3RyaXBJbmRleFBhcmFtKHJlcXVlc3QpIHtcbiAgbGV0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICBsZXQgaW5kZXhWYWx1ZXMgPSB1cmwuc2VhcmNoUGFyYW1zLmdldEFsbChcImluZGV4XCIpO1xuICB1cmwuc2VhcmNoUGFyYW1zLmRlbGV0ZShcImluZGV4XCIpO1xuICBsZXQgaW5kZXhWYWx1ZXNUb0tlZXAgPSBbXTtcblxuICBmb3IgKGxldCBpbmRleFZhbHVlIG9mIGluZGV4VmFsdWVzKSB7XG4gICAgaWYgKGluZGV4VmFsdWUpIHtcbiAgICAgIGluZGV4VmFsdWVzVG9LZWVwLnB1c2goaW5kZXhWYWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgZm9yIChsZXQgdG9LZWVwIG9mIGluZGV4VmFsdWVzVG9LZWVwKSB7XG4gICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJpbmRleFwiLCB0b0tlZXApO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBSZXF1ZXN0KHVybC5ocmVmLCByZXF1ZXN0KTtcbn1cblxuZnVuY3Rpb24gc3RyaXBEYXRhUGFyYW0ocmVxdWVzdCkge1xuICBsZXQgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gIHVybC5zZWFyY2hQYXJhbXMuZGVsZXRlKFwiX2RhdGFcIik7XG4gIHJldHVybiBuZXcgUmVxdWVzdCh1cmwuaHJlZiwgcmVxdWVzdCk7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3REYXRhKHJlc3BvbnNlKSB7XG4gIGxldCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiQ29udGVudC1UeXBlXCIpO1xuXG4gIGlmIChjb250ZW50VHlwZSAmJiAvXFxiYXBwbGljYXRpb25cXC9qc29uXFxiLy50ZXN0KGNvbnRlbnRUeXBlKSkge1xuICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gIH0gLy8gV2hhdCBvdGhlciBkYXRhIHR5cGVzIGRvIHdlIG5lZWQgdG8gaGFuZGxlIGhlcmU/IFdoYXQgb3RoZXIga2luZHMgb2ZcbiAgLy8gcmVzcG9uc2VzIGFyZSBwZW9wbGUgZ29pbmcgdG8gYmUgcmV0dXJuaW5nIGZyb20gdGhlaXIgbG9hZGVycz9cbiAgLy8gLSBhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQgP1xuICAvLyAtIG11bHRpcGFydC9mb3JtLWRhdGEgP1xuICAvLyAtIGJpbmFyeSAoYXVkaW8vdmlkZW8pID9cblxuXG4gIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG59XG5cbmV4cG9ydCB7IGNhbGxSb3V0ZUFjdGlvbiwgY2FsbFJvdXRlTG9hZGVyLCBleHRyYWN0RGF0YSB9O1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZSB2MS4yLjJcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRW50cnlNYXRjaGVzKG1hdGNoZXMsIHJvdXRlcykge1xuICByZXR1cm4gbWF0Y2hlcy5tYXAobWF0Y2ggPT4gKHtcbiAgICBwYXJhbXM6IG1hdGNoLnBhcmFtcyxcbiAgICBwYXRobmFtZTogbWF0Y2gucGF0aG5hbWUsXG4gICAgcm91dGU6IHJvdXRlc1ttYXRjaC5yb3V0ZS5pZF1cbiAgfSkpO1xufVxuZnVuY3Rpb24gY3JlYXRlRW50cnlSb3V0ZU1vZHVsZXMobWFuaWZlc3QpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG1hbmlmZXN0KS5yZWR1Y2UoKG1lbW8sIHJvdXRlSWQpID0+IHtcbiAgICBtZW1vW3JvdXRlSWRdID0gbWFuaWZlc3Rbcm91dGVJZF0ubW9kdWxlO1xuICAgIHJldHVybiBtZW1vO1xuICB9LCB7fSk7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZUVudHJ5TWF0Y2hlcywgY3JlYXRlRW50cnlSb3V0ZU1vZHVsZXMgfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUgdjEuMi4yXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbi8qKlxuICogVGhpcyB0aGluZyBwcm9iYWJseSB3YXJyYW50cyBzb21lIGV4cGxhbmF0aW9uLlxuICpcbiAqIFRoZSB3aG9sZSBwb2ludCBoZXJlIGlzIHRvIGVtdWxhdGUgY29tcG9uZW50RGlkQ2F0Y2ggZm9yIHNlcnZlciByZW5kZXJpbmcgYW5kXG4gKiBkYXRhIGxvYWRpbmcuIEl0IGNhbiBnZXQgdHJpY2t5LiBSZWFjdCBjYW4gZG8gdGhpcyBvbiBjb21wb25lbnQgYm91bmRhcmllc1xuICogYnV0IGRvZXNuJ3Qgc3VwcG9ydCBpdCBmb3Igc2VydmVyIHJlbmRlcmluZyBvciBkYXRhIGxvYWRpbmcuIFdlIGtub3cgZW5vdWdoXG4gKiB3aXRoIG5lc3RlZCByb3V0ZXMgdG8gYmUgYWJsZSB0byBlbXVsYXRlIHRoZSBiZWhhdmlvciAoYmVjYXVzZSB3ZSBrbm93IHRoZW1cbiAqIHN0YXRpY2FsbHkgYmVmb3JlIHJlbmRlcmluZy4pXG4gKlxuICogRWFjaCByb3V0ZSBjYW4gZXhwb3J0IGFuIGBFcnJvckJvdW5kYXJ5YC5cbiAqXG4gKiAtIFdoZW4gcmVuZGVyaW5nIHRocm93cyBhbiBlcnJvciwgdGhlIG5lYXJlc3QgZXJyb3IgYm91bmRhcnkgd2lsbCByZW5kZXJcbiAqICAgKG5vcm1hbCByZWFjdCBjb21wb25lbnREaWRDYXRjaCkuIFRoaXMgd2lsbCBiZSB0aGUgcm91dGUncyBvd24gYm91bmRhcnksIGJ1dFxuICogICBpZiBub25lIGlzIHByb3ZpZGVkLCBpdCB3aWxsIGJ1YmJsZSB1cCB0byB0aGUgcGFyZW50cy5cbiAqIC0gV2hlbiBkYXRhIGxvYWRpbmcgdGhyb3dzIGFuIGVycm9yLCB0aGUgbmVhcmVzdCBlcnJvciBib3VuZGFyeSB3aWxsIHJlbmRlclxuICogLSBXaGVuIHBlcmZvcm1pbmcgYW4gYWN0aW9uLCB0aGUgbmVhcmVzdCBlcnJvciBib3VuZGFyeSBmb3IgdGhlIGFjdGlvbidzXG4gKiAgIHJvdXRlIHRyZWUgd2lsbCByZW5kZXIgKG5vIHJlZGlyZWN0IGhhcHBlbnMpXG4gKlxuICogRHVyaW5nIG5vcm1hbCByZWFjdCByZW5kZXJpbmcsIHdlIGRvIG5vdGhpbmcgc3BlY2lhbCwganVzdCBub3JtYWxcbiAqIGNvbXBvbmVudERpZENhdGNoLlxuICpcbiAqIEZvciBzZXJ2ZXIgcmVuZGVyaW5nLCB3ZSBtdXRhdGUgYHJlbmRlckJvdW5kYXJ5Um91dGVJZGAgdG8ga25vdyB0aGUgbGFzdFxuICogbGF5b3V0IHRoYXQgaGFzIGFuIGVycm9yIGJvdW5kYXJ5IHRoYXQgdHJpZWQgdG8gcmVuZGVyLiBUaGlzIGVtdWxhdGVzIHdoaWNoXG4gKiBsYXlvdXQgd291bGQgY2F0Y2ggYSB0aHJvd24gZXJyb3IuIElmIHRoZSByZW5kZXJpbmcgZmFpbHMsIHdlIGNhdGNoIHRoZSBlcnJvclxuICogb24gdGhlIHNlcnZlciwgYW5kIGdvIGFnYWluIGEgc2Vjb25kIHRpbWUgd2l0aCB0aGUgZW11bGF0b3IgaG9sZGluZyBvbiB0byB0aGVcbiAqIGluZm9ybWF0aW9uIGl0IG5lZWRzIHRvIHJlbmRlciB0aGUgc2FtZSBlcnJvciBib3VuZGFyeSBhcyBhIGR5bmFtaWNhbGx5XG4gKiB0aHJvd24gcmVuZGVyIGVycm9yLlxuICpcbiAqIFdoZW4gZGF0YSBsb2FkaW5nLCBzZXJ2ZXIgb3IgY2xpZW50IHNpZGUsIHdlIHVzZSB0aGUgZW11bGF0b3IgdG8gbGlrZXdpc2VcbiAqIGhhbmcgb24gdG8gdGhlIGVycm9yIGFuZCByZS1yZW5kZXIgYXQgdGhlIGFwcHJvcHJpYXRlIGxheW91dCAod2hlcmUgYSB0aHJvd25cbiAqIGVycm9yIHdvdWxkIGhhdmUgYmVlbiBjYXVnaHQgYnkgY0RDKS5cbiAqXG4gKiBXaGVuIGFjdGlvbnMgdGhyb3csIGl0IGFsbCB3b3JrcyB0aGUgc2FtZS4gVGhlcmUncyBhbiBlZGdlIGNhc2UgdG8gYmUgYXdhcmVcbiAqIG9mIHRob3VnaC4gQWN0aW9ucyBub3JtYWxseSBhcmUgcmVxdWlyZWQgdG8gcmVkaXJlY3QsIGJ1dCBpbiB0aGUgY2FzZSBvZlxuICogZXJyb3JzLCB3ZSByZW5kZXIgdGhlIGFjdGlvbidzIHJvdXRlIHdpdGggdGhlIGVtdWxhdG9yIGhvbGRpbmcgb24gdG8gdGhlXG4gKiBlcnJvci4gSWYgZHVyaW5nIHRoaXMgcmVuZGVyIGEgcGFyZW50IHJvdXRlL2xvYWRlciB0aHJvd3Mgd2UgaWdub3JlIHRoYXQgbmV3XG4gKiBlcnJvciBhbmQgcmVuZGVyIHRoZSBhY3Rpb24ncyBvcmlnaW5hbCBlcnJvciBhcyBkZWVwbHkgYXMgcG9zc2libGUuIEluIG90aGVyXG4gKiB3b3Jkcywgd2Ugc2ltcGx5IGlnbm9yZSB0aGUgbmV3IGVycm9yIGFuZCB1c2UgdGhlIGFjdGlvbidzIGVycm9yIGluIHBsYWNlXG4gKiBiZWNhdXNlIGl0IGNhbWUgZmlyc3QsIGFuZCB0aGF0IGp1c3Qgd291bGRuJ3QgYmUgZmFpciB0byBsZXQgZXJyb3JzIGN1dCBpblxuICogbGluZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2VyaWFsaXplRXJyb3IoZXJyb3IpIHtcbiAgcmV0dXJuIHtcbiAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgIHN0YWNrOiBlcnJvci5zdGFja1xuICB9O1xufVxuXG5leHBvcnQgeyBzZXJpYWxpemVFcnJvciB9O1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZSB2MS4yLjJcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuaW1wb3J0IHsgc3BsaXRDb29raWVzU3RyaW5nIH0gZnJvbSAnc2V0LWNvb2tpZS1wYXJzZXInO1xuXG5mdW5jdGlvbiBnZXREb2N1bWVudEhlYWRlcnMoYnVpbGQsIG1hdGNoZXMsIHJvdXRlTG9hZGVyUmVzcG9uc2VzLCBhY3Rpb25SZXNwb25zZSkge1xuICByZXR1cm4gbWF0Y2hlcy5yZWR1Y2UoKHBhcmVudEhlYWRlcnMsIG1hdGNoLCBpbmRleCkgPT4ge1xuICAgIGxldCByb3V0ZU1vZHVsZSA9IGJ1aWxkLnJvdXRlc1ttYXRjaC5yb3V0ZS5pZF0ubW9kdWxlO1xuICAgIGxldCByb3V0ZUxvYWRlclJlc3BvbnNlID0gcm91dGVMb2FkZXJSZXNwb25zZXNbbWF0Y2gucm91dGUuaWRdO1xuICAgIGxldCBsb2FkZXJIZWFkZXJzID0gcm91dGVMb2FkZXJSZXNwb25zZSA/IHJvdXRlTG9hZGVyUmVzcG9uc2UuaGVhZGVycyA6IG5ldyBIZWFkZXJzKCk7XG4gICAgbGV0IGFjdGlvbkhlYWRlcnMgPSBhY3Rpb25SZXNwb25zZSA/IGFjdGlvblJlc3BvbnNlLmhlYWRlcnMgOiBuZXcgSGVhZGVycygpO1xuICAgIGxldCBoZWFkZXJzID0gbmV3IEhlYWRlcnMocm91dGVNb2R1bGUuaGVhZGVycyA/IHR5cGVvZiByb3V0ZU1vZHVsZS5oZWFkZXJzID09PSBcImZ1bmN0aW9uXCIgPyByb3V0ZU1vZHVsZS5oZWFkZXJzKHtcbiAgICAgIGxvYWRlckhlYWRlcnMsXG4gICAgICBwYXJlbnRIZWFkZXJzLFxuICAgICAgYWN0aW9uSGVhZGVyc1xuICAgIH0pIDogcm91dGVNb2R1bGUuaGVhZGVycyA6IHVuZGVmaW5lZCk7IC8vIEF1dG9tYXRpY2FsbHkgcHJlc2VydmUgU2V0LUNvb2tpZSBoZWFkZXJzIHRoYXQgd2VyZSBzZXQgZWl0aGVyIGJ5IHRoZVxuICAgIC8vIGxvYWRlciBvciBieSBhIHBhcmVudCByb3V0ZS5cblxuICAgIHByZXBlbmRDb29raWVzKGFjdGlvbkhlYWRlcnMsIGhlYWRlcnMpO1xuICAgIHByZXBlbmRDb29raWVzKGxvYWRlckhlYWRlcnMsIGhlYWRlcnMpO1xuICAgIHByZXBlbmRDb29raWVzKHBhcmVudEhlYWRlcnMsIGhlYWRlcnMpO1xuICAgIHJldHVybiBoZWFkZXJzO1xuICB9LCBuZXcgSGVhZGVycygpKTtcbn1cblxuZnVuY3Rpb24gcHJlcGVuZENvb2tpZXMocGFyZW50SGVhZGVycywgY2hpbGRIZWFkZXJzKSB7XG4gIGxldCBwYXJlbnRTZXRDb29raWVTdHJpbmcgPSBwYXJlbnRIZWFkZXJzLmdldChcIlNldC1Db29raWVcIik7XG5cbiAgaWYgKHBhcmVudFNldENvb2tpZVN0cmluZykge1xuICAgIGxldCBjb29raWVzID0gc3BsaXRDb29raWVzU3RyaW5nKHBhcmVudFNldENvb2tpZVN0cmluZyk7XG4gICAgY29va2llcy5mb3JFYWNoKGNvb2tpZSA9PiB7XG4gICAgICBjaGlsZEhlYWRlcnMuYXBwZW5kKFwiU2V0LUNvb2tpZVwiLCBjb29raWUpO1xuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCB7IGdldERvY3VtZW50SGVhZGVycyB9O1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZSB2MS4yLjJcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuaW1wb3J0IHsgbWF0Y2hSb3V0ZXMgfSBmcm9tICdyZWFjdC1yb3V0ZXItZG9tJztcblxuLy8gVE9ETzogZXhwb3J0L2ltcG9ydCBmcm9tIHJlYWN0LXJvdXRlci1kb21cbmZ1bmN0aW9uIG1hdGNoU2VydmVyUm91dGVzKHJvdXRlcywgcGF0aG5hbWUpIHtcbiAgbGV0IG1hdGNoZXMgPSBtYXRjaFJvdXRlcyhyb3V0ZXMsIHBhdGhuYW1lKTtcbiAgaWYgKCFtYXRjaGVzKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIG1hdGNoZXMubWFwKG1hdGNoID0+ICh7XG4gICAgcGFyYW1zOiBtYXRjaC5wYXJhbXMsXG4gICAgcGF0aG5hbWU6IG1hdGNoLnBhdGhuYW1lLFxuICAgIHJvdXRlOiBtYXRjaC5yb3V0ZVxuICB9KSk7XG59XG5cbmV4cG9ydCB7IG1hdGNoU2VydmVyUm91dGVzIH07XG4iLCAiaW1wb3J0IF9leHRlbmRzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMnO1xuXG4vKipcclxuICogQWN0aW9ucyByZXByZXNlbnQgdGhlIHR5cGUgb2YgY2hhbmdlIHRvIGEgbG9jYXRpb24gdmFsdWUuXHJcbiAqXHJcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9oaXN0b3J5L3RyZWUvbWFpbi9kb2NzL2FwaS1yZWZlcmVuY2UubWQjYWN0aW9uXHJcbiAqL1xudmFyIEFjdGlvbjtcblxuKGZ1bmN0aW9uIChBY3Rpb24pIHtcbiAgLyoqXHJcbiAgICogQSBQT1AgaW5kaWNhdGVzIGEgY2hhbmdlIHRvIGFuIGFyYml0cmFyeSBpbmRleCBpbiB0aGUgaGlzdG9yeSBzdGFjaywgc3VjaFxyXG4gICAqIGFzIGEgYmFjayBvciBmb3J3YXJkIG5hdmlnYXRpb24uIEl0IGRvZXMgbm90IGRlc2NyaWJlIHRoZSBkaXJlY3Rpb24gb2YgdGhlXHJcbiAgICogbmF2aWdhdGlvbiwgb25seSB0aGF0IHRoZSBjdXJyZW50IGluZGV4IGNoYW5nZWQuXHJcbiAgICpcclxuICAgKiBOb3RlOiBUaGlzIGlzIHRoZSBkZWZhdWx0IGFjdGlvbiBmb3IgbmV3bHkgY3JlYXRlZCBoaXN0b3J5IG9iamVjdHMuXHJcbiAgICovXG4gIEFjdGlvbltcIlBvcFwiXSA9IFwiUE9QXCI7XG4gIC8qKlxyXG4gICAqIEEgUFVTSCBpbmRpY2F0ZXMgYSBuZXcgZW50cnkgYmVpbmcgYWRkZWQgdG8gdGhlIGhpc3Rvcnkgc3RhY2ssIHN1Y2ggYXMgd2hlblxyXG4gICAqIGEgbGluayBpcyBjbGlja2VkIGFuZCBhIG5ldyBwYWdlIGxvYWRzLiBXaGVuIHRoaXMgaGFwcGVucywgYWxsIHN1YnNlcXVlbnRcclxuICAgKiBlbnRyaWVzIGluIHRoZSBzdGFjayBhcmUgbG9zdC5cclxuICAgKi9cblxuICBBY3Rpb25bXCJQdXNoXCJdID0gXCJQVVNIXCI7XG4gIC8qKlxyXG4gICAqIEEgUkVQTEFDRSBpbmRpY2F0ZXMgdGhlIGVudHJ5IGF0IHRoZSBjdXJyZW50IGluZGV4IGluIHRoZSBoaXN0b3J5IHN0YWNrXHJcbiAgICogYmVpbmcgcmVwbGFjZWQgYnkgYSBuZXcgb25lLlxyXG4gICAqL1xuXG4gIEFjdGlvbltcIlJlcGxhY2VcIl0gPSBcIlJFUExBQ0VcIjtcbn0pKEFjdGlvbiB8fCAoQWN0aW9uID0ge30pKTtcblxudmFyIHJlYWRPbmx5ID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShvYmopO1xufSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iajtcbn07XG5cbmZ1bmN0aW9uIHdhcm5pbmcoY29uZCwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIGNvbnNvbGUud2FybihtZXNzYWdlKTtcblxuICAgIHRyeSB7XG4gICAgICAvLyBXZWxjb21lIHRvIGRlYnVnZ2luZyBoaXN0b3J5IVxuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgZXJyb3IgaXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28geW91IGNhbiBtb3JlIGVhc2lseVxuICAgICAgLy8gZmluZCB0aGUgc291cmNlIGZvciBhIHdhcm5pbmcgdGhhdCBhcHBlYXJzIGluIHRoZSBjb25zb2xlIGJ5XG4gICAgICAvLyBlbmFibGluZyBcInBhdXNlIG9uIGV4Y2VwdGlvbnNcIiBpbiB5b3VyIEphdmFTY3JpcHQgZGVidWdnZXIuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbn1cblxudmFyIEJlZm9yZVVubG9hZEV2ZW50VHlwZSA9ICdiZWZvcmV1bmxvYWQnO1xudmFyIEhhc2hDaGFuZ2VFdmVudFR5cGUgPSAnaGFzaGNoYW5nZSc7XG52YXIgUG9wU3RhdGVFdmVudFR5cGUgPSAncG9wc3RhdGUnO1xuLyoqXHJcbiAqIEJyb3dzZXIgaGlzdG9yeSBzdG9yZXMgdGhlIGxvY2F0aW9uIGluIHJlZ3VsYXIgVVJMcy4gVGhpcyBpcyB0aGUgc3RhbmRhcmQgZm9yXHJcbiAqIG1vc3Qgd2ViIGFwcHMsIGJ1dCBpdCByZXF1aXJlcyBzb21lIGNvbmZpZ3VyYXRpb24gb24gdGhlIHNlcnZlciB0byBlbnN1cmUgeW91XHJcbiAqIHNlcnZlIHRoZSBzYW1lIGFwcCBhdCBtdWx0aXBsZSBVUkxzLlxyXG4gKlxyXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vaGlzdG9yeS90cmVlL21haW4vZG9jcy9hcGktcmVmZXJlbmNlLm1kI2NyZWF0ZWJyb3dzZXJoaXN0b3J5XHJcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVCcm93c2VySGlzdG9yeShvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgX29wdGlvbnMkd2luZG93ID0gX29wdGlvbnMud2luZG93LFxuICAgICAgd2luZG93ID0gX29wdGlvbnMkd2luZG93ID09PSB2b2lkIDAgPyBkb2N1bWVudC5kZWZhdWx0VmlldyA6IF9vcHRpb25zJHdpbmRvdztcbiAgdmFyIGdsb2JhbEhpc3RvcnkgPSB3aW5kb3cuaGlzdG9yeTtcblxuICBmdW5jdGlvbiBnZXRJbmRleEFuZExvY2F0aW9uKCkge1xuICAgIHZhciBfd2luZG93JGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uLFxuICAgICAgICBwYXRobmFtZSA9IF93aW5kb3ckbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICAgIHNlYXJjaCA9IF93aW5kb3ckbG9jYXRpb24uc2VhcmNoLFxuICAgICAgICBoYXNoID0gX3dpbmRvdyRsb2NhdGlvbi5oYXNoO1xuICAgIHZhciBzdGF0ZSA9IGdsb2JhbEhpc3Rvcnkuc3RhdGUgfHwge307XG4gICAgcmV0dXJuIFtzdGF0ZS5pZHgsIHJlYWRPbmx5KHtcbiAgICAgIHBhdGhuYW1lOiBwYXRobmFtZSxcbiAgICAgIHNlYXJjaDogc2VhcmNoLFxuICAgICAgaGFzaDogaGFzaCxcbiAgICAgIHN0YXRlOiBzdGF0ZS51c3IgfHwgbnVsbCxcbiAgICAgIGtleTogc3RhdGUua2V5IHx8ICdkZWZhdWx0J1xuICAgIH0pXTtcbiAgfVxuXG4gIHZhciBibG9ja2VkUG9wVHggPSBudWxsO1xuXG4gIGZ1bmN0aW9uIGhhbmRsZVBvcCgpIHtcbiAgICBpZiAoYmxvY2tlZFBvcFR4KSB7XG4gICAgICBibG9ja2Vycy5jYWxsKGJsb2NrZWRQb3BUeCk7XG4gICAgICBibG9ja2VkUG9wVHggPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbmV4dEFjdGlvbiA9IEFjdGlvbi5Qb3A7XG5cbiAgICAgIHZhciBfZ2V0SW5kZXhBbmRMb2NhdGlvbiA9IGdldEluZGV4QW5kTG9jYXRpb24oKSxcbiAgICAgICAgICBuZXh0SW5kZXggPSBfZ2V0SW5kZXhBbmRMb2NhdGlvblswXSxcbiAgICAgICAgICBuZXh0TG9jYXRpb24gPSBfZ2V0SW5kZXhBbmRMb2NhdGlvblsxXTtcblxuICAgICAgaWYgKGJsb2NrZXJzLmxlbmd0aCkge1xuICAgICAgICBpZiAobmV4dEluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgZGVsdGEgPSBpbmRleCAtIG5leHRJbmRleDtcblxuICAgICAgICAgIGlmIChkZWx0YSkge1xuICAgICAgICAgICAgLy8gUmV2ZXJ0IHRoZSBQT1BcbiAgICAgICAgICAgIGJsb2NrZWRQb3BUeCA9IHtcbiAgICAgICAgICAgICAgYWN0aW9uOiBuZXh0QWN0aW9uLFxuICAgICAgICAgICAgICBsb2NhdGlvbjogbmV4dExvY2F0aW9uLFxuICAgICAgICAgICAgICByZXRyeTogZnVuY3Rpb24gcmV0cnkoKSB7XG4gICAgICAgICAgICAgICAgZ28oZGVsdGEgKiAtMSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbyhkZWx0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRyeWluZyB0byBQT1AgdG8gYSBsb2NhdGlvbiB3aXRoIG5vIGluZGV4LiBXZSBkaWQgbm90IGNyZWF0ZVxuICAgICAgICAgIC8vIHRoaXMgbG9jYXRpb24sIHNvIHdlIGNhbid0IGVmZmVjdGl2ZWx5IGJsb2NrIHRoZSBuYXZpZ2F0aW9uLlxuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsIC8vIFRPRE86IFdyaXRlIHVwIGEgZG9jIHRoYXQgZXhwbGFpbnMgb3VyIGJsb2NraW5nIHN0cmF0ZWd5IGluXG4gICAgICAgICAgLy8gZGV0YWlsIGFuZCBsaW5rIHRvIGl0IGhlcmUgc28gcGVvcGxlIGNhbiB1bmRlcnN0YW5kIGJldHRlciB3aGF0XG4gICAgICAgICAgLy8gaXMgZ29pbmcgb24gYW5kIGhvdyB0byBhdm9pZCBpdC5cbiAgICAgICAgICBcIllvdSBhcmUgdHJ5aW5nIHRvIGJsb2NrIGEgUE9QIG5hdmlnYXRpb24gdG8gYSBsb2NhdGlvbiB0aGF0IHdhcyBub3QgXCIgKyBcImNyZWF0ZWQgYnkgdGhlIGhpc3RvcnkgbGlicmFyeS4gVGhlIGJsb2NrIHdpbGwgZmFpbCBzaWxlbnRseSBpbiBcIiArIFwicHJvZHVjdGlvbiwgYnV0IGluIGdlbmVyYWwgeW91IHNob3VsZCBkbyBhbGwgbmF2aWdhdGlvbiB3aXRoIHRoZSBcIiArIFwiaGlzdG9yeSBsaWJyYXJ5IChpbnN0ZWFkIG9mIHVzaW5nIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSBkaXJlY3RseSkgXCIgKyBcInRvIGF2b2lkIHRoaXMgc2l0dWF0aW9uLlwiKSA6IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXBwbHlUeChuZXh0QWN0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihQb3BTdGF0ZUV2ZW50VHlwZSwgaGFuZGxlUG9wKTtcbiAgdmFyIGFjdGlvbiA9IEFjdGlvbi5Qb3A7XG5cbiAgdmFyIF9nZXRJbmRleEFuZExvY2F0aW9uMiA9IGdldEluZGV4QW5kTG9jYXRpb24oKSxcbiAgICAgIGluZGV4ID0gX2dldEluZGV4QW5kTG9jYXRpb24yWzBdLFxuICAgICAgbG9jYXRpb24gPSBfZ2V0SW5kZXhBbmRMb2NhdGlvbjJbMV07XG5cbiAgdmFyIGxpc3RlbmVycyA9IGNyZWF0ZUV2ZW50cygpO1xuICB2YXIgYmxvY2tlcnMgPSBjcmVhdGVFdmVudHMoKTtcblxuICBpZiAoaW5kZXggPT0gbnVsbCkge1xuICAgIGluZGV4ID0gMDtcbiAgICBnbG9iYWxIaXN0b3J5LnJlcGxhY2VTdGF0ZShfZXh0ZW5kcyh7fSwgZ2xvYmFsSGlzdG9yeS5zdGF0ZSwge1xuICAgICAgaWR4OiBpbmRleFxuICAgIH0pLCAnJyk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVIcmVmKHRvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0byA9PT0gJ3N0cmluZycgPyB0byA6IGNyZWF0ZVBhdGgodG8pO1xuICB9IC8vIHN0YXRlIGRlZmF1bHRzIHRvIGBudWxsYCBiZWNhdXNlIGB3aW5kb3cuaGlzdG9yeS5zdGF0ZWAgZG9lc1xuXG5cbiAgZnVuY3Rpb24gZ2V0TmV4dExvY2F0aW9uKHRvLCBzdGF0ZSkge1xuICAgIGlmIChzdGF0ZSA9PT0gdm9pZCAwKSB7XG4gICAgICBzdGF0ZSA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlYWRPbmx5KF9leHRlbmRzKHtcbiAgICAgIHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgIGhhc2g6ICcnLFxuICAgICAgc2VhcmNoOiAnJ1xuICAgIH0sIHR5cGVvZiB0byA9PT0gJ3N0cmluZycgPyBwYXJzZVBhdGgodG8pIDogdG8sIHtcbiAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgIGtleTogY3JlYXRlS2V5KClcbiAgICB9KSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRIaXN0b3J5U3RhdGVBbmRVcmwobmV4dExvY2F0aW9uLCBpbmRleCkge1xuICAgIHJldHVybiBbe1xuICAgICAgdXNyOiBuZXh0TG9jYXRpb24uc3RhdGUsXG4gICAgICBrZXk6IG5leHRMb2NhdGlvbi5rZXksXG4gICAgICBpZHg6IGluZGV4XG4gICAgfSwgY3JlYXRlSHJlZihuZXh0TG9jYXRpb24pXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFsbG93VHgoYWN0aW9uLCBsb2NhdGlvbiwgcmV0cnkpIHtcbiAgICByZXR1cm4gIWJsb2NrZXJzLmxlbmd0aCB8fCAoYmxvY2tlcnMuY2FsbCh7XG4gICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgIHJldHJ5OiByZXRyeVxuICAgIH0pLCBmYWxzZSk7XG4gIH1cblxuICBmdW5jdGlvbiBhcHBseVR4KG5leHRBY3Rpb24pIHtcbiAgICBhY3Rpb24gPSBuZXh0QWN0aW9uO1xuXG4gICAgdmFyIF9nZXRJbmRleEFuZExvY2F0aW9uMyA9IGdldEluZGV4QW5kTG9jYXRpb24oKTtcblxuICAgIGluZGV4ID0gX2dldEluZGV4QW5kTG9jYXRpb24zWzBdO1xuICAgIGxvY2F0aW9uID0gX2dldEluZGV4QW5kTG9jYXRpb24zWzFdO1xuICAgIGxpc3RlbmVycy5jYWxsKHtcbiAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgbG9jYXRpb246IGxvY2F0aW9uXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoKHRvLCBzdGF0ZSkge1xuICAgIHZhciBuZXh0QWN0aW9uID0gQWN0aW9uLlB1c2g7XG4gICAgdmFyIG5leHRMb2NhdGlvbiA9IGdldE5leHRMb2NhdGlvbih0bywgc3RhdGUpO1xuXG4gICAgZnVuY3Rpb24gcmV0cnkoKSB7XG4gICAgICBwdXNoKHRvLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKGFsbG93VHgobmV4dEFjdGlvbiwgbmV4dExvY2F0aW9uLCByZXRyeSkpIHtcbiAgICAgIHZhciBfZ2V0SGlzdG9yeVN0YXRlQW5kVXIgPSBnZXRIaXN0b3J5U3RhdGVBbmRVcmwobmV4dExvY2F0aW9uLCBpbmRleCArIDEpLFxuICAgICAgICAgIGhpc3RvcnlTdGF0ZSA9IF9nZXRIaXN0b3J5U3RhdGVBbmRVclswXSxcbiAgICAgICAgICB1cmwgPSBfZ2V0SGlzdG9yeVN0YXRlQW5kVXJbMV07IC8vIFRPRE86IFN1cHBvcnQgZm9yY2VkIHJlbG9hZGluZ1xuICAgICAgLy8gdHJ5Li4uY2F0Y2ggYmVjYXVzZSBpT1MgbGltaXRzIHVzIHRvIDEwMCBwdXNoU3RhdGUgY2FsbHMgOi9cblxuXG4gICAgICB0cnkge1xuICAgICAgICBnbG9iYWxIaXN0b3J5LnB1c2hTdGF0ZShoaXN0b3J5U3RhdGUsICcnLCB1cmwpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gVGhleSBhcmUgZ29pbmcgdG8gbG9zZSBzdGF0ZSBoZXJlLCBidXQgdGhlcmUgaXMgbm8gcmVhbFxuICAgICAgICAvLyB3YXkgdG8gd2FybiB0aGVtIGFib3V0IGl0IHNpbmNlIHRoZSBwYWdlIHdpbGwgcmVmcmVzaC4uLlxuICAgICAgICB3aW5kb3cubG9jYXRpb24uYXNzaWduKHVybCk7XG4gICAgICB9XG5cbiAgICAgIGFwcGx5VHgobmV4dEFjdGlvbik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVwbGFjZSh0bywgc3RhdGUpIHtcbiAgICB2YXIgbmV4dEFjdGlvbiA9IEFjdGlvbi5SZXBsYWNlO1xuICAgIHZhciBuZXh0TG9jYXRpb24gPSBnZXROZXh0TG9jYXRpb24odG8sIHN0YXRlKTtcblxuICAgIGZ1bmN0aW9uIHJldHJ5KCkge1xuICAgICAgcmVwbGFjZSh0bywgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChhbGxvd1R4KG5leHRBY3Rpb24sIG5leHRMb2NhdGlvbiwgcmV0cnkpKSB7XG4gICAgICB2YXIgX2dldEhpc3RvcnlTdGF0ZUFuZFVyMiA9IGdldEhpc3RvcnlTdGF0ZUFuZFVybChuZXh0TG9jYXRpb24sIGluZGV4KSxcbiAgICAgICAgICBoaXN0b3J5U3RhdGUgPSBfZ2V0SGlzdG9yeVN0YXRlQW5kVXIyWzBdLFxuICAgICAgICAgIHVybCA9IF9nZXRIaXN0b3J5U3RhdGVBbmRVcjJbMV07IC8vIFRPRE86IFN1cHBvcnQgZm9yY2VkIHJlbG9hZGluZ1xuXG5cbiAgICAgIGdsb2JhbEhpc3RvcnkucmVwbGFjZVN0YXRlKGhpc3RvcnlTdGF0ZSwgJycsIHVybCk7XG4gICAgICBhcHBseVR4KG5leHRBY3Rpb24pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdvKGRlbHRhKSB7XG4gICAgZ2xvYmFsSGlzdG9yeS5nbyhkZWx0YSk7XG4gIH1cblxuICB2YXIgaGlzdG9yeSA9IHtcbiAgICBnZXQgYWN0aW9uKCkge1xuICAgICAgcmV0dXJuIGFjdGlvbjtcbiAgICB9LFxuXG4gICAgZ2V0IGxvY2F0aW9uKCkge1xuICAgICAgcmV0dXJuIGxvY2F0aW9uO1xuICAgIH0sXG5cbiAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLFxuICAgIHB1c2g6IHB1c2gsXG4gICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICBnbzogZ28sXG4gICAgYmFjazogZnVuY3Rpb24gYmFjaygpIHtcbiAgICAgIGdvKC0xKTtcbiAgICB9LFxuICAgIGZvcndhcmQ6IGZ1bmN0aW9uIGZvcndhcmQoKSB7XG4gICAgICBnbygxKTtcbiAgICB9LFxuICAgIGxpc3RlbjogZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIH0sXG4gICAgYmxvY2s6IGZ1bmN0aW9uIGJsb2NrKGJsb2NrZXIpIHtcbiAgICAgIHZhciB1bmJsb2NrID0gYmxvY2tlcnMucHVzaChibG9ja2VyKTtcblxuICAgICAgaWYgKGJsb2NrZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihCZWZvcmVVbmxvYWRFdmVudFR5cGUsIHByb21wdEJlZm9yZVVubG9hZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHVuYmxvY2soKTsgLy8gUmVtb3ZlIHRoZSBiZWZvcmV1bmxvYWQgbGlzdGVuZXIgc28gdGhlIGRvY3VtZW50IG1heVxuICAgICAgICAvLyBzdGlsbCBiZSBzYWx2YWdlYWJsZSBpbiB0aGUgcGFnZWhpZGUgZXZlbnQuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyN1bmxvYWRpbmctZG9jdW1lbnRzXG5cbiAgICAgICAgaWYgKCFibG9ja2Vycy5sZW5ndGgpIHtcbiAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihCZWZvcmVVbmxvYWRFdmVudFR5cGUsIHByb21wdEJlZm9yZVVubG9hZCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xuICByZXR1cm4gaGlzdG9yeTtcbn1cbi8qKlxyXG4gKiBIYXNoIGhpc3Rvcnkgc3RvcmVzIHRoZSBsb2NhdGlvbiBpbiB3aW5kb3cubG9jYXRpb24uaGFzaC4gVGhpcyBtYWtlcyBpdCBpZGVhbFxyXG4gKiBmb3Igc2l0dWF0aW9ucyB3aGVyZSB5b3UgZG9uJ3Qgd2FudCB0byBzZW5kIHRoZSBsb2NhdGlvbiB0byB0aGUgc2VydmVyIGZvclxyXG4gKiBzb21lIHJlYXNvbiwgZWl0aGVyIGJlY2F1c2UgeW91IGRvIGNhbm5vdCBjb25maWd1cmUgaXQgb3IgdGhlIFVSTCBzcGFjZSBpc1xyXG4gKiByZXNlcnZlZCBmb3Igc29tZXRoaW5nIGVsc2UuXHJcbiAqXHJcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9oaXN0b3J5L3RyZWUvbWFpbi9kb2NzL2FwaS1yZWZlcmVuY2UubWQjY3JlYXRlaGFzaGhpc3RvcnlcclxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUhhc2hIaXN0b3J5KG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfb3B0aW9uczIgPSBvcHRpb25zLFxuICAgICAgX29wdGlvbnMyJHdpbmRvdyA9IF9vcHRpb25zMi53aW5kb3csXG4gICAgICB3aW5kb3cgPSBfb3B0aW9uczIkd2luZG93ID09PSB2b2lkIDAgPyBkb2N1bWVudC5kZWZhdWx0VmlldyA6IF9vcHRpb25zMiR3aW5kb3c7XG4gIHZhciBnbG9iYWxIaXN0b3J5ID0gd2luZG93Lmhpc3Rvcnk7XG5cbiAgZnVuY3Rpb24gZ2V0SW5kZXhBbmRMb2NhdGlvbigpIHtcbiAgICB2YXIgX3BhcnNlUGF0aCA9IHBhcnNlUGF0aCh3aW5kb3cubG9jYXRpb24uaGFzaC5zdWJzdHIoMSkpLFxuICAgICAgICBfcGFyc2VQYXRoJHBhdGhuYW1lID0gX3BhcnNlUGF0aC5wYXRobmFtZSxcbiAgICAgICAgcGF0aG5hbWUgPSBfcGFyc2VQYXRoJHBhdGhuYW1lID09PSB2b2lkIDAgPyAnLycgOiBfcGFyc2VQYXRoJHBhdGhuYW1lLFxuICAgICAgICBfcGFyc2VQYXRoJHNlYXJjaCA9IF9wYXJzZVBhdGguc2VhcmNoLFxuICAgICAgICBzZWFyY2ggPSBfcGFyc2VQYXRoJHNlYXJjaCA9PT0gdm9pZCAwID8gJycgOiBfcGFyc2VQYXRoJHNlYXJjaCxcbiAgICAgICAgX3BhcnNlUGF0aCRoYXNoID0gX3BhcnNlUGF0aC5oYXNoLFxuICAgICAgICBoYXNoID0gX3BhcnNlUGF0aCRoYXNoID09PSB2b2lkIDAgPyAnJyA6IF9wYXJzZVBhdGgkaGFzaDtcblxuICAgIHZhciBzdGF0ZSA9IGdsb2JhbEhpc3Rvcnkuc3RhdGUgfHwge307XG4gICAgcmV0dXJuIFtzdGF0ZS5pZHgsIHJlYWRPbmx5KHtcbiAgICAgIHBhdGhuYW1lOiBwYXRobmFtZSxcbiAgICAgIHNlYXJjaDogc2VhcmNoLFxuICAgICAgaGFzaDogaGFzaCxcbiAgICAgIHN0YXRlOiBzdGF0ZS51c3IgfHwgbnVsbCxcbiAgICAgIGtleTogc3RhdGUua2V5IHx8ICdkZWZhdWx0J1xuICAgIH0pXTtcbiAgfVxuXG4gIHZhciBibG9ja2VkUG9wVHggPSBudWxsO1xuXG4gIGZ1bmN0aW9uIGhhbmRsZVBvcCgpIHtcbiAgICBpZiAoYmxvY2tlZFBvcFR4KSB7XG4gICAgICBibG9ja2Vycy5jYWxsKGJsb2NrZWRQb3BUeCk7XG4gICAgICBibG9ja2VkUG9wVHggPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbmV4dEFjdGlvbiA9IEFjdGlvbi5Qb3A7XG5cbiAgICAgIHZhciBfZ2V0SW5kZXhBbmRMb2NhdGlvbjQgPSBnZXRJbmRleEFuZExvY2F0aW9uKCksXG4gICAgICAgICAgbmV4dEluZGV4ID0gX2dldEluZGV4QW5kTG9jYXRpb240WzBdLFxuICAgICAgICAgIG5leHRMb2NhdGlvbiA9IF9nZXRJbmRleEFuZExvY2F0aW9uNFsxXTtcblxuICAgICAgaWYgKGJsb2NrZXJzLmxlbmd0aCkge1xuICAgICAgICBpZiAobmV4dEluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgZGVsdGEgPSBpbmRleCAtIG5leHRJbmRleDtcblxuICAgICAgICAgIGlmIChkZWx0YSkge1xuICAgICAgICAgICAgLy8gUmV2ZXJ0IHRoZSBQT1BcbiAgICAgICAgICAgIGJsb2NrZWRQb3BUeCA9IHtcbiAgICAgICAgICAgICAgYWN0aW9uOiBuZXh0QWN0aW9uLFxuICAgICAgICAgICAgICBsb2NhdGlvbjogbmV4dExvY2F0aW9uLFxuICAgICAgICAgICAgICByZXRyeTogZnVuY3Rpb24gcmV0cnkoKSB7XG4gICAgICAgICAgICAgICAgZ28oZGVsdGEgKiAtMSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbyhkZWx0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRyeWluZyB0byBQT1AgdG8gYSBsb2NhdGlvbiB3aXRoIG5vIGluZGV4LiBXZSBkaWQgbm90IGNyZWF0ZVxuICAgICAgICAgIC8vIHRoaXMgbG9jYXRpb24sIHNvIHdlIGNhbid0IGVmZmVjdGl2ZWx5IGJsb2NrIHRoZSBuYXZpZ2F0aW9uLlxuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsIC8vIFRPRE86IFdyaXRlIHVwIGEgZG9jIHRoYXQgZXhwbGFpbnMgb3VyIGJsb2NraW5nIHN0cmF0ZWd5IGluXG4gICAgICAgICAgLy8gZGV0YWlsIGFuZCBsaW5rIHRvIGl0IGhlcmUgc28gcGVvcGxlIGNhbiB1bmRlcnN0YW5kIGJldHRlclxuICAgICAgICAgIC8vIHdoYXQgaXMgZ29pbmcgb24gYW5kIGhvdyB0byBhdm9pZCBpdC5cbiAgICAgICAgICBcIllvdSBhcmUgdHJ5aW5nIHRvIGJsb2NrIGEgUE9QIG5hdmlnYXRpb24gdG8gYSBsb2NhdGlvbiB0aGF0IHdhcyBub3QgXCIgKyBcImNyZWF0ZWQgYnkgdGhlIGhpc3RvcnkgbGlicmFyeS4gVGhlIGJsb2NrIHdpbGwgZmFpbCBzaWxlbnRseSBpbiBcIiArIFwicHJvZHVjdGlvbiwgYnV0IGluIGdlbmVyYWwgeW91IHNob3VsZCBkbyBhbGwgbmF2aWdhdGlvbiB3aXRoIHRoZSBcIiArIFwiaGlzdG9yeSBsaWJyYXJ5IChpbnN0ZWFkIG9mIHVzaW5nIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSBkaXJlY3RseSkgXCIgKyBcInRvIGF2b2lkIHRoaXMgc2l0dWF0aW9uLlwiKSA6IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXBwbHlUeChuZXh0QWN0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihQb3BTdGF0ZUV2ZW50VHlwZSwgaGFuZGxlUG9wKTsgLy8gcG9wc3RhdGUgZG9lcyBub3QgZmlyZSBvbiBoYXNoY2hhbmdlIGluIElFIDExIGFuZCBvbGQgKHRyaWRlbnQpIEVkZ2VcbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZGUvZG9jcy9XZWIvQVBJL1dpbmRvdy9wb3BzdGF0ZV9ldmVudFxuXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKEhhc2hDaGFuZ2VFdmVudFR5cGUsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2dldEluZGV4QW5kTG9jYXRpb241ID0gZ2V0SW5kZXhBbmRMb2NhdGlvbigpLFxuICAgICAgICBuZXh0TG9jYXRpb24gPSBfZ2V0SW5kZXhBbmRMb2NhdGlvbjVbMV07IC8vIElnbm9yZSBleHRyYW5lb3VzIGhhc2hjaGFuZ2UgZXZlbnRzLlxuXG5cbiAgICBpZiAoY3JlYXRlUGF0aChuZXh0TG9jYXRpb24pICE9PSBjcmVhdGVQYXRoKGxvY2F0aW9uKSkge1xuICAgICAgaGFuZGxlUG9wKCk7XG4gICAgfVxuICB9KTtcbiAgdmFyIGFjdGlvbiA9IEFjdGlvbi5Qb3A7XG5cbiAgdmFyIF9nZXRJbmRleEFuZExvY2F0aW9uNiA9IGdldEluZGV4QW5kTG9jYXRpb24oKSxcbiAgICAgIGluZGV4ID0gX2dldEluZGV4QW5kTG9jYXRpb242WzBdLFxuICAgICAgbG9jYXRpb24gPSBfZ2V0SW5kZXhBbmRMb2NhdGlvbjZbMV07XG5cbiAgdmFyIGxpc3RlbmVycyA9IGNyZWF0ZUV2ZW50cygpO1xuICB2YXIgYmxvY2tlcnMgPSBjcmVhdGVFdmVudHMoKTtcblxuICBpZiAoaW5kZXggPT0gbnVsbCkge1xuICAgIGluZGV4ID0gMDtcbiAgICBnbG9iYWxIaXN0b3J5LnJlcGxhY2VTdGF0ZShfZXh0ZW5kcyh7fSwgZ2xvYmFsSGlzdG9yeS5zdGF0ZSwge1xuICAgICAgaWR4OiBpbmRleFxuICAgIH0pLCAnJyk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRCYXNlSHJlZigpIHtcbiAgICB2YXIgYmFzZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2Jhc2UnKTtcbiAgICB2YXIgaHJlZiA9ICcnO1xuXG4gICAgaWYgKGJhc2UgJiYgYmFzZS5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSkge1xuICAgICAgdmFyIHVybCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICAgICAgdmFyIGhhc2hJbmRleCA9IHVybC5pbmRleE9mKCcjJyk7XG4gICAgICBocmVmID0gaGFzaEluZGV4ID09PSAtMSA/IHVybCA6IHVybC5zbGljZSgwLCBoYXNoSW5kZXgpO1xuICAgIH1cblxuICAgIHJldHVybiBocmVmO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSHJlZih0bykge1xuICAgIHJldHVybiBnZXRCYXNlSHJlZigpICsgJyMnICsgKHR5cGVvZiB0byA9PT0gJ3N0cmluZycgPyB0byA6IGNyZWF0ZVBhdGgodG8pKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE5leHRMb2NhdGlvbih0bywgc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUgPT09IHZvaWQgMCkge1xuICAgICAgc3RhdGUgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiByZWFkT25seShfZXh0ZW5kcyh7XG4gICAgICBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICBoYXNoOiAnJyxcbiAgICAgIHNlYXJjaDogJydcbiAgICB9LCB0eXBlb2YgdG8gPT09ICdzdHJpbmcnID8gcGFyc2VQYXRoKHRvKSA6IHRvLCB7XG4gICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICBrZXk6IGNyZWF0ZUtleSgpXG4gICAgfSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SGlzdG9yeVN0YXRlQW5kVXJsKG5leHRMb2NhdGlvbiwgaW5kZXgpIHtcbiAgICByZXR1cm4gW3tcbiAgICAgIHVzcjogbmV4dExvY2F0aW9uLnN0YXRlLFxuICAgICAga2V5OiBuZXh0TG9jYXRpb24ua2V5LFxuICAgICAgaWR4OiBpbmRleFxuICAgIH0sIGNyZWF0ZUhyZWYobmV4dExvY2F0aW9uKV07XG4gIH1cblxuICBmdW5jdGlvbiBhbGxvd1R4KGFjdGlvbiwgbG9jYXRpb24sIHJldHJ5KSB7XG4gICAgcmV0dXJuICFibG9ja2Vycy5sZW5ndGggfHwgKGJsb2NrZXJzLmNhbGwoe1xuICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICByZXRyeTogcmV0cnlcbiAgICB9KSwgZmFsc2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwbHlUeChuZXh0QWN0aW9uKSB7XG4gICAgYWN0aW9uID0gbmV4dEFjdGlvbjtcblxuICAgIHZhciBfZ2V0SW5kZXhBbmRMb2NhdGlvbjcgPSBnZXRJbmRleEFuZExvY2F0aW9uKCk7XG5cbiAgICBpbmRleCA9IF9nZXRJbmRleEFuZExvY2F0aW9uN1swXTtcbiAgICBsb2NhdGlvbiA9IF9nZXRJbmRleEFuZExvY2F0aW9uN1sxXTtcbiAgICBsaXN0ZW5lcnMuY2FsbCh7XG4gICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgIGxvY2F0aW9uOiBsb2NhdGlvblxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaCh0bywgc3RhdGUpIHtcbiAgICB2YXIgbmV4dEFjdGlvbiA9IEFjdGlvbi5QdXNoO1xuICAgIHZhciBuZXh0TG9jYXRpb24gPSBnZXROZXh0TG9jYXRpb24odG8sIHN0YXRlKTtcblxuICAgIGZ1bmN0aW9uIHJldHJ5KCkge1xuICAgICAgcHVzaCh0bywgc3RhdGUpO1xuICAgIH1cblxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcobmV4dExvY2F0aW9uLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nLCBcIlJlbGF0aXZlIHBhdGhuYW1lcyBhcmUgbm90IHN1cHBvcnRlZCBpbiBoYXNoIGhpc3RvcnkucHVzaChcIiArIEpTT04uc3RyaW5naWZ5KHRvKSArIFwiKVwiKSA6IHZvaWQgMDtcblxuICAgIGlmIChhbGxvd1R4KG5leHRBY3Rpb24sIG5leHRMb2NhdGlvbiwgcmV0cnkpKSB7XG4gICAgICB2YXIgX2dldEhpc3RvcnlTdGF0ZUFuZFVyMyA9IGdldEhpc3RvcnlTdGF0ZUFuZFVybChuZXh0TG9jYXRpb24sIGluZGV4ICsgMSksXG4gICAgICAgICAgaGlzdG9yeVN0YXRlID0gX2dldEhpc3RvcnlTdGF0ZUFuZFVyM1swXSxcbiAgICAgICAgICB1cmwgPSBfZ2V0SGlzdG9yeVN0YXRlQW5kVXIzWzFdOyAvLyBUT0RPOiBTdXBwb3J0IGZvcmNlZCByZWxvYWRpbmdcbiAgICAgIC8vIHRyeS4uLmNhdGNoIGJlY2F1c2UgaU9TIGxpbWl0cyB1cyB0byAxMDAgcHVzaFN0YXRlIGNhbGxzIDovXG5cblxuICAgICAgdHJ5IHtcbiAgICAgICAgZ2xvYmFsSGlzdG9yeS5wdXNoU3RhdGUoaGlzdG9yeVN0YXRlLCAnJywgdXJsKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIFRoZXkgYXJlIGdvaW5nIHRvIGxvc2Ugc3RhdGUgaGVyZSwgYnV0IHRoZXJlIGlzIG5vIHJlYWxcbiAgICAgICAgLy8gd2F5IHRvIHdhcm4gdGhlbSBhYm91dCBpdCBzaW5jZSB0aGUgcGFnZSB3aWxsIHJlZnJlc2guLi5cbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmFzc2lnbih1cmwpO1xuICAgICAgfVxuXG4gICAgICBhcHBseVR4KG5leHRBY3Rpb24pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlcGxhY2UodG8sIHN0YXRlKSB7XG4gICAgdmFyIG5leHRBY3Rpb24gPSBBY3Rpb24uUmVwbGFjZTtcbiAgICB2YXIgbmV4dExvY2F0aW9uID0gZ2V0TmV4dExvY2F0aW9uKHRvLCBzdGF0ZSk7XG5cbiAgICBmdW5jdGlvbiByZXRyeSgpIHtcbiAgICAgIHJlcGxhY2UodG8sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKG5leHRMb2NhdGlvbi5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJywgXCJSZWxhdGl2ZSBwYXRobmFtZXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gaGFzaCBoaXN0b3J5LnJlcGxhY2UoXCIgKyBKU09OLnN0cmluZ2lmeSh0bykgKyBcIilcIikgOiB2b2lkIDA7XG5cbiAgICBpZiAoYWxsb3dUeChuZXh0QWN0aW9uLCBuZXh0TG9jYXRpb24sIHJldHJ5KSkge1xuICAgICAgdmFyIF9nZXRIaXN0b3J5U3RhdGVBbmRVcjQgPSBnZXRIaXN0b3J5U3RhdGVBbmRVcmwobmV4dExvY2F0aW9uLCBpbmRleCksXG4gICAgICAgICAgaGlzdG9yeVN0YXRlID0gX2dldEhpc3RvcnlTdGF0ZUFuZFVyNFswXSxcbiAgICAgICAgICB1cmwgPSBfZ2V0SGlzdG9yeVN0YXRlQW5kVXI0WzFdOyAvLyBUT0RPOiBTdXBwb3J0IGZvcmNlZCByZWxvYWRpbmdcblxuXG4gICAgICBnbG9iYWxIaXN0b3J5LnJlcGxhY2VTdGF0ZShoaXN0b3J5U3RhdGUsICcnLCB1cmwpO1xuICAgICAgYXBwbHlUeChuZXh0QWN0aW9uKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnbyhkZWx0YSkge1xuICAgIGdsb2JhbEhpc3RvcnkuZ28oZGVsdGEpO1xuICB9XG5cbiAgdmFyIGhpc3RvcnkgPSB7XG4gICAgZ2V0IGFjdGlvbigpIHtcbiAgICAgIHJldHVybiBhY3Rpb247XG4gICAgfSxcblxuICAgIGdldCBsb2NhdGlvbigpIHtcbiAgICAgIHJldHVybiBsb2NhdGlvbjtcbiAgICB9LFxuXG4gICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICBwdXNoOiBwdXNoLFxuICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgZ286IGdvLFxuICAgIGJhY2s6IGZ1bmN0aW9uIGJhY2soKSB7XG4gICAgICBnbygtMSk7XG4gICAgfSxcbiAgICBmb3J3YXJkOiBmdW5jdGlvbiBmb3J3YXJkKCkge1xuICAgICAgZ28oMSk7XG4gICAgfSxcbiAgICBsaXN0ZW46IGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9LFxuICAgIGJsb2NrOiBmdW5jdGlvbiBibG9jayhibG9ja2VyKSB7XG4gICAgICB2YXIgdW5ibG9jayA9IGJsb2NrZXJzLnB1c2goYmxvY2tlcik7XG5cbiAgICAgIGlmIChibG9ja2Vycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoQmVmb3JlVW5sb2FkRXZlbnRUeXBlLCBwcm9tcHRCZWZvcmVVbmxvYWQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB1bmJsb2NrKCk7IC8vIFJlbW92ZSB0aGUgYmVmb3JldW5sb2FkIGxpc3RlbmVyIHNvIHRoZSBkb2N1bWVudCBtYXlcbiAgICAgICAgLy8gc3RpbGwgYmUgc2FsdmFnZWFibGUgaW4gdGhlIHBhZ2VoaWRlIGV2ZW50LlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jdW5sb2FkaW5nLWRvY3VtZW50c1xuXG4gICAgICAgIGlmICghYmxvY2tlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoQmVmb3JlVW5sb2FkRXZlbnRUeXBlLCBwcm9tcHRCZWZvcmVVbmxvYWQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGhpc3Rvcnk7XG59XG4vKipcclxuICogTWVtb3J5IGhpc3Rvcnkgc3RvcmVzIHRoZSBjdXJyZW50IGxvY2F0aW9uIGluIG1lbW9yeS4gSXQgaXMgZGVzaWduZWQgZm9yIHVzZVxyXG4gKiBpbiBzdGF0ZWZ1bCBub24tYnJvd3NlciBlbnZpcm9ubWVudHMgbGlrZSB0ZXN0cyBhbmQgUmVhY3QgTmF0aXZlLlxyXG4gKlxyXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vaGlzdG9yeS90cmVlL21haW4vZG9jcy9hcGktcmVmZXJlbmNlLm1kI2NyZWF0ZW1lbW9yeWhpc3RvcnlcclxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZU1lbW9yeUhpc3Rvcnkob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIF9vcHRpb25zMyA9IG9wdGlvbnMsXG4gICAgICBfb3B0aW9uczMkaW5pdGlhbEVudHIgPSBfb3B0aW9uczMuaW5pdGlhbEVudHJpZXMsXG4gICAgICBpbml0aWFsRW50cmllcyA9IF9vcHRpb25zMyRpbml0aWFsRW50ciA9PT0gdm9pZCAwID8gWycvJ10gOiBfb3B0aW9uczMkaW5pdGlhbEVudHIsXG4gICAgICBpbml0aWFsSW5kZXggPSBfb3B0aW9uczMuaW5pdGlhbEluZGV4O1xuICB2YXIgZW50cmllcyA9IGluaXRpYWxFbnRyaWVzLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICB2YXIgbG9jYXRpb24gPSByZWFkT25seShfZXh0ZW5kcyh7XG4gICAgICBwYXRobmFtZTogJy8nLFxuICAgICAgc2VhcmNoOiAnJyxcbiAgICAgIGhhc2g6ICcnLFxuICAgICAgc3RhdGU6IG51bGwsXG4gICAgICBrZXk6IGNyZWF0ZUtleSgpXG4gICAgfSwgdHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJyA/IHBhcnNlUGF0aChlbnRyeSkgOiBlbnRyeSkpO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcobG9jYXRpb24ucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycsIFwiUmVsYXRpdmUgcGF0aG5hbWVzIGFyZSBub3Qgc3VwcG9ydGVkIGluIGNyZWF0ZU1lbW9yeUhpc3RvcnkoeyBpbml0aWFsRW50cmllcyB9KSAoaW52YWxpZCBlbnRyeTogXCIgKyBKU09OLnN0cmluZ2lmeShlbnRyeSkgKyBcIilcIikgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGxvY2F0aW9uO1xuICB9KTtcbiAgdmFyIGluZGV4ID0gY2xhbXAoaW5pdGlhbEluZGV4ID09IG51bGwgPyBlbnRyaWVzLmxlbmd0aCAtIDEgOiBpbml0aWFsSW5kZXgsIDAsIGVudHJpZXMubGVuZ3RoIC0gMSk7XG4gIHZhciBhY3Rpb24gPSBBY3Rpb24uUG9wO1xuICB2YXIgbG9jYXRpb24gPSBlbnRyaWVzW2luZGV4XTtcbiAgdmFyIGxpc3RlbmVycyA9IGNyZWF0ZUV2ZW50cygpO1xuICB2YXIgYmxvY2tlcnMgPSBjcmVhdGVFdmVudHMoKTtcblxuICBmdW5jdGlvbiBjcmVhdGVIcmVmKHRvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0byA9PT0gJ3N0cmluZycgPyB0byA6IGNyZWF0ZVBhdGgodG8pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TmV4dExvY2F0aW9uKHRvLCBzdGF0ZSkge1xuICAgIGlmIChzdGF0ZSA9PT0gdm9pZCAwKSB7XG4gICAgICBzdGF0ZSA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlYWRPbmx5KF9leHRlbmRzKHtcbiAgICAgIHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgIHNlYXJjaDogJycsXG4gICAgICBoYXNoOiAnJ1xuICAgIH0sIHR5cGVvZiB0byA9PT0gJ3N0cmluZycgPyBwYXJzZVBhdGgodG8pIDogdG8sIHtcbiAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgIGtleTogY3JlYXRlS2V5KClcbiAgICB9KSk7XG4gIH1cblxuICBmdW5jdGlvbiBhbGxvd1R4KGFjdGlvbiwgbG9jYXRpb24sIHJldHJ5KSB7XG4gICAgcmV0dXJuICFibG9ja2Vycy5sZW5ndGggfHwgKGJsb2NrZXJzLmNhbGwoe1xuICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICByZXRyeTogcmV0cnlcbiAgICB9KSwgZmFsc2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwbHlUeChuZXh0QWN0aW9uLCBuZXh0TG9jYXRpb24pIHtcbiAgICBhY3Rpb24gPSBuZXh0QWN0aW9uO1xuICAgIGxvY2F0aW9uID0gbmV4dExvY2F0aW9uO1xuICAgIGxpc3RlbmVycy5jYWxsKHtcbiAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgbG9jYXRpb246IGxvY2F0aW9uXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoKHRvLCBzdGF0ZSkge1xuICAgIHZhciBuZXh0QWN0aW9uID0gQWN0aW9uLlB1c2g7XG4gICAgdmFyIG5leHRMb2NhdGlvbiA9IGdldE5leHRMb2NhdGlvbih0bywgc3RhdGUpO1xuXG4gICAgZnVuY3Rpb24gcmV0cnkoKSB7XG4gICAgICBwdXNoKHRvLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhsb2NhdGlvbi5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJywgXCJSZWxhdGl2ZSBwYXRobmFtZXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gbWVtb3J5IGhpc3RvcnkucHVzaChcIiArIEpTT04uc3RyaW5naWZ5KHRvKSArIFwiKVwiKSA6IHZvaWQgMDtcblxuICAgIGlmIChhbGxvd1R4KG5leHRBY3Rpb24sIG5leHRMb2NhdGlvbiwgcmV0cnkpKSB7XG4gICAgICBpbmRleCArPSAxO1xuICAgICAgZW50cmllcy5zcGxpY2UoaW5kZXgsIGVudHJpZXMubGVuZ3RoLCBuZXh0TG9jYXRpb24pO1xuICAgICAgYXBwbHlUeChuZXh0QWN0aW9uLCBuZXh0TG9jYXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlcGxhY2UodG8sIHN0YXRlKSB7XG4gICAgdmFyIG5leHRBY3Rpb24gPSBBY3Rpb24uUmVwbGFjZTtcbiAgICB2YXIgbmV4dExvY2F0aW9uID0gZ2V0TmV4dExvY2F0aW9uKHRvLCBzdGF0ZSk7XG5cbiAgICBmdW5jdGlvbiByZXRyeSgpIHtcbiAgICAgIHJlcGxhY2UodG8sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGxvY2F0aW9uLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nLCBcIlJlbGF0aXZlIHBhdGhuYW1lcyBhcmUgbm90IHN1cHBvcnRlZCBpbiBtZW1vcnkgaGlzdG9yeS5yZXBsYWNlKFwiICsgSlNPTi5zdHJpbmdpZnkodG8pICsgXCIpXCIpIDogdm9pZCAwO1xuXG4gICAgaWYgKGFsbG93VHgobmV4dEFjdGlvbiwgbmV4dExvY2F0aW9uLCByZXRyeSkpIHtcbiAgICAgIGVudHJpZXNbaW5kZXhdID0gbmV4dExvY2F0aW9uO1xuICAgICAgYXBwbHlUeChuZXh0QWN0aW9uLCBuZXh0TG9jYXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdvKGRlbHRhKSB7XG4gICAgdmFyIG5leHRJbmRleCA9IGNsYW1wKGluZGV4ICsgZGVsdGEsIDAsIGVudHJpZXMubGVuZ3RoIC0gMSk7XG4gICAgdmFyIG5leHRBY3Rpb24gPSBBY3Rpb24uUG9wO1xuICAgIHZhciBuZXh0TG9jYXRpb24gPSBlbnRyaWVzW25leHRJbmRleF07XG5cbiAgICBmdW5jdGlvbiByZXRyeSgpIHtcbiAgICAgIGdvKGRlbHRhKTtcbiAgICB9XG5cbiAgICBpZiAoYWxsb3dUeChuZXh0QWN0aW9uLCBuZXh0TG9jYXRpb24sIHJldHJ5KSkge1xuICAgICAgaW5kZXggPSBuZXh0SW5kZXg7XG4gICAgICBhcHBseVR4KG5leHRBY3Rpb24sIG5leHRMb2NhdGlvbik7XG4gICAgfVxuICB9XG5cbiAgdmFyIGhpc3RvcnkgPSB7XG4gICAgZ2V0IGluZGV4KCkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH0sXG5cbiAgICBnZXQgYWN0aW9uKCkge1xuICAgICAgcmV0dXJuIGFjdGlvbjtcbiAgICB9LFxuXG4gICAgZ2V0IGxvY2F0aW9uKCkge1xuICAgICAgcmV0dXJuIGxvY2F0aW9uO1xuICAgIH0sXG5cbiAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLFxuICAgIHB1c2g6IHB1c2gsXG4gICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICBnbzogZ28sXG4gICAgYmFjazogZnVuY3Rpb24gYmFjaygpIHtcbiAgICAgIGdvKC0xKTtcbiAgICB9LFxuICAgIGZvcndhcmQ6IGZ1bmN0aW9uIGZvcndhcmQoKSB7XG4gICAgICBnbygxKTtcbiAgICB9LFxuICAgIGxpc3RlbjogZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIH0sXG4gICAgYmxvY2s6IGZ1bmN0aW9uIGJsb2NrKGJsb2NrZXIpIHtcbiAgICAgIHJldHVybiBibG9ja2Vycy5wdXNoKGJsb2NrZXIpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGhpc3Rvcnk7XG59IC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBVVElMU1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZnVuY3Rpb24gY2xhbXAobiwgbG93ZXJCb3VuZCwgdXBwZXJCb3VuZCkge1xuICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobiwgbG93ZXJCb3VuZCksIHVwcGVyQm91bmQpO1xufVxuXG5mdW5jdGlvbiBwcm9tcHRCZWZvcmVVbmxvYWQoZXZlbnQpIHtcbiAgLy8gQ2FuY2VsIHRoZSBldmVudC5cbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy8gQ2hyb21lIChhbmQgbGVnYWN5IElFKSByZXF1aXJlcyByZXR1cm5WYWx1ZSB0byBiZSBzZXQuXG5cbiAgZXZlbnQucmV0dXJuVmFsdWUgPSAnJztcbn1cblxuZnVuY3Rpb24gY3JlYXRlRXZlbnRzKCkge1xuICB2YXIgaGFuZGxlcnMgPSBbXTtcbiAgcmV0dXJuIHtcbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgcmV0dXJuIGhhbmRsZXJzLmxlbmd0aDtcbiAgICB9LFxuXG4gICAgcHVzaDogZnVuY3Rpb24gcHVzaChmbikge1xuICAgICAgaGFuZGxlcnMucHVzaChmbik7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBoYW5kbGVycyA9IGhhbmRsZXJzLmZpbHRlcihmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgICAgIHJldHVybiBoYW5kbGVyICE9PSBmbjtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH0sXG4gICAgY2FsbDogZnVuY3Rpb24gY2FsbChhcmcpIHtcbiAgICAgIGhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiBmbiAmJiBmbihhcmcpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXkoKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOCk7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIHN0cmluZyBVUkwgcGF0aCBmcm9tIHRoZSBnaXZlbiBwYXRobmFtZSwgc2VhcmNoLCBhbmQgaGFzaCBjb21wb25lbnRzLlxyXG4gKlxyXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vaGlzdG9yeS90cmVlL21haW4vZG9jcy9hcGktcmVmZXJlbmNlLm1kI2NyZWF0ZXBhdGhcclxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlUGF0aChfcmVmKSB7XG4gIHZhciBfcmVmJHBhdGhuYW1lID0gX3JlZi5wYXRobmFtZSxcbiAgICAgIHBhdGhuYW1lID0gX3JlZiRwYXRobmFtZSA9PT0gdm9pZCAwID8gJy8nIDogX3JlZiRwYXRobmFtZSxcbiAgICAgIF9yZWYkc2VhcmNoID0gX3JlZi5zZWFyY2gsXG4gICAgICBzZWFyY2ggPSBfcmVmJHNlYXJjaCA9PT0gdm9pZCAwID8gJycgOiBfcmVmJHNlYXJjaCxcbiAgICAgIF9yZWYkaGFzaCA9IF9yZWYuaGFzaCxcbiAgICAgIGhhc2ggPSBfcmVmJGhhc2ggPT09IHZvaWQgMCA/ICcnIDogX3JlZiRoYXNoO1xuICBpZiAoc2VhcmNoICYmIHNlYXJjaCAhPT0gJz8nKSBwYXRobmFtZSArPSBzZWFyY2guY2hhckF0KDApID09PSAnPycgPyBzZWFyY2ggOiAnPycgKyBzZWFyY2g7XG4gIGlmIChoYXNoICYmIGhhc2ggIT09ICcjJykgcGF0aG5hbWUgKz0gaGFzaC5jaGFyQXQoMCkgPT09ICcjJyA/IGhhc2ggOiAnIycgKyBoYXNoO1xuICByZXR1cm4gcGF0aG5hbWU7XG59XG4vKipcclxuICogUGFyc2VzIGEgc3RyaW5nIFVSTCBwYXRoIGludG8gaXRzIHNlcGFyYXRlIHBhdGhuYW1lLCBzZWFyY2gsIGFuZCBoYXNoIGNvbXBvbmVudHMuXHJcbiAqXHJcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9oaXN0b3J5L3RyZWUvbWFpbi9kb2NzL2FwaS1yZWZlcmVuY2UubWQjcGFyc2VwYXRoXHJcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZVBhdGgocGF0aCkge1xuICB2YXIgcGFyc2VkUGF0aCA9IHt9O1xuXG4gIGlmIChwYXRoKSB7XG4gICAgdmFyIGhhc2hJbmRleCA9IHBhdGguaW5kZXhPZignIycpO1xuXG4gICAgaWYgKGhhc2hJbmRleCA+PSAwKSB7XG4gICAgICBwYXJzZWRQYXRoLmhhc2ggPSBwYXRoLnN1YnN0cihoYXNoSW5kZXgpO1xuICAgICAgcGF0aCA9IHBhdGguc3Vic3RyKDAsIGhhc2hJbmRleCk7XG4gICAgfVxuXG4gICAgdmFyIHNlYXJjaEluZGV4ID0gcGF0aC5pbmRleE9mKCc/Jyk7XG5cbiAgICBpZiAoc2VhcmNoSW5kZXggPj0gMCkge1xuICAgICAgcGFyc2VkUGF0aC5zZWFyY2ggPSBwYXRoLnN1YnN0cihzZWFyY2hJbmRleCk7XG4gICAgICBwYXRoID0gcGF0aC5zdWJzdHIoMCwgc2VhcmNoSW5kZXgpO1xuICAgIH1cblxuICAgIGlmIChwYXRoKSB7XG4gICAgICBwYXJzZWRQYXRoLnBhdGhuYW1lID0gcGF0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFyc2VkUGF0aDtcbn1cblxuZXhwb3J0IHsgQWN0aW9uLCBjcmVhdGVCcm93c2VySGlzdG9yeSwgY3JlYXRlSGFzaEhpc3RvcnksIGNyZWF0ZU1lbW9yeUhpc3RvcnksIGNyZWF0ZVBhdGgsIHBhcnNlUGF0aCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCAiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcblxuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn0iLCAiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgdHlwZSB7XG4gIEhpc3RvcnksXG4gIEluaXRpYWxFbnRyeSxcbiAgTG9jYXRpb24sXG4gIE1lbW9yeUhpc3RvcnksXG4gIFBhdGgsXG4gIFRvXG59IGZyb20gXCJoaXN0b3J5XCI7XG5pbXBvcnQge1xuICBBY3Rpb24gYXMgTmF2aWdhdGlvblR5cGUsXG4gIGNyZWF0ZU1lbW9yeUhpc3RvcnksXG4gIHBhcnNlUGF0aFxufSBmcm9tIFwiaGlzdG9yeVwiO1xuXG5leHBvcnQgdHlwZSB7IExvY2F0aW9uLCBQYXRoLCBUbywgTmF2aWdhdGlvblR5cGUgfTtcblxuZnVuY3Rpb24gaW52YXJpYW50KGNvbmQ6IGFueSwgbWVzc2FnZTogc3RyaW5nKTogYXNzZXJ0cyBjb25kIHtcbiAgaWYgKCFjb25kKSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG59XG5cbmZ1bmN0aW9uIHdhcm5pbmcoY29uZDogYW55LCBtZXNzYWdlOiBzdHJpbmcpOiB2b2lkIHtcbiAgaWYgKCFjb25kKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIpIGNvbnNvbGUud2FybihtZXNzYWdlKTtcblxuICAgIHRyeSB7XG4gICAgICAvLyBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCBSb3V0ZXIhXG4gICAgICAvL1xuICAgICAgLy8gVGhpcyBlcnJvciBpcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB5b3UgY2FuIG1vcmUgZWFzaWx5XG4gICAgICAvLyBmaW5kIHRoZSBzb3VyY2UgZm9yIGEgd2FybmluZyB0aGF0IGFwcGVhcnMgaW4gdGhlIGNvbnNvbGUgYnlcbiAgICAgIC8vIGVuYWJsaW5nIFwicGF1c2Ugb24gZXhjZXB0aW9uc1wiIGluIHlvdXIgSmF2YVNjcmlwdCBkZWJ1Z2dlci5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbn1cblxuY29uc3QgYWxyZWFkeVdhcm5lZDogUmVjb3JkPHN0cmluZywgYm9vbGVhbj4gPSB7fTtcbmZ1bmN0aW9uIHdhcm5pbmdPbmNlKGtleTogc3RyaW5nLCBjb25kOiBib29sZWFuLCBtZXNzYWdlOiBzdHJpbmcpIHtcbiAgaWYgKCFjb25kICYmICFhbHJlYWR5V2FybmVkW2tleV0pIHtcbiAgICBhbHJlYWR5V2FybmVkW2tleV0gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsIG1lc3NhZ2UpO1xuICB9XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIENPTlRFWFRcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBBIE5hdmlnYXRvciBpcyBhIFwibG9jYXRpb24gY2hhbmdlclwiOyBpdCdzIGhvdyB5b3UgZ2V0IHRvIGRpZmZlcmVudCBsb2NhdGlvbnMuXG4gKlxuICogRXZlcnkgaGlzdG9yeSBpbnN0YW5jZSBjb25mb3JtcyB0byB0aGUgTmF2aWdhdG9yIGludGVyZmFjZSwgYnV0IHRoZVxuICogZGlzdGluY3Rpb24gaXMgdXNlZnVsIHByaW1hcmlseSB3aGVuIGl0IGNvbWVzIHRvIHRoZSBsb3ctbGV2ZWwgPFJvdXRlcj4gQVBJXG4gKiB3aGVyZSBib3RoIHRoZSBsb2NhdGlvbiBhbmQgYSBuYXZpZ2F0b3IgbXVzdCBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGluIG9yZGVyXG4gKiB0byBhdm9pZCBcInRlYXJpbmdcIiB0aGF0IG1heSBvY2N1ciBpbiBhIHN1c3BlbnNlLWVuYWJsZWQgYXBwIGlmIHRoZSBhY3Rpb25cbiAqIGFuZC9vciBsb2NhdGlvbiB3ZXJlIHRvIGJlIHJlYWQgZGlyZWN0bHkgZnJvbSB0aGUgaGlzdG9yeSBpbnN0YW5jZS5cbiAqL1xuZXhwb3J0IHR5cGUgTmF2aWdhdG9yID0gUGljazxIaXN0b3J5LCBcImdvXCIgfCBcInB1c2hcIiB8IFwicmVwbGFjZVwiIHwgXCJjcmVhdGVIcmVmXCI+O1xuXG5pbnRlcmZhY2UgTmF2aWdhdGlvbkNvbnRleHRPYmplY3Qge1xuICBiYXNlbmFtZTogc3RyaW5nO1xuICBuYXZpZ2F0b3I6IE5hdmlnYXRvcjtcbiAgc3RhdGljOiBib29sZWFuO1xufVxuXG5jb25zdCBOYXZpZ2F0aW9uQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8TmF2aWdhdGlvbkNvbnRleHRPYmplY3Q+KG51bGwhKTtcblxuaWYgKF9fREVWX18pIHtcbiAgTmF2aWdhdGlvbkNvbnRleHQuZGlzcGxheU5hbWUgPSBcIk5hdmlnYXRpb25cIjtcbn1cblxuaW50ZXJmYWNlIExvY2F0aW9uQ29udGV4dE9iamVjdCB7XG4gIGxvY2F0aW9uOiBMb2NhdGlvbjtcbiAgbmF2aWdhdGlvblR5cGU6IE5hdmlnYXRpb25UeXBlO1xufVxuXG5jb25zdCBMb2NhdGlvbkNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0PExvY2F0aW9uQ29udGV4dE9iamVjdD4obnVsbCEpO1xuXG5pZiAoX19ERVZfXykge1xuICBMb2NhdGlvbkNvbnRleHQuZGlzcGxheU5hbWUgPSBcIkxvY2F0aW9uXCI7XG59XG5cbmludGVyZmFjZSBSb3V0ZUNvbnRleHRPYmplY3Qge1xuICBvdXRsZXQ6IFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bGw7XG4gIG1hdGNoZXM6IFJvdXRlTWF0Y2hbXTtcbn1cblxuY29uc3QgUm91dGVDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dDxSb3V0ZUNvbnRleHRPYmplY3Q+KHtcbiAgb3V0bGV0OiBudWxsLFxuICBtYXRjaGVzOiBbXVxufSk7XG5cbmlmIChfX0RFVl9fKSB7XG4gIFJvdXRlQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiUm91dGVcIjtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gQ09NUE9ORU5UU1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5leHBvcnQgaW50ZXJmYWNlIE1lbW9yeVJvdXRlclByb3BzIHtcbiAgYmFzZW5hbWU/OiBzdHJpbmc7XG4gIGNoaWxkcmVuPzogUmVhY3QuUmVhY3ROb2RlO1xuICBpbml0aWFsRW50cmllcz86IEluaXRpYWxFbnRyeVtdO1xuICBpbml0aWFsSW5kZXg/OiBudW1iZXI7XG59XG5cbi8qKlxuICogQSA8Um91dGVyPiB0aGF0IHN0b3JlcyBhbGwgZW50cmllcyBpbiBtZW1vcnkuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSNtZW1vcnlyb3V0ZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIE1lbW9yeVJvdXRlcih7XG4gIGJhc2VuYW1lLFxuICBjaGlsZHJlbixcbiAgaW5pdGlhbEVudHJpZXMsXG4gIGluaXRpYWxJbmRleFxufTogTWVtb3J5Um91dGVyUHJvcHMpOiBSZWFjdC5SZWFjdEVsZW1lbnQge1xuICBsZXQgaGlzdG9yeVJlZiA9IFJlYWN0LnVzZVJlZjxNZW1vcnlIaXN0b3J5PigpO1xuICBpZiAoaGlzdG9yeVJlZi5jdXJyZW50ID09IG51bGwpIHtcbiAgICBoaXN0b3J5UmVmLmN1cnJlbnQgPSBjcmVhdGVNZW1vcnlIaXN0b3J5KHsgaW5pdGlhbEVudHJpZXMsIGluaXRpYWxJbmRleCB9KTtcbiAgfVxuXG4gIGxldCBoaXN0b3J5ID0gaGlzdG9yeVJlZi5jdXJyZW50O1xuICBsZXQgW3N0YXRlLCBzZXRTdGF0ZV0gPSBSZWFjdC51c2VTdGF0ZSh7XG4gICAgYWN0aW9uOiBoaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvblxuICB9KTtcblxuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gaGlzdG9yeS5saXN0ZW4oc2V0U3RhdGUpLCBbaGlzdG9yeV0pO1xuXG4gIHJldHVybiAoXG4gICAgPFJvdXRlclxuICAgICAgYmFzZW5hbWU9e2Jhc2VuYW1lfVxuICAgICAgY2hpbGRyZW49e2NoaWxkcmVufVxuICAgICAgbG9jYXRpb249e3N0YXRlLmxvY2F0aW9ufVxuICAgICAgbmF2aWdhdGlvblR5cGU9e3N0YXRlLmFjdGlvbn1cbiAgICAgIG5hdmlnYXRvcj17aGlzdG9yeX1cbiAgICAvPlxuICApO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE5hdmlnYXRlUHJvcHMge1xuICB0bzogVG87XG4gIHJlcGxhY2U/OiBib29sZWFuO1xuICBzdGF0ZT86IGFueTtcbn1cblxuLyoqXG4gKiBDaGFuZ2VzIHRoZSBjdXJyZW50IGxvY2F0aW9uLlxuICpcbiAqIE5vdGU6IFRoaXMgQVBJIGlzIG1vc3RseSB1c2VmdWwgaW4gUmVhY3QuQ29tcG9uZW50IHN1YmNsYXNzZXMgdGhhdCBhcmUgbm90XG4gKiBhYmxlIHRvIHVzZSBob29rcy4gSW4gZnVuY3Rpb25hbCBjb21wb25lbnRzLCB3ZSByZWNvbW1lbmQgeW91IHVzZSB0aGVcbiAqIGB1c2VOYXZpZ2F0ZWAgaG9vayBpbnN0ZWFkLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjbmF2aWdhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIE5hdmlnYXRlKHsgdG8sIHJlcGxhY2UsIHN0YXRlIH06IE5hdmlnYXRlUHJvcHMpOiBudWxsIHtcbiAgaW52YXJpYW50KFxuICAgIHVzZUluUm91dGVyQ29udGV4dCgpLFxuICAgIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mXG4gICAgLy8gdGhlIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgICBgPE5hdmlnYXRlPiBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LmBcbiAgKTtcblxuICB3YXJuaW5nKFxuICAgICFSZWFjdC51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KS5zdGF0aWMsXG4gICAgYDxOYXZpZ2F0ZT4gbXVzdCBub3QgYmUgdXNlZCBvbiB0aGUgaW5pdGlhbCByZW5kZXIgaW4gYSA8U3RhdGljUm91dGVyPi4gYCArXG4gICAgICBgVGhpcyBpcyBhIG5vLW9wLCBidXQgeW91IHNob3VsZCBtb2RpZnkgeW91ciBjb2RlIHNvIHRoZSA8TmF2aWdhdGU+IGlzIGAgK1xuICAgICAgYG9ubHkgZXZlciByZW5kZXJlZCBpbiByZXNwb25zZSB0byBzb21lIHVzZXIgaW50ZXJhY3Rpb24gb3Igc3RhdGUgY2hhbmdlLmBcbiAgKTtcblxuICBsZXQgbmF2aWdhdGUgPSB1c2VOYXZpZ2F0ZSgpO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIG5hdmlnYXRlKHRvLCB7IHJlcGxhY2UsIHN0YXRlIH0pO1xuICB9KTtcblxuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPdXRsZXRQcm9wcyB7XG4gIGNvbnRleHQ/OiB1bmtub3duO1xufVxuXG4vKipcbiAqIFJlbmRlcnMgdGhlIGNoaWxkIHJvdXRlJ3MgZWxlbWVudCwgaWYgdGhlcmUgaXMgb25lLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjb3V0bGV0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBPdXRsZXQocHJvcHM6IE91dGxldFByb3BzKTogUmVhY3QuUmVhY3RFbGVtZW50IHwgbnVsbCB7XG4gIHJldHVybiB1c2VPdXRsZXQocHJvcHMuY29udGV4dCk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVQcm9wcyB7XG4gIGNhc2VTZW5zaXRpdmU/OiBib29sZWFuO1xuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgZWxlbWVudD86IFJlYWN0LlJlYWN0Tm9kZSB8IG51bGw7XG4gIGluZGV4PzogYm9vbGVhbjtcbiAgcGF0aD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQYXRoUm91dGVQcm9wcyB7XG4gIGNhc2VTZW5zaXRpdmU/OiBib29sZWFuO1xuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgZWxlbWVudD86IFJlYWN0LlJlYWN0Tm9kZSB8IG51bGw7XG4gIGluZGV4PzogZmFsc2U7XG4gIHBhdGg6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMYXlvdXRSb3V0ZVByb3BzIHtcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGU7XG4gIGVsZW1lbnQ/OiBSZWFjdC5SZWFjdE5vZGUgfCBudWxsO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEluZGV4Um91dGVQcm9wcyB7XG4gIGVsZW1lbnQ/OiBSZWFjdC5SZWFjdE5vZGUgfCBudWxsO1xuICBpbmRleDogdHJ1ZTtcbn1cblxuLyoqXG4gKiBEZWNsYXJlcyBhbiBlbGVtZW50IHRoYXQgc2hvdWxkIGJlIHJlbmRlcmVkIGF0IGEgY2VydGFpbiBVUkwgcGF0aC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI3JvdXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBSb3V0ZShcbiAgX3Byb3BzOiBQYXRoUm91dGVQcm9wcyB8IExheW91dFJvdXRlUHJvcHMgfCBJbmRleFJvdXRlUHJvcHNcbik6IFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bGwge1xuICBpbnZhcmlhbnQoXG4gICAgZmFsc2UsXG4gICAgYEEgPFJvdXRlPiBpcyBvbmx5IGV2ZXIgdG8gYmUgdXNlZCBhcyB0aGUgY2hpbGQgb2YgPFJvdXRlcz4gZWxlbWVudCwgYCArXG4gICAgICBgbmV2ZXIgcmVuZGVyZWQgZGlyZWN0bHkuIFBsZWFzZSB3cmFwIHlvdXIgPFJvdXRlPiBpbiBhIDxSb3V0ZXM+LmBcbiAgKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSb3V0ZXJQcm9wcyB7XG4gIGJhc2VuYW1lPzogc3RyaW5nO1xuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgbG9jYXRpb246IFBhcnRpYWw8TG9jYXRpb24+IHwgc3RyaW5nO1xuICBuYXZpZ2F0aW9uVHlwZT86IE5hdmlnYXRpb25UeXBlO1xuICBuYXZpZ2F0b3I6IE5hdmlnYXRvcjtcbiAgc3RhdGljPzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBQcm92aWRlcyBsb2NhdGlvbiBjb250ZXh0IGZvciB0aGUgcmVzdCBvZiB0aGUgYXBwLlxuICpcbiAqIE5vdGU6IFlvdSB1c3VhbGx5IHdvbid0IHJlbmRlciBhIDxSb3V0ZXI+IGRpcmVjdGx5LiBJbnN0ZWFkLCB5b3UnbGwgcmVuZGVyIGFcbiAqIHJvdXRlciB0aGF0IGlzIG1vcmUgc3BlY2lmaWMgdG8geW91ciBlbnZpcm9ubWVudCBzdWNoIGFzIGEgPEJyb3dzZXJSb3V0ZXI+XG4gKiBpbiB3ZWIgYnJvd3NlcnMgb3IgYSA8U3RhdGljUm91dGVyPiBmb3Igc2VydmVyIHJlbmRlcmluZy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI3JvdXRlclxuICovXG5leHBvcnQgZnVuY3Rpb24gUm91dGVyKHtcbiAgYmFzZW5hbWU6IGJhc2VuYW1lUHJvcCA9IFwiL1wiLFxuICBjaGlsZHJlbiA9IG51bGwsXG4gIGxvY2F0aW9uOiBsb2NhdGlvblByb3AsXG4gIG5hdmlnYXRpb25UeXBlID0gTmF2aWdhdGlvblR5cGUuUG9wLFxuICBuYXZpZ2F0b3IsXG4gIHN0YXRpYzogc3RhdGljUHJvcCA9IGZhbHNlXG59OiBSb3V0ZXJQcm9wcyk6IFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bGwge1xuICBpbnZhcmlhbnQoXG4gICAgIXVzZUluUm91dGVyQ29udGV4dCgpLFxuICAgIGBZb3UgY2Fubm90IHJlbmRlciBhIDxSb3V0ZXI+IGluc2lkZSBhbm90aGVyIDxSb3V0ZXI+LmAgK1xuICAgICAgYCBZb3Ugc2hvdWxkIG5ldmVyIGhhdmUgbW9yZSB0aGFuIG9uZSBpbiB5b3VyIGFwcC5gXG4gICk7XG5cbiAgbGV0IGJhc2VuYW1lID0gbm9ybWFsaXplUGF0aG5hbWUoYmFzZW5hbWVQcm9wKTtcbiAgbGV0IG5hdmlnYXRpb25Db250ZXh0ID0gUmVhY3QudXNlTWVtbyhcbiAgICAoKSA9PiAoeyBiYXNlbmFtZSwgbmF2aWdhdG9yLCBzdGF0aWM6IHN0YXRpY1Byb3AgfSksXG4gICAgW2Jhc2VuYW1lLCBuYXZpZ2F0b3IsIHN0YXRpY1Byb3BdXG4gICk7XG5cbiAgaWYgKHR5cGVvZiBsb2NhdGlvblByb3AgPT09IFwic3RyaW5nXCIpIHtcbiAgICBsb2NhdGlvblByb3AgPSBwYXJzZVBhdGgobG9jYXRpb25Qcm9wKTtcbiAgfVxuXG4gIGxldCB7XG4gICAgcGF0aG5hbWUgPSBcIi9cIixcbiAgICBzZWFyY2ggPSBcIlwiLFxuICAgIGhhc2ggPSBcIlwiLFxuICAgIHN0YXRlID0gbnVsbCxcbiAgICBrZXkgPSBcImRlZmF1bHRcIlxuICB9ID0gbG9jYXRpb25Qcm9wO1xuXG4gIGxldCBsb2NhdGlvbiA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGxldCB0cmFpbGluZ1BhdGhuYW1lID0gc3RyaXBCYXNlbmFtZShwYXRobmFtZSwgYmFzZW5hbWUpO1xuXG4gICAgaWYgKHRyYWlsaW5nUGF0aG5hbWUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGhuYW1lOiB0cmFpbGluZ1BhdGhuYW1lLFxuICAgICAgc2VhcmNoLFxuICAgICAgaGFzaCxcbiAgICAgIHN0YXRlLFxuICAgICAga2V5XG4gICAgfTtcbiAgfSwgW2Jhc2VuYW1lLCBwYXRobmFtZSwgc2VhcmNoLCBoYXNoLCBzdGF0ZSwga2V5XSk7XG5cbiAgd2FybmluZyhcbiAgICBsb2NhdGlvbiAhPSBudWxsLFxuICAgIGA8Um91dGVyIGJhc2VuYW1lPVwiJHtiYXNlbmFtZX1cIj4gaXMgbm90IGFibGUgdG8gbWF0Y2ggdGhlIFVSTCBgICtcbiAgICAgIGBcIiR7cGF0aG5hbWV9JHtzZWFyY2h9JHtoYXNofVwiIGJlY2F1c2UgaXQgZG9lcyBub3Qgc3RhcnQgd2l0aCB0aGUgYCArXG4gICAgICBgYmFzZW5hbWUsIHNvIHRoZSA8Um91dGVyPiB3b24ndCByZW5kZXIgYW55dGhpbmcuYFxuICApO1xuXG4gIGlmIChsb2NhdGlvbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxOYXZpZ2F0aW9uQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17bmF2aWdhdGlvbkNvbnRleHR9PlxuICAgICAgPExvY2F0aW9uQ29udGV4dC5Qcm92aWRlclxuICAgICAgICBjaGlsZHJlbj17Y2hpbGRyZW59XG4gICAgICAgIHZhbHVlPXt7IGxvY2F0aW9uLCBuYXZpZ2F0aW9uVHlwZSB9fVxuICAgICAgLz5cbiAgICA8L05hdmlnYXRpb25Db250ZXh0LlByb3ZpZGVyPlxuICApO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlc1Byb3BzIHtcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGU7XG4gIGxvY2F0aW9uPzogUGFydGlhbDxMb2NhdGlvbj4gfCBzdHJpbmc7XG59XG5cbi8qKlxuICogQSBjb250YWluZXIgZm9yIGEgbmVzdGVkIHRyZWUgb2YgPFJvdXRlPiBlbGVtZW50cyB0aGF0IHJlbmRlcnMgdGhlIGJyYW5jaFxuICogdGhhdCBiZXN0IG1hdGNoZXMgdGhlIGN1cnJlbnQgbG9jYXRpb24uXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSNyb3V0ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFJvdXRlcyh7XG4gIGNoaWxkcmVuLFxuICBsb2NhdGlvblxufTogUm91dGVzUHJvcHMpOiBSZWFjdC5SZWFjdEVsZW1lbnQgfCBudWxsIHtcbiAgcmV0dXJuIHVzZVJvdXRlcyhjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4oY2hpbGRyZW4pLCBsb2NhdGlvbik7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEhPT0tTXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogUmV0dXJucyB0aGUgZnVsbCBocmVmIGZvciB0aGUgZ2l2ZW4gXCJ0b1wiIHZhbHVlLiBUaGlzIGlzIHVzZWZ1bCBmb3IgYnVpbGRpbmdcbiAqIGN1c3RvbSBsaW5rcyB0aGF0IGFyZSBhbHNvIGFjY2Vzc2libGUgYW5kIHByZXNlcnZlIHJpZ2h0LWNsaWNrIGJlaGF2aW9yLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjdXNlaHJlZlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlSHJlZih0bzogVG8pOiBzdHJpbmcge1xuICBpbnZhcmlhbnQoXG4gICAgdXNlSW5Sb3V0ZXJDb250ZXh0KCksXG4gICAgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2YgdGhlXG4gICAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICAgIGB1c2VIcmVmKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5gXG4gICk7XG5cbiAgbGV0IHsgYmFzZW5hbWUsIG5hdmlnYXRvciB9ID0gUmVhY3QudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCk7XG4gIGxldCB7IGhhc2gsIHBhdGhuYW1lLCBzZWFyY2ggfSA9IHVzZVJlc29sdmVkUGF0aCh0byk7XG5cbiAgbGV0IGpvaW5lZFBhdGhuYW1lID0gcGF0aG5hbWU7XG4gIGlmIChiYXNlbmFtZSAhPT0gXCIvXCIpIHtcbiAgICBsZXQgdG9QYXRobmFtZSA9IGdldFRvUGF0aG5hbWUodG8pO1xuICAgIGxldCBlbmRzV2l0aFNsYXNoID0gdG9QYXRobmFtZSAhPSBudWxsICYmIHRvUGF0aG5hbWUuZW5kc1dpdGgoXCIvXCIpO1xuICAgIGpvaW5lZFBhdGhuYW1lID1cbiAgICAgIHBhdGhuYW1lID09PSBcIi9cIlxuICAgICAgICA/IGJhc2VuYW1lICsgKGVuZHNXaXRoU2xhc2ggPyBcIi9cIiA6IFwiXCIpXG4gICAgICAgIDogam9pblBhdGhzKFtiYXNlbmFtZSwgcGF0aG5hbWVdKTtcbiAgfVxuXG4gIHJldHVybiBuYXZpZ2F0b3IuY3JlYXRlSHJlZih7IHBhdGhuYW1lOiBqb2luZWRQYXRobmFtZSwgc2VhcmNoLCBoYXNoIH0pO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGNvbXBvbmVudCBpcyBhIGRlc2NlbmRhbnQgb2YgYSA8Um91dGVyPi5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI3VzZWlucm91dGVyY29udGV4dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlSW5Sb3V0ZXJDb250ZXh0KCk6IGJvb2xlYW4ge1xuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChMb2NhdGlvbkNvbnRleHQpICE9IG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBsb2NhdGlvbiBvYmplY3QsIHdoaWNoIHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgVVJMIGluIHdlYlxuICogYnJvd3NlcnMuXG4gKlxuICogTm90ZTogSWYgeW91J3JlIHVzaW5nIHRoaXMgaXQgbWF5IG1lYW4geW91J3JlIGRvaW5nIHNvbWUgb2YgeW91ciBvd25cbiAqIFwicm91dGluZ1wiIGluIHlvdXIgYXBwLCBhbmQgd2UnZCBsaWtlIHRvIGtub3cgd2hhdCB5b3VyIHVzZSBjYXNlIGlzLiBXZSBtYXlcbiAqIGJlIGFibGUgdG8gcHJvdmlkZSBzb21ldGhpbmcgaGlnaGVyLWxldmVsIHRvIGJldHRlciBzdWl0IHlvdXIgbmVlZHMuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSN1c2Vsb2NhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTG9jYXRpb24oKTogTG9jYXRpb24ge1xuICBpbnZhcmlhbnQoXG4gICAgdXNlSW5Sb3V0ZXJDb250ZXh0KCksXG4gICAgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2YgdGhlXG4gICAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICAgIGB1c2VMb2NhdGlvbigpIG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuYFxuICApO1xuXG4gIHJldHVybiBSZWFjdC51c2VDb250ZXh0KExvY2F0aW9uQ29udGV4dCkubG9jYXRpb247XG59XG5cbnR5cGUgUGFyYW1QYXJzZUZhaWxlZCA9IHsgZmFpbGVkOiB0cnVlIH07XG5cbnR5cGUgUGFyYW1QYXJzZVNlZ21lbnQ8U2VnbWVudCBleHRlbmRzIHN0cmluZz4gPVxuICAvLyBDaGVjayBoZXJlIGlmIHRoZXJlIGV4aXN0cyBhIGZvcndhcmQgc2xhc2ggaW4gdGhlIHN0cmluZy5cbiAgU2VnbWVudCBleHRlbmRzIGAke2luZmVyIExlZnRTZWdtZW50fS8ke2luZmVyIFJpZ2h0U2VnbWVudH1gXG4gICAgPyAvLyBJZiB0aGVyZSBpcyBhIGZvcndhcmQgc2xhc2gsIHRoZW4gYXR0ZW1wdCB0byBwYXJzZSBlYWNoIHNpZGUgb2YgdGhlXG4gICAgICAvLyBmb3J3YXJkIHNsYXNoLlxuICAgICAgUGFyYW1QYXJzZVNlZ21lbnQ8TGVmdFNlZ21lbnQ+IGV4dGVuZHMgaW5mZXIgTGVmdFJlc3VsdFxuICAgICAgPyBQYXJhbVBhcnNlU2VnbWVudDxSaWdodFNlZ21lbnQ+IGV4dGVuZHMgaW5mZXIgUmlnaHRSZXN1bHRcbiAgICAgICAgPyBMZWZ0UmVzdWx0IGV4dGVuZHMgc3RyaW5nXG4gICAgICAgICAgPyAvLyBJZiB0aGUgbGVmdCBzaWRlIGlzIHN1Y2Nlc3NmdWxseSBwYXJzZWQgYXMgYSBwYXJhbSwgdGhlbiBjaGVjayBpZlxuICAgICAgICAgICAgLy8gdGhlIHJpZ2h0IHNpZGUgY2FuIGJlIHN1Y2Nlc3NmdWxseSBwYXJzZWQgYXMgd2VsbC4gSWYgYm90aCBzaWRlc1xuICAgICAgICAgICAgLy8gY2FuIGJlIHBhcnNlZCwgdGhlbiB0aGUgcmVzdWx0IGlzIGEgdW5pb24gb2YgdGhlIHR3byBzaWRlc1xuICAgICAgICAgICAgLy8gKHJlYWQ6IFwiZm9vXCIgfCBcImJhclwiKS5cbiAgICAgICAgICAgIFJpZ2h0UmVzdWx0IGV4dGVuZHMgc3RyaW5nXG4gICAgICAgICAgICA/IExlZnRSZXN1bHQgfCBSaWdodFJlc3VsdFxuICAgICAgICAgICAgOiBMZWZ0UmVzdWx0XG4gICAgICAgICAgOiAvLyBJZiB0aGUgbGVmdCBzaWRlIGlzIG5vdCBzdWNjZXNzZnVsbHkgcGFyc2VkIGFzIGEgcGFyYW0sIHRoZW4gY2hlY2tcbiAgICAgICAgICAvLyBpZiBvbmx5IHRoZSByaWdodCBzaWRlIGNhbiBiZSBzdWNjZXNzZnVsbHkgcGFyc2UgYXMgYSBwYXJhbS4gSWYgaXRcbiAgICAgICAgICAvLyBjYW4sIHRoZW4gdGhlIHJlc3VsdCBpcyBqdXN0IHJpZ2h0LCBlbHNlIGl0J3MgYSBmYWlsdXJlLlxuICAgICAgICAgIFJpZ2h0UmVzdWx0IGV4dGVuZHMgc3RyaW5nXG4gICAgICAgICAgPyBSaWdodFJlc3VsdFxuICAgICAgICAgIDogUGFyYW1QYXJzZUZhaWxlZFxuICAgICAgICA6IFBhcmFtUGFyc2VGYWlsZWRcbiAgICAgIDogLy8gSWYgdGhlIGxlZnQgc2lkZSBkaWRuJ3QgcGFyc2UgaW50byBhIHBhcmFtLCB0aGVuIGp1c3QgY2hlY2sgdGhlIHJpZ2h0XG4gICAgICAvLyBzaWRlLlxuICAgICAgUGFyYW1QYXJzZVNlZ21lbnQ8UmlnaHRTZWdtZW50PiBleHRlbmRzIGluZmVyIFJpZ2h0UmVzdWx0XG4gICAgICA/IFJpZ2h0UmVzdWx0IGV4dGVuZHMgc3RyaW5nXG4gICAgICAgID8gUmlnaHRSZXN1bHRcbiAgICAgICAgOiBQYXJhbVBhcnNlRmFpbGVkXG4gICAgICA6IFBhcmFtUGFyc2VGYWlsZWRcbiAgICA6IC8vIElmIHRoZXJlJ3Mgbm8gZm9yd2FyZCBzbGFzaCwgdGhlbiBjaGVjayBpZiB0aGlzIHNlZ21lbnQgc3RhcnRzIHdpdGggYVxuICAgIC8vIGNvbG9uLiBJZiBpdCBkb2VzLCB0aGVuIHRoaXMgaXMgYSBkeW5hbWljIHNlZ21lbnQsIHNvIHRoZSByZXN1bHQgaXNcbiAgICAvLyBqdXN0IHRoZSByZW1haW5kZXIgb2YgdGhlIHN0cmluZy4gT3RoZXJ3aXNlLCBpdCdzIGEgZmFpbHVyZS5cbiAgICBTZWdtZW50IGV4dGVuZHMgYDoke2luZmVyIFJlbWFpbmluZ31gXG4gICAgPyBSZW1haW5pbmdcbiAgICA6IFBhcmFtUGFyc2VGYWlsZWQ7XG5cbi8vIEF0dGVtcHQgdG8gcGFyc2UgdGhlIGdpdmVuIHN0cmluZyBzZWdtZW50LiBJZiBpdCBmYWlscywgdGhlbiBqdXN0IHJldHVybiB0aGVcbi8vIHBsYWluIHN0cmluZyB0eXBlIGFzIGEgZGVmYXVsdCBmYWxsYmFjay4gT3RoZXJ3aXNlIHJldHVybiB0aGUgdW5pb24gb2YgdGhlXG4vLyBwYXJzZWQgc3RyaW5nIGxpdGVyYWxzIHRoYXQgd2VyZSByZWZlcmVuY2VkIGFzIGR5bmFtaWMgc2VnbWVudHMgaW4gdGhlIHJvdXRlLlxudHlwZSBQYXJhbVBhcnNlS2V5PFNlZ21lbnQgZXh0ZW5kcyBzdHJpbmc+ID1cbiAgUGFyYW1QYXJzZVNlZ21lbnQ8U2VnbWVudD4gZXh0ZW5kcyBzdHJpbmdcbiAgICA/IFBhcmFtUGFyc2VTZWdtZW50PFNlZ21lbnQ+XG4gICAgOiBzdHJpbmc7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBuYXZpZ2F0aW9uIGFjdGlvbiB3aGljaCBkZXNjcmliZXMgaG93IHRoZSByb3V0ZXIgY2FtZSB0b1xuICogdGhlIGN1cnJlbnQgbG9jYXRpb24sIGVpdGhlciBieSBhIHBvcCwgcHVzaCwgb3IgcmVwbGFjZSBvbiB0aGUgaGlzdG9yeSBzdGFjay5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI3VzZW5hdmlnYXRpb250eXBlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VOYXZpZ2F0aW9uVHlwZSgpOiBOYXZpZ2F0aW9uVHlwZSB7XG4gIHJldHVybiBSZWFjdC51c2VDb250ZXh0KExvY2F0aW9uQ29udGV4dCkubmF2aWdhdGlvblR5cGU7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBVUkwgZm9yIHRoZSBnaXZlbiBcInRvXCIgdmFsdWUgbWF0Y2hlcyB0aGUgY3VycmVudCBVUkwuXG4gKiBUaGlzIGlzIHVzZWZ1bCBmb3IgY29tcG9uZW50cyB0aGF0IG5lZWQgdG8ga25vdyBcImFjdGl2ZVwiIHN0YXRlLCBlLmcuXG4gKiA8TmF2TGluaz4uXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSN1c2VtYXRjaFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTWF0Y2g8XG4gIFBhcmFtS2V5IGV4dGVuZHMgUGFyYW1QYXJzZUtleTxQYXRoPixcbiAgUGF0aCBleHRlbmRzIHN0cmluZ1xuPihwYXR0ZXJuOiBQYXRoUGF0dGVybjxQYXRoPiB8IFBhdGgpOiBQYXRoTWF0Y2g8UGFyYW1LZXk+IHwgbnVsbCB7XG4gIGludmFyaWFudChcbiAgICB1c2VJblJvdXRlckNvbnRleHQoKSxcbiAgICAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgICAvLyByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gICAgYHVzZU1hdGNoKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5gXG4gICk7XG5cbiAgbGV0IHsgcGF0aG5hbWUgfSA9IHVzZUxvY2F0aW9uKCk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKFxuICAgICgpID0+IG1hdGNoUGF0aDxQYXJhbUtleSwgUGF0aD4ocGF0dGVybiwgcGF0aG5hbWUpLFxuICAgIFtwYXRobmFtZSwgcGF0dGVybl1cbiAgKTtcbn1cblxuLyoqXG4gKiBUaGUgaW50ZXJmYWNlIGZvciB0aGUgbmF2aWdhdGUoKSBmdW5jdGlvbiByZXR1cm5lZCBmcm9tIHVzZU5hdmlnYXRlKCkuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTmF2aWdhdGVGdW5jdGlvbiB7XG4gICh0bzogVG8sIG9wdGlvbnM/OiBOYXZpZ2F0ZU9wdGlvbnMpOiB2b2lkO1xuICAoZGVsdGE6IG51bWJlcik6IHZvaWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTmF2aWdhdGVPcHRpb25zIHtcbiAgcmVwbGFjZT86IGJvb2xlYW47XG4gIHN0YXRlPzogYW55O1xufVxuXG4vKipcbiAqIFJldHVybnMgYW4gaW1wZXJhdGl2ZSBtZXRob2QgZm9yIGNoYW5naW5nIHRoZSBsb2NhdGlvbi4gVXNlZCBieSA8TGluaz5zLCBidXRcbiAqIG1heSBhbHNvIGJlIHVzZWQgYnkgb3RoZXIgZWxlbWVudHMgdG8gY2hhbmdlIHRoZSBsb2NhdGlvbi5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI3VzZW5hdmlnYXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VOYXZpZ2F0ZSgpOiBOYXZpZ2F0ZUZ1bmN0aW9uIHtcbiAgaW52YXJpYW50KFxuICAgIHVzZUluUm91dGVyQ29udGV4dCgpLFxuICAgIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxuICAgIC8vIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgICBgdXNlTmF2aWdhdGUoKSBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LmBcbiAgKTtcblxuICBsZXQgeyBiYXNlbmFtZSwgbmF2aWdhdG9yIH0gPSBSZWFjdC51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcbiAgbGV0IHsgbWF0Y2hlcyB9ID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBsZXQgeyBwYXRobmFtZTogbG9jYXRpb25QYXRobmFtZSB9ID0gdXNlTG9jYXRpb24oKTtcblxuICBsZXQgcm91dGVQYXRobmFtZXNKc29uID0gSlNPTi5zdHJpbmdpZnkoXG4gICAgbWF0Y2hlcy5tYXAobWF0Y2ggPT4gbWF0Y2gucGF0aG5hbWVCYXNlKVxuICApO1xuXG4gIGxldCBhY3RpdmVSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGFjdGl2ZVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgfSk7XG5cbiAgbGV0IG5hdmlnYXRlOiBOYXZpZ2F0ZUZ1bmN0aW9uID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKHRvOiBUbyB8IG51bWJlciwgb3B0aW9uczogTmF2aWdhdGVPcHRpb25zID0ge30pID0+IHtcbiAgICAgIHdhcm5pbmcoXG4gICAgICAgIGFjdGl2ZVJlZi5jdXJyZW50LFxuICAgICAgICBgWW91IHNob3VsZCBjYWxsIG5hdmlnYXRlKCkgaW4gYSBSZWFjdC51c2VFZmZlY3QoKSwgbm90IHdoZW4gYCArXG4gICAgICAgICAgYHlvdXIgY29tcG9uZW50IGlzIGZpcnN0IHJlbmRlcmVkLmBcbiAgICAgICk7XG5cbiAgICAgIGlmICghYWN0aXZlUmVmLmN1cnJlbnQpIHJldHVybjtcblxuICAgICAgaWYgKHR5cGVvZiB0byA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBuYXZpZ2F0b3IuZ28odG8pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCBwYXRoID0gcmVzb2x2ZVRvKFxuICAgICAgICB0byxcbiAgICAgICAgSlNPTi5wYXJzZShyb3V0ZVBhdGhuYW1lc0pzb24pLFxuICAgICAgICBsb2NhdGlvblBhdGhuYW1lXG4gICAgICApO1xuXG4gICAgICBpZiAoYmFzZW5hbWUgIT09IFwiL1wiKSB7XG4gICAgICAgIHBhdGgucGF0aG5hbWUgPSBqb2luUGF0aHMoW2Jhc2VuYW1lLCBwYXRoLnBhdGhuYW1lXSk7XG4gICAgICB9XG5cbiAgICAgICghIW9wdGlvbnMucmVwbGFjZSA/IG5hdmlnYXRvci5yZXBsYWNlIDogbmF2aWdhdG9yLnB1c2gpKFxuICAgICAgICBwYXRoLFxuICAgICAgICBvcHRpb25zLnN0YXRlXG4gICAgICApO1xuICAgIH0sXG4gICAgW2Jhc2VuYW1lLCBuYXZpZ2F0b3IsIHJvdXRlUGF0aG5hbWVzSnNvbiwgbG9jYXRpb25QYXRobmFtZV1cbiAgKTtcblxuICByZXR1cm4gbmF2aWdhdGU7XG59XG5cbmNvbnN0IE91dGxldENvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0PHVua25vd24+KG51bGwpO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGNvbnRleHQgKGlmIHByb3ZpZGVkKSBmb3IgdGhlIGNoaWxkIHJvdXRlIGF0IHRoaXMgbGV2ZWwgb2YgdGhlIHJvdXRlXG4gKiBoaWVyYXJjaHkuXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI3VzZW91dGxldGNvbnRleHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU91dGxldENvbnRleHQ8Q29udGV4dCA9IHVua25vd24+KCk6IENvbnRleHQge1xuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChPdXRsZXRDb250ZXh0KSBhcyBDb250ZXh0O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGVsZW1lbnQgZm9yIHRoZSBjaGlsZCByb3V0ZSBhdCB0aGlzIGxldmVsIG9mIHRoZSByb3V0ZVxuICogaGllcmFyY2h5LiBVc2VkIGludGVybmFsbHkgYnkgPE91dGxldD4gdG8gcmVuZGVyIGNoaWxkIHJvdXRlcy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI3VzZW91dGxldFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlT3V0bGV0KGNvbnRleHQ/OiB1bmtub3duKTogUmVhY3QuUmVhY3RFbGVtZW50IHwgbnVsbCB7XG4gIGxldCBvdXRsZXQgPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCkub3V0bGV0O1xuICBpZiAob3V0bGV0KSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxPdXRsZXRDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtjb250ZXh0fT57b3V0bGV0fTwvT3V0bGV0Q29udGV4dC5Qcm92aWRlcj5cbiAgICApO1xuICB9XG4gIHJldHVybiBvdXRsZXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBvYmplY3Qgb2Yga2V5L3ZhbHVlIHBhaXJzIG9mIHRoZSBkeW5hbWljIHBhcmFtcyBmcm9tIHRoZSBjdXJyZW50XG4gKiBVUkwgdGhhdCB3ZXJlIG1hdGNoZWQgYnkgdGhlIHJvdXRlIHBhdGguXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSN1c2VwYXJhbXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVBhcmFtczxcbiAgUGFyYW1zT3JLZXkgZXh0ZW5kcyBzdHJpbmcgfCBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCB1bmRlZmluZWQ+ID0gc3RyaW5nXG4+KCk6IFJlYWRvbmx5PFxuICBbUGFyYW1zT3JLZXldIGV4dGVuZHMgW3N0cmluZ10gPyBQYXJhbXM8UGFyYW1zT3JLZXk+IDogUGFydGlhbDxQYXJhbXNPcktleT5cbj4ge1xuICBsZXQgeyBtYXRjaGVzIH0gPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGxldCByb3V0ZU1hdGNoID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gcm91dGVNYXRjaCA/IChyb3V0ZU1hdGNoLnBhcmFtcyBhcyBhbnkpIDoge307XG59XG5cbi8qKlxuICogUmVzb2x2ZXMgdGhlIHBhdGhuYW1lIG9mIHRoZSBnaXZlbiBgdG9gIHZhbHVlIGFnYWluc3QgdGhlIGN1cnJlbnQgbG9jYXRpb24uXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSN1c2VyZXNvbHZlZHBhdGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVJlc29sdmVkUGF0aCh0bzogVG8pOiBQYXRoIHtcbiAgbGV0IHsgbWF0Y2hlcyB9ID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBsZXQgeyBwYXRobmFtZTogbG9jYXRpb25QYXRobmFtZSB9ID0gdXNlTG9jYXRpb24oKTtcblxuICBsZXQgcm91dGVQYXRobmFtZXNKc29uID0gSlNPTi5zdHJpbmdpZnkoXG4gICAgbWF0Y2hlcy5tYXAobWF0Y2ggPT4gbWF0Y2gucGF0aG5hbWVCYXNlKVxuICApO1xuXG4gIHJldHVybiBSZWFjdC51c2VNZW1vKFxuICAgICgpID0+IHJlc29sdmVUbyh0bywgSlNPTi5wYXJzZShyb3V0ZVBhdGhuYW1lc0pzb24pLCBsb2NhdGlvblBhdGhuYW1lKSxcbiAgICBbdG8sIHJvdXRlUGF0aG5hbWVzSnNvbiwgbG9jYXRpb25QYXRobmFtZV1cbiAgKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBlbGVtZW50IG9mIHRoZSByb3V0ZSB0aGF0IG1hdGNoZWQgdGhlIGN1cnJlbnQgbG9jYXRpb24sIHByZXBhcmVkXG4gKiB3aXRoIHRoZSBjb3JyZWN0IGNvbnRleHQgdG8gcmVuZGVyIHRoZSByZW1haW5kZXIgb2YgdGhlIHJvdXRlIHRyZWUuIFJvdXRlXG4gKiBlbGVtZW50cyBpbiB0aGUgdHJlZSBtdXN0IHJlbmRlciBhbiA8T3V0bGV0PiB0byByZW5kZXIgdGhlaXIgY2hpbGQgcm91dGUnc1xuICogZWxlbWVudC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI3VzZXJvdXRlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUm91dGVzKFxuICByb3V0ZXM6IFJvdXRlT2JqZWN0W10sXG4gIGxvY2F0aW9uQXJnPzogUGFydGlhbDxMb2NhdGlvbj4gfCBzdHJpbmdcbik6IFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bGwge1xuICBpbnZhcmlhbnQoXG4gICAgdXNlSW5Sb3V0ZXJDb250ZXh0KCksXG4gICAgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2YgdGhlXG4gICAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICAgIGB1c2VSb3V0ZXMoKSBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LmBcbiAgKTtcblxuICBsZXQgeyBtYXRjaGVzOiBwYXJlbnRNYXRjaGVzIH0gPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGxldCByb3V0ZU1hdGNoID0gcGFyZW50TWF0Y2hlc1twYXJlbnRNYXRjaGVzLmxlbmd0aCAtIDFdO1xuICBsZXQgcGFyZW50UGFyYW1zID0gcm91dGVNYXRjaCA/IHJvdXRlTWF0Y2gucGFyYW1zIDoge307XG4gIGxldCBwYXJlbnRQYXRobmFtZSA9IHJvdXRlTWF0Y2ggPyByb3V0ZU1hdGNoLnBhdGhuYW1lIDogXCIvXCI7XG4gIGxldCBwYXJlbnRQYXRobmFtZUJhc2UgPSByb3V0ZU1hdGNoID8gcm91dGVNYXRjaC5wYXRobmFtZUJhc2UgOiBcIi9cIjtcbiAgbGV0IHBhcmVudFJvdXRlID0gcm91dGVNYXRjaCAmJiByb3V0ZU1hdGNoLnJvdXRlO1xuXG4gIGlmIChfX0RFVl9fKSB7XG4gICAgLy8gWW91IHdvbid0IGdldCBhIHdhcm5pbmcgYWJvdXQgMiBkaWZmZXJlbnQgPFJvdXRlcz4gdW5kZXIgYSA8Um91dGU+XG4gICAgLy8gd2l0aG91dCBhIHRyYWlsaW5nICosIGJ1dCB0aGlzIGlzIGEgYmVzdC1lZmZvcnQgd2FybmluZyBhbnl3YXkgc2luY2Ugd2VcbiAgICAvLyBjYW5ub3QgZXZlbiBnaXZlIHRoZSB3YXJuaW5nIHVubGVzcyB0aGV5IGxhbmQgYXQgdGhlIHBhcmVudCByb3V0ZS5cbiAgICAvL1xuICAgIC8vIEV4YW1wbGU6XG4gICAgLy9cbiAgICAvLyA8Um91dGVzPlxuICAgIC8vICAgey8qIFRoaXMgcm91dGUgcGF0aCBNVVNUIGVuZCB3aXRoIC8qIGJlY2F1c2Ugb3RoZXJ3aXNlXG4gICAgLy8gICAgICAgaXQgd2lsbCBuZXZlciBtYXRjaCAvYmxvZy9wb3N0LzEyMyAqL31cbiAgICAvLyAgIDxSb3V0ZSBwYXRoPVwiYmxvZ1wiIGVsZW1lbnQ9ezxCbG9nIC8+fSAvPlxuICAgIC8vICAgPFJvdXRlIHBhdGg9XCJibG9nL2ZlZWRcIiBlbGVtZW50PXs8QmxvZ0ZlZWQgLz59IC8+XG4gICAgLy8gPC9Sb3V0ZXM+XG4gICAgLy9cbiAgICAvLyBmdW5jdGlvbiBCbG9nKCkge1xuICAgIC8vICAgcmV0dXJuIChcbiAgICAvLyAgICAgPFJvdXRlcz5cbiAgICAvLyAgICAgICA8Um91dGUgcGF0aD1cInBvc3QvOmlkXCIgZWxlbWVudD17PFBvc3QgLz59IC8+XG4gICAgLy8gICAgIDwvUm91dGVzPlxuICAgIC8vICAgKTtcbiAgICAvLyB9XG4gICAgbGV0IHBhcmVudFBhdGggPSAocGFyZW50Um91dGUgJiYgcGFyZW50Um91dGUucGF0aCkgfHwgXCJcIjtcbiAgICB3YXJuaW5nT25jZShcbiAgICAgIHBhcmVudFBhdGhuYW1lLFxuICAgICAgIXBhcmVudFJvdXRlIHx8IHBhcmVudFBhdGguZW5kc1dpdGgoXCIqXCIpLFxuICAgICAgYFlvdSByZW5kZXJlZCBkZXNjZW5kYW50IDxSb3V0ZXM+IChvciBjYWxsZWQgXFxgdXNlUm91dGVzKClcXGApIGF0IGAgK1xuICAgICAgICBgXCIke3BhcmVudFBhdGhuYW1lfVwiICh1bmRlciA8Um91dGUgcGF0aD1cIiR7cGFyZW50UGF0aH1cIj4pIGJ1dCB0aGUgYCArXG4gICAgICAgIGBwYXJlbnQgcm91dGUgcGF0aCBoYXMgbm8gdHJhaWxpbmcgXCIqXCIuIFRoaXMgbWVhbnMgaWYgeW91IG5hdmlnYXRlIGAgK1xuICAgICAgICBgZGVlcGVyLCB0aGUgcGFyZW50IHdvbid0IG1hdGNoIGFueW1vcmUgYW5kIHRoZXJlZm9yZSB0aGUgY2hpbGQgYCArXG4gICAgICAgIGByb3V0ZXMgd2lsbCBuZXZlciByZW5kZXIuXFxuXFxuYCArXG4gICAgICAgIGBQbGVhc2UgY2hhbmdlIHRoZSBwYXJlbnQgPFJvdXRlIHBhdGg9XCIke3BhcmVudFBhdGh9XCI+IHRvIDxSb3V0ZSBgICtcbiAgICAgICAgYHBhdGg9XCIke3BhcmVudFBhdGggPT09IFwiL1wiID8gXCIqXCIgOiBgJHtwYXJlbnRQYXRofS8qYH1cIj4uYFxuICAgICk7XG4gIH1cblxuICBsZXQgbG9jYXRpb25Gcm9tQ29udGV4dCA9IHVzZUxvY2F0aW9uKCk7XG5cbiAgbGV0IGxvY2F0aW9uO1xuICBpZiAobG9jYXRpb25BcmcpIHtcbiAgICBsZXQgcGFyc2VkTG9jYXRpb25BcmcgPVxuICAgICAgdHlwZW9mIGxvY2F0aW9uQXJnID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKGxvY2F0aW9uQXJnKSA6IGxvY2F0aW9uQXJnO1xuXG4gICAgaW52YXJpYW50KFxuICAgICAgcGFyZW50UGF0aG5hbWVCYXNlID09PSBcIi9cIiB8fFxuICAgICAgICBwYXJzZWRMb2NhdGlvbkFyZy5wYXRobmFtZT8uc3RhcnRzV2l0aChwYXJlbnRQYXRobmFtZUJhc2UpLFxuICAgICAgYFdoZW4gb3ZlcnJpZGluZyB0aGUgbG9jYXRpb24gdXNpbmcgXFxgPFJvdXRlcyBsb2NhdGlvbj5cXGAgb3IgXFxgdXNlUm91dGVzKHJvdXRlcywgbG9jYXRpb24pXFxgLCBgICtcbiAgICAgICAgYHRoZSBsb2NhdGlvbiBwYXRobmFtZSBtdXN0IGJlZ2luIHdpdGggdGhlIHBvcnRpb24gb2YgdGhlIFVSTCBwYXRobmFtZSB0aGF0IHdhcyBgICtcbiAgICAgICAgYG1hdGNoZWQgYnkgYWxsIHBhcmVudCByb3V0ZXMuIFRoZSBjdXJyZW50IHBhdGhuYW1lIGJhc2UgaXMgXCIke3BhcmVudFBhdGhuYW1lQmFzZX1cIiBgICtcbiAgICAgICAgYGJ1dCBwYXRobmFtZSBcIiR7cGFyc2VkTG9jYXRpb25BcmcucGF0aG5hbWV9XCIgd2FzIGdpdmVuIGluIHRoZSBcXGBsb2NhdGlvblxcYCBwcm9wLmBcbiAgICApO1xuXG4gICAgbG9jYXRpb24gPSBwYXJzZWRMb2NhdGlvbkFyZztcbiAgfSBlbHNlIHtcbiAgICBsb2NhdGlvbiA9IGxvY2F0aW9uRnJvbUNvbnRleHQ7XG4gIH1cblxuICBsZXQgcGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZSB8fCBcIi9cIjtcbiAgbGV0IHJlbWFpbmluZ1BhdGhuYW1lID1cbiAgICBwYXJlbnRQYXRobmFtZUJhc2UgPT09IFwiL1wiXG4gICAgICA/IHBhdGhuYW1lXG4gICAgICA6IHBhdGhuYW1lLnNsaWNlKHBhcmVudFBhdGhuYW1lQmFzZS5sZW5ndGgpIHx8IFwiL1wiO1xuICBsZXQgbWF0Y2hlcyA9IG1hdGNoUm91dGVzKHJvdXRlcywgeyBwYXRobmFtZTogcmVtYWluaW5nUGF0aG5hbWUgfSk7XG5cbiAgaWYgKF9fREVWX18pIHtcbiAgICB3YXJuaW5nKFxuICAgICAgcGFyZW50Um91dGUgfHwgbWF0Y2hlcyAhPSBudWxsLFxuICAgICAgYE5vIHJvdXRlcyBtYXRjaGVkIGxvY2F0aW9uIFwiJHtsb2NhdGlvbi5wYXRobmFtZX0ke2xvY2F0aW9uLnNlYXJjaH0ke2xvY2F0aW9uLmhhc2h9XCIgYFxuICAgICk7XG5cbiAgICB3YXJuaW5nKFxuICAgICAgbWF0Y2hlcyA9PSBudWxsIHx8XG4gICAgICAgIG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXS5yb3V0ZS5lbGVtZW50ICE9PSB1bmRlZmluZWQsXG4gICAgICBgTWF0Y2hlZCBsZWFmIHJvdXRlIGF0IGxvY2F0aW9uIFwiJHtsb2NhdGlvbi5wYXRobmFtZX0ke2xvY2F0aW9uLnNlYXJjaH0ke2xvY2F0aW9uLmhhc2h9XCIgZG9lcyBub3QgaGF2ZSBhbiBlbGVtZW50LiBgICtcbiAgICAgICAgYFRoaXMgbWVhbnMgaXQgd2lsbCByZW5kZXIgYW4gPE91dGxldCAvPiB3aXRoIGEgbnVsbCB2YWx1ZSBieSBkZWZhdWx0IHJlc3VsdGluZyBpbiBhbiBcImVtcHR5XCIgcGFnZS5gXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBfcmVuZGVyTWF0Y2hlcyhcbiAgICBtYXRjaGVzICYmXG4gICAgICBtYXRjaGVzLm1hcChtYXRjaCA9PlxuICAgICAgICBPYmplY3QuYXNzaWduKHt9LCBtYXRjaCwge1xuICAgICAgICAgIHBhcmFtczogT2JqZWN0LmFzc2lnbih7fSwgcGFyZW50UGFyYW1zLCBtYXRjaC5wYXJhbXMpLFxuICAgICAgICAgIHBhdGhuYW1lOiBqb2luUGF0aHMoW3BhcmVudFBhdGhuYW1lQmFzZSwgbWF0Y2gucGF0aG5hbWVdKSxcbiAgICAgICAgICBwYXRobmFtZUJhc2U6XG4gICAgICAgICAgICBtYXRjaC5wYXRobmFtZUJhc2UgPT09IFwiL1wiXG4gICAgICAgICAgICAgID8gcGFyZW50UGF0aG5hbWVCYXNlXG4gICAgICAgICAgICAgIDogam9pblBhdGhzKFtwYXJlbnRQYXRobmFtZUJhc2UsIG1hdGNoLnBhdGhuYW1lQmFzZV0pXG4gICAgICAgIH0pXG4gICAgICApLFxuICAgIHBhcmVudE1hdGNoZXNcbiAgKTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gVVRJTFNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBDcmVhdGVzIGEgcm91dGUgY29uZmlnIGZyb20gYSBSZWFjdCBcImNoaWxkcmVuXCIgb2JqZWN0LCB3aGljaCBpcyB1c3VhbGx5XG4gKiBlaXRoZXIgYSBgPFJvdXRlPmAgZWxlbWVudCBvciBhbiBhcnJheSBvZiB0aGVtLiBVc2VkIGludGVybmFsbHkgYnlcbiAqIGA8Um91dGVzPmAgdG8gY3JlYXRlIGEgcm91dGUgY29uZmlnIGZyb20gaXRzIGNoaWxkcmVuLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjY3JlYXRlcm91dGVzZnJvbWNoaWxkcmVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4oXG4gIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGVcbik6IFJvdXRlT2JqZWN0W10ge1xuICBsZXQgcm91dGVzOiBSb3V0ZU9iamVjdFtdID0gW107XG5cbiAgUmVhY3QuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgZWxlbWVudCA9PiB7XG4gICAgaWYgKCFSZWFjdC5pc1ZhbGlkRWxlbWVudChlbGVtZW50KSkge1xuICAgICAgLy8gSWdub3JlIG5vbi1lbGVtZW50cy4gVGhpcyBhbGxvd3MgcGVvcGxlIHRvIG1vcmUgZWFzaWx5IGlubGluZVxuICAgICAgLy8gY29uZGl0aW9uYWxzIGluIHRoZWlyIHJvdXRlIGNvbmZpZy5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudC50eXBlID09PSBSZWFjdC5GcmFnbWVudCkge1xuICAgICAgLy8gVHJhbnNwYXJlbnRseSBzdXBwb3J0IFJlYWN0LkZyYWdtZW50IGFuZCBpdHMgY2hpbGRyZW4uXG4gICAgICByb3V0ZXMucHVzaC5hcHBseShcbiAgICAgICAgcm91dGVzLFxuICAgICAgICBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4oZWxlbWVudC5wcm9wcy5jaGlsZHJlbilcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW52YXJpYW50KFxuICAgICAgZWxlbWVudC50eXBlID09PSBSb3V0ZSxcbiAgICAgIGBbJHtcbiAgICAgICAgdHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gXCJzdHJpbmdcIiA/IGVsZW1lbnQudHlwZSA6IGVsZW1lbnQudHlwZS5uYW1lXG4gICAgICB9XSBpcyBub3QgYSA8Um91dGU+IGNvbXBvbmVudC4gQWxsIGNvbXBvbmVudCBjaGlsZHJlbiBvZiA8Um91dGVzPiBtdXN0IGJlIGEgPFJvdXRlPiBvciA8UmVhY3QuRnJhZ21lbnQ+YFxuICAgICk7XG5cbiAgICBsZXQgcm91dGU6IFJvdXRlT2JqZWN0ID0ge1xuICAgICAgY2FzZVNlbnNpdGl2ZTogZWxlbWVudC5wcm9wcy5jYXNlU2Vuc2l0aXZlLFxuICAgICAgZWxlbWVudDogZWxlbWVudC5wcm9wcy5lbGVtZW50LFxuICAgICAgaW5kZXg6IGVsZW1lbnQucHJvcHMuaW5kZXgsXG4gICAgICBwYXRoOiBlbGVtZW50LnByb3BzLnBhdGhcbiAgICB9O1xuXG4gICAgaWYgKGVsZW1lbnQucHJvcHMuY2hpbGRyZW4pIHtcbiAgICAgIHJvdXRlLmNoaWxkcmVuID0gY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuKGVsZW1lbnQucHJvcHMuY2hpbGRyZW4pO1xuICAgIH1cblxuICAgIHJvdXRlcy5wdXNoKHJvdXRlKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHJvdXRlcztcbn1cblxuLyoqXG4gKiBUaGUgcGFyYW1ldGVycyB0aGF0IHdlcmUgcGFyc2VkIGZyb20gdGhlIFVSTCBwYXRoLlxuICovXG5leHBvcnQgdHlwZSBQYXJhbXM8S2V5IGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPiA9IHtcbiAgcmVhZG9ubHkgW2tleSBpbiBLZXldOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIEEgcm91dGUgb2JqZWN0IHJlcHJlc2VudHMgYSBsb2dpY2FsIHJvdXRlLCB3aXRoIChvcHRpb25hbGx5KSBpdHMgY2hpbGRcbiAqIHJvdXRlcyBvcmdhbml6ZWQgaW4gYSB0cmVlLWxpa2Ugc3RydWN0dXJlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlT2JqZWN0IHtcbiAgY2FzZVNlbnNpdGl2ZT86IGJvb2xlYW47XG4gIGNoaWxkcmVuPzogUm91dGVPYmplY3RbXTtcbiAgZWxlbWVudD86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgaW5kZXg/OiBib29sZWFuO1xuICBwYXRoPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBwYXRoIHdpdGggcGFyYW1zIGludGVycG9sYXRlZC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI2dlbmVyYXRlcGF0aFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVQYXRoKHBhdGg6IHN0cmluZywgcGFyYW1zOiBQYXJhbXMgPSB7fSk6IHN0cmluZyB7XG4gIHJldHVybiBwYXRoXG4gICAgLnJlcGxhY2UoLzooXFx3KykvZywgKF8sIGtleSkgPT4ge1xuICAgICAgaW52YXJpYW50KHBhcmFtc1trZXldICE9IG51bGwsIGBNaXNzaW5nIFwiOiR7a2V5fVwiIHBhcmFtYCk7XG4gICAgICByZXR1cm4gcGFyYW1zW2tleV0hO1xuICAgIH0pXG4gICAgLnJlcGxhY2UoL1xcLypcXCokLywgXyA9PlxuICAgICAgcGFyYW1zW1wiKlwiXSA9PSBudWxsID8gXCJcIiA6IHBhcmFtc1tcIipcIl0ucmVwbGFjZSgvXlxcLyovLCBcIi9cIilcbiAgICApO1xufVxuXG4vKipcbiAqIEEgUm91dGVNYXRjaCBjb250YWlucyBpbmZvIGFib3V0IGhvdyBhIHJvdXRlIG1hdGNoZWQgYSBVUkwuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVNYXRjaDxQYXJhbUtleSBleHRlbmRzIHN0cmluZyA9IHN0cmluZz4ge1xuICAvKipcbiAgICogVGhlIG5hbWVzIGFuZCB2YWx1ZXMgb2YgZHluYW1pYyBwYXJhbWV0ZXJzIGluIHRoZSBVUkwuXG4gICAqL1xuICBwYXJhbXM6IFBhcmFtczxQYXJhbUtleT47XG4gIC8qKlxuICAgKiBUaGUgcG9ydGlvbiBvZiB0aGUgVVJMIHBhdGhuYW1lIHRoYXQgd2FzIG1hdGNoZWQuXG4gICAqL1xuICBwYXRobmFtZTogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIHBvcnRpb24gb2YgdGhlIFVSTCBwYXRobmFtZSB0aGF0IHdhcyBtYXRjaGVkIGJlZm9yZSBjaGlsZCByb3V0ZXMuXG4gICAqL1xuICBwYXRobmFtZUJhc2U6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSByb3V0ZSBvYmplY3QgdGhhdCB3YXMgdXNlZCB0byBtYXRjaC5cbiAgICovXG4gIHJvdXRlOiBSb3V0ZU9iamVjdDtcbn1cblxuLyoqXG4gKiBNYXRjaGVzIHRoZSBnaXZlbiByb3V0ZXMgdG8gYSBsb2NhdGlvbiBhbmQgcmV0dXJucyB0aGUgbWF0Y2ggZGF0YS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI21hdGNocm91dGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXRjaFJvdXRlcyhcbiAgcm91dGVzOiBSb3V0ZU9iamVjdFtdLFxuICBsb2NhdGlvbkFyZzogUGFydGlhbDxMb2NhdGlvbj4gfCBzdHJpbmcsXG4gIGJhc2VuYW1lID0gXCIvXCJcbik6IFJvdXRlTWF0Y2hbXSB8IG51bGwge1xuICBsZXQgbG9jYXRpb24gPVxuICAgIHR5cGVvZiBsb2NhdGlvbkFyZyA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aChsb2NhdGlvbkFyZykgOiBsb2NhdGlvbkFyZztcblxuICBsZXQgcGF0aG5hbWUgPSBzdHJpcEJhc2VuYW1lKGxvY2F0aW9uLnBhdGhuYW1lIHx8IFwiL1wiLCBiYXNlbmFtZSk7XG5cbiAgaWYgKHBhdGhuYW1lID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGxldCBicmFuY2hlcyA9IGZsYXR0ZW5Sb3V0ZXMocm91dGVzKTtcbiAgcmFua1JvdXRlQnJhbmNoZXMoYnJhbmNoZXMpO1xuXG4gIGxldCBtYXRjaGVzID0gbnVsbDtcbiAgZm9yIChsZXQgaSA9IDA7IG1hdGNoZXMgPT0gbnVsbCAmJiBpIDwgYnJhbmNoZXMubGVuZ3RoOyArK2kpIHtcbiAgICBtYXRjaGVzID0gbWF0Y2hSb3V0ZUJyYW5jaChicmFuY2hlc1tpXSwgcGF0aG5hbWUpO1xuICB9XG5cbiAgcmV0dXJuIG1hdGNoZXM7XG59XG5cbmludGVyZmFjZSBSb3V0ZU1ldGEge1xuICByZWxhdGl2ZVBhdGg6IHN0cmluZztcbiAgY2FzZVNlbnNpdGl2ZTogYm9vbGVhbjtcbiAgY2hpbGRyZW5JbmRleDogbnVtYmVyO1xuICByb3V0ZTogUm91dGVPYmplY3Q7XG59XG5cbmludGVyZmFjZSBSb3V0ZUJyYW5jaCB7XG4gIHBhdGg6IHN0cmluZztcbiAgc2NvcmU6IG51bWJlcjtcbiAgcm91dGVzTWV0YTogUm91dGVNZXRhW107XG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW5Sb3V0ZXMoXG4gIHJvdXRlczogUm91dGVPYmplY3RbXSxcbiAgYnJhbmNoZXM6IFJvdXRlQnJhbmNoW10gPSBbXSxcbiAgcGFyZW50c01ldGE6IFJvdXRlTWV0YVtdID0gW10sXG4gIHBhcmVudFBhdGggPSBcIlwiXG4pOiBSb3V0ZUJyYW5jaFtdIHtcbiAgcm91dGVzLmZvckVhY2goKHJvdXRlLCBpbmRleCkgPT4ge1xuICAgIGxldCBtZXRhOiBSb3V0ZU1ldGEgPSB7XG4gICAgICByZWxhdGl2ZVBhdGg6IHJvdXRlLnBhdGggfHwgXCJcIixcbiAgICAgIGNhc2VTZW5zaXRpdmU6IHJvdXRlLmNhc2VTZW5zaXRpdmUgPT09IHRydWUsXG4gICAgICBjaGlsZHJlbkluZGV4OiBpbmRleCxcbiAgICAgIHJvdXRlXG4gICAgfTtcblxuICAgIGlmIChtZXRhLnJlbGF0aXZlUGF0aC5zdGFydHNXaXRoKFwiL1wiKSkge1xuICAgICAgaW52YXJpYW50KFxuICAgICAgICBtZXRhLnJlbGF0aXZlUGF0aC5zdGFydHNXaXRoKHBhcmVudFBhdGgpLFxuICAgICAgICBgQWJzb2x1dGUgcm91dGUgcGF0aCBcIiR7bWV0YS5yZWxhdGl2ZVBhdGh9XCIgbmVzdGVkIHVuZGVyIHBhdGggYCArXG4gICAgICAgICAgYFwiJHtwYXJlbnRQYXRofVwiIGlzIG5vdCB2YWxpZC4gQW4gYWJzb2x1dGUgY2hpbGQgcm91dGUgcGF0aCBgICtcbiAgICAgICAgICBgbXVzdCBzdGFydCB3aXRoIHRoZSBjb21iaW5lZCBwYXRoIG9mIGFsbCBpdHMgcGFyZW50IHJvdXRlcy5gXG4gICAgICApO1xuXG4gICAgICBtZXRhLnJlbGF0aXZlUGF0aCA9IG1ldGEucmVsYXRpdmVQYXRoLnNsaWNlKHBhcmVudFBhdGgubGVuZ3RoKTtcbiAgICB9XG5cbiAgICBsZXQgcGF0aCA9IGpvaW5QYXRocyhbcGFyZW50UGF0aCwgbWV0YS5yZWxhdGl2ZVBhdGhdKTtcbiAgICBsZXQgcm91dGVzTWV0YSA9IHBhcmVudHNNZXRhLmNvbmNhdChtZXRhKTtcblxuICAgIC8vIEFkZCB0aGUgY2hpbGRyZW4gYmVmb3JlIGFkZGluZyB0aGlzIHJvdXRlIHRvIHRoZSBhcnJheSBzbyB3ZSB0cmF2ZXJzZSB0aGVcbiAgICAvLyByb3V0ZSB0cmVlIGRlcHRoLWZpcnN0IGFuZCBjaGlsZCByb3V0ZXMgYXBwZWFyIGJlZm9yZSB0aGVpciBwYXJlbnRzIGluXG4gICAgLy8gdGhlIFwiZmxhdHRlbmVkXCIgdmVyc2lvbi5cbiAgICBpZiAocm91dGUuY2hpbGRyZW4gJiYgcm91dGUuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgaW52YXJpYW50KFxuICAgICAgICByb3V0ZS5pbmRleCAhPT0gdHJ1ZSxcbiAgICAgICAgYEluZGV4IHJvdXRlcyBtdXN0IG5vdCBoYXZlIGNoaWxkIHJvdXRlcy4gUGxlYXNlIHJlbW92ZSBgICtcbiAgICAgICAgICBgYWxsIGNoaWxkIHJvdXRlcyBmcm9tIHJvdXRlIHBhdGggXCIke3BhdGh9XCIuYFxuICAgICAgKTtcblxuICAgICAgZmxhdHRlblJvdXRlcyhyb3V0ZS5jaGlsZHJlbiwgYnJhbmNoZXMsIHJvdXRlc01ldGEsIHBhdGgpO1xuICAgIH1cblxuICAgIC8vIFJvdXRlcyB3aXRob3V0IGEgcGF0aCBzaG91bGRuJ3QgZXZlciBtYXRjaCBieSB0aGVtc2VsdmVzIHVubGVzcyB0aGV5IGFyZVxuICAgIC8vIGluZGV4IHJvdXRlcywgc28gZG9uJ3QgYWRkIHRoZW0gdG8gdGhlIGxpc3Qgb2YgcG9zc2libGUgYnJhbmNoZXMuXG4gICAgaWYgKHJvdXRlLnBhdGggPT0gbnVsbCAmJiAhcm91dGUuaW5kZXgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBicmFuY2hlcy5wdXNoKHsgcGF0aCwgc2NvcmU6IGNvbXB1dGVTY29yZShwYXRoLCByb3V0ZS5pbmRleCksIHJvdXRlc01ldGEgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBicmFuY2hlcztcbn1cblxuZnVuY3Rpb24gcmFua1JvdXRlQnJhbmNoZXMoYnJhbmNoZXM6IFJvdXRlQnJhbmNoW10pOiB2b2lkIHtcbiAgYnJhbmNoZXMuc29ydCgoYSwgYikgPT5cbiAgICBhLnNjb3JlICE9PSBiLnNjb3JlXG4gICAgICA/IGIuc2NvcmUgLSBhLnNjb3JlIC8vIEhpZ2hlciBzY29yZSBmaXJzdFxuICAgICAgOiBjb21wYXJlSW5kZXhlcyhcbiAgICAgICAgICBhLnJvdXRlc01ldGEubWFwKG1ldGEgPT4gbWV0YS5jaGlsZHJlbkluZGV4KSxcbiAgICAgICAgICBiLnJvdXRlc01ldGEubWFwKG1ldGEgPT4gbWV0YS5jaGlsZHJlbkluZGV4KVxuICAgICAgICApXG4gICk7XG59XG5cbmNvbnN0IHBhcmFtUmUgPSAvXjpcXHcrJC87XG5jb25zdCBkeW5hbWljU2VnbWVudFZhbHVlID0gMztcbmNvbnN0IGluZGV4Um91dGVWYWx1ZSA9IDI7XG5jb25zdCBlbXB0eVNlZ21lbnRWYWx1ZSA9IDE7XG5jb25zdCBzdGF0aWNTZWdtZW50VmFsdWUgPSAxMDtcbmNvbnN0IHNwbGF0UGVuYWx0eSA9IC0yO1xuY29uc3QgaXNTcGxhdCA9IChzOiBzdHJpbmcpID0+IHMgPT09IFwiKlwiO1xuXG5mdW5jdGlvbiBjb21wdXRlU2NvcmUocGF0aDogc3RyaW5nLCBpbmRleDogYm9vbGVhbiB8IHVuZGVmaW5lZCk6IG51bWJlciB7XG4gIGxldCBzZWdtZW50cyA9IHBhdGguc3BsaXQoXCIvXCIpO1xuICBsZXQgaW5pdGlhbFNjb3JlID0gc2VnbWVudHMubGVuZ3RoO1xuICBpZiAoc2VnbWVudHMuc29tZShpc1NwbGF0KSkge1xuICAgIGluaXRpYWxTY29yZSArPSBzcGxhdFBlbmFsdHk7XG4gIH1cblxuICBpZiAoaW5kZXgpIHtcbiAgICBpbml0aWFsU2NvcmUgKz0gaW5kZXhSb3V0ZVZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHNlZ21lbnRzXG4gICAgLmZpbHRlcihzID0+ICFpc1NwbGF0KHMpKVxuICAgIC5yZWR1Y2UoXG4gICAgICAoc2NvcmUsIHNlZ21lbnQpID0+XG4gICAgICAgIHNjb3JlICtcbiAgICAgICAgKHBhcmFtUmUudGVzdChzZWdtZW50KVxuICAgICAgICAgID8gZHluYW1pY1NlZ21lbnRWYWx1ZVxuICAgICAgICAgIDogc2VnbWVudCA9PT0gXCJcIlxuICAgICAgICAgID8gZW1wdHlTZWdtZW50VmFsdWVcbiAgICAgICAgICA6IHN0YXRpY1NlZ21lbnRWYWx1ZSksXG4gICAgICBpbml0aWFsU2NvcmVcbiAgICApO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlSW5kZXhlcyhhOiBudW1iZXJbXSwgYjogbnVtYmVyW10pOiBudW1iZXIge1xuICBsZXQgc2libGluZ3MgPVxuICAgIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLnNsaWNlKDAsIC0xKS5ldmVyeSgobiwgaSkgPT4gbiA9PT0gYltpXSk7XG5cbiAgcmV0dXJuIHNpYmxpbmdzXG4gICAgPyAvLyBJZiB0d28gcm91dGVzIGFyZSBzaWJsaW5ncywgd2Ugc2hvdWxkIHRyeSB0byBtYXRjaCB0aGUgZWFybGllciBzaWJsaW5nXG4gICAgICAvLyBmaXJzdC4gVGhpcyBhbGxvd3MgcGVvcGxlIHRvIGhhdmUgZmluZS1ncmFpbmVkIGNvbnRyb2wgb3ZlciB0aGUgbWF0Y2hpbmdcbiAgICAgIC8vIGJlaGF2aW9yIGJ5IHNpbXBseSBwdXR0aW5nIHJvdXRlcyB3aXRoIGlkZW50aWNhbCBwYXRocyBpbiB0aGUgb3JkZXIgdGhleVxuICAgICAgLy8gd2FudCB0aGVtIHRyaWVkLlxuICAgICAgYVthLmxlbmd0aCAtIDFdIC0gYltiLmxlbmd0aCAtIDFdXG4gICAgOiAvLyBPdGhlcndpc2UsIGl0IGRvZXNuJ3QgcmVhbGx5IG1ha2Ugc2Vuc2UgdG8gcmFuayBub24tc2libGluZ3MgYnkgaW5kZXgsXG4gICAgICAvLyBzbyB0aGV5IHNvcnQgZXF1YWxseS5cbiAgICAgIDA7XG59XG5cbmZ1bmN0aW9uIG1hdGNoUm91dGVCcmFuY2g8UGFyYW1LZXkgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+KFxuICBicmFuY2g6IFJvdXRlQnJhbmNoLFxuICBwYXRobmFtZTogc3RyaW5nXG4pOiBSb3V0ZU1hdGNoPFBhcmFtS2V5PltdIHwgbnVsbCB7XG4gIGxldCB7IHJvdXRlc01ldGEgfSA9IGJyYW5jaDtcblxuICBsZXQgbWF0Y2hlZFBhcmFtcyA9IHt9O1xuICBsZXQgbWF0Y2hlZFBhdGhuYW1lID0gXCIvXCI7XG4gIGxldCBtYXRjaGVzOiBSb3V0ZU1hdGNoW10gPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3V0ZXNNZXRhLmxlbmd0aDsgKytpKSB7XG4gICAgbGV0IG1ldGEgPSByb3V0ZXNNZXRhW2ldO1xuICAgIGxldCBlbmQgPSBpID09PSByb3V0ZXNNZXRhLmxlbmd0aCAtIDE7XG4gICAgbGV0IHJlbWFpbmluZ1BhdGhuYW1lID1cbiAgICAgIG1hdGNoZWRQYXRobmFtZSA9PT0gXCIvXCJcbiAgICAgICAgPyBwYXRobmFtZVxuICAgICAgICA6IHBhdGhuYW1lLnNsaWNlKG1hdGNoZWRQYXRobmFtZS5sZW5ndGgpIHx8IFwiL1wiO1xuICAgIGxldCBtYXRjaCA9IG1hdGNoUGF0aChcbiAgICAgIHsgcGF0aDogbWV0YS5yZWxhdGl2ZVBhdGgsIGNhc2VTZW5zaXRpdmU6IG1ldGEuY2FzZVNlbnNpdGl2ZSwgZW5kIH0sXG4gICAgICByZW1haW5pbmdQYXRobmFtZVxuICAgICk7XG5cbiAgICBpZiAoIW1hdGNoKSByZXR1cm4gbnVsbDtcblxuICAgIE9iamVjdC5hc3NpZ24obWF0Y2hlZFBhcmFtcywgbWF0Y2gucGFyYW1zKTtcblxuICAgIGxldCByb3V0ZSA9IG1ldGEucm91dGU7XG5cbiAgICBtYXRjaGVzLnB1c2goe1xuICAgICAgcGFyYW1zOiBtYXRjaGVkUGFyYW1zLFxuICAgICAgcGF0aG5hbWU6IGpvaW5QYXRocyhbbWF0Y2hlZFBhdGhuYW1lLCBtYXRjaC5wYXRobmFtZV0pLFxuICAgICAgcGF0aG5hbWVCYXNlOiBqb2luUGF0aHMoW21hdGNoZWRQYXRobmFtZSwgbWF0Y2gucGF0aG5hbWVCYXNlXSksXG4gICAgICByb3V0ZVxuICAgIH0pO1xuXG4gICAgaWYgKG1hdGNoLnBhdGhuYW1lQmFzZSAhPT0gXCIvXCIpIHtcbiAgICAgIG1hdGNoZWRQYXRobmFtZSA9IGpvaW5QYXRocyhbbWF0Y2hlZFBhdGhuYW1lLCBtYXRjaC5wYXRobmFtZUJhc2VdKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWF0Y2hlcztcbn1cblxuLyoqXG4gKiBSZW5kZXJzIHRoZSByZXN1bHQgb2YgYG1hdGNoUm91dGVzKClgIGludG8gYSBSZWFjdCBlbGVtZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyTWF0Y2hlcyhcbiAgbWF0Y2hlczogUm91dGVNYXRjaFtdIHwgbnVsbFxuKTogUmVhY3QuUmVhY3RFbGVtZW50IHwgbnVsbCB7XG4gIHJldHVybiBfcmVuZGVyTWF0Y2hlcyhtYXRjaGVzKTtcbn1cblxuZnVuY3Rpb24gX3JlbmRlck1hdGNoZXMoXG4gIG1hdGNoZXM6IFJvdXRlTWF0Y2hbXSB8IG51bGwsXG4gIHBhcmVudE1hdGNoZXM6IFJvdXRlTWF0Y2hbXSA9IFtdXG4pOiBSZWFjdC5SZWFjdEVsZW1lbnQgfCBudWxsIHtcbiAgaWYgKG1hdGNoZXMgPT0gbnVsbCkgcmV0dXJuIG51bGw7XG5cbiAgcmV0dXJuIG1hdGNoZXMucmVkdWNlUmlnaHQoKG91dGxldCwgbWF0Y2gsIGluZGV4KSA9PiB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxSb3V0ZUNvbnRleHQuUHJvdmlkZXJcbiAgICAgICAgY2hpbGRyZW49e1xuICAgICAgICAgIG1hdGNoLnJvdXRlLmVsZW1lbnQgIT09IHVuZGVmaW5lZCA/IG1hdGNoLnJvdXRlLmVsZW1lbnQgOiA8T3V0bGV0IC8+XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWU9e3tcbiAgICAgICAgICBvdXRsZXQsXG4gICAgICAgICAgbWF0Y2hlczogcGFyZW50TWF0Y2hlcy5jb25jYXQobWF0Y2hlcy5zbGljZSgwLCBpbmRleCArIDEpKVxuICAgICAgICB9fVxuICAgICAgLz5cbiAgICApO1xuICB9LCBudWxsIGFzIFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bGwpO1xufVxuXG4vKipcbiAqIEEgUGF0aFBhdHRlcm4gaXMgdXNlZCB0byBtYXRjaCBvbiBzb21lIHBvcnRpb24gb2YgYSBVUkwgcGF0aG5hbWUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGF0aFBhdHRlcm48UGF0aCBleHRlbmRzIHN0cmluZyA9IHN0cmluZz4ge1xuICAvKipcbiAgICogQSBzdHJpbmcgdG8gbWF0Y2ggYWdhaW5zdCBhIFVSTCBwYXRobmFtZS4gTWF5IGNvbnRhaW4gYDppZGAtc3R5bGUgc2VnbWVudHNcbiAgICogdG8gaW5kaWNhdGUgcGxhY2Vob2xkZXJzIGZvciBkeW5hbWljIHBhcmFtZXRlcnMuIE1heSBhbHNvIGVuZCB3aXRoIGAvKmAgdG9cbiAgICogaW5kaWNhdGUgbWF0Y2hpbmcgdGhlIHJlc3Qgb2YgdGhlIFVSTCBwYXRobmFtZS5cbiAgICovXG4gIHBhdGg6IFBhdGg7XG4gIC8qKlxuICAgKiBTaG91bGQgYmUgYHRydWVgIGlmIHRoZSBzdGF0aWMgcG9ydGlvbnMgb2YgdGhlIGBwYXRoYCBzaG91bGQgYmUgbWF0Y2hlZCBpblxuICAgKiB0aGUgc2FtZSBjYXNlLlxuICAgKi9cbiAgY2FzZVNlbnNpdGl2ZT86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBTaG91bGQgYmUgYHRydWVgIGlmIHRoaXMgcGF0dGVybiBzaG91bGQgbWF0Y2ggdGhlIGVudGlyZSBVUkwgcGF0aG5hbWUuXG4gICAqL1xuICBlbmQ/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIEEgUGF0aE1hdGNoIGNvbnRhaW5zIGluZm8gYWJvdXQgaG93IGEgUGF0aFBhdHRlcm4gbWF0Y2hlZCBvbiBhIFVSTCBwYXRobmFtZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQYXRoTWF0Y2g8UGFyYW1LZXkgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+IHtcbiAgLyoqXG4gICAqIFRoZSBuYW1lcyBhbmQgdmFsdWVzIG9mIGR5bmFtaWMgcGFyYW1ldGVycyBpbiB0aGUgVVJMLlxuICAgKi9cbiAgcGFyYW1zOiBQYXJhbXM8UGFyYW1LZXk+O1xuICAvKipcbiAgICogVGhlIHBvcnRpb24gb2YgdGhlIFVSTCBwYXRobmFtZSB0aGF0IHdhcyBtYXRjaGVkLlxuICAgKi9cbiAgcGF0aG5hbWU6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSBwb3J0aW9uIG9mIHRoZSBVUkwgcGF0aG5hbWUgdGhhdCB3YXMgbWF0Y2hlZCBiZWZvcmUgY2hpbGQgcm91dGVzLlxuICAgKi9cbiAgcGF0aG5hbWVCYXNlOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgcGF0dGVybiB0aGF0IHdhcyB1c2VkIHRvIG1hdGNoLlxuICAgKi9cbiAgcGF0dGVybjogUGF0aFBhdHRlcm47XG59XG5cbnR5cGUgTXV0YWJsZTxUPiA9IHtcbiAgLXJlYWRvbmx5IFtQIGluIGtleW9mIFRdOiBUW1BdO1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBwYXR0ZXJuIG1hdGNoaW5nIG9uIGEgVVJMIHBhdGhuYW1lIGFuZCByZXR1cm5zIGluZm9ybWF0aW9uIGFib3V0XG4gKiB0aGUgbWF0Y2guXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSNtYXRjaHBhdGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoUGF0aDxcbiAgUGFyYW1LZXkgZXh0ZW5kcyBQYXJhbVBhcnNlS2V5PFBhdGg+LFxuICBQYXRoIGV4dGVuZHMgc3RyaW5nXG4+KFxuICBwYXR0ZXJuOiBQYXRoUGF0dGVybjxQYXRoPiB8IFBhdGgsXG4gIHBhdGhuYW1lOiBzdHJpbmdcbik6IFBhdGhNYXRjaDxQYXJhbUtleT4gfCBudWxsIHtcbiAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSBcInN0cmluZ1wiKSB7XG4gICAgcGF0dGVybiA9IHsgcGF0aDogcGF0dGVybiwgY2FzZVNlbnNpdGl2ZTogZmFsc2UsIGVuZDogdHJ1ZSB9O1xuICB9XG5cbiAgbGV0IFttYXRjaGVyLCBwYXJhbU5hbWVzXSA9IGNvbXBpbGVQYXRoKFxuICAgIHBhdHRlcm4ucGF0aCxcbiAgICBwYXR0ZXJuLmNhc2VTZW5zaXRpdmUsXG4gICAgcGF0dGVybi5lbmRcbiAgKTtcblxuICBsZXQgbWF0Y2ggPSBwYXRobmFtZS5tYXRjaChtYXRjaGVyKTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuIG51bGw7XG5cbiAgbGV0IG1hdGNoZWRQYXRobmFtZSA9IG1hdGNoWzBdO1xuICBsZXQgcGF0aG5hbWVCYXNlID0gbWF0Y2hlZFBhdGhuYW1lLnJlcGxhY2UoLyguKVxcLyskLywgXCIkMVwiKTtcbiAgbGV0IGNhcHR1cmVHcm91cHMgPSBtYXRjaC5zbGljZSgxKTtcbiAgbGV0IHBhcmFtczogUGFyYW1zID0gcGFyYW1OYW1lcy5yZWR1Y2U8TXV0YWJsZTxQYXJhbXM+PihcbiAgICAobWVtbywgcGFyYW1OYW1lLCBpbmRleCkgPT4ge1xuICAgICAgLy8gV2UgbmVlZCB0byBjb21wdXRlIHRoZSBwYXRobmFtZUJhc2UgaGVyZSB1c2luZyB0aGUgcmF3IHNwbGF0IHZhbHVlXG4gICAgICAvLyBpbnN0ZWFkIG9mIHVzaW5nIHBhcmFtc1tcIipcIl0gbGF0ZXIgYmVjYXVzZSBpdCB3aWxsIGJlIGRlY29kZWQgdGhlblxuICAgICAgaWYgKHBhcmFtTmFtZSA9PT0gXCIqXCIpIHtcbiAgICAgICAgbGV0IHNwbGF0VmFsdWUgPSBjYXB0dXJlR3JvdXBzW2luZGV4XSB8fCBcIlwiO1xuICAgICAgICBwYXRobmFtZUJhc2UgPSBtYXRjaGVkUGF0aG5hbWVcbiAgICAgICAgICAuc2xpY2UoMCwgbWF0Y2hlZFBhdGhuYW1lLmxlbmd0aCAtIHNwbGF0VmFsdWUubGVuZ3RoKVxuICAgICAgICAgIC5yZXBsYWNlKC8oLilcXC8rJC8sIFwiJDFcIik7XG4gICAgICB9XG5cbiAgICAgIG1lbW9bcGFyYW1OYW1lXSA9IHNhZmVseURlY29kZVVSSUNvbXBvbmVudChcbiAgICAgICAgY2FwdHVyZUdyb3Vwc1tpbmRleF0gfHwgXCJcIixcbiAgICAgICAgcGFyYW1OYW1lXG4gICAgICApO1xuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfSxcbiAgICB7fVxuICApO1xuXG4gIHJldHVybiB7XG4gICAgcGFyYW1zLFxuICAgIHBhdGhuYW1lOiBtYXRjaGVkUGF0aG5hbWUsXG4gICAgcGF0aG5hbWVCYXNlLFxuICAgIHBhdHRlcm5cbiAgfTtcbn1cblxuZnVuY3Rpb24gY29tcGlsZVBhdGgoXG4gIHBhdGg6IHN0cmluZyxcbiAgY2FzZVNlbnNpdGl2ZSA9IGZhbHNlLFxuICBlbmQgPSB0cnVlXG4pOiBbUmVnRXhwLCBzdHJpbmdbXV0ge1xuICB3YXJuaW5nKFxuICAgIHBhdGggPT09IFwiKlwiIHx8ICFwYXRoLmVuZHNXaXRoKFwiKlwiKSB8fCBwYXRoLmVuZHNXaXRoKFwiLypcIiksXG4gICAgYFJvdXRlIHBhdGggXCIke3BhdGh9XCIgd2lsbCBiZSB0cmVhdGVkIGFzIGlmIGl0IHdlcmUgYCArXG4gICAgICBgXCIke3BhdGgucmVwbGFjZSgvXFwqJC8sIFwiLypcIil9XCIgYmVjYXVzZSB0aGUgXFxgKlxcYCBjaGFyYWN0ZXIgbXVzdCBgICtcbiAgICAgIGBhbHdheXMgZm9sbG93IGEgXFxgL1xcYCBpbiB0aGUgcGF0dGVybi4gVG8gZ2V0IHJpZCBvZiB0aGlzIHdhcm5pbmcsIGAgK1xuICAgICAgYHBsZWFzZSBjaGFuZ2UgdGhlIHJvdXRlIHBhdGggdG8gXCIke3BhdGgucmVwbGFjZSgvXFwqJC8sIFwiLypcIil9XCIuYFxuICApO1xuXG4gIGxldCBwYXJhbU5hbWVzOiBzdHJpbmdbXSA9IFtdO1xuICBsZXQgcmVnZXhwU291cmNlID1cbiAgICBcIl5cIiArXG4gICAgcGF0aFxuICAgICAgLnJlcGxhY2UoL1xcLypcXCo/JC8sIFwiXCIpIC8vIElnbm9yZSB0cmFpbGluZyAvIGFuZCAvKiwgd2UnbGwgaGFuZGxlIGl0IGJlbG93XG4gICAgICAucmVwbGFjZSgvXlxcLyovLCBcIi9cIikgLy8gTWFrZSBzdXJlIGl0IGhhcyBhIGxlYWRpbmcgL1xuICAgICAgLnJlcGxhY2UoL1tcXFxcLiorXiQ/e318KClbXFxdXS9nLCBcIlxcXFwkJlwiKSAvLyBFc2NhcGUgc3BlY2lhbCByZWdleCBjaGFyc1xuICAgICAgLnJlcGxhY2UoLzooXFx3KykvZywgKF86IHN0cmluZywgcGFyYW1OYW1lOiBzdHJpbmcpID0+IHtcbiAgICAgICAgcGFyYW1OYW1lcy5wdXNoKHBhcmFtTmFtZSk7XG4gICAgICAgIHJldHVybiBcIihbXlxcXFwvXSspXCI7XG4gICAgICB9KTtcblxuICBpZiAocGF0aC5lbmRzV2l0aChcIipcIikpIHtcbiAgICBwYXJhbU5hbWVzLnB1c2goXCIqXCIpO1xuICAgIHJlZ2V4cFNvdXJjZSArPVxuICAgICAgcGF0aCA9PT0gXCIqXCIgfHwgcGF0aCA9PT0gXCIvKlwiXG4gICAgICAgID8gXCIoLiopJFwiIC8vIEFscmVhZHkgbWF0Y2hlZCB0aGUgaW5pdGlhbCAvLCBqdXN0IG1hdGNoIHRoZSByZXN0XG4gICAgICAgIDogXCIoPzpcXFxcLyguKyl8XFxcXC8qKSRcIjsgLy8gRG9uJ3QgaW5jbHVkZSB0aGUgLyBpbiBwYXJhbXNbXCIqXCJdXG4gIH0gZWxzZSB7XG4gICAgcmVnZXhwU291cmNlICs9IGVuZFxuICAgICAgPyBcIlxcXFwvKiRcIiAvLyBXaGVuIG1hdGNoaW5nIHRvIHRoZSBlbmQsIGlnbm9yZSB0cmFpbGluZyBzbGFzaGVzXG4gICAgICA6IC8vIE90aGVyd2lzZSwgbWF0Y2ggYSB3b3JkIGJvdW5kYXJ5IG9yIGEgcHJvY2VlZGluZyAvLiBUaGUgd29yZCBib3VuZGFyeSByZXN0cmljdHNcbiAgICAgICAgLy8gcGFyZW50IHJvdXRlcyB0byBtYXRjaGluZyBvbmx5IHRoZWlyIG93biB3b3JkcyBhbmQgbm90aGluZyBtb3JlLCBlLmcuIHBhcmVudFxuICAgICAgICAvLyByb3V0ZSBcIi9ob21lXCIgc2hvdWxkIG5vdCBtYXRjaCBcIi9ob21lMlwiLlxuICAgICAgICBcIig/OlxcXFxifFxcXFwvfCQpXCI7XG4gIH1cblxuICBsZXQgbWF0Y2hlciA9IG5ldyBSZWdFeHAocmVnZXhwU291cmNlLCBjYXNlU2Vuc2l0aXZlID8gdW5kZWZpbmVkIDogXCJpXCIpO1xuXG4gIHJldHVybiBbbWF0Y2hlciwgcGFyYW1OYW1lc107XG59XG5cbmZ1bmN0aW9uIHNhZmVseURlY29kZVVSSUNvbXBvbmVudCh2YWx1ZTogc3RyaW5nLCBwYXJhbU5hbWU6IHN0cmluZykge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHdhcm5pbmcoXG4gICAgICBmYWxzZSxcbiAgICAgIGBUaGUgdmFsdWUgZm9yIHRoZSBVUkwgcGFyYW0gXCIke3BhcmFtTmFtZX1cIiB3aWxsIG5vdCBiZSBkZWNvZGVkIGJlY2F1c2VgICtcbiAgICAgICAgYCB0aGUgc3RyaW5nIFwiJHt2YWx1ZX1cIiBpcyBhIG1hbGZvcm1lZCBVUkwgc2VnbWVudC4gVGhpcyBpcyBwcm9iYWJseWAgK1xuICAgICAgICBgIGR1ZSB0byBhIGJhZCBwZXJjZW50IGVuY29kaW5nICgke2Vycm9yfSkuYFxuICAgICk7XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcmVzb2x2ZWQgcGF0aCBvYmplY3QgcmVsYXRpdmUgdG8gdGhlIGdpdmVuIHBhdGhuYW1lLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjcmVzb2x2ZXBhdGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVQYXRoKHRvOiBUbywgZnJvbVBhdGhuYW1lID0gXCIvXCIpOiBQYXRoIHtcbiAgbGV0IHtcbiAgICBwYXRobmFtZTogdG9QYXRobmFtZSxcbiAgICBzZWFyY2ggPSBcIlwiLFxuICAgIGhhc2ggPSBcIlwiXG4gIH0gPSB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgodG8pIDogdG87XG5cbiAgbGV0IHBhdGhuYW1lID0gdG9QYXRobmFtZVxuICAgID8gdG9QYXRobmFtZS5zdGFydHNXaXRoKFwiL1wiKVxuICAgICAgPyB0b1BhdGhuYW1lXG4gICAgICA6IHJlc29sdmVQYXRobmFtZSh0b1BhdGhuYW1lLCBmcm9tUGF0aG5hbWUpXG4gICAgOiBmcm9tUGF0aG5hbWU7XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRobmFtZSxcbiAgICBzZWFyY2g6IG5vcm1hbGl6ZVNlYXJjaChzZWFyY2gpLFxuICAgIGhhc2g6IG5vcm1hbGl6ZUhhc2goaGFzaClcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVBhdGhuYW1lKHJlbGF0aXZlUGF0aDogc3RyaW5nLCBmcm9tUGF0aG5hbWU6IHN0cmluZyk6IHN0cmluZyB7XG4gIGxldCBzZWdtZW50cyA9IGZyb21QYXRobmFtZS5yZXBsYWNlKC9cXC8rJC8sIFwiXCIpLnNwbGl0KFwiL1wiKTtcbiAgbGV0IHJlbGF0aXZlU2VnbWVudHMgPSByZWxhdGl2ZVBhdGguc3BsaXQoXCIvXCIpO1xuXG4gIHJlbGF0aXZlU2VnbWVudHMuZm9yRWFjaChzZWdtZW50ID0+IHtcbiAgICBpZiAoc2VnbWVudCA9PT0gXCIuLlwiKSB7XG4gICAgICAvLyBLZWVwIHRoZSByb290IFwiXCIgc2VnbWVudCBzbyB0aGUgcGF0aG5hbWUgc3RhcnRzIGF0IC9cbiAgICAgIGlmIChzZWdtZW50cy5sZW5ndGggPiAxKSBzZWdtZW50cy5wb3AoKTtcbiAgICB9IGVsc2UgaWYgKHNlZ21lbnQgIT09IFwiLlwiKSB7XG4gICAgICBzZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHNlZ21lbnRzLmxlbmd0aCA+IDEgPyBzZWdtZW50cy5qb2luKFwiL1wiKSA6IFwiL1wiO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlVG8oXG4gIHRvQXJnOiBUbyxcbiAgcm91dGVQYXRobmFtZXM6IHN0cmluZ1tdLFxuICBsb2NhdGlvblBhdGhuYW1lOiBzdHJpbmdcbik6IFBhdGgge1xuICBsZXQgdG8gPSB0eXBlb2YgdG9BcmcgPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgodG9BcmcpIDogdG9Bcmc7XG4gIGxldCB0b1BhdGhuYW1lID0gdG9BcmcgPT09IFwiXCIgfHwgdG8ucGF0aG5hbWUgPT09IFwiXCIgPyBcIi9cIiA6IHRvLnBhdGhuYW1lO1xuXG4gIC8vIElmIGEgcGF0aG5hbWUgaXMgZXhwbGljaXRseSBwcm92aWRlZCBpbiBgdG9gLCBpdCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlXG4gIC8vIHJvdXRlIGNvbnRleHQuIFRoaXMgaXMgZXhwbGFpbmVkIGluIGBOb3RlIG9uIGA8TGluayB0bz5gIHZhbHVlc2AgaW4gb3VyXG4gIC8vIG1pZ3JhdGlvbiBndWlkZSBmcm9tIHY1IGFzIGEgbWVhbnMgb2YgZGlzYW1iaWd1YXRpb24gYmV0d2VlbiBgdG9gIHZhbHVlc1xuICAvLyB0aGF0IGJlZ2luIHdpdGggYC9gIGFuZCB0aG9zZSB0aGF0IGRvIG5vdC4gSG93ZXZlciwgdGhpcyBpcyBwcm9ibGVtYXRpYyBmb3JcbiAgLy8gYHRvYCB2YWx1ZXMgdGhhdCBkbyBub3QgcHJvdmlkZSBhIHBhdGhuYW1lLiBgdG9gIGNhbiBzaW1wbHkgYmUgYSBzZWFyY2ggb3JcbiAgLy8gaGFzaCBzdHJpbmcsIGluIHdoaWNoIGNhc2Ugd2Ugc2hvdWxkIGFzc3VtZSB0aGF0IHRoZSBuYXZpZ2F0aW9uIGlzIHJlbGF0aXZlXG4gIC8vIHRvIHRoZSBjdXJyZW50IGxvY2F0aW9uJ3MgcGF0aG5hbWUgYW5kICpub3QqIHRoZSByb3V0ZSBwYXRobmFtZS5cbiAgbGV0IGZyb206IHN0cmluZztcbiAgaWYgKHRvUGF0aG5hbWUgPT0gbnVsbCkge1xuICAgIGZyb20gPSBsb2NhdGlvblBhdGhuYW1lO1xuICB9IGVsc2Uge1xuICAgIGxldCByb3V0ZVBhdGhuYW1lSW5kZXggPSByb3V0ZVBhdGhuYW1lcy5sZW5ndGggLSAxO1xuXG4gICAgaWYgKHRvUGF0aG5hbWUuc3RhcnRzV2l0aChcIi4uXCIpKSB7XG4gICAgICBsZXQgdG9TZWdtZW50cyA9IHRvUGF0aG5hbWUuc3BsaXQoXCIvXCIpO1xuXG4gICAgICAvLyBFYWNoIGxlYWRpbmcgLi4gc2VnbWVudCBtZWFucyBcImdvIHVwIG9uZSByb3V0ZVwiIGluc3RlYWQgb2YgXCJnbyB1cCBvbmVcbiAgICAgIC8vIFVSTCBzZWdtZW50XCIuICBUaGlzIGlzIGEga2V5IGRpZmZlcmVuY2UgZnJvbSBob3cgPGEgaHJlZj4gd29ya3MgYW5kIGFcbiAgICAgIC8vIG1ham9yIHJlYXNvbiB3ZSBjYWxsIHRoaXMgYSBcInRvXCIgdmFsdWUgaW5zdGVhZCBvZiBhIFwiaHJlZlwiLlxuICAgICAgd2hpbGUgKHRvU2VnbWVudHNbMF0gPT09IFwiLi5cIikge1xuICAgICAgICB0b1NlZ21lbnRzLnNoaWZ0KCk7XG4gICAgICAgIHJvdXRlUGF0aG5hbWVJbmRleCAtPSAxO1xuICAgICAgfVxuXG4gICAgICB0by5wYXRobmFtZSA9IHRvU2VnbWVudHMuam9pbihcIi9cIik7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUgYXJlIG1vcmUgXCIuLlwiIHNlZ21lbnRzIHRoYW4gcGFyZW50IHJvdXRlcywgcmVzb2x2ZSByZWxhdGl2ZSB0b1xuICAgIC8vIHRoZSByb290IC8gVVJMLlxuICAgIGZyb20gPSByb3V0ZVBhdGhuYW1lSW5kZXggPj0gMCA/IHJvdXRlUGF0aG5hbWVzW3JvdXRlUGF0aG5hbWVJbmRleF0gOiBcIi9cIjtcbiAgfVxuXG4gIGxldCBwYXRoID0gcmVzb2x2ZVBhdGgodG8sIGZyb20pO1xuXG4gIC8vIEVuc3VyZSB0aGUgcGF0aG5hbWUgaGFzIGEgdHJhaWxpbmcgc2xhc2ggaWYgdGhlIG9yaWdpbmFsIHRvIHZhbHVlIGhhZCBvbmUuXG4gIGlmIChcbiAgICB0b1BhdGhuYW1lICYmXG4gICAgdG9QYXRobmFtZSAhPT0gXCIvXCIgJiZcbiAgICB0b1BhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKSAmJlxuICAgICFwYXRoLnBhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKVxuICApIHtcbiAgICBwYXRoLnBhdGhuYW1lICs9IFwiL1wiO1xuICB9XG5cbiAgcmV0dXJuIHBhdGg7XG59XG5cbmZ1bmN0aW9uIGdldFRvUGF0aG5hbWUodG86IFRvKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgLy8gRW1wdHkgc3RyaW5ncyBzaG91bGQgYmUgdHJlYXRlZCB0aGUgc2FtZSBhcyAvIHBhdGhzXG4gIHJldHVybiB0byA9PT0gXCJcIiB8fCAodG8gYXMgUGF0aCkucGF0aG5hbWUgPT09IFwiXCJcbiAgICA/IFwiL1wiXG4gICAgOiB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCJcbiAgICA/IHBhcnNlUGF0aCh0bykucGF0aG5hbWVcbiAgICA6IHRvLnBhdGhuYW1lO1xufVxuXG5mdW5jdGlvbiBzdHJpcEJhc2VuYW1lKHBhdGhuYW1lOiBzdHJpbmcsIGJhc2VuYW1lOiBzdHJpbmcpOiBzdHJpbmcgfCBudWxsIHtcbiAgaWYgKGJhc2VuYW1lID09PSBcIi9cIikgcmV0dXJuIHBhdGhuYW1lO1xuXG4gIGlmICghcGF0aG5hbWUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKGJhc2VuYW1lLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBsZXQgbmV4dENoYXIgPSBwYXRobmFtZS5jaGFyQXQoYmFzZW5hbWUubGVuZ3RoKTtcbiAgaWYgKG5leHRDaGFyICYmIG5leHRDaGFyICE9PSBcIi9cIikge1xuICAgIC8vIHBhdGhuYW1lIGRvZXMgbm90IHN0YXJ0IHdpdGggYmFzZW5hbWUvXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gcGF0aG5hbWUuc2xpY2UoYmFzZW5hbWUubGVuZ3RoKSB8fCBcIi9cIjtcbn1cblxuY29uc3Qgam9pblBhdGhzID0gKHBhdGhzOiBzdHJpbmdbXSk6IHN0cmluZyA9PlxuICBwYXRocy5qb2luKFwiL1wiKS5yZXBsYWNlKC9cXC9cXC8rL2csIFwiL1wiKTtcblxuY29uc3Qgbm9ybWFsaXplUGF0aG5hbWUgPSAocGF0aG5hbWU6IHN0cmluZyk6IHN0cmluZyA9PlxuICBwYXRobmFtZS5yZXBsYWNlKC9cXC8rJC8sIFwiXCIpLnJlcGxhY2UoL15cXC8qLywgXCIvXCIpO1xuXG5jb25zdCBub3JtYWxpemVTZWFyY2ggPSAoc2VhcmNoOiBzdHJpbmcpOiBzdHJpbmcgPT5cbiAgIXNlYXJjaCB8fCBzZWFyY2ggPT09IFwiP1wiXG4gICAgPyBcIlwiXG4gICAgOiBzZWFyY2guc3RhcnRzV2l0aChcIj9cIilcbiAgICA/IHNlYXJjaFxuICAgIDogXCI/XCIgKyBzZWFyY2g7XG5cbmNvbnN0IG5vcm1hbGl6ZUhhc2ggPSAoaGFzaDogc3RyaW5nKTogc3RyaW5nID0+XG4gICFoYXNoIHx8IGhhc2ggPT09IFwiI1wiID8gXCJcIiA6IGhhc2guc3RhcnRzV2l0aChcIiNcIikgPyBoYXNoIDogXCIjXCIgKyBoYXNoO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBEQU5HRVIhIFBMRUFTRSBSRUFEIE1FIVxuLy8gV2UgcHJvdmlkZSB0aGVzZSBleHBvcnRzIGFzIGFuIGVzY2FwZSBoYXRjaCBpbiB0aGUgZXZlbnQgdGhhdCB5b3UgbmVlZCBhbnlcbi8vIHJvdXRpbmcgZGF0YSB0aGF0IHdlIGRvbid0IHByb3ZpZGUgYW4gZXhwbGljaXQgQVBJIGZvci4gV2l0aCB0aGF0IHNhaWQsIHdlXG4vLyB3YW50IHRvIGNvdmVyIHlvdXIgdXNlIGNhc2UgaWYgd2UgY2FuLCBzbyBpZiB5b3UgZmVlbCB0aGUgbmVlZCB0byB1c2UgdGhlc2Vcbi8vIHdlIHdhbnQgdG8gaGVhciBmcm9tIHlvdS4gTGV0IHVzIGtub3cgd2hhdCB5b3UncmUgYnVpbGRpbmcgYW5kIHdlJ2xsIGRvIG91clxuLy8gYmVzdCB0byBtYWtlIHN1cmUgd2UgY2FuIHN1cHBvcnQgeW91IVxuLy9cbi8vIFdlIGNvbnNpZGVyIHRoZXNlIGV4cG9ydHMgYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsIGFuZCBkbyBub3QgZ3VhcmFudGVlXG4vLyBhZ2FpbnN0IGFueSBicmVha2luZyBjaGFuZ2VzLCByZWdhcmRsZXNzIG9mIHRoZSBzZW12ZXIgcmVsZWFzZS4gVXNlIHdpdGhcbi8vIGV4dHJlbWUgY2F1dGlvbiBhbmQgb25seSBpZiB5b3UgdW5kZXJzdGFuZCB0aGUgY29uc2VxdWVuY2VzLiBHb2RzcGVlZC5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IHtcbiAgTmF2aWdhdGlvbkNvbnRleHQgYXMgVU5TQUZFX05hdmlnYXRpb25Db250ZXh0LFxuICBMb2NhdGlvbkNvbnRleHQgYXMgVU5TQUZFX0xvY2F0aW9uQ29udGV4dCxcbiAgUm91dGVDb250ZXh0IGFzIFVOU0FGRV9Sb3V0ZUNvbnRleHRcbn07XG4iLCAiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgdHlwZSB7IEJyb3dzZXJIaXN0b3J5LCBIYXNoSGlzdG9yeSwgSGlzdG9yeSB9IGZyb20gXCJoaXN0b3J5XCI7XG5pbXBvcnQgeyBjcmVhdGVCcm93c2VySGlzdG9yeSwgY3JlYXRlSGFzaEhpc3RvcnksIGNyZWF0ZVBhdGggfSBmcm9tIFwiaGlzdG9yeVwiO1xuaW1wb3J0IHtcbiAgTWVtb3J5Um91dGVyLFxuICBOYXZpZ2F0ZSxcbiAgT3V0bGV0LFxuICBSb3V0ZSxcbiAgUm91dGVyLFxuICBSb3V0ZXMsXG4gIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbixcbiAgZ2VuZXJhdGVQYXRoLFxuICBtYXRjaFJvdXRlcyxcbiAgbWF0Y2hQYXRoLFxuICByZXNvbHZlUGF0aCxcbiAgcmVuZGVyTWF0Y2hlcyxcbiAgdXNlSHJlZixcbiAgdXNlSW5Sb3V0ZXJDb250ZXh0LFxuICB1c2VMb2NhdGlvbixcbiAgdXNlTWF0Y2gsXG4gIHVzZU5hdmlnYXRlLFxuICB1c2VOYXZpZ2F0aW9uVHlwZSxcbiAgdXNlT3V0bGV0LFxuICB1c2VQYXJhbXMsXG4gIHVzZVJlc29sdmVkUGF0aCxcbiAgdXNlUm91dGVzLFxuICB1c2VPdXRsZXRDb250ZXh0XG59IGZyb20gXCJyZWFjdC1yb3V0ZXJcIjtcbmltcG9ydCB0eXBlIHsgVG8gfSBmcm9tIFwicmVhY3Qtcm91dGVyXCI7XG5cbmZ1bmN0aW9uIHdhcm5pbmcoY29uZDogYm9vbGVhbiwgbWVzc2FnZTogc3RyaW5nKTogdm9pZCB7XG4gIGlmICghY29uZCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiKSBjb25zb2xlLndhcm4obWVzc2FnZSk7XG5cbiAgICB0cnkge1xuICAgICAgLy8gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgUm91dGVyIVxuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgZXJyb3IgaXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28geW91IGNhbiBtb3JlIGVhc2lseVxuICAgICAgLy8gZmluZCB0aGUgc291cmNlIGZvciBhIHdhcm5pbmcgdGhhdCBhcHBlYXJzIGluIHRoZSBjb25zb2xlIGJ5XG4gICAgICAvLyBlbmFibGluZyBcInBhdXNlIG9uIGV4Y2VwdGlvbnNcIiBpbiB5b3VyIEphdmFTY3JpcHQgZGVidWdnZXIuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBSRS1FWFBPUlRTXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vLyBOb3RlOiBLZWVwIGluIHN5bmMgd2l0aCByZWFjdC1yb3V0ZXIgZXhwb3J0cyFcbmV4cG9ydCB7XG4gIE1lbW9yeVJvdXRlcixcbiAgTmF2aWdhdGUsXG4gIE91dGxldCxcbiAgUm91dGUsXG4gIFJvdXRlcixcbiAgUm91dGVzLFxuICBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4sXG4gIGdlbmVyYXRlUGF0aCxcbiAgbWF0Y2hSb3V0ZXMsXG4gIG1hdGNoUGF0aCxcbiAgcmVuZGVyTWF0Y2hlcyxcbiAgcmVzb2x2ZVBhdGgsXG4gIHVzZUhyZWYsXG4gIHVzZUluUm91dGVyQ29udGV4dCxcbiAgdXNlTG9jYXRpb24sXG4gIHVzZU1hdGNoLFxuICB1c2VOYXZpZ2F0ZSxcbiAgdXNlTmF2aWdhdGlvblR5cGUsXG4gIHVzZU91dGxldCxcbiAgdXNlUGFyYW1zLFxuICB1c2VSZXNvbHZlZFBhdGgsXG4gIHVzZVJvdXRlcyxcbiAgdXNlT3V0bGV0Q29udGV4dFxufTtcblxuZXhwb3J0IHR5cGUge1xuICBMb2NhdGlvbixcbiAgUGF0aCxcbiAgVG8sXG4gIE5hdmlnYXRpb25UeXBlLFxuICBNZW1vcnlSb3V0ZXJQcm9wcyxcbiAgTmF2aWdhdGVGdW5jdGlvbixcbiAgTmF2aWdhdGVPcHRpb25zLFxuICBOYXZpZ2F0ZVByb3BzLFxuICBOYXZpZ2F0b3IsXG4gIE91dGxldFByb3BzLFxuICBQYXJhbXMsXG4gIFBhdGhNYXRjaCxcbiAgUm91dGVNYXRjaCxcbiAgUm91dGVPYmplY3QsXG4gIFJvdXRlUHJvcHMsXG4gIFBhdGhSb3V0ZVByb3BzLFxuICBMYXlvdXRSb3V0ZVByb3BzLFxuICBJbmRleFJvdXRlUHJvcHMsXG4gIFJvdXRlclByb3BzLFxuICBSb3V0ZXNQcm9wc1xufSBmcm9tIFwicmVhY3Qtcm91dGVyXCI7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIERBTkdFUiEgUExFQVNFIFJFQUQgTUUhXG4vLyBXZSBwcm92aWRlIHRoZXNlIGV4cG9ydHMgYXMgYW4gZXNjYXBlIGhhdGNoIGluIHRoZSBldmVudCB0aGF0IHlvdSBuZWVkIGFueVxuLy8gcm91dGluZyBkYXRhIHRoYXQgd2UgZG9uJ3QgcHJvdmlkZSBhbiBleHBsaWNpdCBBUEkgZm9yLiBXaXRoIHRoYXQgc2FpZCwgd2Vcbi8vIHdhbnQgdG8gY292ZXIgeW91ciB1c2UgY2FzZSBpZiB3ZSBjYW4sIHNvIGlmIHlvdSBmZWVsIHRoZSBuZWVkIHRvIHVzZSB0aGVzZVxuLy8gd2Ugd2FudCB0byBoZWFyIGZyb20geW91LiBMZXQgdXMga25vdyB3aGF0IHlvdSdyZSBidWlsZGluZyBhbmQgd2UnbGwgZG8gb3VyXG4vLyBiZXN0IHRvIG1ha2Ugc3VyZSB3ZSBjYW4gc3VwcG9ydCB5b3UhXG4vL1xuLy8gV2UgY29uc2lkZXIgdGhlc2UgZXhwb3J0cyBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgYW5kIGRvIG5vdCBndWFyYW50ZWVcbi8vIGFnYWluc3QgYW55IGJyZWFraW5nIGNoYW5nZXMsIHJlZ2FyZGxlc3Mgb2YgdGhlIHNlbXZlciByZWxlYXNlLiBVc2Ugd2l0aFxuLy8gZXh0cmVtZSBjYXV0aW9uIGFuZCBvbmx5IGlmIHlvdSB1bmRlcnN0YW5kIHRoZSBjb25zZXF1ZW5jZXMuIEdvZHNwZWVkLlxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKiogQGludGVybmFsICovXG5leHBvcnQge1xuICBVTlNBRkVfTmF2aWdhdGlvbkNvbnRleHQsXG4gIFVOU0FGRV9Mb2NhdGlvbkNvbnRleHQsXG4gIFVOU0FGRV9Sb3V0ZUNvbnRleHRcbn0gZnJvbSBcInJlYWN0LXJvdXRlclwiO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gQ09NUE9ORU5UU1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZXhwb3J0IGludGVyZmFjZSBCcm93c2VyUm91dGVyUHJvcHMge1xuICBiYXNlbmFtZT86IHN0cmluZztcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGU7XG4gIHdpbmRvdz86IFdpbmRvdztcbn1cblxuLyoqXG4gKiBBIGA8Um91dGVyPmAgZm9yIHVzZSBpbiB3ZWIgYnJvd3NlcnMuIFByb3ZpZGVzIHRoZSBjbGVhbmVzdCBVUkxzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gQnJvd3NlclJvdXRlcih7XG4gIGJhc2VuYW1lLFxuICBjaGlsZHJlbixcbiAgd2luZG93XG59OiBCcm93c2VyUm91dGVyUHJvcHMpIHtcbiAgbGV0IGhpc3RvcnlSZWYgPSBSZWFjdC51c2VSZWY8QnJvd3Nlckhpc3Rvcnk+KCk7XG4gIGlmIChoaXN0b3J5UmVmLmN1cnJlbnQgPT0gbnVsbCkge1xuICAgIGhpc3RvcnlSZWYuY3VycmVudCA9IGNyZWF0ZUJyb3dzZXJIaXN0b3J5KHsgd2luZG93IH0pO1xuICB9XG5cbiAgbGV0IGhpc3RvcnkgPSBoaXN0b3J5UmVmLmN1cnJlbnQ7XG4gIGxldCBbc3RhdGUsIHNldFN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKHtcbiAgICBhY3Rpb246IGhpc3RvcnkuYWN0aW9uLFxuICAgIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uXG4gIH0pO1xuXG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiBoaXN0b3J5Lmxpc3RlbihzZXRTdGF0ZSksIFtoaXN0b3J5XSk7XG5cbiAgcmV0dXJuIChcbiAgICA8Um91dGVyXG4gICAgICBiYXNlbmFtZT17YmFzZW5hbWV9XG4gICAgICBjaGlsZHJlbj17Y2hpbGRyZW59XG4gICAgICBsb2NhdGlvbj17c3RhdGUubG9jYXRpb259XG4gICAgICBuYXZpZ2F0aW9uVHlwZT17c3RhdGUuYWN0aW9ufVxuICAgICAgbmF2aWdhdG9yPXtoaXN0b3J5fVxuICAgIC8+XG4gICk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSGFzaFJvdXRlclByb3BzIHtcbiAgYmFzZW5hbWU/OiBzdHJpbmc7XG4gIGNoaWxkcmVuPzogUmVhY3QuUmVhY3ROb2RlO1xuICB3aW5kb3c/OiBXaW5kb3c7XG59XG5cbi8qKlxuICogQSBgPFJvdXRlcj5gIGZvciB1c2UgaW4gd2ViIGJyb3dzZXJzLiBTdG9yZXMgdGhlIGxvY2F0aW9uIGluIHRoZSBoYXNoXG4gKiBwb3J0aW9uIG9mIHRoZSBVUkwgc28gaXQgaXMgbm90IHNlbnQgdG8gdGhlIHNlcnZlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEhhc2hSb3V0ZXIoeyBiYXNlbmFtZSwgY2hpbGRyZW4sIHdpbmRvdyB9OiBIYXNoUm91dGVyUHJvcHMpIHtcbiAgbGV0IGhpc3RvcnlSZWYgPSBSZWFjdC51c2VSZWY8SGFzaEhpc3Rvcnk+KCk7XG4gIGlmIChoaXN0b3J5UmVmLmN1cnJlbnQgPT0gbnVsbCkge1xuICAgIGhpc3RvcnlSZWYuY3VycmVudCA9IGNyZWF0ZUhhc2hIaXN0b3J5KHsgd2luZG93IH0pO1xuICB9XG5cbiAgbGV0IGhpc3RvcnkgPSBoaXN0b3J5UmVmLmN1cnJlbnQ7XG4gIGxldCBbc3RhdGUsIHNldFN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKHtcbiAgICBhY3Rpb246IGhpc3RvcnkuYWN0aW9uLFxuICAgIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uXG4gIH0pO1xuXG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiBoaXN0b3J5Lmxpc3RlbihzZXRTdGF0ZSksIFtoaXN0b3J5XSk7XG5cbiAgcmV0dXJuIChcbiAgICA8Um91dGVyXG4gICAgICBiYXNlbmFtZT17YmFzZW5hbWV9XG4gICAgICBjaGlsZHJlbj17Y2hpbGRyZW59XG4gICAgICBsb2NhdGlvbj17c3RhdGUubG9jYXRpb259XG4gICAgICBuYXZpZ2F0aW9uVHlwZT17c3RhdGUuYWN0aW9ufVxuICAgICAgbmF2aWdhdG9yPXtoaXN0b3J5fVxuICAgIC8+XG4gICk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSGlzdG9yeVJvdXRlclByb3BzIHtcbiAgYmFzZW5hbWU/OiBzdHJpbmc7XG4gIGNoaWxkcmVuPzogUmVhY3QuUmVhY3ROb2RlO1xuICBoaXN0b3J5OiBIaXN0b3J5O1xufVxuXG4vKipcbiAqIEEgYDxSb3V0ZXI+YCB0aGF0IGFjY2VwdHMgYSBwcmUtaW5zdGFudGlhdGVkIGhpc3Rvcnkgb2JqZWN0LiBJdCdzIGltcG9ydGFudFxuICogdG8gbm90ZSB0aGF0IHVzaW5nIHlvdXIgb3duIGhpc3Rvcnkgb2JqZWN0IGlzIGhpZ2hseSBkaXNjb3VyYWdlZCBhbmQgbWF5IGFkZFxuICogdHdvIHZlcnNpb25zIG9mIHRoZSBoaXN0b3J5IGxpYnJhcnkgdG8geW91ciBidW5kbGVzIHVubGVzcyB5b3UgdXNlIHRoZSBzYW1lXG4gKiB2ZXJzaW9uIG9mIHRoZSBoaXN0b3J5IGxpYnJhcnkgdGhhdCBSZWFjdCBSb3V0ZXIgdXNlcyBpbnRlcm5hbGx5LlxuICovXG5mdW5jdGlvbiBIaXN0b3J5Um91dGVyKHsgYmFzZW5hbWUsIGNoaWxkcmVuLCBoaXN0b3J5IH06IEhpc3RvcnlSb3V0ZXJQcm9wcykge1xuICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKHtcbiAgICBhY3Rpb246IGhpc3RvcnkuYWN0aW9uLFxuICAgIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uXG4gIH0pO1xuXG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiBoaXN0b3J5Lmxpc3RlbihzZXRTdGF0ZSksIFtoaXN0b3J5XSk7XG5cbiAgcmV0dXJuIChcbiAgICA8Um91dGVyXG4gICAgICBiYXNlbmFtZT17YmFzZW5hbWV9XG4gICAgICBjaGlsZHJlbj17Y2hpbGRyZW59XG4gICAgICBsb2NhdGlvbj17c3RhdGUubG9jYXRpb259XG4gICAgICBuYXZpZ2F0aW9uVHlwZT17c3RhdGUuYWN0aW9ufVxuICAgICAgbmF2aWdhdG9yPXtoaXN0b3J5fVxuICAgIC8+XG4gICk7XG59XG5cbmlmIChfX0RFVl9fKSB7XG4gIEhpc3RvcnlSb3V0ZXIuZGlzcGxheU5hbWUgPSBcInVuc3RhYmxlX0hpc3RvcnlSb3V0ZXJcIjtcbn1cblxuZXhwb3J0IHsgSGlzdG9yeVJvdXRlciBhcyB1bnN0YWJsZV9IaXN0b3J5Um91dGVyIH07XG5cbmZ1bmN0aW9uIGlzTW9kaWZpZWRFdmVudChldmVudDogUmVhY3QuTW91c2VFdmVudCkge1xuICByZXR1cm4gISEoZXZlbnQubWV0YUtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5zaGlmdEtleSk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGlua1Byb3BzXG4gIGV4dGVuZHMgT21pdDxSZWFjdC5BbmNob3JIVE1MQXR0cmlidXRlczxIVE1MQW5jaG9yRWxlbWVudD4sIFwiaHJlZlwiPiB7XG4gIHJlbG9hZERvY3VtZW50PzogYm9vbGVhbjtcbiAgcmVwbGFjZT86IGJvb2xlYW47XG4gIHN0YXRlPzogYW55O1xuICB0bzogVG87XG59XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIHJlbmRlcmluZyBhIGhpc3RvcnktYXdhcmUgPGE+LlxuICovXG5leHBvcnQgY29uc3QgTGluayA9IFJlYWN0LmZvcndhcmRSZWY8SFRNTEFuY2hvckVsZW1lbnQsIExpbmtQcm9wcz4oXG4gIGZ1bmN0aW9uIExpbmtXaXRoUmVmKFxuICAgIHsgb25DbGljaywgcmVsb2FkRG9jdW1lbnQsIHJlcGxhY2UgPSBmYWxzZSwgc3RhdGUsIHRhcmdldCwgdG8sIC4uLnJlc3QgfSxcbiAgICByZWZcbiAgKSB7XG4gICAgbGV0IGhyZWYgPSB1c2VIcmVmKHRvKTtcbiAgICBsZXQgaW50ZXJuYWxPbkNsaWNrID0gdXNlTGlua0NsaWNrSGFuZGxlcih0bywgeyByZXBsYWNlLCBzdGF0ZSwgdGFyZ2V0IH0pO1xuICAgIGZ1bmN0aW9uIGhhbmRsZUNsaWNrKFxuICAgICAgZXZlbnQ6IFJlYWN0Lk1vdXNlRXZlbnQ8SFRNTEFuY2hvckVsZW1lbnQsIE1vdXNlRXZlbnQ+XG4gICAgKSB7XG4gICAgICBpZiAob25DbGljaykgb25DbGljayhldmVudCk7XG4gICAgICBpZiAoIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgJiYgIXJlbG9hZERvY3VtZW50KSB7XG4gICAgICAgIGludGVybmFsT25DbGljayhldmVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc3gtYTExeS9hbmNob3ItaGFzLWNvbnRlbnRcbiAgICAgIDxhXG4gICAgICAgIHsuLi5yZXN0fVxuICAgICAgICBocmVmPXtocmVmfVxuICAgICAgICBvbkNsaWNrPXtoYW5kbGVDbGlja31cbiAgICAgICAgcmVmPXtyZWZ9XG4gICAgICAgIHRhcmdldD17dGFyZ2V0fVxuICAgICAgLz5cbiAgICApO1xuICB9XG4pO1xuXG5pZiAoX19ERVZfXykge1xuICBMaW5rLmRpc3BsYXlOYW1lID0gXCJMaW5rXCI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTmF2TGlua1Byb3BzXG4gIGV4dGVuZHMgT21pdDxMaW5rUHJvcHMsIFwiY2xhc3NOYW1lXCIgfCBcInN0eWxlXCIgfCBcImNoaWxkcmVuXCI+IHtcbiAgY2hpbGRyZW46XG4gICAgfCBSZWFjdC5SZWFjdE5vZGVcbiAgICB8ICgocHJvcHM6IHsgaXNBY3RpdmU6IGJvb2xlYW4gfSkgPT4gUmVhY3QuUmVhY3ROb2RlKTtcbiAgY2FzZVNlbnNpdGl2ZT86IGJvb2xlYW47XG4gIGNsYXNzTmFtZT86IHN0cmluZyB8ICgocHJvcHM6IHsgaXNBY3RpdmU6IGJvb2xlYW4gfSkgPT4gc3RyaW5nKTtcbiAgZW5kPzogYm9vbGVhbjtcbiAgc3R5bGU/OlxuICAgIHwgUmVhY3QuQ1NTUHJvcGVydGllc1xuICAgIHwgKChwcm9wczogeyBpc0FjdGl2ZTogYm9vbGVhbiB9KSA9PiBSZWFjdC5DU1NQcm9wZXJ0aWVzKTtcbn1cblxuLyoqXG4gKiBBIDxMaW5rPiB3cmFwcGVyIHRoYXQga25vd3MgaWYgaXQncyBcImFjdGl2ZVwiIG9yIG5vdC5cbiAqL1xuZXhwb3J0IGNvbnN0IE5hdkxpbmsgPSBSZWFjdC5mb3J3YXJkUmVmPEhUTUxBbmNob3JFbGVtZW50LCBOYXZMaW5rUHJvcHM+KFxuICBmdW5jdGlvbiBOYXZMaW5rV2l0aFJlZihcbiAgICB7XG4gICAgICBcImFyaWEtY3VycmVudFwiOiBhcmlhQ3VycmVudFByb3AgPSBcInBhZ2VcIixcbiAgICAgIGNhc2VTZW5zaXRpdmUgPSBmYWxzZSxcbiAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lUHJvcCA9IFwiXCIsXG4gICAgICBlbmQgPSBmYWxzZSxcbiAgICAgIHN0eWxlOiBzdHlsZVByb3AsXG4gICAgICB0byxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgLi4ucmVzdFxuICAgIH0sXG4gICAgcmVmXG4gICkge1xuICAgIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gICAgbGV0IHBhdGggPSB1c2VSZXNvbHZlZFBhdGgodG8pO1xuXG4gICAgbGV0IGxvY2F0aW9uUGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZTtcbiAgICBsZXQgdG9QYXRobmFtZSA9IHBhdGgucGF0aG5hbWU7XG4gICAgaWYgKCFjYXNlU2Vuc2l0aXZlKSB7XG4gICAgICBsb2NhdGlvblBhdGhuYW1lID0gbG9jYXRpb25QYXRobmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdG9QYXRobmFtZSA9IHRvUGF0aG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBsZXQgaXNBY3RpdmUgPVxuICAgICAgbG9jYXRpb25QYXRobmFtZSA9PT0gdG9QYXRobmFtZSB8fFxuICAgICAgKCFlbmQgJiZcbiAgICAgICAgbG9jYXRpb25QYXRobmFtZS5zdGFydHNXaXRoKHRvUGF0aG5hbWUpICYmXG4gICAgICAgIGxvY2F0aW9uUGF0aG5hbWUuY2hhckF0KHRvUGF0aG5hbWUubGVuZ3RoKSA9PT0gXCIvXCIpO1xuXG4gICAgbGV0IGFyaWFDdXJyZW50ID0gaXNBY3RpdmUgPyBhcmlhQ3VycmVudFByb3AgOiB1bmRlZmluZWQ7XG5cbiAgICBsZXQgY2xhc3NOYW1lOiBzdHJpbmc7XG4gICAgaWYgKHR5cGVvZiBjbGFzc05hbWVQcm9wID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNsYXNzTmFtZSA9IGNsYXNzTmFtZVByb3AoeyBpc0FjdGl2ZSB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgdGhlIGNsYXNzTmFtZSBwcm9wIGlzIG5vdCBhIGZ1bmN0aW9uLCB3ZSB1c2UgYSBkZWZhdWx0IGBhY3RpdmVgXG4gICAgICAvLyBjbGFzcyBmb3IgPE5hdkxpbmsgLz5zIHRoYXQgYXJlIGFjdGl2ZS4gSW4gdjUgYGFjdGl2ZWAgd2FzIHRoZSBkZWZhdWx0XG4gICAgICAvLyB2YWx1ZSBmb3IgYGFjdGl2ZUNsYXNzTmFtZWAsIGJ1dCB3ZSBhcmUgcmVtb3ZpbmcgdGhhdCBBUEkgYW5kIGNhbiBzdGlsbFxuICAgICAgLy8gdXNlIHRoZSBvbGQgZGVmYXVsdCBiZWhhdmlvciBmb3IgYSBjbGVhbmVyIHVwZ3JhZGUgcGF0aCBhbmQga2VlcCB0aGVcbiAgICAgIC8vIHNpbXBsZSBzdHlsaW5nIHJ1bGVzIHdvcmtpbmcgYXMgdGhleSBjdXJyZW50bHkgZG8uXG4gICAgICBjbGFzc05hbWUgPSBbY2xhc3NOYW1lUHJvcCwgaXNBY3RpdmUgPyBcImFjdGl2ZVwiIDogbnVsbF1cbiAgICAgICAgLmZpbHRlcihCb29sZWFuKVxuICAgICAgICAuam9pbihcIiBcIik7XG4gICAgfVxuXG4gICAgbGV0IHN0eWxlID1cbiAgICAgIHR5cGVvZiBzdHlsZVByb3AgPT09IFwiZnVuY3Rpb25cIiA/IHN0eWxlUHJvcCh7IGlzQWN0aXZlIH0pIDogc3R5bGVQcm9wO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxMaW5rXG4gICAgICAgIHsuLi5yZXN0fVxuICAgICAgICBhcmlhLWN1cnJlbnQ9e2FyaWFDdXJyZW50fVxuICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZX1cbiAgICAgICAgcmVmPXtyZWZ9XG4gICAgICAgIHN0eWxlPXtzdHlsZX1cbiAgICAgICAgdG89e3RvfVxuICAgICAgPlxuICAgICAgICB7dHlwZW9mIGNoaWxkcmVuID09PSBcImZ1bmN0aW9uXCIgPyBjaGlsZHJlbih7IGlzQWN0aXZlIH0pIDogY2hpbGRyZW59XG4gICAgICA8L0xpbms+XG4gICAgKTtcbiAgfVxuKTtcblxuaWYgKF9fREVWX18pIHtcbiAgTmF2TGluay5kaXNwbGF5TmFtZSA9IFwiTmF2TGlua1wiO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gSE9PS1Ncbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogSGFuZGxlcyB0aGUgY2xpY2sgYmVoYXZpb3IgZm9yIHJvdXRlciBgPExpbms+YCBjb21wb25lbnRzLiBUaGlzIGlzIHVzZWZ1bCBpZlxuICogeW91IG5lZWQgdG8gY3JlYXRlIGN1c3RvbSBgPExpbms+YCBjb21wb25lbnRzIHdpdGggdGhlIHNhbWUgY2xpY2sgYmVoYXZpb3Igd2VcbiAqIHVzZSBpbiBvdXIgZXhwb3J0ZWQgYDxMaW5rPmAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VMaW5rQ2xpY2tIYW5kbGVyPEUgZXh0ZW5kcyBFbGVtZW50ID0gSFRNTEFuY2hvckVsZW1lbnQ+KFxuICB0bzogVG8sXG4gIHtcbiAgICB0YXJnZXQsXG4gICAgcmVwbGFjZTogcmVwbGFjZVByb3AsXG4gICAgc3RhdGVcbiAgfToge1xuICAgIHRhcmdldD86IFJlYWN0LkhUTUxBdHRyaWJ1dGVBbmNob3JUYXJnZXQ7XG4gICAgcmVwbGFjZT86IGJvb2xlYW47XG4gICAgc3RhdGU/OiBhbnk7XG4gIH0gPSB7fVxuKTogKGV2ZW50OiBSZWFjdC5Nb3VzZUV2ZW50PEUsIE1vdXNlRXZlbnQ+KSA9PiB2b2lkIHtcbiAgbGV0IG5hdmlnYXRlID0gdXNlTmF2aWdhdGUoKTtcbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IHBhdGggPSB1c2VSZXNvbHZlZFBhdGgodG8pO1xuXG4gIHJldHVybiBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAoZXZlbnQ6IFJlYWN0Lk1vdXNlRXZlbnQ8RSwgTW91c2VFdmVudD4pID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgZXZlbnQuYnV0dG9uID09PSAwICYmIC8vIElnbm9yZSBldmVyeXRoaW5nIGJ1dCBsZWZ0IGNsaWNrc1xuICAgICAgICAoIXRhcmdldCB8fCB0YXJnZXQgPT09IFwiX3NlbGZcIikgJiYgLy8gTGV0IGJyb3dzZXIgaGFuZGxlIFwidGFyZ2V0PV9ibGFua1wiIGV0Yy5cbiAgICAgICAgIWlzTW9kaWZpZWRFdmVudChldmVudCkgLy8gSWdub3JlIGNsaWNrcyB3aXRoIG1vZGlmaWVyIGtleXNcbiAgICAgICkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIC8vIElmIHRoZSBVUkwgaGFzbid0IGNoYW5nZWQsIGEgcmVndWxhciA8YT4gd2lsbCBkbyBhIHJlcGxhY2UgaW5zdGVhZCBvZlxuICAgICAgICAvLyBhIHB1c2gsIHNvIGRvIHRoZSBzYW1lIGhlcmUuXG4gICAgICAgIGxldCByZXBsYWNlID1cbiAgICAgICAgICAhIXJlcGxhY2VQcm9wIHx8IGNyZWF0ZVBhdGgobG9jYXRpb24pID09PSBjcmVhdGVQYXRoKHBhdGgpO1xuXG4gICAgICAgIG5hdmlnYXRlKHRvLCB7IHJlcGxhY2UsIHN0YXRlIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgW2xvY2F0aW9uLCBuYXZpZ2F0ZSwgcGF0aCwgcmVwbGFjZVByb3AsIHN0YXRlLCB0YXJnZXQsIHRvXVxuICApO1xufVxuXG4vKipcbiAqIEEgY29udmVuaWVudCB3cmFwcGVyIGZvciByZWFkaW5nIGFuZCB3cml0aW5nIHNlYXJjaCBwYXJhbWV0ZXJzIHZpYSB0aGVcbiAqIFVSTFNlYXJjaFBhcmFtcyBpbnRlcmZhY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VTZWFyY2hQYXJhbXMoZGVmYXVsdEluaXQ/OiBVUkxTZWFyY2hQYXJhbXNJbml0KSB7XG4gIHdhcm5pbmcoXG4gICAgdHlwZW9mIFVSTFNlYXJjaFBhcmFtcyAhPT0gXCJ1bmRlZmluZWRcIixcbiAgICBgWW91IGNhbm5vdCB1c2UgdGhlIFxcYHVzZVNlYXJjaFBhcmFtc1xcYCBob29rIGluIGEgYnJvd3NlciB0aGF0IGRvZXMgbm90IGAgK1xuICAgICAgYHN1cHBvcnQgdGhlIFVSTFNlYXJjaFBhcmFtcyBBUEkuIElmIHlvdSBuZWVkIHRvIHN1cHBvcnQgSW50ZXJuZXQgYCArXG4gICAgICBgRXhwbG9yZXIgMTEsIHdlIHJlY29tbWVuZCB5b3UgbG9hZCBhIHBvbHlmaWxsIHN1Y2ggYXMgYCArXG4gICAgICBgaHR0cHM6Ly9naXRodWIuY29tL3VuZ2FwL3VybC1zZWFyY2gtcGFyYW1zXFxuXFxuYCArXG4gICAgICBgSWYgeW91J3JlIHVuc3VyZSBob3cgdG8gbG9hZCBwb2x5ZmlsbHMsIHdlIHJlY29tbWVuZCB5b3UgY2hlY2sgb3V0IGAgK1xuICAgICAgYGh0dHBzOi8vcG9seWZpbGwuaW8vdjMvIHdoaWNoIHByb3ZpZGVzIHNvbWUgcmVjb21tZW5kYXRpb25zIGFib3V0IGhvdyBgICtcbiAgICAgIGB0byBsb2FkIHBvbHlmaWxscyBvbmx5IGZvciB1c2VycyB0aGF0IG5lZWQgdGhlbSwgaW5zdGVhZCBvZiBmb3IgZXZlcnkgYCArXG4gICAgICBgdXNlci5gXG4gICk7XG5cbiAgbGV0IGRlZmF1bHRTZWFyY2hQYXJhbXNSZWYgPSBSZWFjdC51c2VSZWYoY3JlYXRlU2VhcmNoUGFyYW1zKGRlZmF1bHRJbml0KSk7XG5cbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IHNlYXJjaFBhcmFtcyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGxldCBzZWFyY2hQYXJhbXMgPSBjcmVhdGVTZWFyY2hQYXJhbXMobG9jYXRpb24uc2VhcmNoKTtcblxuICAgIGZvciAobGV0IGtleSBvZiBkZWZhdWx0U2VhcmNoUGFyYW1zUmVmLmN1cnJlbnQua2V5cygpKSB7XG4gICAgICBpZiAoIXNlYXJjaFBhcmFtcy5oYXMoa2V5KSkge1xuICAgICAgICBkZWZhdWx0U2VhcmNoUGFyYW1zUmVmLmN1cnJlbnQuZ2V0QWxsKGtleSkuZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgICAgICAgc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlYXJjaFBhcmFtcztcbiAgfSwgW2xvY2F0aW9uLnNlYXJjaF0pO1xuXG4gIGxldCBuYXZpZ2F0ZSA9IHVzZU5hdmlnYXRlKCk7XG4gIGxldCBzZXRTZWFyY2hQYXJhbXMgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAoXG4gICAgICBuZXh0SW5pdDogVVJMU2VhcmNoUGFyYW1zSW5pdCxcbiAgICAgIG5hdmlnYXRlT3B0aW9ucz86IHsgcmVwbGFjZT86IGJvb2xlYW47IHN0YXRlPzogYW55IH1cbiAgICApID0+IHtcbiAgICAgIG5hdmlnYXRlKFwiP1wiICsgY3JlYXRlU2VhcmNoUGFyYW1zKG5leHRJbml0KSwgbmF2aWdhdGVPcHRpb25zKTtcbiAgICB9LFxuICAgIFtuYXZpZ2F0ZV1cbiAgKTtcblxuICByZXR1cm4gW3NlYXJjaFBhcmFtcywgc2V0U2VhcmNoUGFyYW1zXSBhcyBjb25zdDtcbn1cblxuZXhwb3J0IHR5cGUgUGFyYW1LZXlWYWx1ZVBhaXIgPSBbc3RyaW5nLCBzdHJpbmddO1xuXG5leHBvcnQgdHlwZSBVUkxTZWFyY2hQYXJhbXNJbml0ID1cbiAgfCBzdHJpbmdcbiAgfCBQYXJhbUtleVZhbHVlUGFpcltdXG4gIHwgUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgc3RyaW5nW10+XG4gIHwgVVJMU2VhcmNoUGFyYW1zO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0IHVzaW5nIHRoZSBnaXZlbiBpbml0aWFsaXplci5cbiAqXG4gKiBUaGlzIGlzIGlkZW50aWNhbCB0byBgbmV3IFVSTFNlYXJjaFBhcmFtcyhpbml0KWAgZXhjZXB0IGl0IGFsc29cbiAqIHN1cHBvcnRzIGFycmF5cyBhcyB2YWx1ZXMgaW4gdGhlIG9iamVjdCBmb3JtIG9mIHRoZSBpbml0aWFsaXplclxuICogaW5zdGVhZCBvZiBqdXN0IHN0cmluZ3MuIFRoaXMgaXMgY29udmVuaWVudCB3aGVuIHlvdSBuZWVkIG11bHRpcGxlXG4gKiB2YWx1ZXMgZm9yIGEgZ2l2ZW4ga2V5LCBidXQgZG9uJ3Qgd2FudCB0byB1c2UgYW4gYXJyYXkgaW5pdGlhbGl6ZXIuXG4gKlxuICogRm9yIGV4YW1wbGUsIGluc3RlYWQgb2Y6XG4gKlxuICogICBsZXQgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhbXG4gKiAgICAgWydzb3J0JywgJ25hbWUnXSxcbiAqICAgICBbJ3NvcnQnLCAncHJpY2UnXVxuICogICBdKTtcbiAqXG4gKiB5b3UgY2FuIGRvOlxuICpcbiAqICAgbGV0IHNlYXJjaFBhcmFtcyA9IGNyZWF0ZVNlYXJjaFBhcmFtcyh7XG4gKiAgICAgc29ydDogWyduYW1lJywgJ3ByaWNlJ11cbiAqICAgfSk7XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTZWFyY2hQYXJhbXMoXG4gIGluaXQ6IFVSTFNlYXJjaFBhcmFtc0luaXQgPSBcIlwiXG4pOiBVUkxTZWFyY2hQYXJhbXMge1xuICByZXR1cm4gbmV3IFVSTFNlYXJjaFBhcmFtcyhcbiAgICB0eXBlb2YgaW5pdCA9PT0gXCJzdHJpbmdcIiB8fFxuICAgIEFycmF5LmlzQXJyYXkoaW5pdCkgfHxcbiAgICBpbml0IGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zXG4gICAgICA/IGluaXRcbiAgICAgIDogT2JqZWN0LmtleXMoaW5pdCkucmVkdWNlKChtZW1vLCBrZXkpID0+IHtcbiAgICAgICAgICBsZXQgdmFsdWUgPSBpbml0W2tleV07XG4gICAgICAgICAgcmV0dXJuIG1lbW8uY29uY2F0KFxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5tYXAodiA9PiBba2V5LCB2XSkgOiBbW2tleSwgdmFsdWVdXVxuICAgICAgICAgICk7XG4gICAgICAgIH0sIFtdIGFzIFBhcmFtS2V5VmFsdWVQYWlyW10pXG4gICk7XG59XG4iLCAiLyoqXG4gKiBAcmVtaXgtcnVuL3NlcnZlci1ydW50aW1lIHYxLjIuMlxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG4vKipcbiAqIFRoZSBtb2RlIHRvIHVzZSB3aGVuIHJ1bm5pbmcgdGhlIHNlcnZlci5cbiAqL1xubGV0IFNlcnZlck1vZGU7XG5cbihmdW5jdGlvbiAoU2VydmVyTW9kZSkge1xuICBTZXJ2ZXJNb2RlW1wiRGV2ZWxvcG1lbnRcIl0gPSBcImRldmVsb3BtZW50XCI7XG4gIFNlcnZlck1vZGVbXCJQcm9kdWN0aW9uXCJdID0gXCJwcm9kdWN0aW9uXCI7XG4gIFNlcnZlck1vZGVbXCJUZXN0XCJdID0gXCJ0ZXN0XCI7XG59KShTZXJ2ZXJNb2RlIHx8IChTZXJ2ZXJNb2RlID0ge30pKTtcblxuZnVuY3Rpb24gaXNTZXJ2ZXJNb2RlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gU2VydmVyTW9kZS5EZXZlbG9wbWVudCB8fCB2YWx1ZSA9PT0gU2VydmVyTW9kZS5Qcm9kdWN0aW9uIHx8IHZhbHVlID09PSBTZXJ2ZXJNb2RlLlRlc3Q7XG59XG5cbmV4cG9ydCB7IFNlcnZlck1vZGUsIGlzU2VydmVyTW9kZSB9O1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZSB2MS4yLjJcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuLy8gTk9URTogbWFrZSBzdXJlIHRvIGNoYW5nZSB0aGUgUm91dGUgaW4gcmVtaXgtcmVhY3QgaWYgeW91IGNoYW5nZSB0aGlzXG4vLyBOT1RFOiBtYWtlIHN1cmUgdG8gY2hhbmdlIHRoZSBFbnRyeVJvdXRlIGluIHJlbWl4LXJlYWN0IGlmIHlvdSBjaGFuZ2UgdGhpc1xuZnVuY3Rpb24gY3JlYXRlUm91dGVzKG1hbmlmZXN0LCBwYXJlbnRJZCkge1xuICByZXR1cm4gT2JqZWN0LmtleXMobWFuaWZlc3QpLmZpbHRlcihrZXkgPT4gbWFuaWZlc3Rba2V5XS5wYXJlbnRJZCA9PT0gcGFyZW50SWQpLm1hcChpZCA9PiAoeyAuLi5tYW5pZmVzdFtpZF0sXG4gICAgY2hpbGRyZW46IGNyZWF0ZVJvdXRlcyhtYW5pZmVzdCwgaWQpXG4gIH0pKTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlUm91dGVzIH07XG4iLCAiLyoqXG4gKiBAcmVtaXgtcnVuL3NlcnZlci1ydW50aW1lIHYxLjIuMlxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5pbXBvcnQganNlc2MgZnJvbSAnanNlc2MnO1xuXG5mdW5jdGlvbiBjcmVhdGVTZXJ2ZXJIYW5kb2ZmU3RyaW5nKHNlcnZlckhhbmRvZmYpIHtcbiAgLy8gVXNlIGpzZXNjIHRvIGVzY2FwZSBkYXRhIHJldHVybmVkIGZyb20gdGhlIGxvYWRlcnMuIFRoaXMgc3RyaW5nIGlzXG4gIC8vIGluc2VydGVkIGRpcmVjdGx5IGludG8gdGhlIEhUTUwgaW4gdGhlIGA8U2NyaXB0cz5gIGVsZW1lbnQuXG4gIHJldHVybiBqc2VzYyhzZXJ2ZXJIYW5kb2ZmLCB7XG4gICAgaXNTY3JpcHRDb250ZXh0OiB0cnVlXG4gIH0pO1xufVxuXG5leHBvcnQgeyBjcmVhdGVTZXJ2ZXJIYW5kb2ZmU3RyaW5nIH07XG4iLCAiLyoqXG4gKiBAcmVtaXgtcnVuL2Nsb3VkZmxhcmUtcGFnZXMgdjEuMi4yXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmltcG9ydCB7IGNyZWF0ZVJlcXVlc3RIYW5kbGVyIGFzIGNyZWF0ZVJlcXVlc3RIYW5kbGVyJDEgfSBmcm9tICdAcmVtaXgtcnVuL3NlcnZlci1ydW50aW1lJztcblxuZnVuY3Rpb24gY3JlYXRlUmVxdWVzdEhhbmRsZXIoe1xuICBidWlsZCxcbiAgZ2V0TG9hZENvbnRleHQsXG4gIG1vZGVcbn0pIHtcbiAgbGV0IHBsYXRmb3JtID0ge307XG4gIGxldCBoYW5kbGVSZXF1ZXN0ID0gY3JlYXRlUmVxdWVzdEhhbmRsZXIkMShidWlsZCwgcGxhdGZvcm0sIG1vZGUpO1xuICByZXR1cm4gY29udGV4dCA9PiB7XG4gICAgbGV0IGxvYWRDb250ZXh0ID0gdHlwZW9mIGdldExvYWRDb250ZXh0ID09PSBcImZ1bmN0aW9uXCIgPyBnZXRMb2FkQ29udGV4dChjb250ZXh0KSA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gaGFuZGxlUmVxdWVzdChjb250ZXh0LnJlcXVlc3QsIGxvYWRDb250ZXh0KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhZ2VzRnVuY3Rpb25IYW5kbGVyKHtcbiAgYnVpbGQsXG4gIGdldExvYWRDb250ZXh0LFxuICBtb2RlXG59KSB7XG4gIGNvbnN0IGhhbmRsZVJlcXVlc3QgPSBjcmVhdGVSZXF1ZXN0SGFuZGxlcih7XG4gICAgYnVpbGQsXG4gICAgZ2V0TG9hZENvbnRleHQsXG4gICAgbW9kZVxuICB9KTtcblxuICBjb25zdCBoYW5kbGVGZXRjaCA9IGFzeW5jIGNvbnRleHQgPT4ge1xuICAgIGxldCByZXNwb25zZTsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Nsb3VkZmxhcmUvd3JhbmdsZXIyL2lzc3Vlcy8xMTdcblxuICAgIGNvbnRleHQucmVxdWVzdC5oZWFkZXJzLmRlbGV0ZShcImlmLW5vbmUtbWF0Y2hcIik7XG5cbiAgICB0cnkge1xuICAgICAgcmVzcG9uc2UgPSBhd2FpdCBjb250ZXh0LmVudi5BU1NFVFMuZmV0Y2goY29udGV4dC5yZXF1ZXN0LnVybCwgY29udGV4dC5yZXF1ZXN0LmNsb25lKCkpO1xuICAgICAgcmVzcG9uc2UgPSByZXNwb25zZSAmJiByZXNwb25zZS5zdGF0dXMgPj0gMjAwICYmIHJlc3BvbnNlLnN0YXR1cyA8IDQwMCA/IG5ldyBSZXNwb25zZShyZXNwb25zZS5ib2R5LCByZXNwb25zZSkgOiB1bmRlZmluZWQ7XG4gICAgfSBjYXRjaCB7fVxuXG4gICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgcmVzcG9uc2UgPSBhd2FpdCBoYW5kbGVSZXF1ZXN0KGNvbnRleHQpO1xuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfTtcblxuICByZXR1cm4gYXN5bmMgY29udGV4dCA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBoYW5kbGVGZXRjaChjb250ZXh0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIiAmJiBlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShlLm1lc3NhZ2UgfHwgZS50b1N0cmluZygpLCB7XG4gICAgICAgICAgc3RhdHVzOiA1MDBcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UoXCJJbnRlcm5hbCBFcnJvclwiLCB7XG4gICAgICAgIHN0YXR1czogNTAwXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XG5cbmV4cG9ydCB7IGNyZWF0ZVBhZ2VzRnVuY3Rpb25IYW5kbGVyLCBjcmVhdGVSZXF1ZXN0SGFuZGxlciB9O1xuIiwgIlxuaW1wb3J0ICogYXMgZW50cnlTZXJ2ZXIgZnJvbSBcIkQ6XFxcXEdpdGh1YlxcXFxQcm9qZWN0c1xcXFxhbG9uZ3ZpbGkuZGV2XFxcXGFwcFxcXFxlbnRyeS5zZXJ2ZXIudHN4XCI7XG5pbXBvcnQgKiBhcyByb3V0ZTAgZnJvbSBcIkQ6XFxcXEdpdGh1YlxcXFxQcm9qZWN0c1xcXFxhbG9uZ3ZpbGkuZGV2XFxcXGFwcFxcXFxyb290LnRzeFwiO1xuaW1wb3J0ICogYXMgcm91dGUxIGZyb20gXCJEOlxcXFxHaXRodWJcXFxcUHJvamVjdHNcXFxcYWxvbmd2aWxpLmRldlxcXFxhcHBcXFxccm91dGVzXFxcXHByb2plY3RzLnRzeFwiO1xuaW1wb3J0ICogYXMgcm91dGUyIGZyb20gXCJEOlxcXFxHaXRodWJcXFxcUHJvamVjdHNcXFxcYWxvbmd2aWxpLmRldlxcXFxhcHBcXFxccm91dGVzXFxcXGluZGV4LnRzeFwiO1xuaW1wb3J0ICogYXMgcm91dGUzIGZyb20gXCJEOlxcXFxHaXRodWJcXFxcUHJvamVjdHNcXFxcYWxvbmd2aWxpLmRldlxcXFxhcHBcXFxccm91dGVzXFxcXGxpc3RzLnRzeFwiO1xuaW1wb3J0ICogYXMgcm91dGU0IGZyb20gXCJEOlxcXFxHaXRodWJcXFxcUHJvamVjdHNcXFxcYWxvbmd2aWxpLmRldlxcXFxhcHBcXFxccm91dGVzXFxcXG1lLnRzeFwiO1xuICBleHBvcnQgeyBkZWZhdWx0IGFzIGFzc2V0cyB9IGZyb20gXCJAcmVtaXgtcnVuL2Rldi9hc3NldHMtbWFuaWZlc3RcIjtcbiAgZXhwb3J0IGNvbnN0IGVudHJ5ID0geyBtb2R1bGU6IGVudHJ5U2VydmVyIH07XG4gIGV4cG9ydCBjb25zdCByb3V0ZXMgPSB7XG4gICAgXCJyb290XCI6IHtcbiAgICAgIGlkOiBcInJvb3RcIixcbiAgICAgIHBhcmVudElkOiB1bmRlZmluZWQsXG4gICAgICBwYXRoOiBcIlwiLFxuICAgICAgaW5kZXg6IHVuZGVmaW5lZCxcbiAgICAgIGNhc2VTZW5zaXRpdmU6IHVuZGVmaW5lZCxcbiAgICAgIG1vZHVsZTogcm91dGUwXG4gICAgfSxcbiAgXCJyb3V0ZXMvcHJvamVjdHNcIjoge1xuICAgICAgaWQ6IFwicm91dGVzL3Byb2plY3RzXCIsXG4gICAgICBwYXJlbnRJZDogXCJyb290XCIsXG4gICAgICBwYXRoOiBcInByb2plY3RzXCIsXG4gICAgICBpbmRleDogdW5kZWZpbmVkLFxuICAgICAgY2FzZVNlbnNpdGl2ZTogdW5kZWZpbmVkLFxuICAgICAgbW9kdWxlOiByb3V0ZTFcbiAgICB9LFxuICBcInJvdXRlcy9pbmRleFwiOiB7XG4gICAgICBpZDogXCJyb3V0ZXMvaW5kZXhcIixcbiAgICAgIHBhcmVudElkOiBcInJvb3RcIixcbiAgICAgIHBhdGg6IHVuZGVmaW5lZCxcbiAgICAgIGluZGV4OiB0cnVlLFxuICAgICAgY2FzZVNlbnNpdGl2ZTogdW5kZWZpbmVkLFxuICAgICAgbW9kdWxlOiByb3V0ZTJcbiAgICB9LFxuICBcInJvdXRlcy9saXN0c1wiOiB7XG4gICAgICBpZDogXCJyb3V0ZXMvbGlzdHNcIixcbiAgICAgIHBhcmVudElkOiBcInJvb3RcIixcbiAgICAgIHBhdGg6IFwibGlzdHNcIixcbiAgICAgIGluZGV4OiB1bmRlZmluZWQsXG4gICAgICBjYXNlU2Vuc2l0aXZlOiB1bmRlZmluZWQsXG4gICAgICBtb2R1bGU6IHJvdXRlM1xuICAgIH0sXG4gIFwicm91dGVzL21lXCI6IHtcbiAgICAgIGlkOiBcInJvdXRlcy9tZVwiLFxuICAgICAgcGFyZW50SWQ6IFwicm9vdFwiLFxuICAgICAgcGF0aDogXCJtZVwiLFxuICAgICAgaW5kZXg6IHVuZGVmaW5lZCxcbiAgICAgIGNhc2VTZW5zaXRpdmU6IHVuZGVmaW5lZCxcbiAgICAgIG1vZHVsZTogcm91dGU0XG4gICAgfVxuICB9OyIsICJpbXBvcnQgeyByZW5kZXJUb1N0cmluZyB9IGZyb20gXCJyZWFjdC1kb20vc2VydmVyXCI7XG5pbXBvcnQgeyBSZW1peFNlcnZlciB9IGZyb20gXCJyZW1peFwiO1xuaW1wb3J0IHR5cGUgeyBFbnRyeUNvbnRleHQgfSBmcm9tIFwicmVtaXhcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaGFuZGxlUmVxdWVzdChcbiAgcmVxdWVzdDogUmVxdWVzdCxcbiAgcmVzcG9uc2VTdGF0dXNDb2RlOiBudW1iZXIsXG4gIHJlc3BvbnNlSGVhZGVyczogSGVhZGVycyxcbiAgcmVtaXhDb250ZXh0OiBFbnRyeUNvbnRleHRcbikge1xuICBjb25zdCBtYXJrdXAgPSByZW5kZXJUb1N0cmluZyhcbiAgICA8UmVtaXhTZXJ2ZXIgY29udGV4dD17cmVtaXhDb250ZXh0fSB1cmw9e3JlcXVlc3QudXJsfSAvPlxuICApO1xuXG4gIHJlc3BvbnNlSGVhZGVycy5zZXQoXCJDb250ZW50LVR5cGVcIiwgXCJ0ZXh0L2h0bWxcIik7XG5cbiAgcmV0dXJuIG5ldyBSZXNwb25zZShcIjwhRE9DVFlQRSBodG1sPlwiICsgbWFya3VwLCB7XG4gICAgc3RhdHVzOiByZXNwb25zZVN0YXR1c0NvZGUsXG4gICAgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJzXG4gIH0pO1xufVxuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9jbG91ZGZsYXJlLXBhZ2VzIHYxLjIuMlxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5leHBvcnQgeyBjcmVhdGVDbG91ZGZsYXJlS1ZTZXNzaW9uU3RvcmFnZSB9IGZyb20gJ0ByZW1peC1ydW4vY2xvdWRmbGFyZS1wYWdlcyc7XG5cbi8qKlxuICogQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZSB2MS4yLjJcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuZXhwb3J0IHsgY3JlYXRlQ29va2llLCBjcmVhdGVDb29raWVTZXNzaW9uU3RvcmFnZSwgY3JlYXRlTWVtb3J5U2Vzc2lvblN0b3JhZ2UsIGNyZWF0ZVNlc3Npb24sIGNyZWF0ZVNlc3Npb25TdG9yYWdlLCBpc0Nvb2tpZSwgaXNTZXNzaW9uLCBqc29uLCByZWRpcmVjdCB9IGZyb20gJ0ByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUnO1xuXG4vKipcbiAqIEByZW1peC1ydW4vcmVhY3QgdjEuMi4yXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmV4cG9ydCB7IEZvcm0sIExpbmssIExpbmtzLCBMaXZlUmVsb2FkLCBNZXRhLCBOYXZMaW5rLCBPdXRsZXQsIFByZWZldGNoUGFnZUxpbmtzLCBSZW1peEJyb3dzZXIsIFJlbWl4U2VydmVyLCBTY3JpcHRzLCBTY3JvbGxSZXN0b3JhdGlvbiwgdXNlQWN0aW9uRGF0YSwgdXNlQmVmb3JlVW5sb2FkLCB1c2VDYXRjaCwgdXNlRmV0Y2hlciwgdXNlRmV0Y2hlcnMsIHVzZUZvcm1BY3Rpb24sIHVzZUhyZWYsIHVzZUxvYWRlckRhdGEsIHVzZUxvY2F0aW9uLCB1c2VNYXRjaGVzLCB1c2VOYXZpZ2F0ZSwgdXNlTmF2aWdhdGlvblR5cGUsIHVzZU91dGxldCwgdXNlT3V0bGV0Q29udGV4dCwgdXNlUGFyYW1zLCB1c2VSZXNvbHZlZFBhdGgsIHVzZVNlYXJjaFBhcmFtcywgdXNlU3VibWl0LCB1c2VUcmFuc2l0aW9uIH0gZnJvbSAnQHJlbWl4LXJ1bi9yZWFjdCc7XG5cbiIsICIvKipcbiAqIEByZW1peC1ydW4vcmVhY3QgdjEuMi4yXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmV4cG9ydCB7IFJlbWl4QnJvd3NlciB9IGZyb20gJy4vYnJvd3Nlci5qcyc7XG5leHBvcnQgeyBPdXRsZXQsIHVzZUhyZWYsIHVzZUxvY2F0aW9uLCB1c2VOYXZpZ2F0ZSwgdXNlTmF2aWdhdGlvblR5cGUsIHVzZU91dGxldCwgdXNlT3V0bGV0Q29udGV4dCwgdXNlUGFyYW1zLCB1c2VSZXNvbHZlZFBhdGgsIHVzZVNlYXJjaFBhcmFtcyB9IGZyb20gJ3JlYWN0LXJvdXRlci1kb20nO1xuZXhwb3J0IHsgRm9ybSwgTGluaywgTGlua3MsIExpdmVSZWxvYWQsIE1ldGEsIE5hdkxpbmssIFByZWZldGNoUGFnZUxpbmtzLCBTY3JpcHRzLCB1c2VBY3Rpb25EYXRhLCB1c2VCZWZvcmVVbmxvYWQsIHVzZUZldGNoZXIsIHVzZUZldGNoZXJzLCB1c2VGb3JtQWN0aW9uLCB1c2VMb2FkZXJEYXRhLCB1c2VNYXRjaGVzLCB1c2VTdWJtaXQsIHVzZVRyYW5zaXRpb24gfSBmcm9tICcuL2NvbXBvbmVudHMuanMnO1xuZXhwb3J0IHsgdXNlQ2F0Y2ggfSBmcm9tICcuL2Vycm9yQm91bmRhcmllcy5qcyc7XG5leHBvcnQgeyBTY3JvbGxSZXN0b3JhdGlvbiB9IGZyb20gJy4vc2Nyb2xsLXJlc3RvcmF0aW9uLmpzJztcbmV4cG9ydCB7IFJlbWl4U2VydmVyIH0gZnJvbSAnLi9zZXJ2ZXIuanMnO1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9yZWFjdCB2MS4yLjJcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuaW1wb3J0IHsgZXh0ZW5kcyBhcyBfZXh0ZW5kcyB9IGZyb20gJy4vX3ZpcnR1YWwvX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5qcyc7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VIcmVmLCBOYXZMaW5rIGFzIE5hdkxpbmskMSwgTGluayBhcyBMaW5rJDEsIHVzZUxvY2F0aW9uLCB1c2VSZXNvbHZlZFBhdGgsIHVzZU5hdmlnYXRlLCBSb3V0ZXIsIHVzZVJvdXRlcyB9IGZyb20gJ3JlYWN0LXJvdXRlci1kb20nO1xuaW1wb3J0IHsgUmVtaXhFcnJvckJvdW5kYXJ5LCBSZW1peFJvb3REZWZhdWx0RXJyb3JCb3VuZGFyeSwgUmVtaXhDYXRjaEJvdW5kYXJ5LCBSZW1peFJvb3REZWZhdWx0Q2F0Y2hCb3VuZGFyeSB9IGZyb20gJy4vZXJyb3JCb3VuZGFyaWVzLmpzJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnLi9pbnZhcmlhbnQuanMnO1xuaW1wb3J0IHsgZ2V0TGlua3NGb3JNYXRjaGVzLCBpc1BhZ2VMaW5rRGVzY3JpcHRvciwgZ2V0TmV3TWF0Y2hlc0ZvckxpbmtzLCBnZXREYXRhTGlua0hyZWZzLCBnZXRNb2R1bGVMaW5rSHJlZnMsIGdldFN0eWxlc2hlZXRQcmVmZXRjaExpbmtzIH0gZnJvbSAnLi9saW5rcy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVIdG1sIH0gZnJvbSAnLi9tYXJrdXAuanMnO1xuaW1wb3J0IHsgY3JlYXRlQ2xpZW50Um91dGVzIH0gZnJvbSAnLi9yb3V0ZXMuanMnO1xuaW1wb3J0IHsgbWF0Y2hDbGllbnRSb3V0ZXMgfSBmcm9tICcuL3JvdXRlTWF0Y2hpbmcuanMnO1xuaW1wb3J0IHsgY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIgfSBmcm9tICcuL3RyYW5zaXRpb24uanMnO1xuXG5jb25zdCBSZW1peEVudHJ5Q29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KHVuZGVmaW5lZCk7XG5cbmZ1bmN0aW9uIHVzZVJlbWl4RW50cnlDb250ZXh0KCkge1xuICBsZXQgY29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoUmVtaXhFbnRyeUNvbnRleHQpO1xuICBpbnZhcmlhbnQoY29udGV4dCwgXCJZb3UgbXVzdCByZW5kZXIgdGhpcyBlbGVtZW50IGluc2lkZSBhIDxSZW1peD4gZWxlbWVudFwiKTtcbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIFJlbWl4RW50cnkoe1xuICBjb250ZXh0OiBlbnRyeUNvbnRleHQsXG4gIGFjdGlvbixcbiAgbG9jYXRpb246IGhpc3RvcnlMb2NhdGlvbixcbiAgbmF2aWdhdG9yOiBfbmF2aWdhdG9yLFxuICBzdGF0aWM6IHN0YXRpY1Byb3AgPSBmYWxzZVxufSkge1xuICBsZXQge1xuICAgIG1hbmlmZXN0LFxuICAgIHJvdXRlRGF0YTogZG9jdW1lbnRMb2FkZXJEYXRhLFxuICAgIGFjdGlvbkRhdGE6IGRvY3VtZW50QWN0aW9uRGF0YSxcbiAgICByb3V0ZU1vZHVsZXMsXG4gICAgc2VydmVySGFuZG9mZlN0cmluZyxcbiAgICBhcHBTdGF0ZTogZW50cnlDb21wb25lbnREaWRDYXRjaEVtdWxhdG9yXG4gIH0gPSBlbnRyeUNvbnRleHQ7XG4gIGxldCBjbGllbnRSb3V0ZXMgPSBSZWFjdC51c2VNZW1vKCgpID0+IGNyZWF0ZUNsaWVudFJvdXRlcyhtYW5pZmVzdC5yb3V0ZXMsIHJvdXRlTW9kdWxlcywgUmVtaXhSb3V0ZSksIFttYW5pZmVzdCwgcm91dGVNb2R1bGVzXSk7XG4gIGxldCBbY2xpZW50U3RhdGUsIHNldENsaWVudFN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKGVudHJ5Q29tcG9uZW50RGlkQ2F0Y2hFbXVsYXRvcik7XG4gIGxldCBbdHJhbnNpdGlvbk1hbmFnZXJdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4ge1xuICAgIHJldHVybiBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcih7XG4gICAgICByb3V0ZXM6IGNsaWVudFJvdXRlcyxcbiAgICAgIGFjdGlvbkRhdGE6IGRvY3VtZW50QWN0aW9uRGF0YSxcbiAgICAgIGxvYWRlckRhdGE6IGRvY3VtZW50TG9hZGVyRGF0YSxcbiAgICAgIGxvY2F0aW9uOiBoaXN0b3J5TG9jYXRpb24sXG4gICAgICBjYXRjaDogZW50cnlDb21wb25lbnREaWRDYXRjaEVtdWxhdG9yLmNhdGNoLFxuICAgICAgY2F0Y2hCb3VuZGFyeUlkOiBlbnRyeUNvbXBvbmVudERpZENhdGNoRW11bGF0b3IuY2F0Y2hCb3VuZGFyeVJvdXRlSWQsXG4gICAgICBvblJlZGlyZWN0OiBfbmF2aWdhdG9yLnJlcGxhY2UsXG4gICAgICBvbkNoYW5nZTogc3RhdGUgPT4ge1xuICAgICAgICBzZXRDbGllbnRTdGF0ZSh7XG4gICAgICAgICAgY2F0Y2g6IHN0YXRlLmNhdGNoLFxuICAgICAgICAgIGVycm9yOiBzdGF0ZS5lcnJvcixcbiAgICAgICAgICBjYXRjaEJvdW5kYXJ5Um91dGVJZDogc3RhdGUuY2F0Y2hCb3VuZGFyeUlkLFxuICAgICAgICAgIGxvYWRlckJvdW5kYXJ5Um91dGVJZDogc3RhdGUuZXJyb3JCb3VuZGFyeUlkLFxuICAgICAgICAgIHJlbmRlckJvdW5kYXJ5Um91dGVJZDogbnVsbCxcbiAgICAgICAgICB0cmFja0JvdW5kYXJpZXM6IGZhbHNlLFxuICAgICAgICAgIHRyYWNrQ2F0Y2hCb3VuZGFyaWVzOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7IC8vIEVuc3VyZXMgcHVzaGVzIGludGVycnVwdGluZyBwZW5kaW5nIG5hdmlnYXRpb25zIHVzZSByZXBsYWNlXG4gIC8vIFRPRE86IE1vdmUgdGhpcyB0byBSZWFjdCBSb3V0ZXJcblxuICBsZXQgbmF2aWdhdG9yID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgbGV0IHB1c2ggPSAodG8sIHN0YXRlKSA9PiB7XG4gICAgICByZXR1cm4gdHJhbnNpdGlvbk1hbmFnZXIuZ2V0U3RhdGUoKS50cmFuc2l0aW9uLnN0YXRlICE9PSBcImlkbGVcIiA/IF9uYXZpZ2F0b3IucmVwbGFjZSh0bywgc3RhdGUpIDogX25hdmlnYXRvci5wdXNoKHRvLCBzdGF0ZSk7XG4gICAgfTtcblxuICAgIHJldHVybiB7IC4uLl9uYXZpZ2F0b3IsXG4gICAgICBwdXNoXG4gICAgfTtcbiAgfSwgW19uYXZpZ2F0b3IsIHRyYW5zaXRpb25NYW5hZ2VyXSk7XG4gIGxldCB7XG4gICAgbG9jYXRpb24sXG4gICAgbWF0Y2hlcyxcbiAgICBsb2FkZXJEYXRhLFxuICAgIGFjdGlvbkRhdGFcbiAgfSA9IHRyYW5zaXRpb25NYW5hZ2VyLmdldFN0YXRlKCk7IC8vIFNlbmQgbmV3IGxvY2F0aW9uIHRvIHRoZSB0cmFuc2l0aW9uIG1hbmFnZXJcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCB7XG4gICAgICBsb2NhdGlvblxuICAgIH0gPSB0cmFuc2l0aW9uTWFuYWdlci5nZXRTdGF0ZSgpO1xuICAgIGlmIChoaXN0b3J5TG9jYXRpb24gPT09IGxvY2F0aW9uKSByZXR1cm47XG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuc2VuZCh7XG4gICAgICB0eXBlOiBcIm5hdmlnYXRpb25cIixcbiAgICAgIGxvY2F0aW9uOiBoaXN0b3J5TG9jYXRpb24sXG4gICAgICBzdWJtaXNzaW9uOiBjb25zdW1lTmV4dE5hdmlnYXRpb25TdWJtaXNzaW9uKCksXG4gICAgICBhY3Rpb25cbiAgICB9KTtcbiAgfSwgW3RyYW5zaXRpb25NYW5hZ2VyLCBoaXN0b3J5TG9jYXRpb24sIGFjdGlvbl0pOyAvLyBJZiB3ZSB0cmllZCB0byByZW5kZXIgYW5kIGZhaWxlZCwgYW5kIHRoZSBhcHAgdGhyZXcgYmVmb3JlIHJlbmRlcmluZyBhbnlcbiAgLy8gcm91dGVzLCBnZXQgdGhlIGVycm9yIGFuZCBwYXNzIGl0IHRvIHRoZSBFcnJvckJvdW5kYXJ5IHRvIGVtdWxhdGVcbiAgLy8gYGNvbXBvbmVudERpZENhdGNoYFxuXG4gIGxldCBzc3JFcnJvckJlZm9yZVJvdXRlc1JlbmRlcmVkID0gY2xpZW50U3RhdGUuZXJyb3IgJiYgY2xpZW50U3RhdGUucmVuZGVyQm91bmRhcnlSb3V0ZUlkID09PSBudWxsICYmIGNsaWVudFN0YXRlLmxvYWRlckJvdW5kYXJ5Um91dGVJZCA9PT0gbnVsbCA/IGRlc2VyaWFsaXplRXJyb3IoY2xpZW50U3RhdGUuZXJyb3IpIDogdW5kZWZpbmVkO1xuICBsZXQgc3NyQ2F0Y2hCZWZvcmVSb3V0ZXNSZW5kZXJlZCA9IGNsaWVudFN0YXRlLmNhdGNoICYmIGNsaWVudFN0YXRlLmNhdGNoQm91bmRhcnlSb3V0ZUlkID09PSBudWxsID8gY2xpZW50U3RhdGUuY2F0Y2ggOiB1bmRlZmluZWQ7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZW1peEVudHJ5Q29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiB7XG4gICAgICBtYXRjaGVzLFxuICAgICAgbWFuaWZlc3QsXG4gICAgICBhcHBTdGF0ZTogY2xpZW50U3RhdGUsXG4gICAgICByb3V0ZU1vZHVsZXMsXG4gICAgICBzZXJ2ZXJIYW5kb2ZmU3RyaW5nLFxuICAgICAgY2xpZW50Um91dGVzLFxuICAgICAgcm91dGVEYXRhOiBsb2FkZXJEYXRhLFxuICAgICAgYWN0aW9uRGF0YSxcbiAgICAgIHRyYW5zaXRpb25NYW5hZ2VyXG4gICAgfVxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZW1peEVycm9yQm91bmRhcnksIHtcbiAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgY29tcG9uZW50OiBSZW1peFJvb3REZWZhdWx0RXJyb3JCb3VuZGFyeSxcbiAgICBlcnJvcjogc3NyRXJyb3JCZWZvcmVSb3V0ZXNSZW5kZXJlZFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZW1peENhdGNoQm91bmRhcnksIHtcbiAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgY29tcG9uZW50OiBSZW1peFJvb3REZWZhdWx0Q2F0Y2hCb3VuZGFyeSxcbiAgICBjYXRjaDogc3NyQ2F0Y2hCZWZvcmVSb3V0ZXNSZW5kZXJlZFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIsIHtcbiAgICBuYXZpZ2F0aW9uVHlwZTogYWN0aW9uLFxuICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICBuYXZpZ2F0b3I6IG5hdmlnYXRvcixcbiAgICBzdGF0aWM6IHN0YXRpY1Byb3BcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVzLCBudWxsKSkpKSk7XG59XG5cbmZ1bmN0aW9uIGRlc2VyaWFsaXplRXJyb3IoZGF0YSkge1xuICBsZXQgZXJyb3IgPSBuZXcgRXJyb3IoZGF0YS5tZXNzYWdlKTtcbiAgZXJyb3Iuc3RhY2sgPSBkYXRhLnN0YWNrO1xuICByZXR1cm4gZXJyb3I7XG59XG5cbmZ1bmN0aW9uIFJvdXRlcygpIHtcbiAgLy8gVE9ETzogQWRkIGByZW5kZXJNYXRjaGVzYCBmdW5jdGlvbiB0byBSUiB0aGF0IHdlIGNhbiB1c2UgYW5kIHRoZW4gd2UgZG9uJ3RcbiAgLy8gbmVlZCB0aGlzIGNvbXBvbmVudCwgd2UgY2FuIGp1c3QgYHJlbmRlck1hdGNoZXNgIGZyb20gUmVtaXhFbnRyeVxuICBsZXQge1xuICAgIGNsaWVudFJvdXRlc1xuICB9ID0gdXNlUmVtaXhFbnRyeUNvbnRleHQoKTsgLy8gZmFsbGJhY2sgdG8gdGhlIHJvb3QgaWYgd2UgZG9uJ3QgaGF2ZSBhIG1hdGNoXG5cbiAgbGV0IGVsZW1lbnQgPSB1c2VSb3V0ZXMoY2xpZW50Um91dGVzKSB8fCBjbGllbnRSb3V0ZXNbMF0uZWxlbWVudDtcbiAgcmV0dXJuIGVsZW1lbnQ7XG59IC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBSZW1peFJvdXRlXG5cblxuY29uc3QgUmVtaXhSb3V0ZUNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dCh1bmRlZmluZWQpO1xuXG5mdW5jdGlvbiB1c2VSZW1peFJvdXRlQ29udGV4dCgpIHtcbiAgbGV0IGNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KFJlbWl4Um91dGVDb250ZXh0KTtcbiAgaW52YXJpYW50KGNvbnRleHQsIFwiWW91IG11c3QgcmVuZGVyIHRoaXMgZWxlbWVudCBpbiBhIHJlbWl4IHJvdXRlIGVsZW1lbnRcIik7XG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5mdW5jdGlvbiBEZWZhdWx0Um91dGVDb21wb25lbnQoe1xuICBpZFxufSkge1xuICB0aHJvdyBuZXcgRXJyb3IoYFJvdXRlIFwiJHtpZH1cIiBoYXMgbm8gY29tcG9uZW50ISBQbGVhc2UgZ28gYWRkIGEgXFxgZGVmYXVsdFxcYCBleHBvcnQgaW4gdGhlIHJvdXRlIG1vZHVsZSBmaWxlLlxcbmAgKyBcIklmIHlvdSB3ZXJlIHRyeWluZyB0byBuYXZpZ2F0ZSBvciBzdWJtaXQgdG8gYSByZXNvdXJjZSByb3V0ZSwgdXNlIGA8YT5gIGluc3RlYWQgb2YgYDxMaW5rPmAgb3IgYDxGb3JtIHJlbG9hZERvY3VtZW50PmAuXCIpO1xufVxuXG5mdW5jdGlvbiBSZW1peFJvdXRlKHtcbiAgaWRcbn0pIHtcbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IHtcbiAgICByb3V0ZURhdGEsXG4gICAgcm91dGVNb2R1bGVzLFxuICAgIGFwcFN0YXRlXG4gIH0gPSB1c2VSZW1peEVudHJ5Q29udGV4dCgpO1xuICBsZXQgZGF0YSA9IHJvdXRlRGF0YVtpZF07XG4gIGxldCB7XG4gICAgZGVmYXVsdDogQ29tcG9uZW50LFxuICAgIENhdGNoQm91bmRhcnksXG4gICAgRXJyb3JCb3VuZGFyeVxuICB9ID0gcm91dGVNb2R1bGVzW2lkXTtcbiAgbGV0IGVsZW1lbnQgPSBDb21wb25lbnQgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIG51bGwpIDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRGVmYXVsdFJvdXRlQ29tcG9uZW50LCB7XG4gICAgaWQ6IGlkXG4gIH0pO1xuICBsZXQgY29udGV4dCA9IHtcbiAgICBkYXRhLFxuICAgIGlkXG4gIH07XG5cbiAgaWYgKENhdGNoQm91bmRhcnkpIHtcbiAgICAvLyBJZiB3ZSB0cmllZCB0byByZW5kZXIgYW5kIGZhaWxlZCwgYW5kIHRoaXMgcm91dGUgdGhyZXcgdGhlIGVycm9yLCBmaW5kIGl0XG4gICAgLy8gYW5kIHBhc3MgaXQgdG8gdGhlIEVycm9yQm91bmRhcnkgdG8gZW11bGF0ZSBgY29tcG9uZW50RGlkQ2F0Y2hgXG4gICAgbGV0IG1heWJlU2VydmVyQ2F1Z2h0ID0gYXBwU3RhdGUuY2F0Y2ggJiYgYXBwU3RhdGUuY2F0Y2hCb3VuZGFyeVJvdXRlSWQgPT09IGlkID8gYXBwU3RhdGUuY2F0Y2ggOiB1bmRlZmluZWQ7IC8vIFRoaXMgbmVlZHMgdG8gcnVuIGFmdGVyIHdlIGNoZWNrIGZvciB0aGUgZXJyb3IgZnJvbSBhIHByZXZpb3VzIHJlbmRlcixcbiAgICAvLyBvdGhlcndpc2Ugd2Ugd2lsbCBpbmNvcnJlY3RseSByZW5kZXIgdGhpcyBib3VuZGFyeSBmb3IgYSBsb2FkZXIgZXJyb3JcbiAgICAvLyBkZWVwZXIgaW4gdGhlIHRyZWUuXG5cbiAgICBpZiAoYXBwU3RhdGUudHJhY2tDYXRjaEJvdW5kYXJpZXMpIHtcbiAgICAgIGFwcFN0YXRlLmNhdGNoQm91bmRhcnlSb3V0ZUlkID0gaWQ7XG4gICAgfVxuXG4gICAgY29udGV4dCA9IG1heWJlU2VydmVyQ2F1Z2h0ID8ge1xuICAgICAgaWQsXG5cbiAgICAgIGdldCBkYXRhKCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiWW91IGNhbm5vdCBgdXNlTG9hZGVyRGF0YWAgaW4gYSBjYXRjaCBib3VuZGFyeS5cIik7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IDoge1xuICAgICAgaWQsXG4gICAgICBkYXRhXG4gICAgfTtcbiAgICBlbGVtZW50ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVtaXhDYXRjaEJvdW5kYXJ5LCB7XG4gICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICBjb21wb25lbnQ6IENhdGNoQm91bmRhcnksXG4gICAgICBjYXRjaDogbWF5YmVTZXJ2ZXJDYXVnaHRcbiAgICB9LCBlbGVtZW50KTtcbiAgfSAvLyBPbmx5IHdyYXAgaW4gZXJyb3IgYm91bmRhcnkgaWYgdGhlIHJvdXRlIGRlZmluZWQgb25lLCBvdGhlcndpc2UgbGV0IHRoZVxuICAvLyBlcnJvciBidWJibGUgdG8gdGhlIHBhcmVudCBib3VuZGFyeS4gV2UgY291bGQgZGVmYXVsdCB0byB1c2luZyBlcnJvclxuICAvLyBib3VuZGFyaWVzIGFyb3VuZCBldmVyeSByb3V0ZSwgYnV0IG5vdyBpZiB0aGUgYXBwIGRvZXNuJ3Qgd2FudCB1c2Vyc1xuICAvLyBzZWVpbmcgdGhlIGRlZmF1bHQgUmVtaXggRXJyb3JCb3VuZGFyeSBjb21wb25lbnQsIHRoZXkgKm11c3QqIGRlZmluZSBhblxuICAvLyBlcnJvciBib3VuZGFyeSBmb3IgKmV2ZXJ5KiByb3V0ZSBhbmQgdGhhdCB3b3VsZCBiZSBhbm5veWluZy4gTWlnaHQgYXNcbiAgLy8gd2VsbCBtYWtlIGl0IHJlcXVpcmVkIGF0IHRoYXQgcG9pbnQuXG4gIC8vXG4gIC8vIEJ5IGNvbmRpdGlvbmFsbHkgd3JhcHBpbmcgbGlrZSB0aGlzLCB3ZSBhbGxvdyBhcHBzIHRvIGRlZmluZSBhIHRvcCBsZXZlbFxuICAvLyBFcnJvckJvdW5kYXJ5IGNvbXBvbmVudCBhbmQgYmUgZG9uZSB3aXRoIGl0LiBUaGVuLCBpZiB0aGV5IHdhbnQgdG8sIHRoZXlcbiAgLy8gY2FuIGFkZCBtb3JlIHNwZWNpZmljIGJvdW5kYXJpZXMgYnkgZXhwb3J0aW5nIEVycm9yQm91bmRhcnkgY29tcG9uZW50c1xuICAvLyBmb3Igd2hpY2hldmVyIHJvdXRlcyB0aGV5IHBsZWFzZS5cbiAgLy9cbiAgLy8gTk9URTogdGhpcyBraW5kIG9mIGxvZ2ljIHdpbGwgbW92ZSBpbnRvIFJlYWN0IFJvdXRlclxuXG5cbiAgaWYgKEVycm9yQm91bmRhcnkpIHtcbiAgICAvLyBJZiB3ZSB0cmllZCB0byByZW5kZXIgYW5kIGZhaWxlZCwgYW5kIHRoaXMgcm91dGUgdGhyZXcgdGhlIGVycm9yLCBmaW5kIGl0XG4gICAgLy8gYW5kIHBhc3MgaXQgdG8gdGhlIEVycm9yQm91bmRhcnkgdG8gZW11bGF0ZSBgY29tcG9uZW50RGlkQ2F0Y2hgXG4gICAgbGV0IG1heWJlU2VydmVyUmVuZGVyRXJyb3IgPSBhcHBTdGF0ZS5lcnJvciAmJiAoYXBwU3RhdGUucmVuZGVyQm91bmRhcnlSb3V0ZUlkID09PSBpZCB8fCBhcHBTdGF0ZS5sb2FkZXJCb3VuZGFyeVJvdXRlSWQgPT09IGlkKSA/IGRlc2VyaWFsaXplRXJyb3IoYXBwU3RhdGUuZXJyb3IpIDogdW5kZWZpbmVkOyAvLyBUaGlzIG5lZWRzIHRvIHJ1biBhZnRlciB3ZSBjaGVjayBmb3IgdGhlIGVycm9yIGZyb20gYSBwcmV2aW91cyByZW5kZXIsXG4gICAgLy8gb3RoZXJ3aXNlIHdlIHdpbGwgaW5jb3JyZWN0bHkgcmVuZGVyIHRoaXMgYm91bmRhcnkgZm9yIGEgbG9hZGVyIGVycm9yXG4gICAgLy8gZGVlcGVyIGluIHRoZSB0cmVlLlxuXG4gICAgaWYgKGFwcFN0YXRlLnRyYWNrQm91bmRhcmllcykge1xuICAgICAgYXBwU3RhdGUucmVuZGVyQm91bmRhcnlSb3V0ZUlkID0gaWQ7XG4gICAgfVxuXG4gICAgY29udGV4dCA9IG1heWJlU2VydmVyUmVuZGVyRXJyb3IgPyB7XG4gICAgICBpZCxcblxuICAgICAgZ2V0IGRhdGEoKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJZb3UgY2Fubm90IGB1c2VMb2FkZXJEYXRhYCBpbiBhbiBlcnJvciBib3VuZGFyeS5cIik7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IDoge1xuICAgICAgaWQsXG4gICAgICBkYXRhXG4gICAgfTtcbiAgICBlbGVtZW50ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVtaXhFcnJvckJvdW5kYXJ5LCB7XG4gICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICBjb21wb25lbnQ6IEVycm9yQm91bmRhcnksXG4gICAgICBlcnJvcjogbWF5YmVTZXJ2ZXJSZW5kZXJFcnJvclxuICAgIH0sIGVsZW1lbnQpO1xuICB9IC8vIEl0J3MgaW1wb3J0YW50IGZvciB0aGUgcm91dGUgY29udGV4dCB0byBiZSBhYm92ZSB0aGUgZXJyb3IgYm91bmRhcnkgc28gdGhhdFxuICAvLyBhIGNhbGwgdG8gYHVzZUxvYWRlckRhdGFgIGRvZXNuJ3QgYWNjaWRlbnRhbGx5IGdldCB0aGUgcGFyZW50cyByb3V0ZSdzIGRhdGEuXG5cblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVtaXhSb3V0ZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY29udGV4dFxuICB9LCBlbGVtZW50KTtcbn0gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFB1YmxpYyBBUElcblxuLyoqXG4gKiBEZWZpbmVzIHRoZSBwcmVmZXRjaGluZyBiZWhhdmlvciBvZiB0aGUgbGluazpcbiAqXG4gKiAtIFwiaW50ZW50XCI6IEZldGNoZWQgd2hlbiB0aGUgdXNlciBmb2N1c2VzIG9yIGhvdmVycyB0aGUgbGlua1xuICogLSBcInJlbmRlclwiOiBGZXRjaGVkIHdoZW4gdGhlIGxpbmsgaXMgcmVuZGVyZWRcbiAqIC0gXCJub25lXCI6IE5ldmVyIGZldGNoZWRcbiAqL1xuXG5mdW5jdGlvbiB1c2VQcmVmZXRjaEJlaGF2aW9yKHByZWZldGNoLCB0aGVpckVsZW1lbnRQcm9wcykge1xuICBsZXQgW21heWJlUHJlZmV0Y2gsIHNldE1heWJlUHJlZmV0Y2hdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICBsZXQgW3Nob3VsZFByZWZldGNoLCBzZXRTaG91bGRQcmVmZXRjaF0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gIGxldCB7XG4gICAgb25Gb2N1cyxcbiAgICBvbkJsdXIsXG4gICAgb25Nb3VzZUVudGVyLFxuICAgIG9uTW91c2VMZWF2ZSxcbiAgICBvblRvdWNoU3RhcnRcbiAgfSA9IHRoZWlyRWxlbWVudFByb3BzO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChwcmVmZXRjaCA9PT0gXCJyZW5kZXJcIikge1xuICAgICAgc2V0U2hvdWxkUHJlZmV0Y2godHJ1ZSk7XG4gICAgfVxuICB9LCBbcHJlZmV0Y2hdKTtcblxuICBsZXQgc2V0SW50ZW50ID0gKCkgPT4ge1xuICAgIGlmIChwcmVmZXRjaCA9PT0gXCJpbnRlbnRcIikge1xuICAgICAgc2V0TWF5YmVQcmVmZXRjaCh0cnVlKTtcbiAgICB9XG4gIH07XG5cbiAgbGV0IGNhbmNlbEludGVudCA9ICgpID0+IHtcbiAgICBpZiAocHJlZmV0Y2ggPT09IFwiaW50ZW50XCIpIHtcbiAgICAgIHNldE1heWJlUHJlZmV0Y2goZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChtYXliZVByZWZldGNoKSB7XG4gICAgICBsZXQgaWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgc2V0U2hvdWxkUHJlZmV0Y2godHJ1ZSk7XG4gICAgICB9LCAxMDApO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGlkKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbbWF5YmVQcmVmZXRjaF0pO1xuICByZXR1cm4gW3Nob3VsZFByZWZldGNoLCB7XG4gICAgb25Gb2N1czogY29tcG9zZUV2ZW50SGFuZGxlcnMob25Gb2N1cywgc2V0SW50ZW50KSxcbiAgICBvbkJsdXI6IGNvbXBvc2VFdmVudEhhbmRsZXJzKG9uQmx1ciwgY2FuY2VsSW50ZW50KSxcbiAgICBvbk1vdXNlRW50ZXI6IGNvbXBvc2VFdmVudEhhbmRsZXJzKG9uTW91c2VFbnRlciwgc2V0SW50ZW50KSxcbiAgICBvbk1vdXNlTGVhdmU6IGNvbXBvc2VFdmVudEhhbmRsZXJzKG9uTW91c2VMZWF2ZSwgY2FuY2VsSW50ZW50KSxcbiAgICBvblRvdWNoU3RhcnQ6IGNvbXBvc2VFdmVudEhhbmRsZXJzKG9uVG91Y2hTdGFydCwgc2V0SW50ZW50KVxuICB9XTtcbn1cbi8qKlxuICogQSBzcGVjaWFsIGtpbmQgb2YgYDxMaW5rPmAgdGhhdCBrbm93cyB3aGV0aGVyIG9yIG5vdCBpdCBpcyBcImFjdGl2ZVwiLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZW1peC5ydW4vYXBpL3JlbWl4I25hdmxpbmtcbiAqL1xuXG5cbmxldCBOYXZMaW5rID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoKHtcbiAgdG8sXG4gIHByZWZldGNoID0gXCJub25lXCIsXG4gIC4uLnByb3BzXG59LCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgbGV0IGhyZWYgPSB1c2VIcmVmKHRvKTtcbiAgbGV0IFtzaG91bGRQcmVmZXRjaCwgcHJlZmV0Y2hIYW5kbGVyc10gPSB1c2VQcmVmZXRjaEJlaGF2aW9yKHByZWZldGNoLCBwcm9wcyk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTmF2TGluayQxLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiBmb3J3YXJkZWRSZWYsXG4gICAgdG86IHRvXG4gIH0sIHByb3BzLCBwcmVmZXRjaEhhbmRsZXJzKSksIHNob3VsZFByZWZldGNoID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUHJlZmV0Y2hQYWdlTGlua3MsIHtcbiAgICBwYWdlOiBocmVmXG4gIH0pIDogbnVsbCk7XG59KTtcbi8qKlxuICogVGhpcyBjb21wb25lbnQgcmVuZGVycyBhbiBhbmNob3IgdGFnIGFuZCBpcyB0aGUgcHJpbWFyeSB3YXkgdGhlIHVzZXIgd2lsbFxuICogbmF2aWdhdGUgYXJvdW5kIHlvdXIgd2Vic2l0ZS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVtaXgucnVuL2FwaS9yZW1peCNsaW5rXG4gKi9cblxubGV0IExpbmsgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZigoe1xuICB0byxcbiAgcHJlZmV0Y2ggPSBcIm5vbmVcIixcbiAgLi4ucHJvcHNcbn0sIGZvcndhcmRlZFJlZikgPT4ge1xuICBsZXQgaHJlZiA9IHVzZUhyZWYodG8pO1xuICBsZXQgW3Nob3VsZFByZWZldGNoLCBwcmVmZXRjaEhhbmRsZXJzXSA9IHVzZVByZWZldGNoQmVoYXZpb3IocHJlZmV0Y2gsIHByb3BzKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChMaW5rJDEsIF9leHRlbmRzKHtcbiAgICByZWY6IGZvcndhcmRlZFJlZixcbiAgICB0bzogdG9cbiAgfSwgcHJvcHMsIHByZWZldGNoSGFuZGxlcnMpKSwgc2hvdWxkUHJlZmV0Y2ggPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChQcmVmZXRjaFBhZ2VMaW5rcywge1xuICAgIHBhZ2U6IGhyZWZcbiAgfSkgOiBudWxsKTtcbn0pO1xuZnVuY3Rpb24gY29tcG9zZUV2ZW50SGFuZGxlcnModGhlaXJIYW5kbGVyLCBvdXJIYW5kbGVyKSB7XG4gIHJldHVybiBldmVudCA9PiB7XG4gICAgdGhlaXJIYW5kbGVyICYmIHRoZWlySGFuZGxlcihldmVudCk7XG5cbiAgICBpZiAoIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIG91ckhhbmRsZXIoZXZlbnQpO1xuICAgIH1cbiAgfTtcbn1cbi8qKlxuICogUmVuZGVycyB0aGUgYDxsaW5rPmAgdGFncyBmb3IgdGhlIGN1cnJlbnQgcm91dGVzLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZW1peC5ydW4vYXBpL3JlbWl4I21ldGEtbGlua3Mtc2NyaXB0c1xuICovXG5cbmZ1bmN0aW9uIExpbmtzKCkge1xuICBsZXQge1xuICAgIG1hdGNoZXMsXG4gICAgcm91dGVNb2R1bGVzLFxuICAgIG1hbmlmZXN0XG4gIH0gPSB1c2VSZW1peEVudHJ5Q29udGV4dCgpO1xuICBsZXQgbGlua3MgPSBSZWFjdC51c2VNZW1vKCgpID0+IGdldExpbmtzRm9yTWF0Y2hlcyhtYXRjaGVzLCByb3V0ZU1vZHVsZXMsIG1hbmlmZXN0KSwgW21hdGNoZXMsIHJvdXRlTW9kdWxlcywgbWFuaWZlc3RdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBsaW5rcy5tYXAobGluayA9PiBpc1BhZ2VMaW5rRGVzY3JpcHRvcihsaW5rKSA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFByZWZldGNoUGFnZUxpbmtzLCBfZXh0ZW5kcyh7XG4gICAga2V5OiBsaW5rLnBhZ2VcbiAgfSwgbGluaykpIDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIsIF9leHRlbmRzKHtcbiAgICBrZXk6IGxpbmsucmVsICsgbGluay5ocmVmXG4gIH0sIGxpbmspKSkpO1xufVxuLyoqXG4gKiBUaGlzIGNvbXBvbmVudCByZW5kZXJzIGFsbCBvZiB0aGUgYDxsaW5rIHJlbD1cInByZWZldGNoXCI+YCBhbmRcbiAqIGA8bGluayByZWw9XCJtb2R1bGVwcmVsb2FkXCIvPmAgdGFncyBmb3IgYWxsIHRoZSBhc3NldHMgKGRhdGEsIG1vZHVsZXMsIGNzcykgb2ZcbiAqIGEgZ2l2ZW4gcGFnZS5cbiAqXG4gKiBAcGFyYW0gcHJvcHNcbiAqIEBwYXJhbSBwcm9wcy5wYWdlXG4gKiBAc2VlIGh0dHBzOi8vcmVtaXgucnVuL2FwaS9yZW1peCNwcmVmZXRjaHBhZ2VsaW5rcy1cbiAqL1xuXG5mdW5jdGlvbiBQcmVmZXRjaFBhZ2VMaW5rcyh7XG4gIHBhZ2UsXG4gIC4uLmRhdGFMaW5rUHJvcHNcbn0pIHtcbiAgbGV0IHtcbiAgICBjbGllbnRSb3V0ZXNcbiAgfSA9IHVzZVJlbWl4RW50cnlDb250ZXh0KCk7XG4gIGxldCBtYXRjaGVzID0gUmVhY3QudXNlTWVtbygoKSA9PiBtYXRjaENsaWVudFJvdXRlcyhjbGllbnRSb3V0ZXMsIHBhZ2UpLCBbY2xpZW50Um91dGVzLCBwYWdlXSk7XG5cbiAgaWYgKCFtYXRjaGVzKSB7XG4gICAgY29uc29sZS53YXJuKGBUcmllZCB0byBwcmVmZXRjaCAke3BhZ2V9IGJ1dCBubyByb3V0ZXMgbWF0Y2hlZC5gKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChQcmVmZXRjaFBhZ2VMaW5rc0ltcGwsIF9leHRlbmRzKHtcbiAgICBwYWdlOiBwYWdlLFxuICAgIG1hdGNoZXM6IG1hdGNoZXNcbiAgfSwgZGF0YUxpbmtQcm9wcykpO1xufVxuXG5mdW5jdGlvbiB1c2VQcmVmZXRjaGVkU3R5bGVzaGVldHMobWF0Y2hlcykge1xuICBsZXQge1xuICAgIHJvdXRlTW9kdWxlc1xuICB9ID0gdXNlUmVtaXhFbnRyeUNvbnRleHQoKTtcbiAgbGV0IFtzdHlsZUxpbmtzLCBzZXRTdHlsZUxpbmtzXSA9IFJlYWN0LnVzZVN0YXRlKFtdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBsZXQgaW50ZXJydXB0ZWQgPSBmYWxzZTtcbiAgICBnZXRTdHlsZXNoZWV0UHJlZmV0Y2hMaW5rcyhtYXRjaGVzLCByb3V0ZU1vZHVsZXMpLnRoZW4obGlua3MgPT4ge1xuICAgICAgaWYgKCFpbnRlcnJ1cHRlZCkgc2V0U3R5bGVMaW5rcyhsaW5rcyk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGludGVycnVwdGVkID0gdHJ1ZTtcbiAgICB9O1xuICB9LCBbbWF0Y2hlcywgcm91dGVNb2R1bGVzXSk7XG4gIHJldHVybiBzdHlsZUxpbmtzO1xufVxuXG5mdW5jdGlvbiBQcmVmZXRjaFBhZ2VMaW5rc0ltcGwoe1xuICBwYWdlLFxuICBtYXRjaGVzOiBuZXh0TWF0Y2hlcyxcbiAgLi4ubGlua1Byb3BzXG59KSB7XG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCB7XG4gICAgbWF0Y2hlcyxcbiAgICBtYW5pZmVzdFxuICB9ID0gdXNlUmVtaXhFbnRyeUNvbnRleHQoKTtcbiAgbGV0IG5ld01hdGNoZXNGb3JEYXRhID0gUmVhY3QudXNlTWVtbygoKSA9PiBnZXROZXdNYXRjaGVzRm9yTGlua3MocGFnZSwgbmV4dE1hdGNoZXMsIG1hdGNoZXMsIGxvY2F0aW9uLCBcImRhdGFcIiksIFtwYWdlLCBuZXh0TWF0Y2hlcywgbWF0Y2hlcywgbG9jYXRpb25dKTtcbiAgbGV0IG5ld01hdGNoZXNGb3JBc3NldHMgPSBSZWFjdC51c2VNZW1vKCgpID0+IGdldE5ld01hdGNoZXNGb3JMaW5rcyhwYWdlLCBuZXh0TWF0Y2hlcywgbWF0Y2hlcywgbG9jYXRpb24sIFwiYXNzZXRzXCIpLCBbcGFnZSwgbmV4dE1hdGNoZXMsIG1hdGNoZXMsIGxvY2F0aW9uXSk7XG4gIGxldCBkYXRhSHJlZnMgPSBSZWFjdC51c2VNZW1vKCgpID0+IGdldERhdGFMaW5rSHJlZnMocGFnZSwgbmV3TWF0Y2hlc0ZvckRhdGEsIG1hbmlmZXN0KSwgW25ld01hdGNoZXNGb3JEYXRhLCBwYWdlLCBtYW5pZmVzdF0pO1xuICBsZXQgbW9kdWxlSHJlZnMgPSBSZWFjdC51c2VNZW1vKCgpID0+IGdldE1vZHVsZUxpbmtIcmVmcyhuZXdNYXRjaGVzRm9yQXNzZXRzLCBtYW5pZmVzdCksIFtuZXdNYXRjaGVzRm9yQXNzZXRzLCBtYW5pZmVzdF0pOyAvLyBuZWVkcyB0byBiZSBhIGhvb2sgd2l0aCBhc3luYyBiZWhhdmlvciBiZWNhdXNlIHdlIG5lZWQgdGhlIG1vZHVsZXMsIG5vdFxuICAvLyBqdXN0IHRoZSBtYW5pZmVzdCBsaWtlIHRoZSBvdGhlciBsaW5rcyBpbiBoZXJlLlxuXG4gIGxldCBzdHlsZUxpbmtzID0gdXNlUHJlZmV0Y2hlZFN0eWxlc2hlZXRzKG5ld01hdGNoZXNGb3JBc3NldHMpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIGRhdGFIcmVmcy5tYXAoaHJlZiA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImxpbmtcIiwgX2V4dGVuZHMoe1xuICAgIGtleTogaHJlZixcbiAgICByZWw6IFwicHJlZmV0Y2hcIixcbiAgICBhczogXCJmZXRjaFwiLFxuICAgIGhyZWY6IGhyZWZcbiAgfSwgbGlua1Byb3BzKSkpLCBtb2R1bGVIcmVmcy5tYXAoaHJlZiA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImxpbmtcIiwgX2V4dGVuZHMoe1xuICAgIGtleTogaHJlZixcbiAgICByZWw6IFwibW9kdWxlcHJlbG9hZFwiLFxuICAgIGhyZWY6IGhyZWZcbiAgfSwgbGlua1Byb3BzKSkpLCBzdHlsZUxpbmtzLm1hcChsaW5rID0+XG4gIC8qI19fUFVSRV9fKi9cbiAgLy8gdGhlc2UgZG9uJ3Qgc3ByZWFkIGBsaW5rUHJvcHNgIGJlY2F1c2UgdGhleSBhcmUgZnVsbCBsaW5rIGRlc2NyaXB0b3JzXG4gIC8vIGFscmVhZHkgd2l0aCB0aGVpciBvd24gcHJvcHNcbiAgUmVhY3QuY3JlYXRlRWxlbWVudChcImxpbmtcIiwgX2V4dGVuZHMoe1xuICAgIGtleTogbGluay5ocmVmXG4gIH0sIGxpbmspKSkpO1xufVxuLyoqXG4gKiBSZW5kZXJzIHRoZSBgPHRpdGxlPmAgYW5kIGA8bWV0YT5gIHRhZ3MgZm9yIHRoZSBjdXJyZW50IHJvdXRlcy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVtaXgucnVuL2FwaS9yZW1peCNtZXRhLWxpbmtzLXNjcmlwdHNcbiAqL1xuXG5cbmZ1bmN0aW9uIE1ldGEoKSB7XG4gIGxldCB7XG4gICAgbWF0Y2hlcyxcbiAgICByb3V0ZURhdGEsXG4gICAgcm91dGVNb2R1bGVzXG4gIH0gPSB1c2VSZW1peEVudHJ5Q29udGV4dCgpO1xuICBsZXQgbG9jYXRpb24gPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgbWV0YSA9IHt9O1xuICBsZXQgcGFyZW50c0RhdGEgPSB7fTtcblxuICBmb3IgKGxldCBtYXRjaCBvZiBtYXRjaGVzKSB7XG4gICAgbGV0IHJvdXRlSWQgPSBtYXRjaC5yb3V0ZS5pZDtcbiAgICBsZXQgZGF0YSA9IHJvdXRlRGF0YVtyb3V0ZUlkXTtcbiAgICBsZXQgcGFyYW1zID0gbWF0Y2gucGFyYW1zO1xuICAgIGxldCByb3V0ZU1vZHVsZSA9IHJvdXRlTW9kdWxlc1tyb3V0ZUlkXTtcblxuICAgIGlmIChyb3V0ZU1vZHVsZS5tZXRhKSB7XG4gICAgICBsZXQgcm91dGVNZXRhID0gdHlwZW9mIHJvdXRlTW9kdWxlLm1ldGEgPT09IFwiZnVuY3Rpb25cIiA/IHJvdXRlTW9kdWxlLm1ldGEoe1xuICAgICAgICBkYXRhLFxuICAgICAgICBwYXJlbnRzRGF0YSxcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICBsb2NhdGlvblxuICAgICAgfSkgOiByb3V0ZU1vZHVsZS5tZXRhO1xuICAgICAgT2JqZWN0LmFzc2lnbihtZXRhLCByb3V0ZU1ldGEpO1xuICAgIH1cblxuICAgIHBhcmVudHNEYXRhW3JvdXRlSWRdID0gZGF0YTtcbiAgfVxuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgT2JqZWN0LmVudHJpZXMobWV0YSkubWFwKChbbmFtZSwgdmFsdWVdKSA9PiB7XG4gICAgLy8gT3BlbiBHcmFwaCB0YWdzIHVzZSB0aGUgYHByb3BlcnR5YCBhdHRyaWJ1dGUsIHdoaWxlIG90aGVyIG1ldGEgdGFnc1xuICAgIC8vIHVzZSBgbmFtZWAuIFNlZSBodHRwczovL29ncC5tZS9cbiAgICBsZXQgaXNPcGVuR3JhcGhUYWcgPSBuYW1lLnN0YXJ0c1dpdGgoXCJvZzpcIik7XG4gICAgcmV0dXJuIG5hbWUgPT09IFwidGl0bGVcIiA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwidGl0bGVcIiwge1xuICAgICAga2V5OiBcInRpdGxlXCJcbiAgICB9LCB2YWx1ZSkgOiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLm1hcChjb250ZW50ID0+IGlzT3BlbkdyYXBoVGFnID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJtZXRhXCIsIHtcbiAgICAgIGtleTogbmFtZSArIGNvbnRlbnQsXG4gICAgICBwcm9wZXJ0eTogbmFtZSxcbiAgICAgIGNvbnRlbnQ6IGNvbnRlbnRcbiAgICB9KSA6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwibWV0YVwiLCB7XG4gICAgICBrZXk6IG5hbWUgKyBjb250ZW50LFxuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGNvbnRlbnQ6IGNvbnRlbnRcbiAgICB9KSkgOiBpc09wZW5HcmFwaFRhZyA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwibWV0YVwiLCB7XG4gICAgICBrZXk6IG5hbWUsXG4gICAgICBwcm9wZXJ0eTogbmFtZSxcbiAgICAgIGNvbnRlbnQ6IHZhbHVlXG4gICAgfSkgOiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcIm1ldGFcIiwge1xuICAgICAga2V5OiBuYW1lLFxuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGNvbnRlbnQ6IHZhbHVlXG4gICAgfSk7XG4gIH0pKTtcbn1cbi8qKlxuICogVHJhY2tzIHdoZXRoZXIgUmVtaXggaGFzIGZpbmlzaGVkIGh5ZHJhdGluZyBvciBub3QsIHNvIHNjcmlwdHMgY2FuIGJlIHNraXBwZWRcbiAqIGR1cmluZyBjbGllbnQtc2lkZSB1cGRhdGVzLlxuICovXG5cbmxldCBpc0h5ZHJhdGVkID0gZmFsc2U7XG5cbi8qKlxuICogUmVuZGVycyB0aGUgYDxzY3JpcHQ+YCB0YWdzIG5lZWRlZCBmb3IgdGhlIGluaXRpYWwgcmVuZGVyLiBCdW5kbGVzIGZvclxuICogYWRkaXRpb25hbCByb3V0ZXMgYXJlIGxvYWRlZCBsYXRlciBhcyBuZWVkZWQuXG4gKlxuICogQHBhcmFtIHByb3BzIEFkZGl0aW9uYWwgcHJvcGVydGllcyB0byBhZGQgdG8gZWFjaCBzY3JpcHQgdGFnIHRoYXQgaXMgcmVuZGVyZWQuXG4gKiBJbiBhZGRpdGlvbiB0byBzY3JpcHRzLCBcXDxsaW5rIHJlbD1cIm1vZHVsZXByZWxvYWRcIj4gdGFncyByZWNlaXZlIHRoZSBjcm9zc09yaWdpblxuICogcHJvcGVydHkgaWYgcHJvdmlkZWQuXG4gKlxuICogQHNlZSBodHRwczovL3JlbWl4LnJ1bi9hcGkvcmVtaXgjbWV0YS1saW5rcy1zY3JpcHRzXG4gKi9cbmZ1bmN0aW9uIFNjcmlwdHMocHJvcHMpIHtcbiAgbGV0IHtcbiAgICBtYW5pZmVzdCxcbiAgICBtYXRjaGVzLFxuICAgIHBlbmRpbmdMb2NhdGlvbixcbiAgICBjbGllbnRSb3V0ZXMsXG4gICAgc2VydmVySGFuZG9mZlN0cmluZ1xuICB9ID0gdXNlUmVtaXhFbnRyeUNvbnRleHQoKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpc0h5ZHJhdGVkID0gdHJ1ZTtcbiAgfSwgW10pO1xuICBsZXQgaW5pdGlhbFNjcmlwdHMgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBsZXQgY29udGV4dFNjcmlwdCA9IHNlcnZlckhhbmRvZmZTdHJpbmcgPyBgd2luZG93Ll9fcmVtaXhDb250ZXh0ID0gJHtzZXJ2ZXJIYW5kb2ZmU3RyaW5nfTtgIDogXCJcIjtcbiAgICBsZXQgcm91dGVNb2R1bGVzU2NyaXB0ID0gYCR7bWF0Y2hlcy5tYXAoKG1hdGNoLCBpbmRleCkgPT4gYGltcG9ydCAqIGFzIHJvdXRlJHtpbmRleH0gZnJvbSAke0pTT04uc3RyaW5naWZ5KG1hbmlmZXN0LnJvdXRlc1ttYXRjaC5yb3V0ZS5pZF0ubW9kdWxlKX07YCkuam9pbihcIlxcblwiKX1cbndpbmRvdy5fX3JlbWl4Um91dGVNb2R1bGVzID0geyR7bWF0Y2hlcy5tYXAoKG1hdGNoLCBpbmRleCkgPT4gYCR7SlNPTi5zdHJpbmdpZnkobWF0Y2gucm91dGUuaWQpfTpyb3V0ZSR7aW5kZXh9YCkuam9pbihcIixcIil9fTtgO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIiwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICBzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmc6IHRydWUsXG4gICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDogY3JlYXRlSHRtbChjb250ZXh0U2NyaXB0KVxuICAgIH0pKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIiwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICBzcmM6IG1hbmlmZXN0LnVybFxuICAgIH0pKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIiwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDogY3JlYXRlSHRtbChyb3V0ZU1vZHVsZXNTY3JpcHQpLFxuICAgICAgdHlwZTogXCJtb2R1bGVcIlxuICAgIH0pKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIiwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICBzcmM6IG1hbmlmZXN0LmVudHJ5Lm1vZHVsZSxcbiAgICAgIHR5cGU6IFwibW9kdWxlXCJcbiAgICB9KSkpOyAvLyBkaXNhYmxlZCBkZXBzIGFycmF5IGJlY2F1c2Ugd2UgYXJlIHB1cnBvc2VmdWxseSBvbmx5IHJlbmRlcmluZyB0aGlzIG9uY2VcbiAgICAvLyBmb3IgaHlkcmF0aW9uLCBhZnRlciB0aGF0IHdlIHdhbnQgdG8ganVzdCBjb250aW51ZSByZW5kZXJpbmcgdGhlIGluaXRpYWxcbiAgICAvLyBzY3JpcHRzIGFzIHRoZXkgd2VyZSB3aGVuIHRoZSBwYWdlIGZpcnN0IGxvYWRlZFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICB9LCBbXSk7IC8vIGF2b2lkIHdhdGVyZmFsbCB3aGVuIGltcG9ydGluZyB0aGUgbmV4dCByb3V0ZSBtb2R1bGVcblxuICBsZXQgbmV4dE1hdGNoZXMgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBpZiAocGVuZGluZ0xvY2F0aW9uKSB7XG4gICAgICAvLyBGSVhNRTogY2FuIHByb2JhYmx5IHVzZSB0cmFuc2l0aW9uTWFuYWdlciBgbmV4dE1hdGNoZXNgXG4gICAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoQ2xpZW50Um91dGVzKGNsaWVudFJvdXRlcywgcGVuZGluZ0xvY2F0aW9uKTtcbiAgICAgIGludmFyaWFudChtYXRjaGVzLCBgTm8gcm91dGVzIG1hdGNoIHBhdGggXCIke3BlbmRpbmdMb2NhdGlvbi5wYXRobmFtZX1cImApO1xuICAgICAgcmV0dXJuIG1hdGNoZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtdO1xuICB9LCBbcGVuZGluZ0xvY2F0aW9uLCBjbGllbnRSb3V0ZXNdKTtcbiAgbGV0IHJvdXRlUHJlbG9hZHMgPSBtYXRjaGVzLmNvbmNhdChuZXh0TWF0Y2hlcykubWFwKG1hdGNoID0+IHtcbiAgICBsZXQgcm91dGUgPSBtYW5pZmVzdC5yb3V0ZXNbbWF0Y2gucm91dGUuaWRdO1xuICAgIHJldHVybiAocm91dGUuaW1wb3J0cyB8fCBbXSkuY29uY2F0KFtyb3V0ZS5tb2R1bGVdKTtcbiAgfSkuZmxhdCgxKTtcbiAgbGV0IHByZWxvYWRzID0gbWFuaWZlc3QuZW50cnkuaW1wb3J0cy5jb25jYXQocm91dGVQcmVsb2Fkcyk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgZGVkdXBlKHByZWxvYWRzKS5tYXAocGF0aCA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImxpbmtcIiwge1xuICAgIGtleTogcGF0aCxcbiAgICByZWw6IFwibW9kdWxlcHJlbG9hZFwiLFxuICAgIGhyZWY6IHBhdGgsXG4gICAgY3Jvc3NPcmlnaW46IHByb3BzLmNyb3NzT3JpZ2luXG4gIH0pKSwgaXNIeWRyYXRlZCA/IG51bGwgOiBpbml0aWFsU2NyaXB0cyk7XG59XG5cbmZ1bmN0aW9uIGRlZHVwZShhcnJheSkge1xuICByZXR1cm4gWy4uLm5ldyBTZXQoYXJyYXkpXTtcbn1cblxuLyoqXG4gKiBBIFJlbWl4LWF3YXJlIGA8Zm9ybT5gLiBJdCBiZWhhdmVzIGxpa2UgYSBub3JtYWwgZm9ybSBleGNlcHQgdGhhdCB0aGVcbiAqIGludGVyYWN0aW9uIHdpdGggdGhlIHNlcnZlciBpcyB3aXRoIGBmZXRjaGAgaW5zdGVhZCBvZiBuZXcgZG9jdW1lbnRcbiAqIHJlcXVlc3RzLCBhbGxvd2luZyBjb21wb25lbnRzIHRvIGFkZCBuaWNlciBVWCB0byB0aGUgcGFnZSBhcyB0aGUgZm9ybSBpc1xuICogc3VibWl0dGVkIGFuZCByZXR1cm5zIHdpdGggZGF0YS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVtaXgucnVuL2FwaS9yZW1peCNmb3JtXG4gKi9cbmxldCBGb3JtID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IHtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZvcm1JbXBsLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICByZWY6IHJlZlxuICB9KSk7XG59KTtcbmxldCBGb3JtSW1wbCA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKCh7XG4gIHJlbG9hZERvY3VtZW50ID0gZmFsc2UsXG4gIHJlcGxhY2UgPSBmYWxzZSxcbiAgbWV0aG9kID0gXCJnZXRcIixcbiAgYWN0aW9uID0gXCIuXCIsXG4gIGVuY1R5cGUgPSBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLFxuICBmZXRjaEtleSxcbiAgb25TdWJtaXQsXG4gIC4uLnByb3BzXG59LCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgbGV0IHN1Ym1pdCA9IHVzZVN1Ym1pdEltcGwoZmV0Y2hLZXkpO1xuICBsZXQgZm9ybU1ldGhvZCA9IG1ldGhvZC50b0xvd2VyQ2FzZSgpID09PSBcImdldFwiID8gXCJnZXRcIiA6IFwicG9zdFwiO1xuICBsZXQgZm9ybUFjdGlvbiA9IHVzZUZvcm1BY3Rpb24oYWN0aW9uLCBmb3JtTWV0aG9kKTtcbiAgbGV0IGZvcm1SZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgbGV0IHJlZiA9IHVzZUNvbXBvc2VkUmVmcyhmb3J3YXJkZWRSZWYsIGZvcm1SZWYpOyAvLyBXaGVuIGNhbGxpbmcgYHN1Ym1pdGAgb24gdGhlIGZvcm0gZWxlbWVudCBpdHNlbGYsIHdlIGRvbid0IGdldCBkYXRhIGZyb21cbiAgLy8gdGhlIGJ1dHRvbiB0aGF0IHN1Ym1pdHRlZCB0aGUgZXZlbnQuIEZvciBleGFtcGxlOlxuICAvL1xuICAvLyAgIDxGb3JtPlxuICAvLyAgICAgPGJ1dHRvbiBuYW1lPVwic29tZXRoaW5nXCIgdmFsdWU9XCJ3aGF0ZXZlclwiPlN1Ym1pdDwvYnV0dG9uPlxuICAvLyAgIDwvRm9ybT5cbiAgLy9cbiAgLy8gZm9ybURhdGEuZ2V0KFwic29tZXRoaW5nXCIpIHNob3VsZCBiZSBcIndoYXRldmVyXCIsIGJ1dCB3ZSBkb24ndCBnZXQgdGhhdFxuICAvLyB1bmxlc3Mgd2UgY2FsbCBzdWJtaXQgb24gdGhlIGNsaWNrZWQgYnV0dG9uIGl0c2VsZi5cbiAgLy9cbiAgLy8gVG8gZmlndXJlIG91dCB3aGljaCBidXR0b24gdHJpZ2dlcmVkIHRoZSBzdWJtaXQsIHdlJ2xsIGF0dGFjaCBhIGNsaWNrXG4gIC8vIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBmb3JtLiBUaGUgY2xpY2sgZXZlbnQgaXMgYWx3YXlzIHRyaWdnZXJlZCBiZWZvcmVcbiAgLy8gdGhlIHN1Ym1pdCBldmVudCAoZXZlbiB3aGVuIHN1Ym1pdHRpbmcgdmlhIGtleWJvYXJkIHdoZW4gZm9jdXNlZCBvblxuICAvLyBhbm90aGVyIGZvcm0gZmllbGQsIHllZWVlZXQpIHNvIHdlIHNob3VsZCBoYXZlIGFjY2VzcyB0byB0aGF0IGJ1dHRvbidzXG4gIC8vIGRhdGEgZm9yIHVzZSBpbiB0aGUgc3VibWl0IGhhbmRsZXIuXG5cbiAgbGV0IGNsaWNrZWRCdXR0b25SZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBsZXQgZm9ybSA9IGZvcm1SZWYuY3VycmVudDtcbiAgICBpZiAoIWZvcm0pIHJldHVybjtcblxuICAgIGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgICBpZiAoIShldmVudC50YXJnZXQgaW5zdGFuY2VvZiBFbGVtZW50KSkgcmV0dXJuO1xuICAgICAgbGV0IHN1Ym1pdEJ1dHRvbiA9IGV2ZW50LnRhcmdldC5jbG9zZXN0KFwiYnV0dG9uLGlucHV0W3R5cGU9c3VibWl0XVwiKTtcblxuICAgICAgaWYgKHN1Ym1pdEJ1dHRvbiAmJiBzdWJtaXRCdXR0b24uZm9ybSA9PT0gZm9ybSAmJiBzdWJtaXRCdXR0b24udHlwZSA9PT0gXCJzdWJtaXRcIikge1xuICAgICAgICBjbGlja2VkQnV0dG9uUmVmLmN1cnJlbnQgPSBzdWJtaXRCdXR0b247XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBoYW5kbGVDbGljayk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlQ2xpY2spO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZm9ybVwiLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiByZWYsXG4gICAgbWV0aG9kOiBmb3JtTWV0aG9kLFxuICAgIGFjdGlvbjogZm9ybUFjdGlvbixcbiAgICBlbmNUeXBlOiBlbmNUeXBlLFxuICAgIG9uU3VibWl0OiByZWxvYWREb2N1bWVudCA/IHVuZGVmaW5lZCA6IGV2ZW50ID0+IHtcbiAgICAgIG9uU3VibWl0ICYmIG9uU3VibWl0KGV2ZW50KTtcbiAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgc3VibWl0KGNsaWNrZWRCdXR0b25SZWYuY3VycmVudCB8fCBldmVudC5jdXJyZW50VGFyZ2V0LCB7XG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgcmVwbGFjZVxuICAgICAgfSk7XG4gICAgICBjbGlja2VkQnV0dG9uUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfSwgcHJvcHMpKTtcbn0pO1xuXG5mdW5jdGlvbiBpc0FjdGlvblJlcXVlc3RNZXRob2QobWV0aG9kKSB7XG4gIG1ldGhvZCA9IG1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gbWV0aG9kID09PSBcInBvc3RcIiB8fCBtZXRob2QgPT09IFwicHV0XCIgfHwgbWV0aG9kID09PSBcInBhdGNoXCIgfHwgbWV0aG9kID09PSBcImRlbGV0ZVwiO1xufVxuLyoqXG4gKiBSZXNvbHZlcyBhIGA8Zm9ybSBhY3Rpb24+YCBwYXRoIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHJvdXRlLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZW1peC5ydW4vYXBpL3JlbWl4I3VzZWZvcm1hY3Rpb25cbiAqL1xuXG5cbmZ1bmN0aW9uIHVzZUZvcm1BY3Rpb24oYWN0aW9uID0gXCIuXCIsIG1ldGhvZCA9IFwiZ2V0XCIpIHtcbiAgbGV0IHtcbiAgICBpZFxuICB9ID0gdXNlUmVtaXhSb3V0ZUNvbnRleHQoKTtcbiAgbGV0IHBhdGggPSB1c2VSZXNvbHZlZFBhdGgoYWN0aW9uKTtcbiAgbGV0IHNlYXJjaCA9IHBhdGguc2VhcmNoO1xuICBsZXQgaXNJbmRleFJvdXRlID0gaWQuZW5kc1dpdGgoXCIvaW5kZXhcIik7XG5cbiAgaWYgKGFjdGlvbiA9PT0gXCIuXCIgJiYgaXNJbmRleFJvdXRlICYmIGlzQWN0aW9uUmVxdWVzdE1ldGhvZChtZXRob2QpKSB7XG4gICAgc2VhcmNoID0gc2VhcmNoID8gc2VhcmNoLnJlcGxhY2UoL15cXD8vLCBcIj9pbmRleCZcIikgOiBcIj9pbmRleFwiO1xuICB9XG5cbiAgcmV0dXJuIHBhdGgucGF0aG5hbWUgKyBzZWFyY2g7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgbWF5IGJlIHVzZWQgdG8gcHJvZ3JhbW1hdGljYWxseSBzdWJtaXQgYSBmb3JtIChvclxuICogc29tZSBhcmJpdHJhcnkgZGF0YSkgdG8gdGhlIHNlcnZlci5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVtaXgucnVuL2FwaS9yZW1peCN1c2VzdWJtaXRcbiAqL1xuZnVuY3Rpb24gdXNlU3VibWl0KCkge1xuICByZXR1cm4gdXNlU3VibWl0SW1wbCgpO1xufVxuZnVuY3Rpb24gdXNlU3VibWl0SW1wbChrZXkpIHtcbiAgbGV0IG5hdmlnYXRlID0gdXNlTmF2aWdhdGUoKTtcbiAgbGV0IGRlZmF1bHRBY3Rpb24gPSB1c2VGb3JtQWN0aW9uKCk7XG4gIGxldCB7XG4gICAgdHJhbnNpdGlvbk1hbmFnZXJcbiAgfSA9IHVzZVJlbWl4RW50cnlDb250ZXh0KCk7XG4gIHJldHVybiBSZWFjdC51c2VDYWxsYmFjaygodGFyZ2V0LCBvcHRpb25zID0ge30pID0+IHtcbiAgICBsZXQgbWV0aG9kO1xuICAgIGxldCBhY3Rpb247XG4gICAgbGV0IGVuY1R5cGU7XG4gICAgbGV0IGZvcm1EYXRhO1xuXG4gICAgaWYgKGlzRm9ybUVsZW1lbnQodGFyZ2V0KSkge1xuICAgICAgbGV0IHN1Ym1pc3Npb25UcmlnZ2VyID0gb3B0aW9ucy5zdWJtaXNzaW9uVHJpZ2dlcjtcbiAgICAgIG1ldGhvZCA9IG9wdGlvbnMubWV0aG9kIHx8IHRhcmdldC5tZXRob2Q7XG4gICAgICBhY3Rpb24gPSBvcHRpb25zLmFjdGlvbiB8fCB0YXJnZXQuYWN0aW9uO1xuICAgICAgZW5jVHlwZSA9IG9wdGlvbnMuZW5jVHlwZSB8fCB0YXJnZXQuZW5jdHlwZTtcbiAgICAgIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKHRhcmdldCk7XG5cbiAgICAgIGlmIChzdWJtaXNzaW9uVHJpZ2dlciAmJiBzdWJtaXNzaW9uVHJpZ2dlci5uYW1lKSB7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZChzdWJtaXNzaW9uVHJpZ2dlci5uYW1lLCBzdWJtaXNzaW9uVHJpZ2dlci52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0J1dHRvbkVsZW1lbnQodGFyZ2V0KSB8fCBpc0lucHV0RWxlbWVudCh0YXJnZXQpICYmICh0YXJnZXQudHlwZSA9PT0gXCJzdWJtaXRcIiB8fCB0YXJnZXQudHlwZSA9PT0gXCJpbWFnZVwiKSkge1xuICAgICAgbGV0IGZvcm0gPSB0YXJnZXQuZm9ybTtcblxuICAgICAgaWYgKGZvcm0gPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBzdWJtaXQgYSA8YnV0dG9uPiB3aXRob3V0IGEgPGZvcm0+YCk7XG4gICAgICB9IC8vIDxidXR0b24+LzxpbnB1dCB0eXBlPVwic3VibWl0XCI+IG1heSBvdmVycmlkZSBhdHRyaWJ1dGVzIG9mIDxmb3JtPlxuXG5cbiAgICAgIG1ldGhvZCA9IG9wdGlvbnMubWV0aG9kIHx8IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJmb3JtbWV0aG9kXCIpIHx8IGZvcm0ubWV0aG9kO1xuICAgICAgYWN0aW9uID0gb3B0aW9ucy5hY3Rpb24gfHwgdGFyZ2V0LmdldEF0dHJpYnV0ZShcImZvcm1hY3Rpb25cIikgfHwgZm9ybS5hY3Rpb247XG4gICAgICBlbmNUeXBlID0gb3B0aW9ucy5lbmNUeXBlIHx8IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJmb3JtZW5jdHlwZVwiKSB8fCBmb3JtLmVuY3R5cGU7XG4gICAgICBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YShmb3JtKTsgLy8gSW5jbHVkZSBuYW1lICsgdmFsdWUgZnJvbSBhIDxidXR0b24+XG5cbiAgICAgIGlmICh0YXJnZXQubmFtZSkge1xuICAgICAgICBmb3JtRGF0YS5zZXQodGFyZ2V0Lm5hbWUsIHRhcmdldC52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc0h0bWxFbGVtZW50KHRhcmdldCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3Qgc3VibWl0IGVsZW1lbnQgdGhhdCBpcyBub3QgPGZvcm0+LCA8YnV0dG9uPiwgb3IgYCArIGA8aW5wdXQgdHlwZT1cInN1Ym1pdHxpbWFnZVwiPmApO1xuICAgICAgfVxuXG4gICAgICBtZXRob2QgPSBvcHRpb25zLm1ldGhvZCB8fCBcImdldFwiO1xuICAgICAgYWN0aW9uID0gb3B0aW9ucy5hY3Rpb24gfHwgZGVmYXVsdEFjdGlvbjtcbiAgICAgIGVuY1R5cGUgPSBvcHRpb25zLmVuY1R5cGUgfHwgXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIjtcblxuICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG4gICAgICAgIGZvcm1EYXRhID0gdGFyZ2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcblxuICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zKSB7XG4gICAgICAgICAgZm9yIChsZXQgW25hbWUsIHZhbHVlXSBvZiB0YXJnZXQpIHtcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRhcmdldCAhPSBudWxsKSB7XG4gICAgICAgICAgZm9yIChsZXQgbmFtZSBvZiBPYmplY3Qua2V5cyh0YXJnZXQpKSB7XG4gICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQobmFtZSwgdGFyZ2V0W25hbWVdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgYXJlIGNhbGxpbmcgc3VibWl0IGR1cmluZyB0aGUgc2VydmVyIHJlbmRlci4gXCIgKyBcIlRyeSBjYWxsaW5nIHN1Ym1pdCB3aXRoaW4gYSBgdXNlRWZmZWN0YCBvciBjYWxsYmFjayBpbnN0ZWFkLlwiKTtcbiAgICB9XG5cbiAgICBsZXQge1xuICAgICAgcHJvdG9jb2wsXG4gICAgICBob3N0XG4gICAgfSA9IHdpbmRvdy5sb2NhdGlvbjtcbiAgICBsZXQgdXJsID0gbmV3IFVSTChhY3Rpb24sIGAke3Byb3RvY29sfS8vJHtob3N0fWApO1xuXG4gICAgaWYgKG1ldGhvZC50b0xvd2VyQ2FzZSgpID09PSBcImdldFwiKSB7XG4gICAgICBmb3IgKGxldCBbbmFtZSwgdmFsdWVdIG9mIGZvcm1EYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3Qgc3VibWl0IGJpbmFyeSBmb3JtIGRhdGEgdXNpbmcgR0VUYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgc3VibWlzc2lvbiA9IHtcbiAgICAgIGZvcm1EYXRhLFxuICAgICAgYWN0aW9uOiB1cmwucGF0aG5hbWUgKyB1cmwuc2VhcmNoLFxuICAgICAgbWV0aG9kOiBtZXRob2QudG9VcHBlckNhc2UoKSxcbiAgICAgIGVuY1R5cGUsXG4gICAgICBrZXk6IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA4KVxuICAgIH07XG5cbiAgICBpZiAoa2V5KSB7XG4gICAgICB0cmFuc2l0aW9uTWFuYWdlci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJmZXRjaGVyXCIsXG4gICAgICAgIGhyZWY6IHN1Ym1pc3Npb24uYWN0aW9uLFxuICAgICAgICBzdWJtaXNzaW9uLFxuICAgICAgICBrZXlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXROZXh0TmF2aWdhdGlvblN1Ym1pc3Npb24oc3VibWlzc2lvbik7XG4gICAgICBuYXZpZ2F0ZSh1cmwucGF0aG5hbWUgKyB1cmwuc2VhcmNoLCB7XG4gICAgICAgIHJlcGxhY2U6IG9wdGlvbnMucmVwbGFjZVxuICAgICAgfSk7XG4gICAgfVxuICB9LCBbZGVmYXVsdEFjdGlvbiwga2V5LCBuYXZpZ2F0ZSwgdHJhbnNpdGlvbk1hbmFnZXJdKTtcbn1cbmxldCBuZXh0TmF2aWdhdGlvblN1Ym1pc3Npb247XG5cbmZ1bmN0aW9uIHNldE5leHROYXZpZ2F0aW9uU3VibWlzc2lvbihzdWJtaXNzaW9uKSB7XG4gIG5leHROYXZpZ2F0aW9uU3VibWlzc2lvbiA9IHN1Ym1pc3Npb247XG59XG5cbmZ1bmN0aW9uIGNvbnN1bWVOZXh0TmF2aWdhdGlvblN1Ym1pc3Npb24oKSB7XG4gIGxldCBzdWJtaXNzaW9uID0gbmV4dE5hdmlnYXRpb25TdWJtaXNzaW9uO1xuICBuZXh0TmF2aWdhdGlvblN1Ym1pc3Npb24gPSB1bmRlZmluZWQ7XG4gIHJldHVybiBzdWJtaXNzaW9uO1xufVxuXG5mdW5jdGlvbiBpc0h0bWxFbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgdHlwZW9mIG9iamVjdC50YWdOYW1lID09PSBcInN0cmluZ1wiO1xufVxuXG5mdW5jdGlvbiBpc0J1dHRvbkVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiBpc0h0bWxFbGVtZW50KG9iamVjdCkgJiYgb2JqZWN0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJidXR0b25cIjtcbn1cblxuZnVuY3Rpb24gaXNGb3JtRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIGlzSHRtbEVsZW1lbnQob2JqZWN0KSAmJiBvYmplY3QudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImZvcm1cIjtcbn1cblxuZnVuY3Rpb24gaXNJbnB1dEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiBpc0h0bWxFbGVtZW50KG9iamVjdCkgJiYgb2JqZWN0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiO1xufVxuLyoqXG4gKiBTZXR1cCBhIGNhbGxiYWNrIHRvIGJlIGZpcmVkIG9uIHRoZSB3aW5kb3cncyBgYmVmb3JldW5sb2FkYCBldmVudC4gVGhpcyBpc1xuICogdXNlZnVsIGZvciBzYXZpbmcgc29tZSBkYXRhIHRvIGB3aW5kb3cubG9jYWxTdG9yYWdlYCBqdXN0IGJlZm9yZSB0aGUgcGFnZVxuICogcmVmcmVzaGVzLCB3aGljaCBhdXRvbWF0aWNhbGx5IGhhcHBlbnMgb24gdGhlIG5leHQgYDxMaW5rPmAgY2xpY2sgd2hlbiBSZW1peFxuICogZGV0ZWN0cyBhIG5ldyB2ZXJzaW9uIG9mIHRoZSBhcHAgaXMgYXZhaWxhYmxlIG9uIHRoZSBzZXJ2ZXIuXG4gKlxuICogTm90ZTogVGhlIGBjYWxsYmFja2AgYXJndW1lbnQgc2hvdWxkIGJlIGEgZnVuY3Rpb24gY3JlYXRlZCB3aXRoXG4gKiBgUmVhY3QudXNlQ2FsbGJhY2soKWAuXG4gKlxuICogQHNlZSBodHRwczovL3JlbWl4LnJ1bi9hcGkvcmVtaXgjdXNlYmVmb3JldW5sb2FkXG4gKi9cblxuXG5mdW5jdGlvbiB1c2VCZWZvcmVVbmxvYWQoY2FsbGJhY2spIHtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsIGNhbGxiYWNrKTtcbiAgICB9O1xuICB9LCBbY2FsbGJhY2tdKTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCByb3V0ZSBtYXRjaGVzIG9uIHRoZSBwYWdlLiBUaGlzIGlzIHVzZWZ1bCBmb3IgY3JlYXRpbmdcbiAqIGxheW91dCBhYnN0cmFjdGlvbnMgd2l0aCB5b3VyIGN1cnJlbnQgcm91dGVzLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZW1peC5ydW4vYXBpL3JlbWl4I3VzZW1hdGNoZXNcbiAqL1xuXG5mdW5jdGlvbiB1c2VNYXRjaGVzKCkge1xuICBsZXQge1xuICAgIG1hdGNoZXMsXG4gICAgcm91dGVEYXRhLFxuICAgIHJvdXRlTW9kdWxlc1xuICB9ID0gdXNlUmVtaXhFbnRyeUNvbnRleHQoKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gbWF0Y2hlcy5tYXAobWF0Y2ggPT4ge1xuICAgIHZhciBfcm91dGVNb2R1bGVzJG1hdGNoJHI7XG5cbiAgICBsZXQge1xuICAgICAgcGF0aG5hbWUsXG4gICAgICBwYXJhbXNcbiAgICB9ID0gbWF0Y2g7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBtYXRjaC5yb3V0ZS5pZCxcbiAgICAgIHBhdGhuYW1lLFxuICAgICAgcGFyYW1zLFxuICAgICAgZGF0YTogcm91dGVEYXRhW21hdGNoLnJvdXRlLmlkXSxcbiAgICAgIC8vIGlmIHRoZSBtb2R1bGUgZmFpbHMgdG8gbG9hZCBvciBhbiBlcnJvci9yZXNwb25zZSBpcyB0aHJvd24sIHRoZSBtb2R1bGVcbiAgICAgIC8vIHdvbid0IGJlIGRlZmluZWQuXG4gICAgICBoYW5kbGU6IChfcm91dGVNb2R1bGVzJG1hdGNoJHIgPSByb3V0ZU1vZHVsZXNbbWF0Y2gucm91dGUuaWRdKSA9PT0gbnVsbCB8fCBfcm91dGVNb2R1bGVzJG1hdGNoJHIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9yb3V0ZU1vZHVsZXMkbWF0Y2gkci5oYW5kbGVcbiAgICB9O1xuICB9KSwgW21hdGNoZXMsIHJvdXRlRGF0YSwgcm91dGVNb2R1bGVzXSk7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIEpTT04gcGFyc2VkIGRhdGEgZnJvbSB0aGUgY3VycmVudCByb3V0ZSdzIGBsb2FkZXJgLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZW1peC5ydW4vYXBpL3JlbWl4I3VzZWxvYWRlcmRhdGFcbiAqL1xuXG5mdW5jdGlvbiB1c2VMb2FkZXJEYXRhKCkge1xuICByZXR1cm4gdXNlUmVtaXhSb3V0ZUNvbnRleHQoKS5kYXRhO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBKU09OIHBhcnNlZCBkYXRhIGZyb20gdGhlIGN1cnJlbnQgcm91dGUncyBgYWN0aW9uYC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVtaXgucnVuL2FwaS9yZW1peCN1c2VhY3Rpb25kYXRhXG4gKi9cblxuZnVuY3Rpb24gdXNlQWN0aW9uRGF0YSgpIHtcbiAgbGV0IHtcbiAgICBpZDogcm91dGVJZFxuICB9ID0gdXNlUmVtaXhSb3V0ZUNvbnRleHQoKTtcbiAgbGV0IHtcbiAgICB0cmFuc2l0aW9uTWFuYWdlclxuICB9ID0gdXNlUmVtaXhFbnRyeUNvbnRleHQoKTtcbiAgbGV0IHtcbiAgICBhY3Rpb25EYXRhXG4gIH0gPSB0cmFuc2l0aW9uTWFuYWdlci5nZXRTdGF0ZSgpO1xuICByZXR1cm4gYWN0aW9uRGF0YSA/IGFjdGlvbkRhdGFbcm91dGVJZF0gOiB1bmRlZmluZWQ7XG59XG4vKipcbiAqIFJldHVybnMgZXZlcnl0aGluZyB5b3UgbmVlZCB0byBrbm93IGFib3V0IGEgcGFnZSB0cmFuc2l0aW9uIHRvIGJ1aWxkIHBlbmRpbmdcbiAqIG5hdmlnYXRpb24gaW5kaWNhdG9ycyBhbmQgb3B0aW1pc3RpYyBVSSBvbiBkYXRhIG11dGF0aW9ucy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVtaXgucnVuL2FwaS9yZW1peCN1c2V0cmFuc2l0aW9uXG4gKi9cblxuZnVuY3Rpb24gdXNlVHJhbnNpdGlvbigpIHtcbiAgbGV0IHtcbiAgICB0cmFuc2l0aW9uTWFuYWdlclxuICB9ID0gdXNlUmVtaXhFbnRyeUNvbnRleHQoKTtcbiAgcmV0dXJuIHRyYW5zaXRpb25NYW5hZ2VyLmdldFN0YXRlKCkudHJhbnNpdGlvbjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmV0Y2hlckZvcm0oZmV0Y2hLZXkpIHtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7XG4gICAgLy8gVE9ETzogbWFrZSBBTk9USEVSIGZvcm0gdy9vIGEgZmV0Y2hLZXkgcHJvcFxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGb3JtSW1wbCwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICByZWY6IHJlZixcbiAgICAgIGZldGNoS2V5OiBmZXRjaEtleVxuICAgIH0pKTtcbiAgfSk7XG59XG5cbmxldCBmZXRjaGVySWQgPSAwO1xuXG4vKipcbiAqIEludGVyYWN0cyB3aXRoIHJvdXRlIGxvYWRlcnMgYW5kIGFjdGlvbnMgd2l0aG91dCBjYXVzaW5nIGEgbmF2aWdhdGlvbi4gR3JlYXRcbiAqIGZvciBhbnkgaW50ZXJhY3Rpb24gdGhhdCBzdGF5cyBvbiB0aGUgc2FtZSBwYWdlLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZW1peC5ydW4vYXBpL3JlbWl4I3VzZWZldGNoZXJcbiAqL1xuZnVuY3Rpb24gdXNlRmV0Y2hlcigpIHtcbiAgbGV0IHtcbiAgICB0cmFuc2l0aW9uTWFuYWdlclxuICB9ID0gdXNlUmVtaXhFbnRyeUNvbnRleHQoKTtcbiAgbGV0IFtrZXldID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gU3RyaW5nKCsrZmV0Y2hlcklkKSk7XG4gIGxldCBbRm9ybV0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBjcmVhdGVGZXRjaGVyRm9ybShrZXkpKTtcbiAgbGV0IFtsb2FkXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IGhyZWYgPT4ge1xuICAgIHRyYW5zaXRpb25NYW5hZ2VyLnNlbmQoe1xuICAgICAgdHlwZTogXCJmZXRjaGVyXCIsXG4gICAgICBocmVmLFxuICAgICAga2V5XG4gICAgfSk7XG4gIH0pO1xuICBsZXQgc3VibWl0ID0gdXNlU3VibWl0SW1wbChrZXkpO1xuICBsZXQgZmV0Y2hlciA9IHRyYW5zaXRpb25NYW5hZ2VyLmdldEZldGNoZXIoa2V5KTtcbiAgbGV0IGZldGNoZXJXaXRoQ29tcG9uZW50cyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICBGb3JtLFxuICAgIHN1Ym1pdCxcbiAgICBsb2FkLFxuICAgIC4uLmZldGNoZXJcbiAgfSksIFtmZXRjaGVyLCBGb3JtLCBzdWJtaXQsIGxvYWRdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBJcyB0aGlzIGJ1c3RlZCB3aGVuIHRoZSBSZWFjdCB0ZWFtIGdldHMgcmVhbCB3ZWlyZCBhbmQgY2FsbHMgZWZmZWN0c1xuICAgIC8vIHR3aWNlIG9uIG1vdW50PyAgV2UgcmVhbGx5IGp1c3QgbmVlZCB0byBnYXJiYWdlIGNvbGxlY3QgaGVyZSB3aGVuIHRoaXNcbiAgICAvLyBmZXRjaGVyIGlzIG5vIGxvbmdlciBhcm91bmQuXG4gICAgcmV0dXJuICgpID0+IHRyYW5zaXRpb25NYW5hZ2VyLmRlbGV0ZUZldGNoZXIoa2V5KTtcbiAgfSwgW3RyYW5zaXRpb25NYW5hZ2VyLCBrZXldKTtcbiAgcmV0dXJuIGZldGNoZXJXaXRoQ29tcG9uZW50cztcbn1cbi8qKlxuICogUHJvdmlkZXMgYWxsIGZldGNoZXJzIGN1cnJlbnRseSBvbiB0aGUgcGFnZS4gVXNlZnVsIGZvciBsYXlvdXRzIGFuZCBwYXJlbnRcbiAqIHJvdXRlcyB0aGF0IG5lZWQgdG8gcHJvdmlkZSBwZW5kaW5nL29wdGltaXN0aWMgVUkgcmVnYXJkaW5nIHRoZSBmZXRjaC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVtaXgucnVuL2FwaS9yZW1peCN1c2VmZXRjaGVyc1xuICovXG5cbmZ1bmN0aW9uIHVzZUZldGNoZXJzKCkge1xuICBsZXQge1xuICAgIHRyYW5zaXRpb25NYW5hZ2VyXG4gIH0gPSB1c2VSZW1peEVudHJ5Q29udGV4dCgpO1xuICBsZXQge1xuICAgIGZldGNoZXJzXG4gIH0gPSB0cmFuc2l0aW9uTWFuYWdlci5nZXRTdGF0ZSgpO1xuICByZXR1cm4gWy4uLmZldGNoZXJzLnZhbHVlcygpXTtcbn0gLy8gRGVhZCBDb2RlIEVsaW1pbmF0aW9uIG1hZ2ljIGZvciBwcm9kdWN0aW9uIGJ1aWxkcy5cbi8vIFRoaXMgd2F5IGRldnMgZG9uJ3QgaGF2ZSB0byB3b3JyeSBhYm91dCBkb2luZyB0aGUgTk9ERV9FTlYgY2hlY2sgdGhlbXNlbHZlcy5cblxuY29uc3QgTGl2ZVJlbG9hZCA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcImRldmVsb3BtZW50XCIgPyAoKSA9PiBudWxsIDogZnVuY3Rpb24gTGl2ZVJlbG9hZCh7XG4gIHBvcnQgPSBOdW1iZXIocHJvY2Vzcy5lbnYuUkVNSVhfREVWX1NFUlZFUl9XU19QT1JUIHx8IDgwMDIpXG59KSB7XG4gIGxldCBzZXR1cExpdmVSZWxvYWQgPSAocG9ydCA9PiB7XG4gICAgbGV0IHByb3RvY29sID0gbG9jYXRpb24ucHJvdG9jb2wgPT09IFwiaHR0cHM6XCIgPyBcIndzczpcIiA6IFwid3M6XCI7XG4gICAgbGV0IGhvc3QgPSBsb2NhdGlvbi5ob3N0bmFtZTtcbiAgICBsZXQgc29ja2V0UGF0aCA9IGAke3Byb3RvY29sfS8vJHtob3N0fToke3BvcnR9L3NvY2tldGA7XG4gICAgbGV0IHdzID0gbmV3IFdlYlNvY2tldChzb2NrZXRQYXRoKTtcblxuICAgIHdzLm9ubWVzc2FnZSA9IG1lc3NhZ2UgPT4ge1xuICAgICAgbGV0IGV2ZW50ID0gSlNPTi5wYXJzZShtZXNzYWdlLmRhdGEpO1xuXG4gICAgICBpZiAoZXZlbnQudHlwZSA9PT0gXCJMT0dcIikge1xuICAgICAgICBjb25zb2xlLmxvZyhldmVudC5tZXNzYWdlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50LnR5cGUgPT09IFwiUkVMT0FEXCIpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJcdUQ4M0RcdURDQkYgUmVsb2FkaW5nIHdpbmRvdyAuLi5cIik7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd3Mub25lcnJvciA9IGVycm9yID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKFwiUmVtaXggZGV2IGFzc2V0IHNlcnZlciB3ZWIgc29ja2V0IGVycm9yOlwiKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIH07XG4gIH0pLnRvU3RyaW5nKCk7XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIsIHtcbiAgICBzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmc6IHRydWUsXG4gICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHtcbiAgICAgIF9faHRtbDogYCgke3NldHVwTGl2ZVJlbG9hZH0pKCR7SlNPTi5zdHJpbmdpZnkocG9ydCl9KWBcbiAgICB9XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gdXNlQ29tcG9zZWRSZWZzKC4uLnJlZnMpIHtcbiAgcmV0dXJuIFJlYWN0LnVzZUNhbGxiYWNrKG5vZGUgPT4ge1xuICAgIGZvciAobGV0IHJlZiBvZiByZWZzKSB7XG4gICAgICBpZiAocmVmID09IG51bGwpIGNvbnRpbnVlO1xuXG4gICAgICBpZiAodHlwZW9mIHJlZiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJlZihub2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVmLmN1cnJlbnQgPSBub2RlO1xuICAgICAgICB9IGNhdGNoIChfKSB7fVxuICAgICAgfVxuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuXG4gIH0sIHJlZnMpO1xufVxuXG5leHBvcnQgeyBGb3JtLCBGb3JtSW1wbCwgTGluaywgTGlua3MsIExpdmVSZWxvYWQsIE1ldGEsIE5hdkxpbmssIFByZWZldGNoUGFnZUxpbmtzLCBSZW1peEVudHJ5LCBSZW1peEVudHJ5Q29udGV4dCwgUmVtaXhSb3V0ZSwgU2NyaXB0cywgY29tcG9zZUV2ZW50SGFuZGxlcnMsIHVzZUFjdGlvbkRhdGEsIHVzZUJlZm9yZVVubG9hZCwgdXNlRmV0Y2hlciwgdXNlRmV0Y2hlcnMsIHVzZUZvcm1BY3Rpb24sIHVzZUxvYWRlckRhdGEsIHVzZU1hdGNoZXMsIHVzZVN1Ym1pdCwgdXNlU3VibWl0SW1wbCwgdXNlVHJhbnNpdGlvbiB9O1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9yZWFjdCB2MS4yLjJcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcblxuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZXhwb3J0IHsgX2V4dGVuZHMgYXMgZXh0ZW5kcyB9O1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9yZWFjdCB2MS4yLjJcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuaW1wb3J0IFJlYWN0X19kZWZhdWx0LCB7IHVzZUNvbnRleHQgfSBmcm9tICdyZWFjdCc7XG5cbi8vIFRPRE86IFdlIGV2ZW50dWFsbHkgbWlnaHQgbm90IHdhbnQgdG8gaW1wb3J0IGFueXRoaW5nIGRpcmVjdGx5IGZyb20gYGhpc3RvcnlgXG5jbGFzcyBSZW1peEVycm9yQm91bmRhcnkgZXh0ZW5kcyBSZWFjdF9fZGVmYXVsdC5Db21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgZXJyb3I6IHByb3BzLmVycm9yIHx8IG51bGwsXG4gICAgICBsb2NhdGlvbjogcHJvcHMubG9jYXRpb25cbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICBlcnJvclxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKHByb3BzLCBzdGF0ZSkge1xuICAgIC8vIFdoZW4gd2UgZ2V0IGludG8gYW4gZXJyb3Igc3RhdGUsIHRoZSB1c2VyIHdpbGwgbGlrZWx5IGNsaWNrIFwiYmFja1wiIHRvIHRoZVxuICAgIC8vIHByZXZpb3VzIHBhZ2UgdGhhdCBkaWRuJ3QgaGF2ZSBhbiBlcnJvci4gQmVjYXVzZSB0aGlzIHdyYXBzIHRoZSBlbnRpcmVcbiAgICAvLyBhcHBsaWNhdGlvbiAoZXZlbiB0aGUgSFRNTCEpIHRoYXQgd2lsbCBoYXZlIG5vIGVmZmVjdC0tdGhlIGVycm9yIHBhZ2VcbiAgICAvLyBjb250aW51ZXMgdG8gZGlzcGxheS4gVGhpcyBnaXZlcyB1cyBhIG1lY2hhbmlzbSB0byByZWNvdmVyIGZyb20gdGhlIGVycm9yXG4gICAgLy8gd2hlbiB0aGUgbG9jYXRpb24gY2hhbmdlcy5cbiAgICAvL1xuICAgIC8vIFdoZXRoZXIgd2UncmUgaW4gYW4gZXJyb3Igc3RhdGUgb3Igbm90LCB3ZSB1cGRhdGUgdGhlIGxvY2F0aW9uIGluIHN0YXRlXG4gICAgLy8gc28gdGhhdCB3aGVuIHdlIGFyZSBpbiBhbiBlcnJvciBzdGF0ZSwgaXQgZ2V0cyByZXNldCB3aGVuIGEgbmV3IGxvY2F0aW9uXG4gICAgLy8gY29tZXMgaW4gYW5kIHRoZSB1c2VyIHJlY292ZXJzIGZyb20gdGhlIGVycm9yLlxuICAgIGlmIChzdGF0ZS5sb2NhdGlvbiAhPT0gcHJvcHMubG9jYXRpb24pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVycm9yOiBwcm9wcy5lcnJvciB8fCBudWxsLFxuICAgICAgICBsb2NhdGlvbjogcHJvcHMubG9jYXRpb25cbiAgICAgIH07XG4gICAgfSAvLyBJZiB3ZSdyZSBub3QgY2hhbmdpbmcgbG9jYXRpb25zLCBwcmVzZXJ2ZSB0aGUgbG9jYXRpb24gYnV0IHN0aWxsIHN1cmZhY2VcbiAgICAvLyBhbnkgbmV3IGVycm9ycyB0aGF0IG1heSBjb21lIHRocm91Z2guIFdlIHJldGFpbiB0aGUgZXhpc3RpbmcgZXJyb3IsIHdlIGRvXG4gICAgLy8gdGhpcyBiZWNhdXNlIHRoZSBlcnJvciBwcm92aWRlZCBmcm9tIHRoZSBhcHAgc3RhdGUgbWF5IGJlIGNsZWFyZWQgd2l0aG91dFxuICAgIC8vIHRoZSBsb2NhdGlvbiBjaGFuZ2luZy5cblxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGVycm9yOiBwcm9wcy5lcnJvciB8fCBzdGF0ZS5lcnJvcixcbiAgICAgIGxvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvblxuICAgIH07XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuZXJyb3IpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudCh0aGlzLnByb3BzLmNvbXBvbmVudCwge1xuICAgICAgICBlcnJvcjogdGhpcy5zdGF0ZS5lcnJvclxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICAgIH1cbiAgfVxuXG59XG4vKipcbiAqIFdoZW4gYXBwJ3MgZG9uJ3QgcHJvdmlkZSBhIHJvb3QgbGV2ZWwgRXJyb3JCb3VuZGFyeSwgd2UgZGVmYXVsdCB0byB0aGlzLlxuICovXG5cbmZ1bmN0aW9uIFJlbWl4Um9vdERlZmF1bHRFcnJvckJvdW5kYXJ5KHtcbiAgZXJyb3Jcbn0pIHtcbiAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImh0bWxcIiwge1xuICAgIGxhbmc6IFwiZW5cIlxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImhlYWRcIiwgbnVsbCwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJtZXRhXCIsIHtcbiAgICBjaGFyU2V0OiBcInV0Zi04XCJcbiAgfSksIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwibWV0YVwiLCB7XG4gICAgbmFtZTogXCJ2aWV3cG9ydFwiLFxuICAgIGNvbnRlbnQ6IFwid2lkdGg9ZGV2aWNlLXdpZHRoLGluaXRpYWwtc2NhbGU9MSx2aWV3cG9ydC1maXQ9Y292ZXJcIlxuICB9KSwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJ0aXRsZVwiLCBudWxsLCBcIkFwcGxpY2F0aW9uIEVycm9yIVwiKSksIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiYm9keVwiLCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcIm1haW5cIiwge1xuICAgIHN0eWxlOiB7XG4gICAgICBmb250RmFtaWx5OiBcInN5c3RlbS11aSwgc2Fucy1zZXJpZlwiLFxuICAgICAgcGFkZGluZzogXCIycmVtXCJcbiAgICB9XG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaDFcIiwge1xuICAgIHN0eWxlOiB7XG4gICAgICBmb250U2l6ZTogXCIyNHB4XCJcbiAgICB9XG4gIH0sIFwiQXBwbGljYXRpb24gRXJyb3JcIiksIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwicHJlXCIsIHtcbiAgICBzdHlsZToge1xuICAgICAgcGFkZGluZzogXCIycmVtXCIsXG4gICAgICBiYWNrZ3JvdW5kOiBcImhzbGEoMTAsIDUwJSwgNTAlLCAwLjEpXCIsXG4gICAgICBjb2xvcjogXCJyZWRcIixcbiAgICAgIG92ZXJmbG93OiBcImF1dG9cIlxuICAgIH1cbiAgfSwgZXJyb3Iuc3RhY2spKSwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIiwge1xuICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XG4gICAgICBfX2h0bWw6IGBcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgXCJcdUQ4M0RcdURDQkYgSGV5IGRldmVsb3Blclx1RDgzRFx1REM0Qi4gWW91IGNhbiBwcm92aWRlIGEgd2F5IGJldHRlciBVWCB0aGFuIHRoaXMgd2hlbiB5b3VyIGFwcCB0aHJvd3MgZXJyb3JzLiBDaGVjayBvdXQgaHR0cHM6Ly9yZW1peC5ydW4vZ3VpZGVzL2Vycm9ycyBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgYFxuICAgIH1cbiAgfSkpKTtcbn1cbmxldCBSZW1peENhdGNoQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVDb250ZXh0KHVuZGVmaW5lZCk7XG4vKipcbiAqIFJldHVybnMgdGhlIHN0YXR1cyBjb2RlIGFuZCB0aHJvd24gcmVzcG9uc2UgZGF0YS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVtaXgucnVuL2FwaS9jb252ZW50aW9ucyNjYXRjaGJvdW5kYXJ5XG4gKi9cblxuZnVuY3Rpb24gdXNlQ2F0Y2goKSB7XG4gIHJldHVybiB1c2VDb250ZXh0KFJlbWl4Q2F0Y2hDb250ZXh0KTtcbn1cbmZ1bmN0aW9uIFJlbWl4Q2F0Y2hCb3VuZGFyeSh7XG4gIGNhdGNoOiBjYXRjaFZhbCxcbiAgY29tcG9uZW50OiBDb21wb25lbnQsXG4gIGNoaWxkcmVuXG59KSB7XG4gIGlmIChjYXRjaFZhbCkge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChSZW1peENhdGNoQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgdmFsdWU6IGNhdGNoVmFsXG4gICAgfSwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCBudWxsKSk7XG4gIH1cblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoUmVhY3RfX2RlZmF1bHQuRnJhZ21lbnQsIG51bGwsIGNoaWxkcmVuKTtcbn1cbi8qKlxuICogV2hlbiBhcHAncyBkb24ndCBwcm92aWRlIGEgcm9vdCBsZXZlbCBDYXRjaEJvdW5kYXJ5LCB3ZSBkZWZhdWx0IHRvIHRoaXMuXG4gKi9cblxuZnVuY3Rpb24gUmVtaXhSb290RGVmYXVsdENhdGNoQm91bmRhcnkoKSB7XG4gIGxldCBjYXVnaHQgPSB1c2VDYXRjaCgpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJodG1sXCIsIHtcbiAgICBsYW5nOiBcImVuXCJcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJoZWFkXCIsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwibWV0YVwiLCB7XG4gICAgY2hhclNldDogXCJ1dGYtOFwiXG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcIm1ldGFcIiwge1xuICAgIG5hbWU6IFwidmlld3BvcnRcIixcbiAgICBjb250ZW50OiBcIndpZHRoPWRldmljZS13aWR0aCxpbml0aWFsLXNjYWxlPTEsdmlld3BvcnQtZml0PWNvdmVyXCJcbiAgfSksIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwidGl0bGVcIiwgbnVsbCwgXCJVbmhhbmRsZWQgVGhyb3duIFJlc3BvbnNlIVwiKSksIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiYm9keVwiLCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImgxXCIsIHtcbiAgICBzdHlsZToge1xuICAgICAgZm9udEZhbWlseTogXCJzeXN0ZW0tdWksIHNhbnMtc2VyaWZcIixcbiAgICAgIHBhZGRpbmc6IFwiMnJlbVwiXG4gICAgfVxuICB9LCBjYXVnaHQuc3RhdHVzLCBcIiBcIiwgY2F1Z2h0LnN0YXR1c1RleHQpLCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiLCB7XG4gICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHtcbiAgICAgIF9faHRtbDogYFxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICBcIlx1RDgzRFx1RENCRiBIZXkgZGV2ZWxvcGVyXHVEODNEXHVEQzRCLiBZb3UgY2FuIHByb3ZpZGUgYSB3YXkgYmV0dGVyIFVYIHRoYW4gdGhpcyB3aGVuIHlvdXIgYXBwIHRocm93cyA0MDRzIChhbmQgb3RoZXIgcmVzcG9uc2VzKS4gQ2hlY2sgb3V0IGh0dHBzOi8vcmVtaXgucnVuL2d1aWRlcy9ub3QtZm91bmQgZm9yIG1vcmUgaW5mb3JtYXRpb24uXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGBcbiAgICB9XG4gIH0pKSk7XG59XG5cbmV4cG9ydCB7IFJlbWl4Q2F0Y2hCb3VuZGFyeSwgUmVtaXhFcnJvckJvdW5kYXJ5LCBSZW1peFJvb3REZWZhdWx0Q2F0Y2hCb3VuZGFyeSwgUmVtaXhSb290RGVmYXVsdEVycm9yQm91bmRhcnksIHVzZUNhdGNoIH07XG4iLCAiLyoqXG4gKiBAcmVtaXgtcnVuL3JlYWN0IHYxLjIuMlxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5mdW5jdGlvbiBpbnZhcmlhbnQodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKHZhbHVlID09PSBmYWxzZSB8fCB2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cbn1cblxuZXhwb3J0IHsgaW52YXJpYW50IGFzIGRlZmF1bHQgfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vcmVhY3QgdjEuMi4yXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmltcG9ydCB7IHBhcnNlUGF0aCB9IGZyb20gJ2hpc3RvcnknO1xuaW1wb3J0IHsgbG9hZFJvdXRlTW9kdWxlIH0gZnJvbSAnLi9yb3V0ZU1vZHVsZXMuanMnO1xuXG4vLyBUT0RPOiBXZSBldmVudHVhbGx5IG1pZ2h0IG5vdCB3YW50IHRvIGltcG9ydCBhbnl0aGluZyBkaXJlY3RseSBmcm9tIGBoaXN0b3J5YFxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBHZXRzIGFsbCB0aGUgbGlua3MgZm9yIGEgc2V0IG9mIG1hdGNoZXMuIFRoZSBtb2R1bGVzIGFyZSBhc3N1bWVkIHRvIGhhdmUgYmVlblxuICogbG9hZGVkIGFscmVhZHkuXG4gKi9cbmZ1bmN0aW9uIGdldExpbmtzRm9yTWF0Y2hlcyhtYXRjaGVzLCByb3V0ZU1vZHVsZXMsIG1hbmlmZXN0KSB7XG4gIGxldCBkZXNjcmlwdG9ycyA9IG1hdGNoZXMubWFwKG1hdGNoID0+IHtcbiAgICB2YXIgX21vZHVsZSRsaW5rcztcblxuICAgIGxldCBtb2R1bGUgPSByb3V0ZU1vZHVsZXNbbWF0Y2gucm91dGUuaWRdO1xuICAgIHJldHVybiAoKF9tb2R1bGUkbGlua3MgPSBtb2R1bGUubGlua3MpID09PSBudWxsIHx8IF9tb2R1bGUkbGlua3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9tb2R1bGUkbGlua3MuY2FsbChtb2R1bGUpKSB8fCBbXTtcbiAgfSkuZmxhdCgxKTtcbiAgbGV0IHByZWxvYWRzID0gZ2V0Q3VycmVudFBhZ2VNb2R1bGVQcmVsb2FkSHJlZnMobWF0Y2hlcywgbWFuaWZlc3QpO1xuICByZXR1cm4gZGVkdXBlKGRlc2NyaXB0b3JzLCBwcmVsb2Fkcyk7XG59XG5hc3luYyBmdW5jdGlvbiBwcmVmZXRjaFN0eWxlTGlua3Mocm91dGVNb2R1bGUpIHtcbiAgaWYgKCFyb3V0ZU1vZHVsZS5saW5rcykgcmV0dXJuO1xuICBsZXQgZGVzY3JpcHRvcnMgPSByb3V0ZU1vZHVsZS5saW5rcygpO1xuICBpZiAoIWRlc2NyaXB0b3JzKSByZXR1cm47XG4gIGxldCBzdHlsZUxpbmtzID0gW107XG5cbiAgZm9yIChsZXQgZGVzY3JpcHRvciBvZiBkZXNjcmlwdG9ycykge1xuICAgIGlmICghaXNQYWdlTGlua0Rlc2NyaXB0b3IoZGVzY3JpcHRvcikgJiYgZGVzY3JpcHRvci5yZWwgPT09IFwic3R5bGVzaGVldFwiKSB7XG4gICAgICBzdHlsZUxpbmtzLnB1c2goeyAuLi5kZXNjcmlwdG9yLFxuICAgICAgICByZWw6IFwicHJlbG9hZFwiLFxuICAgICAgICBhczogXCJzdHlsZVwiXG4gICAgICB9KTtcbiAgICB9XG4gIH0gLy8gZG9uJ3QgYmxvY2sgZm9yIG5vbi1tYXRjaGluZyBtZWRpYSBxdWVyaWVzXG5cblxuICBsZXQgbWF0Y2hpbmdMaW5rcyA9IHN0eWxlTGlua3MuZmlsdGVyKGxpbmsgPT4gIWxpbmsubWVkaWEgfHwgd2luZG93Lm1hdGNoTWVkaWEobGluay5tZWRpYSkubWF0Y2hlcyk7XG4gIGF3YWl0IFByb21pc2UuYWxsKG1hdGNoaW5nTGlua3MubWFwKHByZWZldGNoU3R5bGVMaW5rKSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHByZWZldGNoU3R5bGVMaW5rKGRlc2NyaXB0b3IpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIGxldCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG4gICAgT2JqZWN0LmFzc2lnbihsaW5rLCBkZXNjcmlwdG9yKTtcblxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpbmsoKSB7XG4gICAgICAvLyBpZiBhIG5hdmlnYXRpb24gaW50ZXJydXB0cyB0aGlzIHByZWZldGNoIFJlYWN0IHdpbGwgdXBkYXRlIHRoZSA8aGVhZD5cbiAgICAgIC8vIGFuZCByZW1vdmUgdGhlIGxpbmsgd2UgcHV0IGluIHRoZXJlIG1hbnVhbGx5LCBzbyB3ZSBjaGVjayBpZiBpdCdzIHN0aWxsXG4gICAgICAvLyB0aGVyZSBiZWZvcmUgdHJ5aW5nIHRvIHJlbW92ZSBpdFxuICAgICAgaWYgKGRvY3VtZW50LmhlYWQuY29udGFpbnMobGluaykpIHtcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5yZW1vdmVDaGlsZChsaW5rKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsaW5rLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgIHJlbW92ZUxpbmsoKTtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9O1xuXG4gICAgbGluay5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgcmVtb3ZlTGluaygpO1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH07XG5cbiAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGxpbmspO1xuICB9KTtcbn0gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG5mdW5jdGlvbiBpc1BhZ2VMaW5rRGVzY3JpcHRvcihvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIHR5cGVvZiBvYmplY3QucGFnZSA9PT0gXCJzdHJpbmdcIjtcbn1cbmZ1bmN0aW9uIGlzSHRtbExpbmtEZXNjcmlwdG9yKG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgdHlwZW9mIG9iamVjdC5yZWwgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIG9iamVjdC5ocmVmID09PSBcInN0cmluZ1wiO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0U3R5bGVzaGVldFByZWZldGNoTGlua3MobWF0Y2hlcywgcm91dGVNb2R1bGVzKSB7XG4gIGxldCBsaW5rcyA9IGF3YWl0IFByb21pc2UuYWxsKG1hdGNoZXMubWFwKGFzeW5jIG1hdGNoID0+IHtcbiAgICBsZXQgbW9kID0gYXdhaXQgbG9hZFJvdXRlTW9kdWxlKG1hdGNoLnJvdXRlLCByb3V0ZU1vZHVsZXMpO1xuICAgIHJldHVybiBtb2QubGlua3MgPyBtb2QubGlua3MoKSA6IFtdO1xuICB9KSk7XG4gIHJldHVybiBsaW5rcy5mbGF0KDEpLmZpbHRlcihpc0h0bWxMaW5rRGVzY3JpcHRvcikuZmlsdGVyKGxpbmsgPT4gbGluay5yZWwgPT09IFwic3R5bGVzaGVldFwiIHx8IGxpbmsucmVsID09PSBcInByZWxvYWRcIikubWFwKCh7XG4gICAgcmVsLFxuICAgIC4uLmF0dHJzXG4gIH0pID0+IHJlbCA9PT0gXCJwcmVsb2FkXCIgPyB7XG4gICAgcmVsOiBcInByZWZldGNoXCIsXG4gICAgLi4uYXR0cnNcbiAgfSA6IHtcbiAgICByZWw6IFwicHJlZmV0Y2hcIixcbiAgICBhczogXCJzdHlsZVwiLFxuICAgIC4uLmF0dHJzXG4gIH0pO1xufSAvLyBUaGlzIGlzIHJpZGljdWxvdXNseSBpZGVudGljYWwgdG8gdHJhbnNpdGlvbi50cyBgZmlsdGVyTWF0Y2hlc1RvTG9hZGBcblxuZnVuY3Rpb24gZ2V0TmV3TWF0Y2hlc0ZvckxpbmtzKHBhZ2UsIG5leHRNYXRjaGVzLCBjdXJyZW50TWF0Y2hlcywgbG9jYXRpb24sIG1vZGUpIHtcbiAgbGV0IHBhdGggPSBwYXJzZVBhdGhQYXRjaChwYWdlKTtcblxuICBsZXQgaXNOZXcgPSAobWF0Y2gsIGluZGV4KSA9PiB7XG4gICAgaWYgKCFjdXJyZW50TWF0Y2hlc1tpbmRleF0pIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBtYXRjaC5yb3V0ZS5pZCAhPT0gY3VycmVudE1hdGNoZXNbaW5kZXhdLnJvdXRlLmlkO1xuICB9O1xuXG4gIGxldCBtYXRjaFBhdGhDaGFuZ2VkID0gKG1hdGNoLCBpbmRleCkgPT4ge1xuICAgIHZhciBfY3VycmVudE1hdGNoZXMkaW5kZXg7XG5cbiAgICByZXR1cm4gKC8vIHBhcmFtIGNoYW5nZSwgL3VzZXJzLzEyMyAtPiAvdXNlcnMvNDU2XG4gICAgICBjdXJyZW50TWF0Y2hlc1tpbmRleF0ucGF0aG5hbWUgIT09IG1hdGNoLnBhdGhuYW1lIHx8ICgoX2N1cnJlbnRNYXRjaGVzJGluZGV4ID0gY3VycmVudE1hdGNoZXNbaW5kZXhdLnJvdXRlLnBhdGgpID09PSBudWxsIHx8IF9jdXJyZW50TWF0Y2hlcyRpbmRleCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2N1cnJlbnRNYXRjaGVzJGluZGV4LmVuZHNXaXRoKFwiKlwiKSkgJiYgY3VycmVudE1hdGNoZXNbaW5kZXhdLnBhcmFtc1tcIipcIl0gIT09IG1hdGNoLnBhcmFtc1tcIipcIl1cbiAgICApO1xuICB9OyAvLyBOT1RFOiBrZWVwIHRoaXMgbW9zdGx5IHVwLXRvLWRhdGUgdy8gdGhlIHRyYW5zaXRpb24gZGF0YSBkaWZmLCBidXQgdGhpc1xuICAvLyB2ZXJzaW9uIGRvZXNuJ3QgY2FyZSBhYm91dCBzdWJtaXNzaW9uc1xuXG5cbiAgbGV0IG5ld01hdGNoZXMgPSBtb2RlID09PSBcImRhdGFcIiAmJiBsb2NhdGlvbi5zZWFyY2ggIT09IHBhdGguc2VhcmNoID8gLy8gdGhpcyBpcyByZWFsbHkgc2ltaWxhciB0byBzdHVmZiBpbiB0cmFuc2l0aW9uLnRzLCBtYXliZSBzb21lYm9keSBzbWFydGVyXG4gIC8vIHRoYW4gbWUgKG9yIGluIGxlc3Mgb2YgYSBodXJyeSkgY2FuIHNoYXJlIHNvbWUgb2YgaXQuIFlvdSdyZSB0aGUgYmVzdC5cbiAgbmV4dE1hdGNoZXMuZmlsdGVyKChtYXRjaCwgaW5kZXgpID0+IHtcbiAgICBpZiAoIW1hdGNoLnJvdXRlLmhhc0xvYWRlcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChpc05ldyhtYXRjaCwgaW5kZXgpIHx8IG1hdGNoUGF0aENoYW5nZWQobWF0Y2gsIGluZGV4KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG1hdGNoLnJvdXRlLnNob3VsZFJlbG9hZCkge1xuICAgICAgcmV0dXJuIG1hdGNoLnJvdXRlLnNob3VsZFJlbG9hZCh7XG4gICAgICAgIHBhcmFtczogbWF0Y2gucGFyYW1zLFxuICAgICAgICBwcmV2VXJsOiBuZXcgVVJMKGxvY2F0aW9uLnBhdGhuYW1lICsgbG9jYXRpb24uc2VhcmNoICsgbG9jYXRpb24uaGFzaCwgd2luZG93Lm9yaWdpbiksXG4gICAgICAgIHVybDogbmV3IFVSTChwYWdlLCB3aW5kb3cub3JpZ2luKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0pIDogbmV4dE1hdGNoZXMuZmlsdGVyKChtYXRjaCwgaW5kZXgpID0+IHtcbiAgICByZXR1cm4gbWF0Y2gucm91dGUuaGFzTG9hZGVyICYmIChpc05ldyhtYXRjaCwgaW5kZXgpIHx8IG1hdGNoUGF0aENoYW5nZWQobWF0Y2gsIGluZGV4KSk7XG4gIH0pO1xuICByZXR1cm4gbmV3TWF0Y2hlcztcbn1cbmZ1bmN0aW9uIGdldERhdGFMaW5rSHJlZnMocGFnZSwgbWF0Y2hlcywgbWFuaWZlc3QpIHtcbiAgbGV0IHBhdGggPSBwYXJzZVBhdGhQYXRjaChwYWdlKTtcbiAgcmV0dXJuIGRlZHVwZUhyZWZzKG1hdGNoZXMuZmlsdGVyKG1hdGNoID0+IG1hbmlmZXN0LnJvdXRlc1ttYXRjaC5yb3V0ZS5pZF0uaGFzTG9hZGVyKS5tYXAobWF0Y2ggPT4ge1xuICAgIGxldCB7XG4gICAgICBwYXRobmFtZSxcbiAgICAgIHNlYXJjaFxuICAgIH0gPSBwYXRoO1xuICAgIGxldCBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHNlYXJjaCk7XG4gICAgc2VhcmNoUGFyYW1zLnNldChcIl9kYXRhXCIsIG1hdGNoLnJvdXRlLmlkKTtcbiAgICByZXR1cm4gYCR7cGF0aG5hbWV9PyR7c2VhcmNoUGFyYW1zfWA7XG4gIH0pKTtcbn1cbmZ1bmN0aW9uIGdldE1vZHVsZUxpbmtIcmVmcyhtYXRjaGVzLCBtYW5pZmVzdFBhdGNoKSB7XG4gIHJldHVybiBkZWR1cGVIcmVmcyhtYXRjaGVzLm1hcChtYXRjaCA9PiB7XG4gICAgbGV0IHJvdXRlID0gbWFuaWZlc3RQYXRjaC5yb3V0ZXNbbWF0Y2gucm91dGUuaWRdO1xuICAgIGxldCBocmVmcyA9IFtyb3V0ZS5tb2R1bGVdO1xuXG4gICAgaWYgKHJvdXRlLmltcG9ydHMpIHtcbiAgICAgIGhyZWZzID0gaHJlZnMuY29uY2F0KHJvdXRlLmltcG9ydHMpO1xuICAgIH1cblxuICAgIHJldHVybiBocmVmcztcbiAgfSkuZmxhdCgxKSk7XG59IC8vIFRoZSBgPFNjcmlwdD5gIHdpbGwgcmVuZGVyIHJlbD1tb2R1bGVwcmVsb2FkIGZvciB0aGUgY3VycmVudCBwYWdlLCB3ZSBkb24ndFxuLy8gbmVlZCB0byBpbmNsdWRlIHRoZW0gaW4gYSBwYWdlIHByZWZldGNoLCB0aGlzIGdpdmVzIHVzIHRoZSBsaXN0IHRvIHJlbW92ZVxuLy8gd2hpbGUgZGVkdXBpbmcuXG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRQYWdlTW9kdWxlUHJlbG9hZEhyZWZzKG1hdGNoZXMsIG1hbmlmZXN0KSB7XG4gIHJldHVybiBkZWR1cGVIcmVmcyhtYXRjaGVzLm1hcChtYXRjaCA9PiB7XG4gICAgbGV0IHJvdXRlID0gbWFuaWZlc3Qucm91dGVzW21hdGNoLnJvdXRlLmlkXTtcbiAgICBsZXQgaHJlZnMgPSBbcm91dGUubW9kdWxlXTtcblxuICAgIGlmIChyb3V0ZS5pbXBvcnRzKSB7XG4gICAgICBocmVmcyA9IGhyZWZzLmNvbmNhdChyb3V0ZS5pbXBvcnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaHJlZnM7XG4gIH0pLmZsYXQoMSkpO1xufVxuXG5mdW5jdGlvbiBkZWR1cGVIcmVmcyhocmVmcykge1xuICByZXR1cm4gWy4uLm5ldyBTZXQoaHJlZnMpXTtcbn1cblxuZnVuY3Rpb24gZGVkdXBlKGRlc2NyaXB0b3JzLCBwcmVsb2Fkcykge1xuICBsZXQgc2V0ID0gbmV3IFNldCgpO1xuICBsZXQgcHJlbG9hZHNTZXQgPSBuZXcgU2V0KHByZWxvYWRzKTtcbiAgcmV0dXJuIGRlc2NyaXB0b3JzLnJlZHVjZSgoZGVkdXBlZCwgZGVzY3JpcHRvcikgPT4ge1xuICAgIGxldCBhbHJlYWR5TW9kdWxlUHJlbG9hZCA9ICFpc1BhZ2VMaW5rRGVzY3JpcHRvcihkZXNjcmlwdG9yKSAmJiBkZXNjcmlwdG9yLmFzID09PSBcInNjcmlwdFwiICYmIGRlc2NyaXB0b3IuaHJlZiAmJiBwcmVsb2Fkc1NldC5oYXMoZGVzY3JpcHRvci5ocmVmKTtcblxuICAgIGlmIChhbHJlYWR5TW9kdWxlUHJlbG9hZCkge1xuICAgICAgcmV0dXJuIGRlZHVwZWQ7XG4gICAgfVxuXG4gICAgbGV0IHN0ciA9IEpTT04uc3RyaW5naWZ5KGRlc2NyaXB0b3IpO1xuXG4gICAgaWYgKCFzZXQuaGFzKHN0cikpIHtcbiAgICAgIHNldC5hZGQoc3RyKTtcbiAgICAgIGRlZHVwZWQucHVzaChkZXNjcmlwdG9yKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVkdXBlZDtcbiAgfSwgW10pO1xufSAvLyBodHRwczovL2dpdGh1Yi5jb20vcmVtaXgtcnVuL2hpc3RvcnkvaXNzdWVzLzg5N1xuXG5mdW5jdGlvbiBwYXJzZVBhdGhQYXRjaChocmVmKSB7XG4gIGxldCBwYXRoID0gcGFyc2VQYXRoKGhyZWYpO1xuICBpZiAocGF0aC5zZWFyY2ggPT09IHVuZGVmaW5lZCkgcGF0aC5zZWFyY2ggPSBcIlwiO1xuICByZXR1cm4gcGF0aDtcbn1cblxuZXhwb3J0IHsgZGVkdXBlLCBnZXREYXRhTGlua0hyZWZzLCBnZXRMaW5rc0Zvck1hdGNoZXMsIGdldE1vZHVsZUxpbmtIcmVmcywgZ2V0TmV3TWF0Y2hlc0ZvckxpbmtzLCBnZXRTdHlsZXNoZWV0UHJlZmV0Y2hMaW5rcywgaXNIdG1sTGlua0Rlc2NyaXB0b3IsIGlzUGFnZUxpbmtEZXNjcmlwdG9yLCBwcmVmZXRjaFN0eWxlTGlua3MgfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vcmVhY3QgdjEuMi4yXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbi8vIFRPRE86IFdlIGV2ZW50dWFsbHkgbWlnaHQgbm90IHdhbnQgdG8gaW1wb3J0IGFueXRoaW5nIGRpcmVjdGx5IGZyb20gYGhpc3RvcnlgXG4vLyBhbmQgbGV2ZXJhZ2UgYHJlYWN0LXJvdXRlcmAgaGVyZSBpbnN0ZWFkXG4vLyBUT0RPOiBpbXBvcnQvZXhwb3J0IGZyb20gcmVhY3Qtcm91dGVyLWRvbVxuXG4vKipcbiAqIEEgUmVhY3QgY29tcG9uZW50IHRoYXQgaXMgcmVuZGVyZWQgd2hlbiB0aGUgc2VydmVyIHRocm93cyBhIFJlc3BvbnNlLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZW1peC5ydW4vYXBpL2NvbnZlbnRpb25zI2NhdGNoYm91bmRhcnlcbiAqL1xuXG4vKipcbiAqIEEgUmVhY3QgY29tcG9uZW50IHRoYXQgaXMgcmVuZGVyZWQgd2hlbiB0aGVyZSBpcyBhbiBlcnJvciBvbiBhIHJvdXRlLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZW1peC5ydW4vYXBpL2NvbnZlbnRpb25zI2Vycm9yYm91bmRhcnlcbiAqL1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCBkZWZpbmVzIGA8bGluaz5gIHRhZ3MgdG8gYmUgaW5zZXJ0ZWQgaW50byB0aGUgYDxoZWFkPmAgb2ZcbiAqIHRoZSBkb2N1bWVudCBvbiByb3V0ZSB0cmFuc2l0aW9ucy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVtaXgucnVuL2FwaS9yZW1peCNtZXRhLWxpbmtzLXNjcmlwdHNcbiAqL1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIG9iamVjdCBvZiBuYW1lICsgY29udGVudCBwYWlycyB0byB1c2UgZm9yXG4gKiBgPG1ldGE+YCB0YWdzIGZvciBhIHJvdXRlLiBUaGVzZSB0YWdzIHdpbGwgYmUgbWVyZ2VkIHdpdGggKGFuZCB0YWtlXG4gKiBwcmVjZWRlbmNlIG92ZXIpIHRhZ3MgZnJvbSBwYXJlbnQgcm91dGVzLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZW1peC5ydW4vYXBpL3JlbWl4I21ldGEtbGlua3Mtc2NyaXB0c1xuICovXG5cbi8qKlxuICogQSBuYW1lL2NvbnRlbnQgcGFpciB1c2VkIHRvIHJlbmRlciBgPG1ldGE+YCB0YWdzIGluIGEgbWV0YSBmdW5jdGlvbiBmb3IgYVxuICogcm91dGUuIFRoZSB2YWx1ZSBjYW4gYmUgZWl0aGVyIGEgc3RyaW5nLCB3aGljaCB3aWxsIHJlbmRlciBhIHNpbmdsZSBgPG1ldGE+YFxuICogdGFnLCBvciBhbiBhcnJheSBvZiBzdHJpbmdzIHRoYXQgd2lsbCByZW5kZXIgbXVsdGlwbGUgdGFncyB3aXRoIHRoZSBzYW1lXG4gKiBgbmFtZWAgYXR0cmlidXRlLlxuICovXG5cbi8qKlxuICogRHVyaW5nIGNsaWVudCBzaWRlIHRyYW5zaXRpb25zIFJlbWl4IHdpbGwgb3B0aW1pemUgcmVsb2FkaW5nIG9mIHJvdXRlcyB0aGF0XG4gKiBhcmUgY3VycmVudGx5IG9uIHRoZSBwYWdlIGJ5IGF2b2lkaW5nIGxvYWRpbmcgcm91dGVzIHRoYXQgYXJlbid0IGNoYW5naW5nLlxuICogSG93ZXZlciwgaW4gc29tZSBjYXNlcywgbGlrZSBmb3JtIHN1Ym1pc3Npb25zIG9yIHNlYXJjaCBwYXJhbXMgUmVtaXggZG9lc24ndFxuICoga25vdyB3aGljaCByb3V0ZXMgbmVlZCB0byBiZSByZWxvYWRlZCBzbyBpdCByZWxvYWRzIHRoZW0gYWxsIHRvIGJlIHNhZmUuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBsZXRzIGFwcHMgZnVydGhlciBvcHRpbWl6ZSBieSByZXR1cm5pbmcgYGZhbHNlYCB3aGVuIFJlbWl4IGlzXG4gKiBhYm91dCB0byByZWxvYWQgdGhlIHJvdXRlLiBBIGNvbW1vbiBjYXNlIGlzIGEgcm9vdCBsb2FkZXIgd2l0aCBub3RoaW5nIGJ1dFxuICogZW52aXJvbm1lbnQgdmFyaWFibGVzOiBhZnRlciBmb3JtIHN1Ym1pc3Npb25zIHRoZSByb290IHByb2JhYmx5IGRvZXNuJ3QgbmVlZFxuICogdG8gYmUgcmVsb2FkZWQuXG4gKlxuICogQHNlZSBodHRwczovL3JlbWl4LnJ1bi9hcGkvY29udmVudGlvbnMjdW5zdGFibGVfc2hvdWxkcmVsb2FkXG4gKi9cblxuLyoqXG4gKiBBIFJlYWN0IGNvbXBvbmVudCB0aGF0IGlzIHJlbmRlcmVkIGZvciBhIHJvdXRlLlxuICovXG5cbi8qKlxuICogQW4gYXJiaXRyYXJ5IG9iamVjdCB0aGF0IGlzIGFzc29jaWF0ZWQgd2l0aCBhIHJvdXRlLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZW1peC5ydW4vYXBpL2NvbnZlbnRpb25zI2hhbmRsZVxuICovXG5hc3luYyBmdW5jdGlvbiBsb2FkUm91dGVNb2R1bGUocm91dGUsIHJvdXRlTW9kdWxlc0NhY2hlKSB7XG4gIGlmIChyb3V0ZS5pZCBpbiByb3V0ZU1vZHVsZXNDYWNoZSkge1xuICAgIHJldHVybiByb3V0ZU1vZHVsZXNDYWNoZVtyb3V0ZS5pZF07XG4gIH1cblxuICB0cnkge1xuICAgIGxldCByb3V0ZU1vZHVsZSA9IGF3YWl0IGltcG9ydChyb3V0ZS5tb2R1bGUpO1xuICAgIHJvdXRlTW9kdWxlc0NhY2hlW3JvdXRlLmlkXSA9IHJvdXRlTW9kdWxlO1xuICAgIHJldHVybiByb3V0ZU1vZHVsZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyBVc2VyIGdvdCBjYXVnaHQgaW4gdGhlIG1pZGRsZSBvZiBhIGRlcGxveSBhbmQgdGhlIENETiBubyBsb25nZXIgaGFzIHRoZVxuICAgIC8vIGFzc2V0IHdlJ3JlIHRyeWluZyB0byBpbXBvcnQhIFJlbG9hZCBmcm9tIHRoZSBzZXJ2ZXIgYW5kIHRoZSB1c2VyXG4gICAgLy8gKHNob3VsZCkgZ2V0IHRoZSBuZXcgbWFuaWZlc3QtLXVubGVzcyB0aGUgZGV2ZWxvcGVyIHB1cmdlZCB0aGUgc3RhdGljXG4gICAgLy8gYXNzZXRzLCB0aGUgbWFuaWZlc3QgcGF0aCwgYnV0IG5vdCB0aGUgZG9jdW1lbnRzIFx1RDgzRFx1REUyQ1xuICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKCkgPT4gey8vIGNoZWNrIG91dCBvZiB0aGlzIGhvb2sgY2F1c2UgdGhlIERKcyBuZXZlciBnb25uYSByZVtzXW9sdmUgdGhpc1xuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCB7IGxvYWRSb3V0ZU1vZHVsZSB9O1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9yZWFjdCB2MS4yLjJcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSHRtbChodG1sKSB7XG4gIHJldHVybiB7XG4gICAgX19odG1sOiBodG1sXG4gIH07XG59XG5cbmV4cG9ydCB7IGNyZWF0ZUh0bWwgfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vcmVhY3QgdjEuMi4yXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGxvYWRSb3V0ZU1vZHVsZSB9IGZyb20gJy4vcm91dGVNb2R1bGVzLmpzJztcbmltcG9ydCB7IGZldGNoRGF0YSwgaXNDYXRjaFJlc3BvbnNlLCBleHRyYWN0RGF0YSwgaXNSZWRpcmVjdFJlc3BvbnNlIH0gZnJvbSAnLi9kYXRhLmpzJztcbmltcG9ydCB7IENhdGNoVmFsdWUsIFRyYW5zaXRpb25SZWRpcmVjdCB9IGZyb20gJy4vdHJhbnNpdGlvbi5qcyc7XG5pbXBvcnQgeyBwcmVmZXRjaFN0eWxlTGlua3MgfSBmcm9tICcuL2xpbmtzLmpzJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnLi9pbnZhcmlhbnQuanMnO1xuXG5mdW5jdGlvbiBjcmVhdGVDbGllbnRSb3V0ZShlbnRyeVJvdXRlLCByb3V0ZU1vZHVsZXNDYWNoZSwgQ29tcG9uZW50KSB7XG4gIHJldHVybiB7XG4gICAgY2FzZVNlbnNpdGl2ZTogISFlbnRyeVJvdXRlLmNhc2VTZW5zaXRpdmUsXG4gICAgZWxlbWVudDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCB7XG4gICAgICBpZDogZW50cnlSb3V0ZS5pZFxuICAgIH0pLFxuICAgIGlkOiBlbnRyeVJvdXRlLmlkLFxuICAgIHBhdGg6IGVudHJ5Um91dGUucGF0aCxcbiAgICBpbmRleDogZW50cnlSb3V0ZS5pbmRleCxcbiAgICBtb2R1bGU6IGVudHJ5Um91dGUubW9kdWxlLFxuICAgIGxvYWRlcjogY3JlYXRlTG9hZGVyKGVudHJ5Um91dGUsIHJvdXRlTW9kdWxlc0NhY2hlKSxcbiAgICBhY3Rpb246IGNyZWF0ZUFjdGlvbihlbnRyeVJvdXRlKSxcbiAgICBzaG91bGRSZWxvYWQ6IGNyZWF0ZVNob3VsZFJlbG9hZChlbnRyeVJvdXRlLCByb3V0ZU1vZHVsZXNDYWNoZSksXG4gICAgRXJyb3JCb3VuZGFyeTogZW50cnlSb3V0ZS5oYXNFcnJvckJvdW5kYXJ5LFxuICAgIENhdGNoQm91bmRhcnk6IGVudHJ5Um91dGUuaGFzQ2F0Y2hCb3VuZGFyeSxcbiAgICBoYXNMb2FkZXI6IGVudHJ5Um91dGUuaGFzTG9hZGVyXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVDbGllbnRSb3V0ZXMocm91dGVNYW5pZmVzdCwgcm91dGVNb2R1bGVzQ2FjaGUsIENvbXBvbmVudCwgcGFyZW50SWQpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHJvdXRlTWFuaWZlc3QpLmZpbHRlcihrZXkgPT4gcm91dGVNYW5pZmVzdFtrZXldLnBhcmVudElkID09PSBwYXJlbnRJZCkubWFwKGtleSA9PiB7XG4gICAgbGV0IHJvdXRlID0gY3JlYXRlQ2xpZW50Um91dGUocm91dGVNYW5pZmVzdFtrZXldLCByb3V0ZU1vZHVsZXNDYWNoZSwgQ29tcG9uZW50KTtcbiAgICBsZXQgY2hpbGRyZW4gPSBjcmVhdGVDbGllbnRSb3V0ZXMocm91dGVNYW5pZmVzdCwgcm91dGVNb2R1bGVzQ2FjaGUsIENvbXBvbmVudCwgcm91dGUuaWQpO1xuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAwKSByb3V0ZS5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIHJldHVybiByb3V0ZTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNob3VsZFJlbG9hZChyb3V0ZSwgcm91dGVNb2R1bGVzKSB7XG4gIGxldCBzaG91bGRSZWxvYWQgPSBhcmcgPT4ge1xuICAgIGxldCBtb2R1bGUgPSByb3V0ZU1vZHVsZXNbcm91dGUuaWRdO1xuICAgIGludmFyaWFudChtb2R1bGUsIGBFeHBlY3RlZCByb3V0ZSBtb2R1bGUgdG8gYmUgbG9hZGVkIGZvciAke3JvdXRlLmlkfWApO1xuXG4gICAgaWYgKG1vZHVsZS51bnN0YWJsZV9zaG91bGRSZWxvYWQpIHtcbiAgICAgIHJldHVybiBtb2R1bGUudW5zdGFibGVfc2hvdWxkUmVsb2FkKGFyZyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgcmV0dXJuIHNob3VsZFJlbG9hZDtcbn1cblxuYXN5bmMgZnVuY3Rpb24gbG9hZFJvdXRlTW9kdWxlV2l0aEJsb2NraW5nTGlua3Mocm91dGUsIHJvdXRlTW9kdWxlcykge1xuICBsZXQgcm91dGVNb2R1bGUgPSBhd2FpdCBsb2FkUm91dGVNb2R1bGUocm91dGUsIHJvdXRlTW9kdWxlcyk7XG4gIGF3YWl0IHByZWZldGNoU3R5bGVMaW5rcyhyb3V0ZU1vZHVsZSk7XG4gIHJldHVybiByb3V0ZU1vZHVsZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTG9hZGVyKHJvdXRlLCByb3V0ZU1vZHVsZXMpIHtcbiAgbGV0IGxvYWRlciA9IGFzeW5jICh7XG4gICAgdXJsLFxuICAgIHNpZ25hbCxcbiAgICBzdWJtaXNzaW9uXG4gIH0pID0+IHtcbiAgICBpZiAocm91dGUuaGFzTG9hZGVyKSB7XG4gICAgICBsZXQgW3Jlc3VsdF0gPSBhd2FpdCBQcm9taXNlLmFsbChbZmV0Y2hEYXRhKHVybCwgcm91dGUuaWQsIHNpZ25hbCwgc3VibWlzc2lvbiksIGxvYWRSb3V0ZU1vZHVsZVdpdGhCbG9ja2luZ0xpbmtzKHJvdXRlLCByb3V0ZU1vZHVsZXMpXSk7XG4gICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRXJyb3IpIHRocm93IHJlc3VsdDtcbiAgICAgIGxldCByZWRpcmVjdCA9IGF3YWl0IGNoZWNrUmVkaXJlY3QocmVzdWx0KTtcbiAgICAgIGlmIChyZWRpcmVjdCkgcmV0dXJuIHJlZGlyZWN0O1xuXG4gICAgICBpZiAoaXNDYXRjaFJlc3BvbnNlKHJlc3VsdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IENhdGNoVmFsdWUocmVzdWx0LnN0YXR1cywgcmVzdWx0LnN0YXR1c1RleHQsIGF3YWl0IGV4dHJhY3REYXRhKHJlc3VsdC5jbG9uZSgpKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBleHRyYWN0RGF0YShyZXN1bHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhd2FpdCBsb2FkUm91dGVNb2R1bGVXaXRoQmxvY2tpbmdMaW5rcyhyb3V0ZSwgcm91dGVNb2R1bGVzKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGxvYWRlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQWN0aW9uKHJvdXRlKSB7XG4gIGlmICghcm91dGUuaGFzQWN0aW9uKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gIGxldCBhY3Rpb24gPSBhc3luYyAoe1xuICAgIHVybCxcbiAgICBzaWduYWwsXG4gICAgc3VibWlzc2lvblxuICB9KSA9PiB7XG4gICAgbGV0IHJlc3VsdCA9IGF3YWl0IGZldGNoRGF0YSh1cmwsIHJvdXRlLmlkLCBzaWduYWwsIHN1Ym1pc3Npb24pO1xuXG4gICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aHJvdyByZXN1bHQ7XG4gICAgfVxuXG4gICAgbGV0IHJlZGlyZWN0ID0gYXdhaXQgY2hlY2tSZWRpcmVjdChyZXN1bHQpO1xuICAgIGlmIChyZWRpcmVjdCkgcmV0dXJuIHJlZGlyZWN0O1xuXG4gICAgaWYgKGlzQ2F0Y2hSZXNwb25zZShyZXN1bHQpKSB7XG4gICAgICB0aHJvdyBuZXcgQ2F0Y2hWYWx1ZShyZXN1bHQuc3RhdHVzLCByZXN1bHQuc3RhdHVzVGV4dCwgYXdhaXQgZXh0cmFjdERhdGEocmVzdWx0LmNsb25lKCkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXh0cmFjdERhdGEocmVzdWx0KTtcbiAgfTtcblxuICByZXR1cm4gYWN0aW9uO1xufVxuXG5hc3luYyBmdW5jdGlvbiBjaGVja1JlZGlyZWN0KHJlc3BvbnNlKSB7XG4gIGlmIChpc1JlZGlyZWN0UmVzcG9uc2UocmVzcG9uc2UpKSB7XG4gICAgbGV0IHVybCA9IG5ldyBVUkwocmVzcG9uc2UuaGVhZGVycy5nZXQoXCJYLVJlbWl4LVJlZGlyZWN0XCIpLCB3aW5kb3cubG9jYXRpb24ub3JpZ2luKTtcblxuICAgIGlmICh1cmwub3JpZ2luICE9PSB3aW5kb3cubG9jYXRpb24ub3JpZ2luKSB7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZSgoKSA9PiB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKHVybC5ocmVmKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFRyYW5zaXRpb25SZWRpcmVjdCh1cmwucGF0aG5hbWUgKyB1cmwuc2VhcmNoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IHsgY3JlYXRlQ2xpZW50Um91dGUsIGNyZWF0ZUNsaWVudFJvdXRlcyB9O1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9yZWFjdCB2MS4yLjJcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuaW1wb3J0IGludmFyaWFudCBmcm9tICcuL2ludmFyaWFudC5qcyc7XG5cbmZ1bmN0aW9uIGlzQ2F0Y2hSZXNwb25zZShyZXNwb25zZSkge1xuICByZXR1cm4gcmVzcG9uc2UgaW5zdGFuY2VvZiBSZXNwb25zZSAmJiByZXNwb25zZS5oZWFkZXJzLmdldChcIlgtUmVtaXgtQ2F0Y2hcIikgIT0gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzRXJyb3JSZXNwb25zZShyZXNwb25zZSkge1xuICByZXR1cm4gcmVzcG9uc2UgaW5zdGFuY2VvZiBSZXNwb25zZSAmJiByZXNwb25zZS5oZWFkZXJzLmdldChcIlgtUmVtaXgtRXJyb3JcIikgIT0gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzUmVkaXJlY3RSZXNwb25zZShyZXNwb25zZSkge1xuICByZXR1cm4gcmVzcG9uc2UgaW5zdGFuY2VvZiBSZXNwb25zZSAmJiByZXNwb25zZS5oZWFkZXJzLmdldChcIlgtUmVtaXgtUmVkaXJlY3RcIikgIT0gbnVsbDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGZldGNoRGF0YSh1cmwsIHJvdXRlSWQsIHNpZ25hbCwgc3VibWlzc2lvbikge1xuICB1cmwuc2VhcmNoUGFyYW1zLnNldChcIl9kYXRhXCIsIHJvdXRlSWQpO1xuICBsZXQgaW5pdCA9IHN1Ym1pc3Npb24gPyBnZXRBY3Rpb25Jbml0KHN1Ym1pc3Npb24sIHNpZ25hbCkgOiB7XG4gICAgY3JlZGVudGlhbHM6IFwic2FtZS1vcmlnaW5cIixcbiAgICBzaWduYWxcbiAgfTtcbiAgbGV0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLmhyZWYsIGluaXQpO1xuXG4gIGlmIChpc0Vycm9yUmVzcG9uc2UocmVzcG9uc2UpKSB7XG4gICAgbGV0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgbGV0IGVycm9yID0gbmV3IEVycm9yKGRhdGEubWVzc2FnZSk7XG4gICAgZXJyb3Iuc3RhY2sgPSBkYXRhLnN0YWNrO1xuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuXG4gIHJldHVybiByZXNwb25zZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGV4dHJhY3REYXRhKHJlc3BvbnNlKSB7XG4gIC8vIFRoaXMgc2FtZSBhbGdvcml0aG0gaXMgdXNlZCBvbiB0aGUgc2VydmVyIHRvIGludGVycHJldCBsb2FkXG4gIC8vIHJlc3VsdHMgd2hlbiB3ZSByZW5kZXIgdGhlIEhUTUwgcGFnZS5cbiAgbGV0IGNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJDb250ZW50LVR5cGVcIik7XG5cbiAgaWYgKGNvbnRlbnRUeXBlICYmIC9cXGJhcHBsaWNhdGlvblxcL2pzb25cXGIvLnRlc3QoY29udGVudFR5cGUpKSB7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgfVxuXG4gIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG59XG5cbmZ1bmN0aW9uIGdldEFjdGlvbkluaXQoc3VibWlzc2lvbiwgc2lnbmFsKSB7XG4gIGxldCB7XG4gICAgZW5jVHlwZSxcbiAgICBtZXRob2QsXG4gICAgZm9ybURhdGFcbiAgfSA9IHN1Ym1pc3Npb247XG4gIGxldCBoZWFkZXJzID0gdW5kZWZpbmVkO1xuICBsZXQgYm9keSA9IGZvcm1EYXRhO1xuXG4gIGlmIChlbmNUeXBlID09PSBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiKSB7XG4gICAgYm9keSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcblxuICAgIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiBmb3JtRGF0YSkge1xuICAgICAgaW52YXJpYW50KHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiwgYEZpbGUgaW5wdXRzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggZW5jVHlwZSBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLCBwbGVhc2UgdXNlIFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiIGluc3RlYWQuYCk7XG4gICAgICBib2R5LmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICB9XG5cbiAgICBoZWFkZXJzID0ge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogZW5jVHlwZVxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG1ldGhvZCxcbiAgICBib2R5LFxuICAgIHNpZ25hbCxcbiAgICBjcmVkZW50aWFsczogXCJzYW1lLW9yaWdpblwiLFxuICAgIGhlYWRlcnNcbiAgfTtcbn1cblxuZXhwb3J0IHsgZXh0cmFjdERhdGEsIGZldGNoRGF0YSwgaXNDYXRjaFJlc3BvbnNlLCBpc0Vycm9yUmVzcG9uc2UsIGlzUmVkaXJlY3RSZXNwb25zZSB9O1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9yZWFjdCB2MS4yLjJcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuaW1wb3J0IHsgQWN0aW9uIH0gZnJvbSAnaGlzdG9yeSc7XG5pbXBvcnQgeyBtYXRjaENsaWVudFJvdXRlcyB9IGZyb20gJy4vcm91dGVNYXRjaGluZy5qcyc7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gJy4vaW52YXJpYW50LmpzJztcblxuLy8gVE9ETzogV2UgZXZlbnR1YWxseSBtaWdodCBub3Qgd2FudCB0byBpbXBvcnQgYW55dGhpbmcgZGlyZWN0bHkgZnJvbSBgaGlzdG9yeWBcbmNsYXNzIENhdGNoVmFsdWUge1xuICBjb25zdHJ1Y3RvcihzdGF0dXMsIHN0YXR1c1RleHQsIGRhdGEpIHtcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICB0aGlzLnN0YXR1c1RleHQgPSBzdGF0dXNUZXh0O1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gIH1cblxufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZnVuY3Rpb24gaXNBY3Rpb25TdWJtaXNzaW9uKHN1Ym1pc3Npb24pIHtcbiAgcmV0dXJuIFtcIlBPU1RcIiwgXCJQVVRcIiwgXCJQQVRDSFwiLCBcIkRFTEVURVwiXS5pbmNsdWRlcyhzdWJtaXNzaW9uLm1ldGhvZCk7XG59XG5cbmZ1bmN0aW9uIGlzTG9hZGVyU3VibWlzc2lvbihzdWJtaXNzaW9uKSB7XG4gIHJldHVybiBzdWJtaXNzaW9uLm1ldGhvZCA9PT0gXCJHRVRcIjtcbn1cblxuZnVuY3Rpb24gaXNSZWRpcmVjdExvY2F0aW9uKGxvY2F0aW9uKSB7XG4gIHJldHVybiBCb29sZWFuKGxvY2F0aW9uLnN0YXRlKSAmJiBsb2NhdGlvbi5zdGF0ZS5pc1JlZGlyZWN0O1xufVxuXG5mdW5jdGlvbiBpc0xvYWRlclJlZGlyZWN0TG9jYXRpb24obG9jYXRpb24pIHtcbiAgcmV0dXJuIGlzUmVkaXJlY3RMb2NhdGlvbihsb2NhdGlvbikgJiYgbG9jYXRpb24uc3RhdGUudHlwZSA9PT0gXCJsb2FkZXJcIjtcbn1cblxuZnVuY3Rpb24gaXNBY3Rpb25SZWRpcmVjdExvY2F0aW9uKGxvY2F0aW9uKSB7XG4gIHJldHVybiBpc1JlZGlyZWN0TG9jYXRpb24obG9jYXRpb24pICYmIGxvY2F0aW9uLnN0YXRlLnR5cGUgPT09IFwiYWN0aW9uXCI7XG59XG5cbmZ1bmN0aW9uIGlzRmV0Y2hBY3Rpb25SZWRpcmVjdChsb2NhdGlvbikge1xuICByZXR1cm4gaXNSZWRpcmVjdExvY2F0aW9uKGxvY2F0aW9uKSAmJiBsb2NhdGlvbi5zdGF0ZS50eXBlID09PSBcImZldGNoQWN0aW9uXCI7XG59XG5cbmZ1bmN0aW9uIGlzTG9hZGVyU3VibWlzc2lvblJlZGlyZWN0TG9jYXRpb24obG9jYXRpb24pIHtcbiAgcmV0dXJuIGlzUmVkaXJlY3RMb2NhdGlvbihsb2NhdGlvbikgJiYgbG9jYXRpb24uc3RhdGUudHlwZSA9PT0gXCJsb2FkZXJTdWJtaXNzaW9uXCI7XG59XG5cbmNsYXNzIFRyYW5zaXRpb25SZWRpcmVjdCB7XG4gIGNvbnN0cnVjdG9yKGxvY2F0aW9uKSB7XG4gICAgdGhpcy5sb2NhdGlvbiA9IHR5cGVvZiBsb2NhdGlvbiA9PT0gXCJzdHJpbmdcIiA/IGxvY2F0aW9uIDogbG9jYXRpb24ucGF0aG5hbWUgKyBsb2NhdGlvbi5zZWFyY2g7XG4gIH1cblxufVxuY29uc3QgSURMRV9UUkFOU0lUSU9OID0ge1xuICBzdGF0ZTogXCJpZGxlXCIsXG4gIHN1Ym1pc3Npb246IHVuZGVmaW5lZCxcbiAgbG9jYXRpb246IHVuZGVmaW5lZCxcbiAgdHlwZTogXCJpZGxlXCJcbn07XG5jb25zdCBJRExFX0ZFVENIRVIgPSB7XG4gIHN0YXRlOiBcImlkbGVcIixcbiAgdHlwZTogXCJpbml0XCIsXG4gIGRhdGE6IHVuZGVmaW5lZCxcbiAgc3VibWlzc2lvbjogdW5kZWZpbmVkXG59O1xuZnVuY3Rpb24gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIoaW5pdCkge1xuICBsZXQge1xuICAgIHJvdXRlc1xuICB9ID0gaW5pdDtcbiAgbGV0IHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlcjtcbiAgbGV0IGZldGNoQ29udHJvbGxlcnMgPSBuZXcgTWFwKCk7XG4gIGxldCBpbmNyZW1lbnRpbmdMb2FkSWQgPSAwO1xuICBsZXQgbmF2aWdhdGlvbkxvYWRJZCA9IC0xO1xuICBsZXQgZmV0Y2hSZWxvYWRJZHMgPSBuZXcgTWFwKCk7XG4gIGxldCBtYXRjaGVzID0gbWF0Y2hDbGllbnRSb3V0ZXMocm91dGVzLCBpbml0LmxvY2F0aW9uKTtcblxuICBpZiAoIW1hdGNoZXMpIHtcbiAgICAvLyBJZiB3ZSBkbyBub3QgbWF0Y2ggYSB1c2VyLXByb3ZpZGVkLXJvdXRlLCBmYWxsIGJhY2sgdG8gdGhlIHJvb3RcbiAgICAvLyB0byBhbGxvdyB0aGUgQ2F0Y2hCb3VuZGFyeSB0byB0YWtlIG92ZXJcbiAgICBtYXRjaGVzID0gW3tcbiAgICAgIHBhcmFtczoge30sXG4gICAgICBwYXRobmFtZTogXCJcIixcbiAgICAgIHJvdXRlOiByb3V0ZXNbMF1cbiAgICB9XTtcbiAgfVxuXG4gIGxldCBzdGF0ZSA9IHtcbiAgICBsb2NhdGlvbjogaW5pdC5sb2NhdGlvbixcbiAgICBsb2FkZXJEYXRhOiBpbml0LmxvYWRlckRhdGEgfHwge30sXG4gICAgYWN0aW9uRGF0YTogaW5pdC5hY3Rpb25EYXRhLFxuICAgIGNhdGNoOiBpbml0LmNhdGNoLFxuICAgIGVycm9yOiBpbml0LmVycm9yLFxuICAgIGNhdGNoQm91bmRhcnlJZDogaW5pdC5jYXRjaEJvdW5kYXJ5SWQgfHwgbnVsbCxcbiAgICBlcnJvckJvdW5kYXJ5SWQ6IGluaXQuZXJyb3JCb3VuZGFyeUlkIHx8IG51bGwsXG4gICAgbWF0Y2hlcyxcbiAgICBuZXh0TWF0Y2hlczogdW5kZWZpbmVkLFxuICAgIHRyYW5zaXRpb246IElETEVfVFJBTlNJVElPTixcbiAgICBmZXRjaGVyczogbmV3IE1hcCgpXG4gIH07XG5cbiAgZnVuY3Rpb24gdXBkYXRlKHVwZGF0ZXMpIHtcbiAgICBzdGF0ZSA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCB1cGRhdGVzKTtcbiAgICBpbml0Lm9uQ2hhbmdlKHN0YXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFN0YXRlKCkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEZldGNoZXIoa2V5KSB7XG4gICAgcmV0dXJuIHN0YXRlLmZldGNoZXJzLmdldChrZXkpIHx8IElETEVfRkVUQ0hFUjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGV0ZUZldGNoZXIoa2V5KSB7XG4gICAgaWYgKGZldGNoQ29udHJvbGxlcnMuaGFzKGtleSkpIGFib3J0RmV0Y2hlcihrZXkpO1xuICAgIGZldGNoUmVsb2FkSWRzLmRlbGV0ZShrZXkpO1xuICAgIHN0YXRlLmZldGNoZXJzLmRlbGV0ZShrZXkpO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gc2VuZChldmVudCkge1xuICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgY2FzZSBcIm5hdmlnYXRpb25cIjpcbiAgICAgICAge1xuICAgICAgICAgIGxldCB7XG4gICAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgICAgIHN1Ym1pc3Npb25cbiAgICAgICAgICB9ID0gZXZlbnQ7XG4gICAgICAgICAgbGV0IG1hdGNoZXMgPSBtYXRjaENsaWVudFJvdXRlcyhyb3V0ZXMsIGxvY2F0aW9uKTtcblxuICAgICAgICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgICAgICAgbWF0Y2hlcyA9IFt7XG4gICAgICAgICAgICAgIHBhcmFtczoge30sXG4gICAgICAgICAgICAgIHBhdGhuYW1lOiBcIlwiLFxuICAgICAgICAgICAgICByb3V0ZTogcm91dGVzWzBdXG4gICAgICAgICAgICB9XTtcbiAgICAgICAgICAgIGF3YWl0IGhhbmRsZU5vdEZvdW5kTmF2aWdhdGlvbihsb2NhdGlvbiwgbWF0Y2hlcyk7XG4gICAgICAgICAgfSBlbHNlIGlmICghc3VibWlzc2lvbiAmJiBpc0hhc2hDaGFuZ2VPbmx5KGxvY2F0aW9uKSkge1xuICAgICAgICAgICAgYXdhaXQgaGFuZGxlSGFzaENoYW5nZShsb2NhdGlvbiwgbWF0Y2hlcyk7XG4gICAgICAgICAgfSAvLyBiYWNrL2ZvcndhcmQgYnV0dG9uLCB0cmVhdCBhbGwgYXMgbm9ybWFsIG5hdmlnYXRpb25cbiAgICAgICAgICBlbHNlIGlmIChhY3Rpb24gPT09IEFjdGlvbi5Qb3ApIHtcbiAgICAgICAgICAgIGF3YWl0IGhhbmRsZUxvYWQobG9jYXRpb24sIG1hdGNoZXMpO1xuICAgICAgICAgIH0gLy8gPEZvcm0gbWV0aG9kPVwicG9zdCB8IHB1dCB8IGRlbGV0ZSB8IHBhdGNoXCI+XG4gICAgICAgICAgZWxzZSBpZiAoc3VibWlzc2lvbiAmJiBpc0FjdGlvblN1Ym1pc3Npb24oc3VibWlzc2lvbikpIHtcbiAgICAgICAgICAgIGF3YWl0IGhhbmRsZUFjdGlvblN1Ym1pc3Npb25OYXZpZ2F0aW9uKGxvY2F0aW9uLCBzdWJtaXNzaW9uLCBtYXRjaGVzKTtcbiAgICAgICAgICB9IC8vIDxGb3JtIG1ldGhvZD1cImdldFwiLz5cbiAgICAgICAgICBlbHNlIGlmIChzdWJtaXNzaW9uICYmIGlzTG9hZGVyU3VibWlzc2lvbihzdWJtaXNzaW9uKSkge1xuICAgICAgICAgICAgYXdhaXQgaGFuZGxlTG9hZGVyU3VibWlzc2lvbk5hdmlnYXRpb24obG9jYXRpb24sIHN1Ym1pc3Npb24sIG1hdGNoZXMpO1xuICAgICAgICAgIH0gLy8gYWN0aW9uPT5yZWRpcmVjdFxuICAgICAgICAgIGVsc2UgaWYgKGlzQWN0aW9uUmVkaXJlY3RMb2NhdGlvbihsb2NhdGlvbikpIHtcbiAgICAgICAgICAgIGF3YWl0IGhhbmRsZUFjdGlvblJlZGlyZWN0KGxvY2F0aW9uLCBtYXRjaGVzKTtcbiAgICAgICAgICB9IC8vIDxGb3JtIG1ldGhvZD1cImdldFwiPiAtLT4gbG9hZGVyPT5yZWRpcmVjdFxuICAgICAgICAgIGVsc2UgaWYgKGlzTG9hZGVyU3VibWlzc2lvblJlZGlyZWN0TG9jYXRpb24obG9jYXRpb24pKSB7XG4gICAgICAgICAgICBhd2FpdCBoYW5kbGVMb2FkZXJTdWJtaXNzaW9uUmVkaXJlY3QobG9jYXRpb24sIG1hdGNoZXMpO1xuICAgICAgICAgIH0gLy8gbG9hZGVyPT5yZWRpcmVjdFxuICAgICAgICAgIGVsc2UgaWYgKGlzTG9hZGVyUmVkaXJlY3RMb2NhdGlvbihsb2NhdGlvbikpIHtcbiAgICAgICAgICAgIGF3YWl0IGhhbmRsZUxvYWRlclJlZGlyZWN0KGxvY2F0aW9uLCBtYXRjaGVzKTtcbiAgICAgICAgICB9IC8vIHVzZVN1Ym1pc3Npb24oKT0+cmVkaXJlY3RcbiAgICAgICAgICBlbHNlIGlmIChpc0ZldGNoQWN0aW9uUmVkaXJlY3QobG9jYXRpb24pKSB7XG4gICAgICAgICAgICBhd2FpdCBoYW5kbGVGZXRjaEFjdGlvblJlZGlyZWN0KGxvY2F0aW9uLCBtYXRjaGVzKTtcbiAgICAgICAgICB9IC8vIDxMaW5rPiwgbmF2aWdhdGUoKVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgaGFuZGxlTG9hZChsb2NhdGlvbiwgbWF0Y2hlcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmF2aWdhdGlvbkxvYWRJZCA9IC0xO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJmZXRjaGVyXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBsZXQge1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgc3VibWlzc2lvbixcbiAgICAgICAgICAgIGhyZWZcbiAgICAgICAgICB9ID0gZXZlbnQ7XG4gICAgICAgICAgbGV0IG1hdGNoZXMgPSBtYXRjaENsaWVudFJvdXRlcyhyb3V0ZXMsIGhyZWYpO1xuICAgICAgICAgIGludmFyaWFudChtYXRjaGVzLCBcIk5vIG1hdGNoZXMgZm91bmRcIik7XG4gICAgICAgICAgbGV0IG1hdGNoID0gbWF0Y2hlcy5zbGljZSgtMSlbMF07XG4gICAgICAgICAgaWYgKGZldGNoQ29udHJvbGxlcnMuaGFzKGtleSkpIGFib3J0RmV0Y2hlcihrZXkpO1xuXG4gICAgICAgICAgaWYgKHN1Ym1pc3Npb24gJiYgaXNBY3Rpb25TdWJtaXNzaW9uKHN1Ym1pc3Npb24pKSB7XG4gICAgICAgICAgICBhd2FpdCBoYW5kbGVBY3Rpb25GZXRjaFN1Ym1pc3Npb24oa2V5LCBzdWJtaXNzaW9uLCBtYXRjaCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdWJtaXNzaW9uICYmIGlzTG9hZGVyU3VibWlzc2lvbihzdWJtaXNzaW9uKSkge1xuICAgICAgICAgICAgYXdhaXQgaGFuZGxlTG9hZGVyRmV0Y2hTdWJtaXNzaW9uKGhyZWYsIGtleSwgc3VibWlzc2lvbiwgbWF0Y2gpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCBoYW5kbGVMb2FkZXJGZXRjaChocmVmLCBrZXksIG1hdGNoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBkYXRhIGV2ZW50IHR5cGU6ICR7ZXZlbnQudHlwZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgYWJvcnROb3JtYWxOYXZpZ2F0aW9uKCk7XG5cbiAgICBmb3IgKGxldCBbLCBjb250cm9sbGVyXSBvZiBmZXRjaENvbnRyb2xsZXJzKSB7XG4gICAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlQWN0aW9uRmV0Y2hTdWJtaXNzaW9uKGtleSwgc3VibWlzc2lvbiwgbWF0Y2gpIHtcbiAgICBsZXQgY3VycmVudEZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcbiAgICBsZXQgZmV0Y2hlciA9IHtcbiAgICAgIHN0YXRlOiBcInN1Ym1pdHRpbmdcIixcbiAgICAgIHR5cGU6IFwiYWN0aW9uU3VibWlzc2lvblwiLFxuICAgICAgc3VibWlzc2lvbixcbiAgICAgIGRhdGE6IChjdXJyZW50RmV0Y2hlciA9PT0gbnVsbCB8fCBjdXJyZW50RmV0Y2hlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudEZldGNoZXIuZGF0YSkgfHwgdW5kZWZpbmVkXG4gICAgfTtcbiAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBmZXRjaGVyKTtcbiAgICB1cGRhdGUoe1xuICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpXG4gICAgfSk7XG4gICAgbGV0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgZmV0Y2hDb250cm9sbGVycy5zZXQoa2V5LCBjb250cm9sbGVyKTtcbiAgICBsZXQgcmVzdWx0ID0gYXdhaXQgY2FsbEFjdGlvbihzdWJtaXNzaW9uLCBtYXRjaCwgY29udHJvbGxlci5zaWduYWwpO1xuXG4gICAgaWYgKGNvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBsZXQgbG9jYXRpb25TdGF0ZSA9IHtcbiAgICAgICAgaXNSZWRpcmVjdDogdHJ1ZSxcbiAgICAgICAgdHlwZTogXCJmZXRjaEFjdGlvblwiXG4gICAgICB9O1xuICAgICAgaW5pdC5vblJlZGlyZWN0KHJlc3VsdC52YWx1ZS5sb2NhdGlvbiwgbG9jYXRpb25TdGF0ZSk7XG4gICAgICBsZXQgZG9uZUZldGNoZXIgPSB7XG4gICAgICAgIHN0YXRlOiBcImlkbGVcIixcbiAgICAgICAgdHlwZTogXCJkb25lXCIsXG4gICAgICAgIGRhdGE6IHJlc3VsdC52YWx1ZSxcbiAgICAgICAgc3VibWlzc2lvbjogdW5kZWZpbmVkXG4gICAgICB9O1xuICAgICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgZG9uZUZldGNoZXIpO1xuICAgICAgdXBkYXRlKHtcbiAgICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobWF5YmVCYWlsT25FcnJvcihtYXRjaCwga2V5LCByZXN1bHQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGF3YWl0IG1heWJlQmFpbE9uQ2F0Y2gobWF0Y2gsIGtleSwgcmVzdWx0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBsb2FkRmV0Y2hlciA9IHtcbiAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgIHR5cGU6IFwiYWN0aW9uUmVsb2FkXCIsXG4gICAgICBkYXRhOiByZXN1bHQudmFsdWUsXG4gICAgICBzdWJtaXNzaW9uXG4gICAgfTtcbiAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBsb2FkRmV0Y2hlcik7XG4gICAgdXBkYXRlKHtcbiAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxuICAgIH0pO1xuICAgIGxldCBtYXliZUFjdGlvbkVycm9yUmVzdWx0ID0gaXNFcnJvclJlc3VsdChyZXN1bHQpID8gcmVzdWx0IDogdW5kZWZpbmVkO1xuICAgIGxldCBtYXliZUFjdGlvbkNhdGNoUmVzdWx0ID0gaXNDYXRjaFJlc3VsdChyZXN1bHQpID8gcmVzdWx0IDogdW5kZWZpbmVkO1xuICAgIGxldCBsb2FkSWQgPSArK2luY3JlbWVudGluZ0xvYWRJZDtcbiAgICBmZXRjaFJlbG9hZElkcy5zZXQoa2V5LCBsb2FkSWQpO1xuICAgIGxldCBtYXRjaGVzVG9Mb2FkID0gc3RhdGUubmV4dE1hdGNoZXMgfHwgc3RhdGUubWF0Y2hlcztcbiAgICBsZXQgaHJlZlRvTG9hZCA9IGNyZWF0ZUhyZWYoc3RhdGUudHJhbnNpdGlvbi5sb2NhdGlvbiB8fCBzdGF0ZS5sb2NhdGlvbik7XG4gICAgbGV0IHJlc3VsdHMgPSBhd2FpdCBjYWxsTG9hZGVycyhzdGF0ZSwgY3JlYXRlVXJsKGhyZWZUb0xvYWQpLCBtYXRjaGVzVG9Mb2FkLCBjb250cm9sbGVyLnNpZ25hbCwgbWF5YmVBY3Rpb25FcnJvclJlc3VsdCwgbWF5YmVBY3Rpb25DYXRjaFJlc3VsdCwgc3VibWlzc2lvbiwgbWF0Y2gucm91dGUuaWQsIGxvYWRGZXRjaGVyKTtcblxuICAgIGlmIChjb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZmV0Y2hSZWxvYWRJZHMuZGVsZXRlKGtleSk7XG4gICAgZmV0Y2hDb250cm9sbGVycy5kZWxldGUoa2V5KTtcbiAgICBsZXQgcmVkaXJlY3QgPSBmaW5kUmVkaXJlY3QocmVzdWx0cyk7XG5cbiAgICBpZiAocmVkaXJlY3QpIHtcbiAgICAgIGxldCBsb2NhdGlvblN0YXRlID0ge1xuICAgICAgICBpc1JlZGlyZWN0OiB0cnVlLFxuICAgICAgICB0eXBlOiBcImxvYWRlclwiXG4gICAgICB9O1xuICAgICAgaW5pdC5vblJlZGlyZWN0KHJlZGlyZWN0LmxvY2F0aW9uLCBsb2NhdGlvblN0YXRlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgW2Vycm9yLCBlcnJvckJvdW5kYXJ5SWRdID0gZmluZEVycm9yQW5kQm91bmRhcnlJZChyZXN1bHRzLCBzdGF0ZS5tYXRjaGVzLCBtYXliZUFjdGlvbkVycm9yUmVzdWx0KTtcbiAgICBsZXQgW2NhdGNoVmFsLCBjYXRjaEJvdW5kYXJ5SWRdID0gYXdhaXQgZmluZENhdGNoQW5kQm91bmRhcnlJZChyZXN1bHRzLCBzdGF0ZS5tYXRjaGVzLCBtYXliZUFjdGlvbkNhdGNoUmVzdWx0KTtcbiAgICBsZXQgZG9uZUZldGNoZXIgPSB7XG4gICAgICBzdGF0ZTogXCJpZGxlXCIsXG4gICAgICB0eXBlOiBcImRvbmVcIixcbiAgICAgIGRhdGE6IHJlc3VsdC52YWx1ZSxcbiAgICAgIHN1Ym1pc3Npb246IHVuZGVmaW5lZFxuICAgIH07XG4gICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgZG9uZUZldGNoZXIpO1xuICAgIGxldCBhYm9ydGVkS2V5cyA9IGFib3J0U3RhbGVGZXRjaExvYWRzKGxvYWRJZCk7XG5cbiAgICBpZiAoYWJvcnRlZEtleXMpIHtcbiAgICAgIG1hcmtGZXRjaGVyc0RvbmUoYWJvcnRlZEtleXMpO1xuICAgIH1cblxuICAgIGxldCB5ZWV0ZWROYXZpZ2F0aW9uID0geWVldFN0YWxlTmF2aWdhdGlvbkxvYWQobG9hZElkKTsgLy8gbmVlZCB0byBkbyB3aGF0IHdlIHdvdWxkIGhhdmUgZG9uZSB3aGVuIHRoZSBuYXZpZ2F0aW9uIGxvYWQgY29tcGxldGVkXG5cbiAgICBpZiAoeWVldGVkTmF2aWdhdGlvbikge1xuICAgICAgbGV0IHtcbiAgICAgICAgdHJhbnNpdGlvblxuICAgICAgfSA9IHN0YXRlO1xuICAgICAgaW52YXJpYW50KHRyYW5zaXRpb24uc3RhdGUgPT09IFwibG9hZGluZ1wiLCBcIkV4cGVjdGVkIGxvYWRpbmcgdHJhbnNpdGlvblwiKTtcbiAgICAgIHVwZGF0ZSh7XG4gICAgICAgIGxvY2F0aW9uOiB0cmFuc2l0aW9uLmxvY2F0aW9uLFxuICAgICAgICBtYXRjaGVzOiBzdGF0ZS5uZXh0TWF0Y2hlcyxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIGVycm9yQm91bmRhcnlJZCxcbiAgICAgICAgY2F0Y2g6IGNhdGNoVmFsLFxuICAgICAgICBjYXRjaEJvdW5kYXJ5SWQsXG4gICAgICAgIGxvYWRlckRhdGE6IG1ha2VMb2FkZXJEYXRhKHN0YXRlLCByZXN1bHRzLCBtYXRjaGVzVG9Mb2FkKSxcbiAgICAgICAgYWN0aW9uRGF0YTogdHJhbnNpdGlvbi50eXBlID09PSBcImFjdGlvblJlbG9hZFwiID8gc3RhdGUuYWN0aW9uRGF0YSA6IHVuZGVmaW5lZCxcbiAgICAgICAgdHJhbnNpdGlvbjogSURMRV9UUkFOU0lUSU9OLFxuICAgICAgICBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycylcbiAgICAgIH0pO1xuICAgIH0gLy8gb3RoZXJ3aXNlIGp1c3QgdXBkYXRlIHRoZSBpbmZvIGZvciB0aGUgZGF0YVxuICAgIGVsc2Uge1xuICAgICAgdXBkYXRlKHtcbiAgICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgZXJyb3JCb3VuZGFyeUlkLFxuICAgICAgICBsb2FkZXJEYXRhOiBtYWtlTG9hZGVyRGF0YShzdGF0ZSwgcmVzdWx0cywgbWF0Y2hlc1RvTG9hZClcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHllZXRTdGFsZU5hdmlnYXRpb25Mb2FkKGxhbmRlZElkKSB7XG4gICAgbGV0IGlzTG9hZGluZ05hdmlnYXRpb24gPSBzdGF0ZS50cmFuc2l0aW9uLnN0YXRlID09PSBcImxvYWRpbmdcIjtcblxuICAgIGlmIChpc0xvYWRpbmdOYXZpZ2F0aW9uICYmIG5hdmlnYXRpb25Mb2FkSWQgPCBsYW5kZWRJZCkge1xuICAgICAgYWJvcnROb3JtYWxOYXZpZ2F0aW9uKCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrRmV0Y2hlcnNEb25lKGtleXMpIHtcbiAgICBmb3IgKGxldCBrZXkgb2Yga2V5cykge1xuICAgICAgbGV0IGZldGNoZXIgPSBnZXRGZXRjaGVyKGtleSk7XG4gICAgICBsZXQgZG9uZUZldGNoZXIgPSB7XG4gICAgICAgIHN0YXRlOiBcImlkbGVcIixcbiAgICAgICAgdHlwZTogXCJkb25lXCIsXG4gICAgICAgIGRhdGE6IGZldGNoZXIuZGF0YSxcbiAgICAgICAgc3VibWlzc2lvbjogdW5kZWZpbmVkXG4gICAgICB9O1xuICAgICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgZG9uZUZldGNoZXIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFib3J0U3RhbGVGZXRjaExvYWRzKGxhbmRlZElkKSB7XG4gICAgbGV0IHllZXRlZEtleXMgPSBbXTtcblxuICAgIGZvciAobGV0IFtrZXksIGlkXSBvZiBmZXRjaFJlbG9hZElkcykge1xuICAgICAgaWYgKGlkIDwgbGFuZGVkSWQpIHtcbiAgICAgICAgbGV0IGZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcbiAgICAgICAgaW52YXJpYW50KGZldGNoZXIsIGBFeHBlY3RlZCBmZXRjaGVyOiAke2tleX1gKTtcblxuICAgICAgICBpZiAoZmV0Y2hlci5zdGF0ZSA9PT0gXCJsb2FkaW5nXCIpIHtcbiAgICAgICAgICBhYm9ydEZldGNoZXIoa2V5KTtcbiAgICAgICAgICBmZXRjaFJlbG9hZElkcy5kZWxldGUoa2V5KTtcbiAgICAgICAgICB5ZWV0ZWRLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB5ZWV0ZWRLZXlzLmxlbmd0aCA/IHllZXRlZEtleXMgOiBmYWxzZTtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUxvYWRlckZldGNoU3VibWlzc2lvbihocmVmLCBrZXksIHN1Ym1pc3Npb24sIG1hdGNoKSB7XG4gICAgbGV0IGN1cnJlbnRGZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSk7XG4gICAgbGV0IGZldGNoZXIgPSB7XG4gICAgICBzdGF0ZTogXCJzdWJtaXR0aW5nXCIsXG4gICAgICB0eXBlOiBcImxvYWRlclN1Ym1pc3Npb25cIixcbiAgICAgIHN1Ym1pc3Npb24sXG4gICAgICBkYXRhOiAoY3VycmVudEZldGNoZXIgPT09IG51bGwgfHwgY3VycmVudEZldGNoZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnRGZXRjaGVyLmRhdGEpIHx8IHVuZGVmaW5lZFxuICAgIH07XG4gICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgZmV0Y2hlcik7XG4gICAgdXBkYXRlKHtcbiAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxuICAgIH0pO1xuICAgIGxldCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGZldGNoQ29udHJvbGxlcnMuc2V0KGtleSwgY29udHJvbGxlcik7XG4gICAgbGV0IHJlc3VsdCA9IGF3YWl0IGNhbGxMb2FkZXIobWF0Y2gsIGNyZWF0ZVVybChocmVmKSwgY29udHJvbGxlci5zaWduYWwpO1xuICAgIGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKGtleSk7XG5cbiAgICBpZiAoY29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGxldCBsb2NhdGlvblN0YXRlID0ge1xuICAgICAgICBpc1JlZGlyZWN0OiB0cnVlLFxuICAgICAgICB0eXBlOiBcImxvYWRlclwiXG4gICAgICB9O1xuICAgICAgaW5pdC5vblJlZGlyZWN0KHJlc3VsdC52YWx1ZS5sb2NhdGlvbiwgbG9jYXRpb25TdGF0ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG1heWJlQmFpbE9uRXJyb3IobWF0Y2gsIGtleSwgcmVzdWx0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChhd2FpdCBtYXliZUJhaWxPbkNhdGNoKG1hdGNoLCBrZXksIHJlc3VsdCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgZG9uZUZldGNoZXIgPSB7XG4gICAgICBzdGF0ZTogXCJpZGxlXCIsXG4gICAgICB0eXBlOiBcImRvbmVcIixcbiAgICAgIGRhdGE6IHJlc3VsdC52YWx1ZSxcbiAgICAgIHN1Ym1pc3Npb246IHVuZGVmaW5lZFxuICAgIH07XG4gICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgZG9uZUZldGNoZXIpO1xuICAgIHVwZGF0ZSh7XG4gICAgICBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycylcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUxvYWRlckZldGNoKGhyZWYsIGtleSwgbWF0Y2gpIHtcbiAgICBpZiAodHlwZW9mIEFib3J0Q29udHJvbGxlciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaGFuZGxlTG9hZGVyRmV0Y2ggd2FzIGNhbGxlZCBkdXJpbmcgdGhlIHNlcnZlciByZW5kZXIsIGJ1dCBpdCBzaG91bGRuJ3QgYmUuIFwiICsgXCJZb3UgYXJlIGxpa2VseSBjYWxsaW5nIHVzZUZldGNoZXIubG9hZCgpIGluIHRoZSBib2R5IG9mIHlvdXIgY29tcG9uZW50LiBcIiArIFwiVHJ5IG1vdmluZyBpdCB0byBhIHVzZUVmZmVjdCBvciBhIGNhbGxiYWNrLlwiKTtcbiAgICB9XG5cbiAgICBsZXQgY3VycmVudEZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcbiAgICBsZXQgZmV0Y2hlciA9IHtcbiAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgIHR5cGU6IFwibm9ybWFsTG9hZFwiLFxuICAgICAgc3VibWlzc2lvbjogdW5kZWZpbmVkLFxuICAgICAgZGF0YTogKGN1cnJlbnRGZXRjaGVyID09PSBudWxsIHx8IGN1cnJlbnRGZXRjaGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50RmV0Y2hlci5kYXRhKSB8fCB1bmRlZmluZWRcbiAgICB9O1xuICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGZldGNoZXIpO1xuICAgIHVwZGF0ZSh7XG4gICAgICBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycylcbiAgICB9KTtcbiAgICBsZXQgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBmZXRjaENvbnRyb2xsZXJzLnNldChrZXksIGNvbnRyb2xsZXIpO1xuICAgIGxldCByZXN1bHQgPSBhd2FpdCBjYWxsTG9hZGVyKG1hdGNoLCBjcmVhdGVVcmwoaHJlZiksIGNvbnRyb2xsZXIuc2lnbmFsKTtcbiAgICBpZiAoY29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkgcmV0dXJuO1xuICAgIGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKGtleSk7XG5cbiAgICBpZiAoaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBsZXQgbG9jYXRpb25TdGF0ZSA9IHtcbiAgICAgICAgaXNSZWRpcmVjdDogdHJ1ZSxcbiAgICAgICAgdHlwZTogXCJsb2FkZXJcIlxuICAgICAgfTtcbiAgICAgIGluaXQub25SZWRpcmVjdChyZXN1bHQudmFsdWUubG9jYXRpb24sIGxvY2F0aW9uU3RhdGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChtYXliZUJhaWxPbkVycm9yKG1hdGNoLCBrZXksIHJlc3VsdCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoYXdhaXQgbWF5YmVCYWlsT25DYXRjaChtYXRjaCwga2V5LCByZXN1bHQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGRvbmVGZXRjaGVyID0ge1xuICAgICAgc3RhdGU6IFwiaWRsZVwiLFxuICAgICAgdHlwZTogXCJkb25lXCIsXG4gICAgICBkYXRhOiByZXN1bHQudmFsdWUsXG4gICAgICBzdWJtaXNzaW9uOiB1bmRlZmluZWRcbiAgICB9O1xuICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGRvbmVGZXRjaGVyKTtcbiAgICB1cGRhdGUoe1xuICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpXG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBtYXliZUJhaWxPbkNhdGNoKG1hdGNoLCBrZXksIHJlc3VsdCkge1xuICAgIGlmIChpc0NhdGNoUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGxldCBjYXRjaEJvdW5kYXJ5SWQgPSBmaW5kTmVhcmVzdENhdGNoQm91bmRhcnkobWF0Y2gsIHN0YXRlLm1hdGNoZXMpO1xuICAgICAgc3RhdGUuZmV0Y2hlcnMuZGVsZXRlKGtleSk7XG4gICAgICB1cGRhdGUoe1xuICAgICAgICB0cmFuc2l0aW9uOiBJRExFX1RSQU5TSVRJT04sXG4gICAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSxcbiAgICAgICAgY2F0Y2g6IHtcbiAgICAgICAgICBkYXRhOiByZXN1bHQudmFsdWUuZGF0YSxcbiAgICAgICAgICBzdGF0dXM6IHJlc3VsdC52YWx1ZS5zdGF0dXMsXG4gICAgICAgICAgc3RhdHVzVGV4dDogcmVzdWx0LnZhbHVlLnN0YXR1c1RleHRcbiAgICAgICAgfSxcbiAgICAgICAgY2F0Y2hCb3VuZGFyeUlkXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1heWJlQmFpbE9uRXJyb3IobWF0Y2gsIGtleSwgcmVzdWx0KSB7XG4gICAgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSkge1xuICAgICAgbGV0IGVycm9yQm91bmRhcnlJZCA9IGZpbmROZWFyZXN0Qm91bmRhcnkobWF0Y2gsIHN0YXRlLm1hdGNoZXMpO1xuICAgICAgc3RhdGUuZmV0Y2hlcnMuZGVsZXRlKGtleSk7XG4gICAgICB1cGRhdGUoe1xuICAgICAgICBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycyksXG4gICAgICAgIGVycm9yOiByZXN1bHQudmFsdWUsXG4gICAgICAgIGVycm9yQm91bmRhcnlJZFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVOb3RGb3VuZE5hdmlnYXRpb24obG9jYXRpb24sIG1hdGNoZXMpIHtcbiAgICBhYm9ydE5vcm1hbE5hdmlnYXRpb24oKTtcbiAgICBsZXQgdHJhbnNpdGlvbiA9IHtcbiAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgIHR5cGU6IFwibm9ybWFsTG9hZFwiLFxuICAgICAgc3VibWlzc2lvbjogdW5kZWZpbmVkLFxuICAgICAgbG9jYXRpb25cbiAgICB9O1xuICAgIHVwZGF0ZSh7XG4gICAgICB0cmFuc2l0aW9uLFxuICAgICAgbmV4dE1hdGNoZXM6IG1hdGNoZXNcbiAgICB9KTsgLy8gRm9yY2UgYXN5bmMgc28gVUkgY29kZSBkb2Vzbid0IGhhdmUgdG8gc3BlY2lhbCBub3QgZm91bmQgcm91dGUgY2hhbmdlcyBub3RcbiAgICAvLyBza2lwcGluZyB0aGUgcGVuZGluZyBzdGF0ZSAobGlrZSBzY3JvbGwgcmVzdG9yYXRpb24gZ2V0cyByZWFsbHlcbiAgICAvLyBjb21wbGljYXRlZCB3aXRob3V0IHRoZSBwZW5kaW5nIHN0YXRlLCBtYXliZSB3ZSBjYW4gZmlndXJlIHNvbWV0aGluZyBlbHNlXG4gICAgLy8gb3V0IGxhdGVyLCBidXQgdGhpcyB3b3JrcyBncmVhdC4pXG5cbiAgICBhd2FpdCBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBsZXQgY2F0Y2hCb3VuZGFyeUlkID0gZmluZE5lYXJlc3RDYXRjaEJvdW5kYXJ5KG1hdGNoZXNbMF0sIG1hdGNoZXMpO1xuICAgIHVwZGF0ZSh7XG4gICAgICBsb2NhdGlvbixcbiAgICAgIG1hdGNoZXMsXG4gICAgICBjYXRjaDoge1xuICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICBzdGF0dXM6IDQwNCxcbiAgICAgICAgc3RhdHVzVGV4dDogXCJOb3QgRm91bmRcIlxuICAgICAgfSxcbiAgICAgIGNhdGNoQm91bmRhcnlJZCxcbiAgICAgIHRyYW5zaXRpb246IElETEVfVFJBTlNJVElPTlxuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlQWN0aW9uU3VibWlzc2lvbk5hdmlnYXRpb24obG9jYXRpb24sIHN1Ym1pc3Npb24sIG1hdGNoZXMpIHtcbiAgICBhYm9ydE5vcm1hbE5hdmlnYXRpb24oKTtcbiAgICBsZXQgdHJhbnNpdGlvbiA9IHtcbiAgICAgIHN0YXRlOiBcInN1Ym1pdHRpbmdcIixcbiAgICAgIHR5cGU6IFwiYWN0aW9uU3VibWlzc2lvblwiLFxuICAgICAgc3VibWlzc2lvbixcbiAgICAgIGxvY2F0aW9uXG4gICAgfTtcbiAgICB1cGRhdGUoe1xuICAgICAgdHJhbnNpdGlvbixcbiAgICAgIG5leHRNYXRjaGVzOiBtYXRjaGVzXG4gICAgfSk7XG4gICAgbGV0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyID0gY29udHJvbGxlcjtcblxuICAgIGlmICghaXNJbmRleFJlcXVlc3RBY3Rpb24oc3VibWlzc2lvbi5hY3Rpb24pICYmIG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXS5yb3V0ZS5pZC5lbmRzV2l0aChcIi9pbmRleFwiKSkge1xuICAgICAgbWF0Y2hlcyA9IG1hdGNoZXMuc2xpY2UoMCwgLTEpO1xuICAgIH1cblxuICAgIGxldCBsZWFmTWF0Y2ggPSBtYXRjaGVzLnNsaWNlKC0xKVswXTtcbiAgICBsZXQgcmVzdWx0ID0gYXdhaXQgY2FsbEFjdGlvbihzdWJtaXNzaW9uLCBsZWFmTWF0Y2gsIGNvbnRyb2xsZXIuc2lnbmFsKTtcblxuICAgIGlmIChjb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSkge1xuICAgICAgbGV0IGxvY2F0aW9uU3RhdGUgPSB7XG4gICAgICAgIGlzUmVkaXJlY3Q6IHRydWUsXG4gICAgICAgIHR5cGU6IFwiYWN0aW9uXCJcbiAgICAgIH07XG4gICAgICBpbml0Lm9uUmVkaXJlY3QocmVzdWx0LnZhbHVlLmxvY2F0aW9uLCBsb2NhdGlvblN0YXRlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNDYXRjaFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBsZXQgW2NhdGNoVmFsLCBjYXRjaEJvdW5kYXJ5SWRdID0gYXdhaXQgZmluZENhdGNoQW5kQm91bmRhcnlJZChbcmVzdWx0XSwgbWF0Y2hlcywgcmVzdWx0KTtcbiAgICAgIHVwZGF0ZSh7XG4gICAgICAgIHRyYW5zaXRpb246IElETEVfVFJBTlNJVElPTixcbiAgICAgICAgY2F0Y2g6IGNhdGNoVmFsLFxuICAgICAgICBjYXRjaEJvdW5kYXJ5SWRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBsb2FkVHJhbnNpdGlvbiA9IHtcbiAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgIHR5cGU6IFwiYWN0aW9uUmVsb2FkXCIsXG4gICAgICBzdWJtaXNzaW9uLFxuICAgICAgbG9jYXRpb25cbiAgICB9O1xuICAgIHVwZGF0ZSh7XG4gICAgICB0cmFuc2l0aW9uOiBsb2FkVHJhbnNpdGlvbixcbiAgICAgIGFjdGlvbkRhdGE6IHtcbiAgICAgICAgW2xlYWZNYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC52YWx1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIGF3YWl0IGxvYWRQYWdlRGF0YShsb2NhdGlvbiwgbWF0Y2hlcywgc3VibWlzc2lvbiwgbGVhZk1hdGNoLnJvdXRlLmlkLCByZXN1bHQpO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlTG9hZGVyU3VibWlzc2lvbk5hdmlnYXRpb24obG9jYXRpb24sIHN1Ym1pc3Npb24sIG1hdGNoZXMpIHtcbiAgICBhYm9ydE5vcm1hbE5hdmlnYXRpb24oKTtcbiAgICBsZXQgdHJhbnNpdGlvbiA9IHtcbiAgICAgIHN0YXRlOiBcInN1Ym1pdHRpbmdcIixcbiAgICAgIHR5cGU6IFwibG9hZGVyU3VibWlzc2lvblwiLFxuICAgICAgc3VibWlzc2lvbixcbiAgICAgIGxvY2F0aW9uXG4gICAgfTtcbiAgICB1cGRhdGUoe1xuICAgICAgdHJhbnNpdGlvbixcbiAgICAgIG5leHRNYXRjaGVzOiBtYXRjaGVzXG4gICAgfSk7XG4gICAgYXdhaXQgbG9hZFBhZ2VEYXRhKGxvY2F0aW9uLCBtYXRjaGVzLCBzdWJtaXNzaW9uKTtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUhhc2hDaGFuZ2UobG9jYXRpb24sIG1hdGNoZXMpIHtcbiAgICBhYm9ydE5vcm1hbE5hdmlnYXRpb24oKTtcbiAgICBsZXQgdHJhbnNpdGlvbiA9IHtcbiAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgIHR5cGU6IFwibm9ybWFsTG9hZFwiLFxuICAgICAgc3VibWlzc2lvbjogdW5kZWZpbmVkLFxuICAgICAgbG9jYXRpb25cbiAgICB9O1xuICAgIHVwZGF0ZSh7XG4gICAgICB0cmFuc2l0aW9uLFxuICAgICAgbmV4dE1hdGNoZXM6IG1hdGNoZXNcbiAgICB9KTsgLy8gRm9yY2UgYXN5bmMgc28gVUkgY29kZSBkb2Vzbid0IGhhdmUgdG8gc3BlY2lhbCBjYXNlIGhhc2ggY2hhbmdlcyBub3RcbiAgICAvLyBza2lwcGluZyB0aGUgcGVuZGluZyBzdGF0ZSAobGlrZSBzY3JvbGwgcmVzdG9yYXRpb24gZ2V0cyByZWFsbHlcbiAgICAvLyBjb21wbGljYXRlZCB3aXRob3V0IHRoZSBwZW5kaW5nIHN0YXRlLCBtYXliZSB3ZSBjYW4gZmlndXJlIHNvbWV0aGluZyBlbHNlXG4gICAgLy8gb3V0IGxhdGVyLCBidXQgdGhpcyB3b3JrcyBncmVhdC4pXG5cbiAgICBhd2FpdCBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB1cGRhdGUoe1xuICAgICAgbG9jYXRpb24sXG4gICAgICBtYXRjaGVzLFxuICAgICAgdHJhbnNpdGlvbjogSURMRV9UUkFOU0lUSU9OXG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVMb2FkKGxvY2F0aW9uLCBtYXRjaGVzKSB7XG4gICAgYWJvcnROb3JtYWxOYXZpZ2F0aW9uKCk7XG4gICAgbGV0IHRyYW5zaXRpb24gPSB7XG4gICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICB0eXBlOiBcIm5vcm1hbExvYWRcIixcbiAgICAgIHN1Ym1pc3Npb246IHVuZGVmaW5lZCxcbiAgICAgIGxvY2F0aW9uXG4gICAgfTtcbiAgICB1cGRhdGUoe1xuICAgICAgdHJhbnNpdGlvbixcbiAgICAgIG5leHRNYXRjaGVzOiBtYXRjaGVzXG4gICAgfSk7XG4gICAgYXdhaXQgbG9hZFBhZ2VEYXRhKGxvY2F0aW9uLCBtYXRjaGVzKTtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUxvYWRlclJlZGlyZWN0KGxvY2F0aW9uLCBtYXRjaGVzKSB7XG4gICAgYWJvcnROb3JtYWxOYXZpZ2F0aW9uKCk7XG4gICAgbGV0IHRyYW5zaXRpb24gPSB7XG4gICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICB0eXBlOiBcIm5vcm1hbFJlZGlyZWN0XCIsXG4gICAgICBzdWJtaXNzaW9uOiB1bmRlZmluZWQsXG4gICAgICBsb2NhdGlvblxuICAgIH07XG4gICAgdXBkYXRlKHtcbiAgICAgIHRyYW5zaXRpb24sXG4gICAgICBuZXh0TWF0Y2hlczogbWF0Y2hlc1xuICAgIH0pO1xuICAgIGF3YWl0IGxvYWRQYWdlRGF0YShsb2NhdGlvbiwgbWF0Y2hlcyk7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVMb2FkZXJTdWJtaXNzaW9uUmVkaXJlY3QobG9jYXRpb24sIG1hdGNoZXMpIHtcbiAgICBhYm9ydE5vcm1hbE5hdmlnYXRpb24oKTtcbiAgICBpbnZhcmlhbnQoc3RhdGUudHJhbnNpdGlvbi50eXBlID09PSBcImxvYWRlclN1Ym1pc3Npb25cIiwgYFVuZXhwZWN0ZWQgdHJhbnNpdGlvbjogJHtKU09OLnN0cmluZ2lmeShzdGF0ZS50cmFuc2l0aW9uKX1gKTtcbiAgICBsZXQge1xuICAgICAgc3VibWlzc2lvblxuICAgIH0gPSBzdGF0ZS50cmFuc2l0aW9uO1xuICAgIGxldCB0cmFuc2l0aW9uID0ge1xuICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgdHlwZTogXCJsb2FkZXJTdWJtaXNzaW9uUmVkaXJlY3RcIixcbiAgICAgIHN1Ym1pc3Npb24sXG4gICAgICBsb2NhdGlvbjogbG9jYXRpb25cbiAgICB9O1xuICAgIHVwZGF0ZSh7XG4gICAgICB0cmFuc2l0aW9uLFxuICAgICAgbmV4dE1hdGNoZXM6IG1hdGNoZXNcbiAgICB9KTtcbiAgICBhd2FpdCBsb2FkUGFnZURhdGEobG9jYXRpb24sIG1hdGNoZXMsIHN1Ym1pc3Npb24pO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlRmV0Y2hBY3Rpb25SZWRpcmVjdChsb2NhdGlvbiwgbWF0Y2hlcykge1xuICAgIGFib3J0Tm9ybWFsTmF2aWdhdGlvbigpO1xuICAgIGxldCB0cmFuc2l0aW9uID0ge1xuICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgdHlwZTogXCJmZXRjaEFjdGlvblJlZGlyZWN0XCIsXG4gICAgICBzdWJtaXNzaW9uOiB1bmRlZmluZWQsXG4gICAgICBsb2NhdGlvblxuICAgIH07XG4gICAgdXBkYXRlKHtcbiAgICAgIHRyYW5zaXRpb24sXG4gICAgICBuZXh0TWF0Y2hlczogbWF0Y2hlc1xuICAgIH0pO1xuICAgIGF3YWl0IGxvYWRQYWdlRGF0YShsb2NhdGlvbiwgbWF0Y2hlcyk7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVBY3Rpb25SZWRpcmVjdChsb2NhdGlvbiwgbWF0Y2hlcykge1xuICAgIGFib3J0Tm9ybWFsTmF2aWdhdGlvbigpO1xuICAgIGludmFyaWFudChzdGF0ZS50cmFuc2l0aW9uLnR5cGUgPT09IFwiYWN0aW9uU3VibWlzc2lvblwiIHx8IC8vIGxvYWRlciByZWRpcmVjdGVkIGR1cmluZyBhY3Rpb24gcmVsb2FkXG4gICAgc3RhdGUudHJhbnNpdGlvbi50eXBlID09PSBcImFjdGlvblJlbG9hZFwiLCBgVW5leHBlY3RlZCB0cmFuc2l0aW9uOiAke0pTT04uc3RyaW5naWZ5KHN0YXRlLnRyYW5zaXRpb24pfWApO1xuICAgIGxldCB7XG4gICAgICBzdWJtaXNzaW9uXG4gICAgfSA9IHN0YXRlLnRyYW5zaXRpb247XG4gICAgbGV0IHRyYW5zaXRpb24gPSB7XG4gICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICB0eXBlOiBcImFjdGlvblJlZGlyZWN0XCIsXG4gICAgICBzdWJtaXNzaW9uLFxuICAgICAgbG9jYXRpb25cbiAgICB9O1xuICAgIHVwZGF0ZSh7XG4gICAgICB0cmFuc2l0aW9uLFxuICAgICAgbmV4dE1hdGNoZXM6IG1hdGNoZXNcbiAgICB9KTtcbiAgICBhd2FpdCBsb2FkUGFnZURhdGEobG9jYXRpb24sIG1hdGNoZXMsIHN1Ym1pc3Npb24pO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNIYXNoQ2hhbmdlT25seShsb2NhdGlvbikge1xuICAgIHJldHVybiBjcmVhdGVIcmVmKHN0YXRlLmxvY2F0aW9uKSA9PT0gY3JlYXRlSHJlZihsb2NhdGlvbikgJiYgc3RhdGUubG9jYXRpb24uaGFzaCAhPT0gbG9jYXRpb24uaGFzaDtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGxvYWRQYWdlRGF0YShsb2NhdGlvbiwgbWF0Y2hlcywgc3VibWlzc2lvbiwgc3VibWlzc2lvblJvdXRlSWQsIGFjdGlvblJlc3VsdCkge1xuICAgIGxldCBtYXliZUFjdGlvbkVycm9yUmVzdWx0ID0gYWN0aW9uUmVzdWx0ICYmIGlzRXJyb3JSZXN1bHQoYWN0aW9uUmVzdWx0KSA/IGFjdGlvblJlc3VsdCA6IHVuZGVmaW5lZDtcbiAgICBsZXQgbWF5YmVBY3Rpb25DYXRjaFJlc3VsdCA9IGFjdGlvblJlc3VsdCAmJiBpc0NhdGNoUmVzdWx0KGFjdGlvblJlc3VsdCkgPyBhY3Rpb25SZXN1bHQgOiB1bmRlZmluZWQ7XG4gICAgbGV0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgICBuYXZpZ2F0aW9uTG9hZElkID0gKytpbmNyZW1lbnRpbmdMb2FkSWQ7XG4gICAgbGV0IHJlc3VsdHMgPSBhd2FpdCBjYWxsTG9hZGVycyhzdGF0ZSwgY3JlYXRlVXJsKGNyZWF0ZUhyZWYobG9jYXRpb24pKSwgbWF0Y2hlcywgY29udHJvbGxlci5zaWduYWwsIG1heWJlQWN0aW9uRXJyb3JSZXN1bHQsIG1heWJlQWN0aW9uQ2F0Y2hSZXN1bHQsIHN1Ym1pc3Npb24sIHN1Ym1pc3Npb25Sb3V0ZUlkKTtcblxuICAgIGlmIChjb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IHJlZGlyZWN0ID0gZmluZFJlZGlyZWN0KHJlc3VsdHMpO1xuXG4gICAgaWYgKHJlZGlyZWN0KSB7XG4gICAgICAvLyBsb2FkZXIgcmVkaXJlY3RlZCBkdXJpbmcgYW4gYWN0aW9uIHJlbG9hZCwgdHJlYXQgaXQgbGlrZSBhblxuICAgICAgLy8gYWN0aW9uUmVkaXJlY3QgaW5zdGVhZCBzbyB0aGF0IGFsbCB0aGUgbG9hZGVycyBnZXQgY2FsbGVkIGFnYWluIGFuZCB0aGVcbiAgICAgIC8vIHN1Ym1pc3Npb24gc3RpY2tzIGFyb3VuZCBmb3Igb3B0aW1pc3RpYy9wZW5kaW5nIFVJLlxuICAgICAgaWYgKHN0YXRlLnRyYW5zaXRpb24udHlwZSA9PT0gXCJhY3Rpb25SZWxvYWRcIikge1xuICAgICAgICBsZXQgbG9jYXRpb25TdGF0ZSA9IHtcbiAgICAgICAgICBpc1JlZGlyZWN0OiB0cnVlLFxuICAgICAgICAgIHR5cGU6IFwiYWN0aW9uXCJcbiAgICAgICAgfTtcbiAgICAgICAgaW5pdC5vblJlZGlyZWN0KHJlZGlyZWN0LmxvY2F0aW9uLCBsb2NhdGlvblN0YXRlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUudHJhbnNpdGlvbi50eXBlID09PSBcImxvYWRlclN1Ym1pc3Npb25cIikge1xuICAgICAgICBsZXQgbG9jYXRpb25TdGF0ZSA9IHtcbiAgICAgICAgICBpc1JlZGlyZWN0OiB0cnVlLFxuICAgICAgICAgIHR5cGU6IFwibG9hZGVyU3VibWlzc2lvblwiXG4gICAgICAgIH07XG4gICAgICAgIGluaXQub25SZWRpcmVjdChyZWRpcmVjdC5sb2NhdGlvbiwgbG9jYXRpb25TdGF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgbG9jYXRpb25TdGF0ZSA9IHtcbiAgICAgICAgICBpc1JlZGlyZWN0OiB0cnVlLFxuICAgICAgICAgIHR5cGU6IFwibG9hZGVyXCJcbiAgICAgICAgfTtcbiAgICAgICAgaW5pdC5vblJlZGlyZWN0KHJlZGlyZWN0LmxvY2F0aW9uLCBsb2NhdGlvblN0YXRlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBbZXJyb3IsIGVycm9yQm91bmRhcnlJZF0gPSBmaW5kRXJyb3JBbmRCb3VuZGFyeUlkKHJlc3VsdHMsIG1hdGNoZXMsIG1heWJlQWN0aW9uRXJyb3JSZXN1bHQpO1xuICAgIGxldCBbY2F0Y2hWYWwsIGNhdGNoQm91bmRhcnlJZF0gPSBhd2FpdCBmaW5kQ2F0Y2hBbmRCb3VuZGFyeUlkKHJlc3VsdHMsIG1hdGNoZXMsIG1heWJlQWN0aW9uRXJyb3JSZXN1bHQpO1xuICAgIGxldCBhYm9ydGVkSWRzID0gYWJvcnRTdGFsZUZldGNoTG9hZHMobmF2aWdhdGlvbkxvYWRJZCk7XG5cbiAgICBpZiAoYWJvcnRlZElkcykge1xuICAgICAgbWFya0ZldGNoZXJzRG9uZShhYm9ydGVkSWRzKTtcbiAgICB9XG5cbiAgICB1cGRhdGUoe1xuICAgICAgbG9jYXRpb24sXG4gICAgICBtYXRjaGVzLFxuICAgICAgZXJyb3IsXG4gICAgICBlcnJvckJvdW5kYXJ5SWQsXG4gICAgICBjYXRjaDogY2F0Y2hWYWwsXG4gICAgICBjYXRjaEJvdW5kYXJ5SWQsXG4gICAgICBsb2FkZXJEYXRhOiBtYWtlTG9hZGVyRGF0YShzdGF0ZSwgcmVzdWx0cywgbWF0Y2hlcyksXG4gICAgICBhY3Rpb25EYXRhOiBzdGF0ZS50cmFuc2l0aW9uLnR5cGUgPT09IFwiYWN0aW9uUmVsb2FkXCIgPyBzdGF0ZS5hY3Rpb25EYXRhIDogdW5kZWZpbmVkLFxuICAgICAgdHJhbnNpdGlvbjogSURMRV9UUkFOU0lUSU9OLFxuICAgICAgZmV0Y2hlcnM6IGFib3J0ZWRJZHMgPyBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSA6IHN0YXRlLmZldGNoZXJzXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBhYm9ydE5vcm1hbE5hdmlnYXRpb24oKSB7XG4gICAgdmFyIF9wZW5kaW5nTmF2aWdhdGlvbkNvbjtcblxuICAgIChfcGVuZGluZ05hdmlnYXRpb25Db24gPSBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIpID09PSBudWxsIHx8IF9wZW5kaW5nTmF2aWdhdGlvbkNvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3BlbmRpbmdOYXZpZ2F0aW9uQ29uLmFib3J0KCk7XG4gIH1cblxuICBmdW5jdGlvbiBhYm9ydEZldGNoZXIoa2V5KSB7XG4gICAgbGV0IGNvbnRyb2xsZXIgPSBmZXRjaENvbnRyb2xsZXJzLmdldChrZXkpO1xuICAgIGludmFyaWFudChjb250cm9sbGVyLCBgRXhwZWN0ZWQgZmV0Y2ggY29udHJvbGxlcjogJHtrZXl9YCk7XG4gICAgY29udHJvbGxlci5hYm9ydCgpO1xuICAgIGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKGtleSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHNlbmQsXG4gICAgZ2V0U3RhdGUsXG4gICAgZ2V0RmV0Y2hlcixcbiAgICBkZWxldGVGZXRjaGVyLFxuICAgIGRpc3Bvc2UsXG5cbiAgICBnZXQgX2ludGVybmFsRmV0Y2hDb250cm9sbGVycygpIHtcbiAgICAgIHJldHVybiBmZXRjaENvbnRyb2xsZXJzO1xuICAgIH1cblxuICB9O1xufSAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiBpc0luZGV4UmVxdWVzdEFjdGlvbihhY3Rpb24pIHtcbiAgbGV0IGluZGV4UmVxdWVzdCA9IGZhbHNlO1xuICBsZXQgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhhY3Rpb24uc3BsaXQoXCI/XCIsIDIpWzFdIHx8IFwiXCIpO1xuXG4gIGZvciAobGV0IHBhcmFtIG9mIHNlYXJjaFBhcmFtcy5nZXRBbGwoXCJpbmRleFwiKSkge1xuICAgIGlmICghcGFyYW0pIHtcbiAgICAgIGluZGV4UmVxdWVzdCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGluZGV4UmVxdWVzdDtcbn1cblxuYXN5bmMgZnVuY3Rpb24gY2FsbExvYWRlcnMoc3RhdGUsIHVybCwgbWF0Y2hlcywgc2lnbmFsLCBhY3Rpb25FcnJvclJlc3VsdCwgYWN0aW9uQ2F0Y2hSZXN1bHQsIHN1Ym1pc3Npb24sIHN1Ym1pc3Npb25Sb3V0ZUlkLCBmZXRjaGVyKSB7XG4gIGxldCBtYXRjaGVzVG9Mb2FkID0gZmlsdGVyTWF0Y2hlc1RvTG9hZChzdGF0ZSwgdXJsLCBtYXRjaGVzLCBhY3Rpb25FcnJvclJlc3VsdCwgYWN0aW9uQ2F0Y2hSZXN1bHQsIHN1Ym1pc3Npb24sIHN1Ym1pc3Npb25Sb3V0ZUlkLCBmZXRjaGVyKTtcbiAgcmV0dXJuIFByb21pc2UuYWxsKG1hdGNoZXNUb0xvYWQubWFwKG1hdGNoID0+IGNhbGxMb2FkZXIobWF0Y2gsIHVybCwgc2lnbmFsKSkpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBjYWxsTG9hZGVyKG1hdGNoLCB1cmwsIHNpZ25hbCkge1xuICBpbnZhcmlhbnQobWF0Y2gucm91dGUubG9hZGVyLCBgRXhwZWN0ZWQgbG9hZGVyIGZvciAke21hdGNoLnJvdXRlLmlkfWApO1xuXG4gIHRyeSB7XG4gICAgbGV0IHtcbiAgICAgIHBhcmFtc1xuICAgIH0gPSBtYXRjaDtcbiAgICBsZXQgdmFsdWUgPSBhd2FpdCBtYXRjaC5yb3V0ZS5sb2FkZXIoe1xuICAgICAgcGFyYW1zLFxuICAgICAgdXJsLFxuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1hdGNoLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICBtYXRjaCxcbiAgICAgIHZhbHVlOiBlcnJvclxuICAgIH07XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gY2FsbEFjdGlvbihzdWJtaXNzaW9uLCBtYXRjaCwgc2lnbmFsKSB7XG4gIGlmICghbWF0Y2gucm91dGUuYWN0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBSb3V0ZSBcIiR7bWF0Y2gucm91dGUuaWR9XCIgZG9lcyBub3QgaGF2ZSBhbiBhY3Rpb24sIGJ1dCB5b3UgYXJlIHRyeWluZyBgICsgYHRvIHN1Ym1pdCB0byBpdC4gVG8gZml4IHRoaXMsIHBsZWFzZSBhZGQgYW4gXFxgYWN0aW9uXFxgIGZ1bmN0aW9uIHRvIHRoZSByb3V0ZWApO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBsZXQgdmFsdWUgPSBhd2FpdCBtYXRjaC5yb3V0ZS5hY3Rpb24oe1xuICAgICAgdXJsOiBjcmVhdGVVcmwoc3VibWlzc2lvbi5hY3Rpb24pLFxuICAgICAgcGFyYW1zOiBtYXRjaC5wYXJhbXMsXG4gICAgICBzdWJtaXNzaW9uLFxuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1hdGNoLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICBtYXRjaCxcbiAgICAgIHZhbHVlOiBlcnJvclxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gZmlsdGVyTWF0Y2hlc1RvTG9hZChzdGF0ZSwgdXJsLCBtYXRjaGVzLCBhY3Rpb25FcnJvclJlc3VsdCwgYWN0aW9uQ2F0Y2hSZXN1bHQsIHN1Ym1pc3Npb24sIHN1Ym1pc3Npb25Sb3V0ZUlkLCBmZXRjaGVyKSB7XG4gIC8vIEZpbHRlciBvdXQgYWxsIHJvdXRlcyBiZWxvdyB0aGUgcHJvYmxlbWF0aWMgcm91dGUgYXMgdGhleSBhcmVuJ3QgZ29pbmdcbiAgLy8gdG8gcmVuZGVyIHNvIHdlIGRvbid0IG5lZWQgdG8gbG9hZCB0aGVtLlxuICBpZiAoc3VibWlzc2lvblJvdXRlSWQgJiYgKGFjdGlvbkNhdGNoUmVzdWx0IHx8IGFjdGlvbkVycm9yUmVzdWx0KSkge1xuICAgIGxldCBmb3VuZFByb2JsZW1hdGljUm91dGUgPSBmYWxzZTtcbiAgICBtYXRjaGVzID0gbWF0Y2hlcy5maWx0ZXIobWF0Y2ggPT4ge1xuICAgICAgaWYgKGZvdW5kUHJvYmxlbWF0aWNSb3V0ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXRjaC5yb3V0ZS5pZCA9PT0gc3VibWlzc2lvblJvdXRlSWQpIHtcbiAgICAgICAgZm91bmRQcm9ibGVtYXRpY1JvdXRlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIGxldCBpc05ldyA9IChtYXRjaCwgaW5kZXgpID0+IHtcbiAgICAvLyBbYV0gLT4gW2EsIGJdXG4gICAgaWYgKCFzdGF0ZS5tYXRjaGVzW2luZGV4XSkgcmV0dXJuIHRydWU7IC8vIFthLCBiXSAtPiBbYSwgY11cblxuICAgIHJldHVybiBtYXRjaC5yb3V0ZS5pZCAhPT0gc3RhdGUubWF0Y2hlc1tpbmRleF0ucm91dGUuaWQ7XG4gIH07XG5cbiAgbGV0IG1hdGNoUGF0aENoYW5nZWQgPSAobWF0Y2gsIGluZGV4KSA9PiB7XG4gICAgdmFyIF9zdGF0ZSRtYXRjaGVzJGluZGV4JDtcblxuICAgIHJldHVybiAoLy8gcGFyYW0gY2hhbmdlLCAvdXNlcnMvMTIzIC0+IC91c2Vycy80NTZcbiAgICAgIHN0YXRlLm1hdGNoZXNbaW5kZXhdLnBhdGhuYW1lICE9PSBtYXRjaC5wYXRobmFtZSB8fCAoKF9zdGF0ZSRtYXRjaGVzJGluZGV4JCA9IHN0YXRlLm1hdGNoZXNbaW5kZXhdLnJvdXRlLnBhdGgpID09PSBudWxsIHx8IF9zdGF0ZSRtYXRjaGVzJGluZGV4JCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0YXRlJG1hdGNoZXMkaW5kZXgkLmVuZHNXaXRoKFwiKlwiKSkgJiYgc3RhdGUubWF0Y2hlc1tpbmRleF0ucGFyYW1zW1wiKlwiXSAhPT0gbWF0Y2gucGFyYW1zW1wiKlwiXVxuICAgICk7XG4gIH07XG5cbiAgbGV0IGZpbHRlckJ5Um91dGVQcm9wcyA9IChtYXRjaCwgaW5kZXgpID0+IHtcbiAgICBpZiAoIW1hdGNoLnJvdXRlLmxvYWRlcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChpc05ldyhtYXRjaCwgaW5kZXgpIHx8IG1hdGNoUGF0aENoYW5nZWQobWF0Y2gsIGluZGV4KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG1hdGNoLnJvdXRlLnNob3VsZFJlbG9hZCkge1xuICAgICAgbGV0IHByZXZVcmwgPSBjcmVhdGVVcmwoY3JlYXRlSHJlZihzdGF0ZS5sb2NhdGlvbikpO1xuICAgICAgcmV0dXJuIG1hdGNoLnJvdXRlLnNob3VsZFJlbG9hZCh7XG4gICAgICAgIHByZXZVcmwsXG4gICAgICAgIHVybCxcbiAgICAgICAgc3VibWlzc2lvbixcbiAgICAgICAgcGFyYW1zOiBtYXRjaC5wYXJhbXNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIGxldCBpc0luUm9vdENhdGNoQm91bmRhcnkgPSBzdGF0ZS5tYXRjaGVzLmxlbmd0aCA9PT0gMTtcblxuICBpZiAoaXNJblJvb3RDYXRjaEJvdW5kYXJ5KSB7XG4gICAgcmV0dXJuIG1hdGNoZXMuZmlsdGVyKG1hdGNoID0+ICEhbWF0Y2gucm91dGUubG9hZGVyKTtcbiAgfVxuXG4gIGlmICgoZmV0Y2hlciA9PT0gbnVsbCB8fCBmZXRjaGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmZXRjaGVyLnR5cGUpID09PSBcImFjdGlvblJlbG9hZFwiKSB7XG4gICAgcmV0dXJuIG1hdGNoZXMuZmlsdGVyKGZpbHRlckJ5Um91dGVQcm9wcyk7XG4gIH0gZWxzZSBpZiAoIC8vIG11dGF0aW9uLCByZWxvYWQgZm9yIGZyZXNoIGRhdGFcbiAgc3RhdGUudHJhbnNpdGlvbi50eXBlID09PSBcImFjdGlvblJlbG9hZFwiIHx8IHN0YXRlLnRyYW5zaXRpb24udHlwZSA9PT0gXCJhY3Rpb25SZWRpcmVjdFwiIHx8IC8vIGNsaWNrZWQgdGhlIHNhbWUgbGluaywgcmVzdWJtaXR0ZWQgYSBHRVQgZm9ybVxuICBjcmVhdGVIcmVmKHVybCkgPT09IGNyZWF0ZUhyZWYoc3RhdGUubG9jYXRpb24pIHx8IC8vIHNlYXJjaCBhZmZlY3RzIGFsbCBsb2FkZXJzXG4gIHVybC5zZWFyY2hQYXJhbXMudG9TdHJpbmcoKSAhPT0gc3RhdGUubG9jYXRpb24uc2VhcmNoLnN1YnN0cmluZygxKSkge1xuICAgIHJldHVybiBtYXRjaGVzLmZpbHRlcihmaWx0ZXJCeVJvdXRlUHJvcHMpO1xuICB9XG5cbiAgcmV0dXJuIG1hdGNoZXMuZmlsdGVyKChtYXRjaCwgaW5kZXgsIGFycikgPT4ge1xuICAgIC8vIGRvbid0IGxvYWQgZXJyb3JlZCBhY3Rpb24gcm91dGVcbiAgICBpZiAoKGFjdGlvbkVycm9yUmVzdWx0IHx8IGFjdGlvbkNhdGNoUmVzdWx0KSAmJiBhcnIubGVuZ3RoIC0gMSA9PT0gaW5kZXgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWF0Y2gucm91dGUubG9hZGVyICYmIChpc05ldyhtYXRjaCwgaW5kZXgpIHx8IG1hdGNoUGF0aENoYW5nZWQobWF0Y2gsIGluZGV4KSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkge1xuICByZXR1cm4gcmVzdWx0LnZhbHVlIGluc3RhbmNlb2YgVHJhbnNpdGlvblJlZGlyZWN0O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVIcmVmKGxvY2F0aW9uKSB7XG4gIHJldHVybiBsb2NhdGlvbi5wYXRobmFtZSArIGxvY2F0aW9uLnNlYXJjaDtcbn1cblxuZnVuY3Rpb24gZmluZFJlZGlyZWN0KHJlc3VsdHMpIHtcbiAgZm9yIChsZXQgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICBpZiAoaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5hc3luYyBmdW5jdGlvbiBmaW5kQ2F0Y2hBbmRCb3VuZGFyeUlkKHJlc3VsdHMsIG1hdGNoZXMsIGFjdGlvbkNhdGNoUmVzdWx0KSB7XG4gIGxldCBsb2FkZXJDYXRjaFJlc3VsdDtcblxuICBmb3IgKGxldCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgIGlmIChpc0NhdGNoUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGxvYWRlckNhdGNoUmVzdWx0ID0gcmVzdWx0O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgbGV0IGV4dHJhY3RDYXRjaERhdGEgPSBhc3luYyByZXMgPT4gKHtcbiAgICBzdGF0dXM6IHJlcy5zdGF0dXMsXG4gICAgc3RhdHVzVGV4dDogcmVzLnN0YXR1c1RleHQsXG4gICAgZGF0YTogcmVzLmRhdGFcbiAgfSk7IC8vIFdlaXJkIGNhc2Ugd2hlcmUgYWN0aW9uIHRocmV3LCBhbmQgdGhlbiBhIHBhcmVudCBsb2FkZXIgQUxTTyB0aHJldywgd2VcbiAgLy8gdXNlIHRoZSBhY3Rpb24gY2F0Y2ggYnV0IHRoZSBsb2FkZXIncyBuZWFyZXN0IGJvdW5kYXJ5IChjYXVzZSB3ZSBjYW4ndFxuICAvLyByZW5kZXIgZG93biB0byB0aGUgYm91bmRhcnkgdGhlIGFjdGlvbiB3b3VsZCBwcmVmZXIpXG5cblxuICBpZiAoYWN0aW9uQ2F0Y2hSZXN1bHQgJiYgbG9hZGVyQ2F0Y2hSZXN1bHQpIHtcbiAgICBsZXQgYm91bmRhcnlJZCA9IGZpbmROZWFyZXN0Q2F0Y2hCb3VuZGFyeShsb2FkZXJDYXRjaFJlc3VsdC5tYXRjaCwgbWF0Y2hlcyk7XG4gICAgcmV0dXJuIFthd2FpdCBleHRyYWN0Q2F0Y2hEYXRhKGFjdGlvbkNhdGNoUmVzdWx0LnZhbHVlKSwgYm91bmRhcnlJZF07XG4gIH1cblxuICBpZiAobG9hZGVyQ2F0Y2hSZXN1bHQpIHtcbiAgICBsZXQgYm91bmRhcnlJZCA9IGZpbmROZWFyZXN0Q2F0Y2hCb3VuZGFyeShsb2FkZXJDYXRjaFJlc3VsdC5tYXRjaCwgbWF0Y2hlcyk7XG4gICAgcmV0dXJuIFthd2FpdCBleHRyYWN0Q2F0Y2hEYXRhKGxvYWRlckNhdGNoUmVzdWx0LnZhbHVlKSwgYm91bmRhcnlJZF07XG4gIH1cblxuICByZXR1cm4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkXTtcbn1cblxuZnVuY3Rpb24gZmluZEVycm9yQW5kQm91bmRhcnlJZChyZXN1bHRzLCBtYXRjaGVzLCBhY3Rpb25FcnJvclJlc3VsdCkge1xuICBsZXQgbG9hZGVyRXJyb3JSZXN1bHQ7XG5cbiAgZm9yIChsZXQgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBsb2FkZXJFcnJvclJlc3VsdCA9IHJlc3VsdDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSAvLyBXZWlyZCBjYXNlIHdoZXJlIGFjdGlvbiBlcnJvcmVkLCBhbmQgdGhlbiBhIHBhcmVudCBsb2FkZXIgQUxTTyBlcnJvcmVkLCB3ZVxuICAvLyB1c2UgdGhlIGFjdGlvbiBlcnJvciBidXQgdGhlIGxvYWRlcidzIG5lYXJlc3QgYm91bmRhcnkgKGNhdXNlIHdlIGNhbid0XG4gIC8vIHJlbmRlciBkb3duIHRvIHRoZSBib3VuZGFyeSB0aGUgYWN0aW9uIHdvdWxkIHByZWZlcilcblxuXG4gIGlmIChhY3Rpb25FcnJvclJlc3VsdCAmJiBsb2FkZXJFcnJvclJlc3VsdCkge1xuICAgIGxldCBib3VuZGFyeUlkID0gZmluZE5lYXJlc3RCb3VuZGFyeShsb2FkZXJFcnJvclJlc3VsdC5tYXRjaCwgbWF0Y2hlcyk7XG4gICAgcmV0dXJuIFthY3Rpb25FcnJvclJlc3VsdC52YWx1ZSwgYm91bmRhcnlJZF07XG4gIH1cblxuICBpZiAoYWN0aW9uRXJyb3JSZXN1bHQpIHtcbiAgICBsZXQgYm91bmRhcnlJZCA9IGZpbmROZWFyZXN0Qm91bmRhcnkoYWN0aW9uRXJyb3JSZXN1bHQubWF0Y2gsIG1hdGNoZXMpO1xuICAgIHJldHVybiBbYWN0aW9uRXJyb3JSZXN1bHQudmFsdWUsIGJvdW5kYXJ5SWRdO1xuICB9XG5cbiAgaWYgKGxvYWRlckVycm9yUmVzdWx0KSB7XG4gICAgbGV0IGJvdW5kYXJ5SWQgPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KGxvYWRlckVycm9yUmVzdWx0Lm1hdGNoLCBtYXRjaGVzKTtcbiAgICByZXR1cm4gW2xvYWRlckVycm9yUmVzdWx0LnZhbHVlLCBib3VuZGFyeUlkXTtcbiAgfVxuXG4gIHJldHVybiBbdW5kZWZpbmVkLCB1bmRlZmluZWRdO1xufVxuXG5mdW5jdGlvbiBmaW5kTmVhcmVzdENhdGNoQm91bmRhcnkobWF0Y2hXaXRoRXJyb3IsIG1hdGNoZXMpIHtcbiAgbGV0IG5lYXJlc3RCb3VuZGFyeUlkID0gbnVsbDtcblxuICBmb3IgKGxldCBtYXRjaCBvZiBtYXRjaGVzKSB7XG4gICAgaWYgKG1hdGNoLnJvdXRlLkNhdGNoQm91bmRhcnkpIHtcbiAgICAgIG5lYXJlc3RCb3VuZGFyeUlkID0gbWF0Y2gucm91dGUuaWQ7XG4gICAgfSAvLyBvbmx5IHNlYXJjaCBwYXJlbnRzIChzdG9wIGF0IHRocm93aW5nIG1hdGNoKVxuXG5cbiAgICBpZiAobWF0Y2ggPT09IG1hdGNoV2l0aEVycm9yKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmVhcmVzdEJvdW5kYXJ5SWQ7XG59XG5cbmZ1bmN0aW9uIGZpbmROZWFyZXN0Qm91bmRhcnkobWF0Y2hXaXRoRXJyb3IsIG1hdGNoZXMpIHtcbiAgbGV0IG5lYXJlc3RCb3VuZGFyeUlkID0gbnVsbDtcblxuICBmb3IgKGxldCBtYXRjaCBvZiBtYXRjaGVzKSB7XG4gICAgaWYgKG1hdGNoLnJvdXRlLkVycm9yQm91bmRhcnkpIHtcbiAgICAgIG5lYXJlc3RCb3VuZGFyeUlkID0gbWF0Y2gucm91dGUuaWQ7XG4gICAgfSAvLyBvbmx5IHNlYXJjaCBwYXJlbnRzIChzdG9wIGF0IHRocm93aW5nIG1hdGNoKVxuXG5cbiAgICBpZiAobWF0Y2ggPT09IG1hdGNoV2l0aEVycm9yKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmVhcmVzdEJvdW5kYXJ5SWQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VMb2FkZXJEYXRhKHN0YXRlLCByZXN1bHRzLCBtYXRjaGVzKSB7XG4gIGxldCBuZXdEYXRhID0ge307XG5cbiAgZm9yIChsZXQge1xuICAgIG1hdGNoLFxuICAgIHZhbHVlXG4gIH0gb2YgcmVzdWx0cykge1xuICAgIG5ld0RhdGFbbWF0Y2gucm91dGUuaWRdID0gdmFsdWU7XG4gIH1cblxuICBsZXQgbG9hZGVyRGF0YSA9IHt9O1xuXG4gIGZvciAobGV0IHtcbiAgICByb3V0ZVxuICB9IG9mIG1hdGNoZXMpIHtcbiAgICBsZXQgdmFsdWUgPSBuZXdEYXRhW3JvdXRlLmlkXSAhPT0gdW5kZWZpbmVkID8gbmV3RGF0YVtyb3V0ZS5pZF0gOiBzdGF0ZS5sb2FkZXJEYXRhW3JvdXRlLmlkXTtcblxuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBsb2FkZXJEYXRhW3JvdXRlLmlkXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsb2FkZXJEYXRhO1xufVxuXG5mdW5jdGlvbiBpc0NhdGNoUmVzdWx0KHJlc3VsdCkge1xuICByZXR1cm4gcmVzdWx0LnZhbHVlIGluc3RhbmNlb2YgQ2F0Y2hWYWx1ZTtcbn1cblxuZnVuY3Rpb24gaXNFcnJvclJlc3VsdChyZXN1bHQpIHtcbiAgcmV0dXJuIHJlc3VsdC52YWx1ZSBpbnN0YW5jZW9mIEVycm9yO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVVcmwoaHJlZikge1xuICByZXR1cm4gbmV3IFVSTChocmVmLCB3aW5kb3cubG9jYXRpb24ub3JpZ2luKTtcbn1cblxuZXhwb3J0IHsgQ2F0Y2hWYWx1ZSwgSURMRV9GRVRDSEVSLCBJRExFX1RSQU5TSVRJT04sIFRyYW5zaXRpb25SZWRpcmVjdCwgY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIgfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vcmVhY3QgdjEuMi4yXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmltcG9ydCB7IG1hdGNoUm91dGVzIH0gZnJvbSAncmVhY3Qtcm91dGVyLWRvbSc7XG5cbi8vIFRPRE86IFdlIGV2ZW50dWFsbHkgbWlnaHQgbm90IHdhbnQgdG8gaW1wb3J0IGFueXRoaW5nIGRpcmVjdGx5IGZyb20gYGhpc3RvcnlgXG5mdW5jdGlvbiBtYXRjaENsaWVudFJvdXRlcyhyb3V0ZXMsIGxvY2F0aW9uKSB7XG4gIGxldCBtYXRjaGVzID0gbWF0Y2hSb3V0ZXMocm91dGVzLCBsb2NhdGlvbik7XG4gIGlmICghbWF0Y2hlcykgcmV0dXJuIG51bGw7XG4gIHJldHVybiBtYXRjaGVzLm1hcChtYXRjaCA9PiAoe1xuICAgIHBhcmFtczogbWF0Y2gucGFyYW1zLFxuICAgIHBhdGhuYW1lOiBtYXRjaC5wYXRobmFtZSxcbiAgICByb3V0ZTogbWF0Y2gucm91dGVcbiAgfSkpO1xufVxuXG5leHBvcnQgeyBtYXRjaENsaWVudFJvdXRlcyB9O1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9yZWFjdCB2MS4yLjJcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlTG9jYXRpb24gfSBmcm9tICdyZWFjdC1yb3V0ZXItZG9tJztcbmltcG9ydCB7IHVzZUJlZm9yZVVubG9hZCwgdXNlVHJhbnNpdGlvbiB9IGZyb20gJy4vY29tcG9uZW50cy5qcyc7XG5cbmxldCBTVE9SQUdFX0tFWSA9IFwicG9zaXRpb25zXCI7XG5sZXQgcG9zaXRpb25zID0ge307XG5cbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgbGV0IHNlc3Npb25Qb3NpdGlvbnMgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFNUT1JBR0VfS0VZKTtcblxuICBpZiAoc2Vzc2lvblBvc2l0aW9ucykge1xuICAgIHBvc2l0aW9ucyA9IEpTT04ucGFyc2Uoc2Vzc2lvblBvc2l0aW9ucyk7XG4gIH1cbn1cbi8qKlxuICogVGhpcyBjb21wb25lbnQgd2lsbCBlbXVsYXRlIHRoZSBicm93c2VyJ3Mgc2Nyb2xsIHJlc3RvcmF0aW9uIG9uIGxvY2F0aW9uXG4gKiBjaGFuZ2VzLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZW1peC5ydW4vYXBpL3JlbWl4I3Njcm9sbHJlc3RvcmF0aW9uXG4gKi9cblxuXG5mdW5jdGlvbiBTY3JvbGxSZXN0b3JhdGlvbigpIHtcbiAgdXNlU2Nyb2xsUmVzdG9yYXRpb24oKTsgLy8gd2FpdCBmb3IgdGhlIGJyb3dzZXIgdG8gcmVzdG9yZSBpdCBvbiBpdHMgb3duXG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICB3aW5kb3cuaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9IFwibWFudWFsXCI7XG4gIH0sIFtdKTsgLy8gbGV0IHRoZSBicm93c2VyIHJlc3RvcmUgb24gaXQncyBvd24gZm9yIHJlZnJlc2hcblxuICB1c2VCZWZvcmVVbmxvYWQoUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHdpbmRvdy5oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gXCJhdXRvXCI7XG4gIH0sIFtdKSk7XG5cbiAgbGV0IHJlc3RvcmVTY3JvbGwgPSAoU1RPUkFHRV9LRVkgPT4ge1xuICAgIGlmICghd2luZG93Lmhpc3Rvcnkuc3RhdGUgfHwgIXdpbmRvdy5oaXN0b3J5LnN0YXRlLmtleSkge1xuICAgICAgbGV0IGtleSA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzIpLnNsaWNlKDIpO1xuICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKHtcbiAgICAgICAga2V5XG4gICAgICB9LCBcIlwiKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgbGV0IHBvc2l0aW9ucyA9IEpTT04ucGFyc2Uoc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShTVE9SQUdFX0tFWSkgfHwgXCJ7fVwiKTtcbiAgICAgIGxldCBzdG9yZWRZID0gcG9zaXRpb25zW3dpbmRvdy5oaXN0b3J5LnN0YXRlLmtleV07XG5cbiAgICAgIGlmICh0eXBlb2Ygc3RvcmVkWSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgc3RvcmVkWSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShTVE9SQUdFX0tFWSk7XG4gICAgfVxuICB9KS50b1N0cmluZygpO1xuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiLCB7XG4gICAgc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nOiB0cnVlLFxuICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XG4gICAgICBfX2h0bWw6IGAoJHtyZXN0b3JlU2Nyb2xsfSkoJHtKU09OLnN0cmluZ2lmeShTVE9SQUdFX0tFWSl9KWBcbiAgICB9XG4gIH0pO1xufVxubGV0IGh5ZHJhdGVkID0gZmFsc2U7XG5cbmZ1bmN0aW9uIHVzZVNjcm9sbFJlc3RvcmF0aW9uKCkge1xuICBsZXQgbG9jYXRpb24gPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgdHJhbnNpdGlvbiA9IHVzZVRyYW5zaXRpb24oKTtcbiAgbGV0IHdhc1N1Ym1pc3Npb25SZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0cmFuc2l0aW9uLnN1Ym1pc3Npb24pIHtcbiAgICAgIHdhc1N1Ym1pc3Npb25SZWYuY3VycmVudCA9IHRydWU7XG4gICAgfVxuICB9LCBbdHJhbnNpdGlvbl0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0cmFuc2l0aW9uLmxvY2F0aW9uKSB7XG4gICAgICBwb3NpdGlvbnNbbG9jYXRpb24ua2V5XSA9IHdpbmRvdy5zY3JvbGxZO1xuICAgIH1cbiAgfSwgW3RyYW5zaXRpb24sIGxvY2F0aW9uXSk7XG4gIHVzZUJlZm9yZVVubG9hZChSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShTVE9SQUdFX0tFWSwgSlNPTi5zdHJpbmdpZnkocG9zaXRpb25zKSk7XG4gIH0sIFtdKSk7XG5cbiAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAvLyBkb24ndCBkbyBhbnl0aGluZyBvbiBoeWRyYXRpb24sIHRoZSBjb21wb25lbnQgYWxyZWFkeSBkaWQgdGhpcyB3aXRoIGFuXG4gICAgICAvLyBpbmxpbmUgc2NyaXB0LlxuICAgICAgaWYgKCFoeWRyYXRlZCkge1xuICAgICAgICBoeWRyYXRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGV0IHkgPSBwb3NpdGlvbnNbbG9jYXRpb24ua2V5XTsgLy8gYmVlbiBoZXJlIGJlZm9yZSwgc2Nyb2xsIHRvIGl0XG5cbiAgICAgIGlmICh5ICE9IHVuZGVmaW5lZCkge1xuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgeSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gdHJ5IHRvIHNjcm9sbCB0byB0aGUgaGFzaFxuXG5cbiAgICAgIGlmIChsb2NhdGlvbi5oYXNoKSB7XG4gICAgICAgIGxldCBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGxvY2F0aW9uLmhhc2guc2xpY2UoMSkpO1xuXG4gICAgICAgIGlmIChlbCkge1xuICAgICAgICAgIGVsLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IC8vIGRvbid0IGRvIGFueXRoaW5nIG9uIHN1Ym1pc3Npb25zXG5cblxuICAgICAgaWYgKHdhc1N1Ym1pc3Npb25SZWYuY3VycmVudCA9PT0gdHJ1ZSkge1xuICAgICAgICB3YXNTdWJtaXNzaW9uUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBvdGhlcndpc2UgZ28gdG8gdGhlIHRvcCBvbiBuZXcgbG9jYXRpb25zXG5cblxuICAgICAgd2luZG93LnNjcm9sbFRvKDAsIDApO1xuICAgIH0sIFtsb2NhdGlvbl0pO1xuICB9XG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHJhbnNpdGlvbi5zdWJtaXNzaW9uKSB7XG4gICAgICB3YXNTdWJtaXNzaW9uUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIH1cbiAgfSwgW3RyYW5zaXRpb25dKTtcbn1cblxuZXhwb3J0IHsgU2Nyb2xsUmVzdG9yYXRpb24gfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vcmVhY3QgdjEuMi4yXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmltcG9ydCB7IEFjdGlvbiwgY3JlYXRlUGF0aCB9IGZyb20gJ2hpc3RvcnknO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgUmVtaXhFbnRyeSB9IGZyb20gJy4vY29tcG9uZW50cy5qcyc7XG5cbi8vIFRPRE86IFdlIGV2ZW50dWFsbHkgbWlnaHQgbm90IHdhbnQgdG8gaW1wb3J0IGFueXRoaW5nIGRpcmVjdGx5IGZyb20gYGhpc3RvcnlgXG5cbi8qKlxuICogVGhlIGVudHJ5IHBvaW50IGZvciBhIFJlbWl4IGFwcCB3aGVuIGl0IGlzIHJlbmRlcmVkIG9uIHRoZSBzZXJ2ZXIgKGluXG4gKiBgYXBwL2VudHJ5LnNlcnZlci5qc2ApLiBUaGlzIGNvbXBvbmVudCBpcyB1c2VkIHRvIGdlbmVyYXRlIHRoZSBIVE1MIGluIHRoZVxuICogcmVzcG9uc2UgZnJvbSB0aGUgc2VydmVyLlxuICovXG5mdW5jdGlvbiBSZW1peFNlcnZlcih7XG4gIGNvbnRleHQsXG4gIHVybFxufSkge1xuICBpZiAodHlwZW9mIHVybCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHVybCA9IG5ldyBVUkwodXJsKTtcbiAgfVxuXG4gIGxldCBsb2NhdGlvbiA9IHtcbiAgICBwYXRobmFtZTogdXJsLnBhdGhuYW1lLFxuICAgIHNlYXJjaDogdXJsLnNlYXJjaCxcbiAgICBoYXNoOiBcIlwiLFxuICAgIHN0YXRlOiBudWxsLFxuICAgIGtleTogXCJkZWZhdWx0XCJcbiAgfTtcbiAgbGV0IHN0YXRpY05hdmlnYXRvciA9IHtcbiAgICBjcmVhdGVIcmVmKHRvKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gdG8gOiBjcmVhdGVQYXRoKHRvKTtcbiAgICB9LFxuXG4gICAgcHVzaCh0bykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgY2Fubm90IHVzZSBuYXZpZ2F0b3IucHVzaCgpIG9uIHRoZSBzZXJ2ZXIgYmVjYXVzZSBpdCBpcyBhIHN0YXRlbGVzcyBgICsgYGVudmlyb25tZW50LiBUaGlzIGVycm9yIHdhcyBwcm9iYWJseSB0cmlnZ2VyZWQgd2hlbiB5b3UgZGlkIGEgYCArIGBcXGBuYXZpZ2F0ZSgke0pTT04uc3RyaW5naWZ5KHRvKX0pXFxgIHNvbWV3aGVyZSBpbiB5b3VyIGFwcC5gKTtcbiAgICB9LFxuXG4gICAgcmVwbGFjZSh0bykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgY2Fubm90IHVzZSBuYXZpZ2F0b3IucmVwbGFjZSgpIG9uIHRoZSBzZXJ2ZXIgYmVjYXVzZSBpdCBpcyBhIHN0YXRlbGVzcyBgICsgYGVudmlyb25tZW50LiBUaGlzIGVycm9yIHdhcyBwcm9iYWJseSB0cmlnZ2VyZWQgd2hlbiB5b3UgZGlkIGEgYCArIGBcXGBuYXZpZ2F0ZSgke0pTT04uc3RyaW5naWZ5KHRvKX0sIHsgcmVwbGFjZTogdHJ1ZSB9KVxcYCBzb21ld2hlcmUgYCArIGBpbiB5b3VyIGFwcC5gKTtcbiAgICB9LFxuXG4gICAgZ28oZGVsdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgWW91IGNhbm5vdCB1c2UgbmF2aWdhdG9yLmdvKCkgb24gdGhlIHNlcnZlciBiZWNhdXNlIGl0IGlzIGEgc3RhdGVsZXNzIGAgKyBgZW52aXJvbm1lbnQuIFRoaXMgZXJyb3Igd2FzIHByb2JhYmx5IHRyaWdnZXJlZCB3aGVuIHlvdSBkaWQgYSBgICsgYFxcYG5hdmlnYXRlKCR7ZGVsdGF9KVxcYCBzb21ld2hlcmUgaW4geW91ciBhcHAuYCk7XG4gICAgfSxcblxuICAgIGJhY2soKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBjYW5ub3QgdXNlIG5hdmlnYXRvci5iYWNrKCkgb24gdGhlIHNlcnZlciBiZWNhdXNlIGl0IGlzIGEgc3RhdGVsZXNzIGAgKyBgZW52aXJvbm1lbnQuYCk7XG4gICAgfSxcblxuICAgIGZvcndhcmQoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBjYW5ub3QgdXNlIG5hdmlnYXRvci5mb3J3YXJkKCkgb24gdGhlIHNlcnZlciBiZWNhdXNlIGl0IGlzIGEgc3RhdGVsZXNzIGAgKyBgZW52aXJvbm1lbnQuYCk7XG4gICAgfSxcblxuICAgIGJsb2NrKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgY2Fubm90IHVzZSBuYXZpZ2F0b3IuYmxvY2soKSBvbiB0aGUgc2VydmVyIGJlY2F1c2UgaXQgaXMgYSBzdGF0ZWxlc3MgYCArIGBlbnZpcm9ubWVudC5gKTtcbiAgICB9XG5cbiAgfTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlbWl4RW50cnksIHtcbiAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgIGFjdGlvbjogQWN0aW9uLlBvcCxcbiAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgbmF2aWdhdG9yOiBzdGF0aWNOYXZpZ2F0b3IsXG4gICAgc3RhdGljOiB0cnVlXG4gIH0pO1xufVxuXG5leHBvcnQgeyBSZW1peFNlcnZlciB9O1xuIiwgImltcG9ydCB7IExpbmtzLCBMaW5rc0Z1bmN0aW9uLCBMaXZlUmVsb2FkLCBNZXRhLCBPdXRsZXQsIFNjcmlwdHMsIFNjcm9sbFJlc3RvcmF0aW9uIH0gZnJvbSBcInJlbWl4XCI7XG5pbXBvcnQgdHlwZSB7IE1ldGFGdW5jdGlvbiB9IGZyb20gXCJyZW1peFwiO1xuaW1wb3J0IE5hdkJhciBmcm9tIFwiLi9jb21wb25lbnRzL25hdmJhclwiO1xuaW1wb3J0IHN0eWxlcyBmcm9tIFwifi90YWlsd2luZC5jc3NcIjtcblxuZXhwb3J0IGxldCBsaW5rczogTGlua3NGdW5jdGlvbiA9ICgpID0+IHtcblx0cmV0dXJuIFtcblx0XHR7XG5cdFx0XHRocmVmOiBzdHlsZXMsXG5cdFx0XHRyZWw6IFwic3R5bGVzaGVldFwiXG5cdFx0fVxuXHRdO1xufTtcblxuZXhwb3J0IGNvbnN0IG1ldGE6IE1ldGFGdW5jdGlvbiA9ICgpID0+IHtcblx0cmV0dXJuIHsgdGl0bGU6IFwiTmV3IFJlbWl4IEFwcFwiIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBBcHAoKSB7XG5cdHJldHVybiAoXG5cdFx0PGh0bWwgbGFuZz1cImVuXCI+XG5cdFx0XHQ8aGVhZD5cblx0XHRcdFx0PG1ldGEgY2hhclNldD1cInV0Zi04XCIgLz5cblx0XHRcdFx0PG1ldGEgbmFtZT1cInZpZXdwb3J0XCIgY29udGVudD1cIndpZHRoPWRldmljZS13aWR0aCxpbml0aWFsLXNjYWxlPTFcIiAvPlxuXHRcdFx0XHQ8TWV0YSAvPlxuXHRcdFx0XHQ8TGlua3MgLz5cblx0XHRcdDwvaGVhZD5cblx0XHRcdDxib2R5IGNsYXNzTmFtZT1cImJnLXN1cmZhY2VcIj5cblx0XHRcdFx0PE5hdkJhciAvPlxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cIm10LTE2IG14LWF1dG8gbWF4LXctNnhsIHAtNFwiPlxuXHRcdFx0XHRcdDxPdXRsZXQgLz5cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDxTY3JvbGxSZXN0b3JhdGlvbiAvPlxuXHRcdFx0XHQ8U2NyaXB0cyAvPlxuXHRcdFx0XHQ8TGl2ZVJlbG9hZCAvPlxuXHRcdFx0PC9ib2R5PlxuXHRcdDwvaHRtbD5cblx0KTtcbn1cbiIsICJpbXBvcnQgeyBMaW5rLCBOYXZMaW5rIH0gZnJvbSBcInJlbWl4XCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBOYXZCYXIoKSB7XHJcblx0cmV0dXJuIChcclxuXHRcdDxuYXYgY2xhc3NOYW1lPVwiZmxleCBqdXN0aWZ5LWJldHdlZW4gbWF4LXctNnhsIG14LWF1dG8gZml4ZWQgaW5zZXQtMCBoLTE2IHAtNFwiPlxyXG5cdFx0XHQ8TGluayBjbGFzc05hbWU9XCJ0ZXh0LVsjMzk0MzU5XVwiIHRvPVwiL1wiPlxyXG5cdFx0XHRcdEFsb25HdmlsaVxyXG5cdFx0XHQ8L0xpbms+XHJcblx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIgc3BhY2UteC02XCI+XHJcblx0XHRcdFx0PE5hdkxpbmsgdG89XCIvcHJvamVjdHNcIiBjbGFzc05hbWU9eyh7aXNBY3RpdmV9KSA9PiBpc0FjdGl2ZSA/ICd0ZXh0LXdoaXRlJyA6IGB0ZXh0LVsjMzk0MzU5XWB9PlxyXG5cdFx0XHRcdFx0UHJvamVjdHNcclxuXHRcdFx0XHQ8L05hdkxpbms+XHJcblx0XHRcdFx0PE5hdkxpbmsgdG89XCIvbGlzdHNcIiBjbGFzc05hbWU9eyh7aXNBY3RpdmV9KSA9PiBpc0FjdGl2ZSA/ICd0ZXh0LXdoaXRlJyA6IGB0ZXh0LVsjMzk0MzU5XWB9PlxyXG5cdFx0XHRcdFx0TGlzdHNcclxuXHRcdFx0XHQ8L05hdkxpbms+XHJcblx0XHRcdFx0PE5hdkxpbmsgdG89XCIvbWVcIiBjbGFzc05hbWU9eyh7aXNBY3RpdmV9KSA9PiBpc0FjdGl2ZSA/ICd0ZXh0LXdoaXRlJyA6IGB0ZXh0LVsjMzk0MzU5XWB9PlxyXG5cdFx0XHRcdFx0TWVcclxuXHRcdFx0XHQ8L05hdkxpbms+XHJcblx0XHRcdDwvZGl2PlxyXG5cdFx0PC9uYXY+XHJcblx0KTtcclxufVxyXG4iLCAiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUHJvamVjdHMoKSB7XHJcblx0cmV0dXJuIChcclxuXHRcdDxkaXY+XHJcblx0XHRcdDxoMSBjbGFzc05hbWU9XCJ0ZXh0LTZ4bCBtYXgtdy0yeGwgdGV4dC1bIzM5NDM1OV0gdXBwZXJjYXNlIGZvbnQtYm9sZFwiPlxyXG5cdFx0XHRcdFNvbWUgPHNwYW4gY2xhc3NOYW1lPVwidGV4dC1bI0EyNjZDQV1cIj50aGluZ3MgPC9zcGFuPlxyXG5cdFx0XHRcdCB0aGF0IGkndmUgPHNwYW4gY2xhc3NOYW1lPVwidGV4dC1bI0NCQURDQ11cIj5idWlsZDwvc3Bhbj5cclxuXHRcdFx0PC9oMT5cclxuXHRcdDwvZGl2PlxyXG5cdCk7XHJcbn1cclxuIiwgImltcG9ydCB7IExpbmtzRnVuY3Rpb24gfSBmcm9tIFwicmVtaXhcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gSW5kZXgoKSB7XG4gIHJldHVybiAoXG4gICAgPGRpdj5cbiAgICAgIDxoMSBjbGFzc05hbWU9XCJ0ZXh0LTJ4bCB0ZXh0LVsjMzk0MzU5XVwiPldlbGNvbWUgdG8gQWxvbiBHdmlsaSBzaXRlPC9oMT5cbiAgICA8L2Rpdj5cbiAgKTtcbn1cbiIsICJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBQcm9qZWN0cygpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgPGgxIGNsYXNzTmFtZT1cInRleHQtMnhsIHRleHQtWyMzOTQzNTldXCI+UHJvamVjdHM8L2gxPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKTtcclxufSIsICJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBQcm9qZWN0cygpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgPGgxIGNsYXNzTmFtZT1cInRleHQtMnhsIHRleHQtWyMzOTQzNTldXCI+UHJvamVjdHM8L2gxPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKTtcclxufSIsICJleHBvcnQgZGVmYXVsdCB7J3ZlcnNpb24nOidkZmYwYTY4YycsJ2VudHJ5Jzp7J21vZHVsZSc6Jy9idWlsZC9lbnRyeS5jbGllbnQtNkpHS0ZLRFkuanMnLCdpbXBvcnRzJzpbJy9idWlsZC9fc2hhcmVkL2NodW5rLUw1REQ2NFlLLmpzJywnL2J1aWxkL19zaGFyZWQvY2h1bmstV0U0STRGRDYuanMnXX0sJ3JvdXRlcyc6eydyb290Jzp7J2lkJzoncm9vdCcsJ3BhcmVudElkJzp1bmRlZmluZWQsJ3BhdGgnOicnLCdpbmRleCc6dW5kZWZpbmVkLCdjYXNlU2Vuc2l0aXZlJzp1bmRlZmluZWQsJ21vZHVsZSc6Jy9idWlsZC9yb290LVlPVTNFTlpZLmpzJywnaW1wb3J0cyc6dW5kZWZpbmVkLCdoYXNBY3Rpb24nOmZhbHNlLCdoYXNMb2FkZXInOmZhbHNlLCdoYXNDYXRjaEJvdW5kYXJ5JzpmYWxzZSwnaGFzRXJyb3JCb3VuZGFyeSc6ZmFsc2V9LCdyb3V0ZXMvaW5kZXgnOnsnaWQnOidyb3V0ZXMvaW5kZXgnLCdwYXJlbnRJZCc6J3Jvb3QnLCdwYXRoJzp1bmRlZmluZWQsJ2luZGV4Jzp0cnVlLCdjYXNlU2Vuc2l0aXZlJzp1bmRlZmluZWQsJ21vZHVsZSc6Jy9idWlsZC9yb3V0ZXMvaW5kZXgtQkpKUlBEN0QuanMnLCdpbXBvcnRzJzp1bmRlZmluZWQsJ2hhc0FjdGlvbic6ZmFsc2UsJ2hhc0xvYWRlcic6ZmFsc2UsJ2hhc0NhdGNoQm91bmRhcnknOmZhbHNlLCdoYXNFcnJvckJvdW5kYXJ5JzpmYWxzZX0sJ3JvdXRlcy9saXN0cyc6eydpZCc6J3JvdXRlcy9saXN0cycsJ3BhcmVudElkJzoncm9vdCcsJ3BhdGgnOidsaXN0cycsJ2luZGV4Jzp1bmRlZmluZWQsJ2Nhc2VTZW5zaXRpdmUnOnVuZGVmaW5lZCwnbW9kdWxlJzonL2J1aWxkL3JvdXRlcy9saXN0cy0zUkhGM1VXVC5qcycsJ2ltcG9ydHMnOnVuZGVmaW5lZCwnaGFzQWN0aW9uJzpmYWxzZSwnaGFzTG9hZGVyJzpmYWxzZSwnaGFzQ2F0Y2hCb3VuZGFyeSc6ZmFsc2UsJ2hhc0Vycm9yQm91bmRhcnknOmZhbHNlfSwncm91dGVzL21lJzp7J2lkJzoncm91dGVzL21lJywncGFyZW50SWQnOidyb290JywncGF0aCc6J21lJywnaW5kZXgnOnVuZGVmaW5lZCwnY2FzZVNlbnNpdGl2ZSc6dW5kZWZpbmVkLCdtb2R1bGUnOicvYnVpbGQvcm91dGVzL21lLVJBRVhIWjdILmpzJywnaW1wb3J0cyc6dW5kZWZpbmVkLCdoYXNBY3Rpb24nOmZhbHNlLCdoYXNMb2FkZXInOmZhbHNlLCdoYXNDYXRjaEJvdW5kYXJ5JzpmYWxzZSwnaGFzRXJyb3JCb3VuZGFyeSc6ZmFsc2V9LCdyb3V0ZXMvcHJvamVjdHMnOnsnaWQnOidyb3V0ZXMvcHJvamVjdHMnLCdwYXJlbnRJZCc6J3Jvb3QnLCdwYXRoJzoncHJvamVjdHMnLCdpbmRleCc6dW5kZWZpbmVkLCdjYXNlU2Vuc2l0aXZlJzp1bmRlZmluZWQsJ21vZHVsZSc6Jy9idWlsZC9yb3V0ZXMvcHJvamVjdHMtWlI0UlRHVE8uanMnLCdpbXBvcnRzJzp1bmRlZmluZWQsJ2hhc0FjdGlvbic6ZmFsc2UsJ2hhc0xvYWRlcic6ZmFsc2UsJ2hhc0NhdGNoQm91bmRhcnknOmZhbHNlLCdoYXNFcnJvckJvdW5kYXJ5JzpmYWxzZX19LCd1cmwnOicvYnVpbGQvbWFuaWZlc3QtREZGMEE2OEMuanMnfTsiXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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Q1gsU0FBUztBQUFBLFVBQ1QsY0FBYztBQUFBLFVBQ2QsS0FBSztBQUFBLFVBQ0wsTUFBTTtBQUFBLFVBQ04sWUFBWTtBQUFBLFVBQ1osWUFBWTtBQUFBLFVBQ1osYUFBYTtBQUFBLFVBQ2IsZ0JBQWdCO0FBQUEsVUFDaEIsWUFBWTtBQUFBLFVBQ1osYUFBYTtBQUFBLFVBQ2IsU0FBUztBQUFBLFVBQ1QsUUFBUTtBQUFBLFVBQ1IsUUFBUTtBQUFBLFVBQ1IsTUFBTTtBQUFBLFVBQ04sTUFBTTtBQUFBLFVBQ04sVUFBVTtBQUFBLFVBQ1YsU0FBUztBQUFBLFVBQ1QsV0FBVztBQUFBLFVBQ1gsY0FBYztBQUFBLFVBQ2QsTUFBTTtBQUFBLFVBQ04sSUFBSTtBQUFBLFVBQ0osV0FBVztBQUFBLFVBQ1gsV0FBVztBQUFBLFVBQ1gsV0FBVztBQUFBLFVBQ1gsSUFBSTtBQUFBLFVBQ0osUUFBUTtBQUFBLFVBQ1IsVUFBVTtBQUFBLFVBQ1YsU0FBUztBQUFBLFVBQ1QsV0FBVztBQUFBLFVBQ1gsVUFBVTtBQUFBLFVBQ1YsV0FBVztBQUFBLFVBQ1gsU0FBUztBQUFBLFVBQ1QsTUFBTTtBQUFBLFVBQ04sT0FBTztBQUFBLFVBQ1AsTUFBTTtBQUFBLFVBQ04sTUFBTTtBQUFBLFVBQ04sTUFBTTtBQUFBLFVBQ04sS0FBSztBQUFBLFVBQ0wsVUFBVTtBQUFBLFVBQ1YsYUFBYTtBQUFBLFVBQ2IsY0FBYztBQUFBLFVBQ2QsS0FBSztBQUFBLFVBQ0wsV0FBVztBQUFBLFVBQ1gsT0FBTztBQUFBLFVBQ1AsWUFBWTtBQUFBLFVBQ1osUUFBUTtBQUFBLFVBQ1IsS0FBSztBQUFBLFVBQ0wsV0FBVztBQUFBLFVBQ1gsVUFBVTtBQUFBLFVBQ1YsT0FBTztBQUFBLFVBQ1AsTUFBTTtBQUFBLFVBQ04sVUFBVTtBQUFBLFVBQ1YsT0FBTztBQUFBLFVBQ1AsWUFBWTtBQUFBLFVBQ1osTUFBTTtBQUFBLFVBQ04sU0FBUztBQUFBLFVBQ1QsU0FBUztBQUFBLFVBQ1QsYUFBYTtBQUFBLFVBQ2IsYUFBYTtBQUFBLFVBQ2IsUUFBUTtBQUFBLFVBQ1IsU0FBUztBQUFBLFVBQ1QsU0FBUztBQUFBLFVBQ1QsWUFBWTtBQUFBLFVBQ1osVUFBVTtBQUFBLFVBQ1YsZ0JBQWdCO0FBQUEsVUFDaEIsS0FBSztBQUFBLFVBQ0wsVUFBVTtBQUFBLFVBQ1YsVUFBVTtBQUFBLFVBQ1YsTUFBTTtBQUFBLFVBQ04sTUFBTTtBQUFBLFVBQ04sU0FBUztBQUFBLFVBQ1QsU0FBUztBQUFBLFVBQ1QsT0FBTztBQUFBLFVBQ1AsUUFBUTtBQUFBLFVBQ1IsV0FBVztBQUFBLFVBQ1gsVUFBVTtBQUFBLFVBQ1YsVUFBVTtBQUFBLFVBQ1YsT0FBTztBQUFBLFVBQ1AsTUFBTTtBQUFBLFVBQ04sT0FBTztBQUFBLFVBQ1AsTUFBTTtBQUFBLFVBQ04sWUFBWTtBQUFBLFVBQ1osS0FBSztBQUFBLFVBQ0wsUUFBUTtBQUFBLFVBQ1IsU0FBUztBQUFBLFVBQ1QsUUFBUTtBQUFBLFVBQ1IsT0FBTztBQUFBLFVBQ1AsTUFBTTtBQUFBLFVBQ04sT0FBTztBQUFBLFVBQ1AsU0FBUztBQUFBLFVBQ1QsVUFBVTtBQUFBLFVBQ1YsUUFBUTtBQUFBLFVBQ1IsT0FBTztBQUFBLFVBQ1AsTUFBTTtBQUFBLFVBQ04sUUFBUTtBQUFBLFVBQ1IsT0FBTztBQUFBLFVBQ1AsT0FBTztBQUFBLFVBQ1AsT0FBTztBQUFBLFVBQ1AsTUFBTTtBQUFBLFVBRU4sT0FBTztBQUFBLFVBQ1AsY0FBYztBQUFBLFVBQ2QsaUJBQWlCO0FBQUEsVUFDakIsWUFBWTtBQUFBLFVBQ1osVUFBVTtBQUFBLFVBQ1YsbUJBQW1CO0FBQUEsVUFDbkIsc0JBQXNCO0FBQUEsVUFDdEIsY0FBYztBQUFBLFVBQ2QsWUFBWTtBQUFBLFVBQ1osV0FBVztBQUFBLFVBQ1gsWUFBWTtBQUFBLFVBQ1osZUFBZTtBQUFBLFVBQ2YsUUFBUTtBQUFBLFVBQ1IsZUFBZTtBQUFBLFVBQ2YsZUFBZTtBQUFBLFVBQ2YsYUFBYTtBQUFBLFVBQ2IsU0FBUztBQUFBLFVBQ1QsZUFBZTtBQUFBLFVBQ2YsZUFBZTtBQUFBLFVBQ2Ysa0JBQWtCO0FBQUEsVUFDbEIsYUFBYTtBQUFBLFVBQ2IsTUFBTTtBQUFBLFVBQ04sT0FBTztBQUFBLFVBQ1AsTUFBTTtBQUFBLFVBQ04sSUFBSTtBQUFBLFVBQ0osVUFBVTtBQUFBLFVBQ1YsV0FBVztBQUFBLFVBQ1gsY0FBYztBQUFBLFVBQ2QsTUFBTTtBQUFBLFVBQ04sVUFBVTtBQUFBLFVBQ1YsYUFBYTtBQUFBLFVBQ2IsZUFBZTtBQUFBLFVBQ2YsVUFBVTtBQUFBLFVBQ1YsYUFBYTtBQUFBLFVBQ2IsT0FBTztBQUFBLFVBQ1Asb0JBQW9CO0FBQUEsVUFDcEIsdUJBQXVCO0FBQUEsVUFDdkIsMkJBQTJCO0FBQUEsVUFDM0IsK0JBQStCO0FBQUEsVUFDL0IsY0FBYztBQUFBLFVBQ2QsaUJBQWlCO0FBQUEsVUFDakIsZ0JBQWdCO0FBQUEsVUFDaEIsbUJBQW1CO0FBQUEsVUFDbkIsbUJBQW1CO0FBQUEsVUFDbkIsa0JBQWtCO0FBQUEsVUFDbEIsUUFBUTtBQUFBLFVBQ1IsSUFBSTtBQUFBLFVBQ0osSUFBSTtBQUFBLFVBQ0osR0FBRztBQUFBLFVBQ0gsVUFBVTtBQUFBLFVBQ1YsWUFBWTtBQUFBLFVBQ1osU0FBUztBQUFBLFVBQ1QsaUJBQWlCO0FBQUEsVUFDakIsV0FBVztBQUFBLFVBQ1gsU0FBUztBQUFBLFVBQ1QsU0FBUztBQUFBLFVBQ1Qsa0JBQWtCO0FBQUEsVUFDbEIscUJBQXFCO0FBQUEsVUFDckIsS0FBSztBQUFBLFVBQ0wsSUFBSTtBQUFBLFVBQ0osSUFBSTtBQUFBLFVBQ0osVUFBVTtBQUFBLFVBQ1YsV0FBVztBQUFBLFVBQ1gsa0JBQWtCO0FBQUEsVUFDbEIscUJBQXFCO0FBQUEsVUFDckIsS0FBSztBQUFBLFVBQ0wsVUFBVTtBQUFBLFVBQ1YsMkJBQTJCO0FBQUEsVUFDM0IsTUFBTTtBQUFBLFVBQ04sYUFBYTtBQUFBLFVBQ2IsZ0JBQWdCO0FBQUEsVUFDaEIsVUFBVTtBQUFBLFVBQ1YsYUFBYTtBQUFBLFVBQ2IsUUFBUTtBQUFBLFVBQ1IsV0FBVztBQUFBLFVBQ1gsYUFBYTtBQUFBLFVBQ2IsY0FBYztBQUFBLFVBQ2QsaUJBQWlCO0FBQUEsVUFDakIsWUFBWTtBQUFBLFVBQ1osZUFBZTtBQUFBLFVBQ2YsV0FBVztBQUFBLFVBQ1gsWUFBWTtBQUFBLFVBQ1osZUFBZTtBQUFBLFVBQ2YsVUFBVTtBQUFBLFVBQ1YsYUFBYTtBQUFBLFVBQ2IsZ0JBQWdCO0FBQUEsVUFDaEIsb0JBQW9CO0FBQUEsVUFDcEIsYUFBYTtBQUFBLFVBQ2IsZ0JBQWdCO0FBQUEsVUFDaEIsV0FBVztBQUFBLFVBQ1gsY0FBYztBQUFBLFVBQ2QsYUFBYTtBQUFBLFVBQ2IsZ0JBQWdCO0FBQUEsVUFDaEIsWUFBWTtBQUFBLFVBQ1osZUFBZTtBQUFBLFVBQ2YsUUFBUTtBQUFBLFVBQ1IsTUFBTTtBQUFBLFVBQ04sSUFBSTtBQUFBLFVBQ0osSUFBSTtBQUFBLFVBQ0osSUFBSTtBQUFBLFVBQ0osSUFBSTtBQUFBLFVBQ0osV0FBVztBQUFBLFVBQ1gsY0FBYztBQUFBLFVBQ2QsNEJBQTRCO0FBQUEsVUFDNUIsZ0NBQWdDO0FBQUEsVUFDaEMsMEJBQTBCO0FBQUEsVUFDMUIsOEJBQThCO0FBQUEsVUFDOUIsVUFBVTtBQUFBLFVBQ1YsbUJBQW1CO0FBQUEsVUFDbkIsZUFBZTtBQUFBLFVBQ2YsU0FBUztBQUFBLFVBQ1QsV0FBVztBQUFBLFVBQ1gsZUFBZTtBQUFBLFVBQ2YsY0FBYztBQUFBLFVBQ2Qsa0JBQWtCO0FBQUEsVUFDbEIsYUFBYTtBQUFBLFVBQ2IsZ0JBQWdCO0FBQUEsVUFDaEIsbUJBQW1CO0FBQUEsVUFDbkIsS0FBSztBQUFBLFVBQ0wsSUFBSTtBQUFBLFVBQ0osUUFBUTtBQUFBLFVBQ1IsV0FBVztBQUFBLFVBQ1gsSUFBSTtBQUFBLFVBQ0osSUFBSTtBQUFBLFVBQ0osSUFBSTtBQUFBLFVBQ0osSUFBSTtBQUFBLFVBQ0osR0FBRztBQUFBLFVBQ0gsY0FBYztBQUFBLFVBQ2Qsa0JBQWtCO0FBQUEsVUFDbEIsU0FBUztBQUFBLFVBQ1QsV0FBVztBQUFBLFVBQ1gsWUFBWTtBQUFBLFVBQ1osVUFBVTtBQUFBLFVBQ1YsY0FBYztBQUFBLFVBQ2QsZUFBZTtBQUFBLFVBQ2Ysa0JBQWtCO0FBQUEsVUFDbEIsZUFBZTtBQUFBLFVBQ2Ysa0JBQWtCO0FBQUEsVUFDbEIsbUJBQW1CO0FBQUEsVUFDbkIsT0FBTztBQUFBLFVBQ1AsV0FBVztBQUFBLFVBQ1gsY0FBYztBQUFBLFVBQ2QsY0FBYztBQUFBLFVBQ2QsV0FBVztBQUFBLFVBQ1gsY0FBYztBQUFBLFVBQ2QsYUFBYTtBQUFBLFVBQ2IsZ0JBQWdCO0FBQUEsVUFDaEIsYUFBYTtBQUFBLFVBQ2IsYUFBYTtBQUFBLFVBQ2IsTUFBTTtBQUFBLFVBQ04sa0JBQWtCO0FBQUEsVUFDbEIsV0FBVztBQUFBLFVBQ1gsY0FBYztBQUFBLFVBQ2QsTUFBTTtBQUFBLFVBQ04sWUFBWTtBQUFBLFVBQ1osUUFBUTtBQUFBLFVBQ1IsU0FBUztBQUFBLFVBQ1QsVUFBVTtBQUFBLFVBQ1YsT0FBTztBQUFBLFVBQ1AsUUFBUTtBQUFBLFVBQ1IsYUFBYTtBQUFBLFVBQ2IsUUFBUTtBQUFBLFVBQ1IsVUFBVTtBQUFBLFVBQ1Ysa0JBQWtCO0FBQUEsVUFDbEIscUJBQXFCO0FBQUEsVUFDckIsbUJBQW1CO0FBQUEsVUFDbkIsc0JBQXNCO0FBQUEsVUFDdEIsWUFBWTtBQUFBLFVBQ1osZUFBZTtBQUFBLFVBQ2YsU0FBUztBQUFBLFVBQ1QsWUFBWTtBQUFBLFVBQ1osWUFBWTtBQUFBLFVBQ1oscUJBQXFCO0FBQUEsVUFDckIsa0JBQWtCO0FBQUEsVUFDbEIsY0FBYztBQUFBLFVBQ2QsZUFBZTtBQUFBLFVBQ2Ysa0JBQWtCO0FBQUEsVUFDbEIsUUFBUTtBQUFBLFVBQ1IsV0FBVztBQUFBLFVBQ1gsV0FBVztBQUFBLFVBQ1gsV0FBVztBQUFBLFVBQ1gsUUFBUTtBQUFBLFVBQ1IsZUFBZTtBQUFBLFVBQ2YscUJBQXFCO0FBQUEsVUFDckIsZ0JBQWdCO0FBQUEsVUFDaEIsVUFBVTtBQUFBLFVBQ1YsR0FBRztBQUFBLFVBQ0gsUUFBUTtBQUFBLFVBQ1IsTUFBTTtBQUFBLFVBQ04sTUFBTTtBQUFBLFVBQ04saUJBQWlCO0FBQUEsVUFDakIsb0JBQW9CO0FBQUEsVUFDcEIsYUFBYTtBQUFBLFVBQ2IsV0FBVztBQUFBLFVBQ1gsb0JBQW9CO0FBQUEsVUFDcEIsa0JBQWtCO0FBQUEsVUFDbEIsVUFBVTtBQUFBLFVBQ1YsU0FBUztBQUFBLFVBQ1QsUUFBUTtBQUFBLFVBQ1IsU0FBUztBQUFBLFVBQ1QsUUFBUTtBQUFBLFVBQ1IsSUFBSTtBQUFBLFVBQ0osSUFBSTtBQUFBLFVBQ0osT0FBTztBQUFBLFVBQ1AsVUFBVTtBQUFBLFVBQ1YsTUFBTTtBQUFBLFVBQ04sZ0JBQWdCO0FBQUEsVUFDaEIsbUJBQW1CO0FBQUEsVUFDbkIsT0FBTztBQUFBLFVBQ1AsU0FBUztBQUFBLFVBQ1Qsa0JBQWtCO0FBQUEsVUFDbEIsa0JBQWtCO0FBQUEsVUFDbEIsT0FBTztBQUFBLFVBQ1AsY0FBYztBQUFBLFVBQ2QsYUFBYTtBQUFBLFVBQ2IsY0FBYztBQUFBLFVBQ2QsT0FBTztBQUFBLFVBQ1AsT0FBTztBQUFBLFVBQ1AsYUFBYTtBQUFBLFVBQ2IsV0FBVztBQUFBLFVBQ1gsY0FBYztBQUFBLFVBQ2QsYUFBYTtBQUFBLFVBQ2IsZ0JBQWdCO0FBQUEsVUFDaEIsdUJBQXVCO0FBQUEsVUFDdkIsMEJBQTBCO0FBQUEsVUFDMUIsd0JBQXdCO0FBQUEsVUFDeEIsMkJBQTJCO0FBQUEsVUFDM0IsUUFBUTtBQUFBLFVBQ1IsUUFBUTtBQUFBLFVBQ1IsaUJBQWlCO0FBQUEsVUFDakIsb0JBQW9CO0FBQUEsVUFDcEIsa0JBQWtCO0FBQUEsVUFDbEIscUJBQXFCO0FBQUEsVUFDckIsZUFBZTtBQUFBLFVBQ2Ysa0JBQWtCO0FBQUEsVUFDbEIsZ0JBQWdCO0FBQUEsVUFDaEIsbUJBQW1CO0FBQUEsVUFDbkIsa0JBQWtCO0FBQUEsVUFDbEIscUJBQXFCO0FBQUEsVUFDckIsYUFBYTtBQUFBLFVBQ2IsZ0JBQWdCO0FBQUEsVUFDaEIsZUFBZTtBQUFBLFVBQ2Ysa0JBQWtCO0FBQUEsVUFDbEIsZ0NBQWdDO0FBQUEsVUFDaEMsMEJBQTBCO0FBQUEsVUFDMUIsY0FBYztBQUFBLFVBQ2QsZ0JBQWdCO0FBQUEsVUFDaEIsYUFBYTtBQUFBLFVBQ2IsU0FBUztBQUFBLFVBQ1QsU0FBUztBQUFBLFVBQ1QsWUFBWTtBQUFBLFVBQ1osZUFBZTtBQUFBLFVBQ2YsZ0JBQWdCO0FBQUEsVUFDaEIsbUJBQW1CO0FBQUEsVUFDbkIsWUFBWTtBQUFBLFVBQ1osZUFBZTtBQUFBLFVBQ2Ysa0JBQWtCO0FBQUEsVUFDbEIsSUFBSTtBQUFBLFVBQ0osV0FBVztBQUFBLFVBQ1gsUUFBUTtBQUFBLFVBQ1IsSUFBSTtBQUFBLFVBQ0osSUFBSTtBQUFBLFVBQ0osbUJBQW1CO0FBQUEsVUFDbkIsc0JBQXNCO0FBQUEsVUFDdEIsb0JBQW9CO0FBQUEsVUFDcEIsdUJBQXVCO0FBQUEsVUFDdkIsU0FBUztBQUFBLFVBQ1QsYUFBYTtBQUFBLFVBQ2IsZ0JBQWdCO0FBQUEsVUFDaEIsY0FBYztBQUFBLFVBQ2QsaUJBQWlCO0FBQUEsVUFDakIsWUFBWTtBQUFBLFVBQ1osZ0JBQWdCO0FBQUEsVUFDaEIsY0FBYztBQUFBLFVBQ2QsYUFBYTtBQUFBLFVBQ2IsZ0JBQWdCO0FBQUEsVUFDaEIsUUFBUTtBQUFBLFVBQ1IsY0FBYztBQUFBLFVBQ2QsaUJBQWlCO0FBQUEsVUFDakIsU0FBUztBQUFBLFVBQ1QsVUFBVTtBQUFBLFVBQ1YsY0FBYztBQUFBLFVBQ2QsYUFBYTtBQUFBLFVBQ2IsaUJBQWlCO0FBQUEsVUFDakIsYUFBYTtBQUFBLFVBQ2IsaUJBQWlCO0FBQUEsVUFDakIsVUFBVTtBQUFBLFVBQ1YsYUFBYTtBQUFBLFVBQ2IsY0FBYztBQUFBLFVBQ2QsaUJBQWlCO0FBQUEsVUFDakIsU0FBUztBQUFBLFVBQ1QsWUFBWTtBQUFBLFVBQ1osWUFBWTtBQUFBLFVBQ1osZUFBZTtBQUFBLFVBQ2Ysa0JBQWtCO0FBQUEsVUFDbEIsT0FBTztBQUFBLFVBQ1AsUUFBUTtBQUFBLFVBQ1IsYUFBYTtBQUFBLFVBQ2IsZ0JBQWdCO0FBQUEsVUFDaEIsYUFBYTtBQUFBLFVBQ2IsZ0JBQWdCO0FBQUEsVUFDaEIsSUFBSTtBQUFBLFVB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
